With timestamps:

00:00 - hello in this tutorial we are going to
00:02 - cover cameras in pygame and i have
00:05 - created six projects that should
00:07 - basically cover any kind of camera you
00:09 - would ever need so let's go through them
00:12 - before i jump into the code
00:14 - number one is a camera that dynamically
00:16 - places elements on top of each other so
00:18 - we have a proper drawing order
00:20 - and this is creating a nice fake 3d
00:23 - effect the next camera is going to be a
00:25 - camera that always centers on the player
00:27 - number three is a camera box so we do
00:30 - not center the player but if the player
00:32 - moves too far to the left to the right
00:34 - up or down we are moving the camera
00:36 - along with the player so the player
00:38 - never leaves the screen
00:40 - number four is quite simple we are
00:42 - controlling the camera with the keyboard
00:44 - and in number five we are using the
00:46 - mouse in the same way
00:48 - and finally number six
00:49 - we are going to give our camera the
00:51 - ability to zoom in and out
00:53 - and all of these cameras also work with
00:55 - each other if you really want to combine
00:57 - them
00:58 - and really quick for the setup we have
01:01 - all of our code inside of one folder
01:03 - that is going to contain all of our
01:05 - files and inside of that folder we have
01:08 - one subfolder called graphics and inside
01:10 - of that we have three different files we
01:13 - have the ground the player and one tree
01:16 - so my case there's not much variety but
01:19 - if you had a proper game obviously you
01:21 - would add a lot more graphics in here
01:24 - so with that let's get started with the
01:27 - project setup i already have a couple of
01:30 - things in the game to save some time
01:32 - and i guess let's have a look at them
01:35 - here we are in the code and we already
01:38 - have 64 lines of code
01:40 - so i do want to go over that but we only
01:43 - have a single python file so all of our
01:45 - code is going to be in this one file we
01:47 - will never create another one
01:50 - we are starting by importing the usual
01:52 - stuff for pygame and randint you will
01:55 - see why we need rent in in just a second
01:58 - after that we have two classes tree and
02:01 - player for now don't worry too much
02:03 - about them i'll go over them in just a
02:05 - second
02:06 - once we have those we are initiating
02:08 - pygame with the display surface and the
02:10 - clock nothing fancy is happening here
02:13 - after that we are creating our camera
02:17 - group this one is later going to become
02:19 - incredibly important but for now it is
02:23 - just a sprite group nothing more
02:25 - after that
02:26 - we are putting the player somewhere
02:28 - inside of this group so the player has a
02:30 - position and a group
02:33 - once that is done
02:35 - we are placing our trees in here
02:38 - so i just have a for loop and we are
02:39 - placing 20 trees
02:41 - i am using rand end to create a random
02:43 - position
02:44 - and then we are placing the trees in
02:46 - this line here
02:48 - so just like the player the trees get a
02:50 - random position and the camera group
02:54 - that's just about it
02:57 - and with that setup
02:59 - we have our game loop our event loop
03:02 - doesn't really do anything right now
03:04 - except for closing the game we are
03:06 - filling the game with a bluish
03:07 - watercolor then we are updating and
03:10 - drawing the screen and we are doing the
03:11 - usual pie game stuff
03:14 - and all of that gets us
03:19 - basically this we have a player and we
03:21 - have a couple of trees and a blue
03:23 - background and right now my player is
03:25 - always behind the trees
03:28 - and the reason why the player is always
03:30 - behind the trees
03:31 - is because
03:33 - the player is created here let's call it
03:36 - number one
03:37 - and all of our trees are created here
03:39 - let's say number two and because of that
03:42 - the trees are always on top
03:45 - which is well not ideal but we are going
03:48 - to fix that
03:50 - and let's have a really quick look at
03:51 - the classes they aren't that complicated
03:54 - the tree class is incredibly simple
03:56 - so we are giving them a position and a
03:58 - group they have an image and the image
04:01 - is always going to be the tree in our
04:03 - folder and then this tree gets position
04:06 - and the position is well wherever we
04:08 - want the tree to be
04:11 - and the player is a tiny bit more
04:13 - complex
04:14 - although not that much
04:17 - for the image we are still importing an
04:19 - image and we are giving it a position
04:21 - and that is the position we get from the
04:23 - parameters
04:25 - the one thing we have for the player as
04:27 - well is a direction and a speed
04:30 - and this speed we are using in the
04:33 - update method down
04:35 - here
04:36 - to move the player itself
04:39 - and how the movement works is from the
04:42 - input we are influencing the direction
04:45 - and then we're adding this to the
04:46 - rectangle center and that way our player
04:48 - is moving
04:50 - and all that the input method really
04:52 - does is we are checking for up down
04:56 - right and left
04:58 - and using that to influence the vector
05:02 - so if you have any idea of pi game this
05:04 - shouldn't be difficult
05:06 - speaking of if none of this made sense
05:09 - check out my introduction to pygame this
05:11 - one is going to explain all of this in
05:13 - quite a bit more detail
05:15 - and if you want to have more information
05:17 - on a top-down game i have made a full
05:19 - zelda game and a simplified zelda game
05:21 - so check out those as well if you're
05:23 - really interested
05:25 - so alright with that we have our setup
05:28 - so let's get started with the first
05:30 - camera and that camera is going to order
05:32 - which elements are supposed to be on top
05:34 - of each other
05:36 - and this kind of camera is called the y
05:38 - sword camera you're gonna see in a
05:40 - second why
05:42 - but let me explain the problem first
05:44 - so what we want to achieve is something
05:47 - like this
05:48 - that the player is dynamically on top of
05:50 - the trees if the player is in front of
05:52 - it
05:53 - but we also want the player to be behind
05:56 - the trees if the player is well behind
05:58 - the trees
06:00 - but we don't really have a concept of
06:02 - behind or in front in our game because
06:05 - we only have a x and a y coordinate we
06:07 - don't have a z coordinate
06:10 - so we have to figure out
06:12 - how to know
06:13 - when the player is supposed to be in
06:15 - front like this one or behind another
06:18 - element like in this one
06:20 - and the solution to figure this one out
06:22 - is actually quite simple
06:25 - and well like the camera name implies
06:28 - we are sorting all of our elements by
06:30 - the y sort position
06:31 - so if this here is the top of the window
06:35 - so y being zero
06:39 - the further down element comes in this
06:41 - the higher it should be drawn
06:44 - so for example for this player here
06:46 - let's say the y position is 10
06:49 - and for the tree in both cases
06:52 - we have a y position of let's say 50.
06:56 - now because the tree has a higher y
06:58 - value than the player the tree is going
07:00 - to be drawn on top
07:02 - however now
07:04 - for the other player this one down here
07:06 - if this one has a y position of 100
07:09 - then this y
07:11 - is going to take priority over this one
07:13 - here
07:15 - and that way we make sure that elements
07:18 - overlap in the right way
07:21 - although
07:22 - we do have a problem and the problem is
07:25 - where can we actually implement this
07:27 - kind of logic so where can we control
07:30 - the drawing logic for our game
07:32 - and the answer is quite simple
07:34 - that all of our drawing happens inside
07:37 - of the group in our case this is the
07:39 - camera group
07:40 - and this we are going to customize so we
07:44 - are going to take some parts of the
07:45 - group and change them to make them more
07:48 - useful for us
07:49 - and let's do this straighten code i
07:52 - think that's going to be the easiest way
07:53 - to approach this
07:55 - here we are back in our code and
07:59 - right now my camera group is this
08:01 - pygame.sprite.group
08:03 - and i want to overwrite this group so
08:06 - let's call it camera
08:08 - group to have a specific name
08:10 - and this camera group is still going to
08:12 - be a sprite group just one with more
08:15 - custom functionalities so let me create
08:19 - a new class that i called camera
08:22 - group
08:23 - and in here we have to inherit from
08:25 - pygame.sprite.group
08:29 - and the very first thing we need just
08:32 - like for the player and for the tree
08:34 - we need to create an init method and
08:36 - initialize the parent class
08:39 - so
08:40 - we again need define underscore init
08:45 - it needs self and nothing else and then
08:47 - we need super and dunder
08:50 - init
08:52 - and with that our camera group already
08:55 - has the same functionality as a sprite
08:57 - group so if we had to run the game now
09:00 - nothing should change and let's try and
09:02 - it is indeed working like any other pi
09:06 - game group so this is a good sign
09:09 - now what we can do is to overwrite
09:11 - functionalities in this class
09:14 - and what i essentially want to do is to
09:16 - create a custom draw method
09:20 - and for now this is only going to need
09:22 - self and nothing else
09:25 - and now
09:27 - we kind of have to understand how pie
09:29 - game actually draws something
09:31 - and this is remarkably similar if you
09:34 - have any idea of pie game
09:37 - in the normal draw method what basically
09:39 - happens is we are cycling through all
09:41 - the sprites in self.sprites
09:46 - in this camera group right now we have
09:48 - the player and all of the trees and they
09:52 - are stored in self.sprites
09:55 - and it's really easy to forget the
09:56 - brackets don't make that mistake
10:00 - and then all that pie game really does
10:03 - is it calls
10:05 - the screen
10:06 - then a chord split and then sprite dot
10:09 - image
10:11 - and sprite dot
10:13 - rect
10:15 - or i guess to be a bit more specific
10:18 - this screen here comes from a parameter
10:21 - so let's call it screen in here
10:23 - and this is the screen we have to pass
10:25 - in here
10:28 - and now we can use our custom draw
10:31 - method and
10:33 - use custom draw and if i run this
10:36 - we still get the very same results even
10:38 - though now we have created our own
10:41 - custom draw
10:42 - which is remarkably simple
10:45 - and now let's start to make some changes
10:48 - to this so we can use it a bit more
10:50 - easily
10:51 - the first one i would like to make is i
10:54 - don't really care about creating a
10:55 - parameter here
10:56 - i want to have my display surface
10:59 - available in my camera group immediately
11:02 - and all we have to do for that is create
11:04 - another attribute let's call it display
11:08 - underscore surface
11:10 - and to get the display surface we need
11:13 - pygame dot display dot get underscore
11:17 - surface
11:19 - and now we can use that display surface
11:22 - to draw on
11:23 - and because of that we don't need the
11:26 - parameter anymore and we don't need the
11:29 - argument down here anymore
11:31 - and still if i run out of this
11:33 - same result
11:35 - the game works just fine
11:37 - and with that we can actually already
11:39 - get our sprites sorted all we
11:42 - essentially have to do is when we are
11:44 - drawing all of our sprites here
11:47 - we have to sort them by the y position
11:50 - and this happens
11:52 - with
11:53 - the
11:55 - sorted method that is native to python
11:58 - and sorted takes two arguments
12:01 - it takes the list you want to sort so my
12:04 - case self.sprites
12:06 - and then it needs some kind of key on
12:09 - how to sort these elements
12:12 - so key
12:14 - and in here
12:15 - we have to extract the y position from
12:18 - each of the sprites
12:19 - and for that
12:21 - i'm going to use a lambda function with
12:24 - sprite is what i'm looking at
12:26 - and
12:27 - all i really want to return is
12:29 - sprite.rect.center
12:32 - y
12:33 - which basically means i am telling
12:35 - python to look at this list and sorted
12:37 - by the center y position of each of the
12:39 - sprites
12:41 - if you understand lambda functions this
12:43 - should be fairly straightforward
12:45 - and well that's actually all we needed
12:48 - so let's try this now
12:49 - and now my player is behind the trees
12:52 - but now it's in front
12:55 - and this works for all of the trees
12:58 - so now we have dynamically added
13:00 - the ability for our game to draw stuff
13:02 - on top or behind and this adds some nice
13:06 - fake 3d which i really like it makes the
13:09 - game look significantly better
13:14 - and cool this is working super well
13:17 - now you can actually work with this
13:19 - quite a bit more for example what we
13:22 - also have is a ground and the ground
13:24 - shouldn't be in this list at all the
13:27 - ground should happen before
13:30 - so we want to have the ground here and
13:32 - then let's call it active
13:34 - elements or something like that
13:38 - and to implement this logic we just have
13:40 - to draw elements here
13:42 - before this for loop that's all you need
13:46 - and in my case i have approached this in
13:49 - this way
13:50 - in the init method i have created
13:53 - self.ground underscore surface
13:56 - and this one is just pygame.image.load
14:01 - and we need to import graphics
14:05 - and ground dot png and don't forget to
14:08 - convert that
14:10 - and then we also need self.ground
14:13 - underscore rectangle
14:15 - and we need
14:17 - self.groundsurface.get underscore rect
14:20 - and the top left
14:23 - is going to be a tuple with 0 and 0.
14:26 - and that way
14:28 - we have access to a ground and a
14:31 - rectangle on where to place it
14:33 - and now we can just call self dot
14:36 - display surface dot blit
14:39 - and place in self.groundsurface
14:42 - and
14:42 - self.ground rect
14:45 - and if i draw this now we have a ground
14:48 - but something went wrong with the alpha
14:50 - but at the very least we have a ground
14:52 - that's always well on the ground
14:55 - and otherwise
14:56 - we are still having our player behind or
14:59 - in front of the trees depending on where
15:01 - we are
15:02 - and the one mistake i made
15:04 - is that this convert should be convert
15:06 - alpha
15:07 - so now the stress again that fits better
15:10 - so now this is still working really
15:13 - really well
15:15 - and that is already the first camera
15:19 - that we needed
15:20 - to create some fake 3d
15:23 - and with that we can come to the second
15:25 - camera and that is a player-centered
15:28 - camera so a camera that always follows
15:31 - the player
15:32 - and before we can implement that we have
15:35 - to address another question
15:38 - and that question is how does a moving
15:40 - camera work in the first place so how
15:43 - can we shift stuff around on the screen
15:46 - because our game window always starts at
15:49 - position 0 and then goes up to a certain
15:52 - point in our case 1280 and 720
15:56 - and this window we cannot move no matter
15:59 - what we do
16:00 - so we have to figure out something else
16:02 - and let me explain how this is working
16:05 - usually when you use pygame you have a
16:07 - rectangle
16:08 - and you place a surface right in the
16:11 - middle of that rectangle so the position
16:13 - of these two elements are identical
16:16 - but they don't have to be you could
16:18 - totally draw the surface somewhere
16:20 - outside of that rectangle
16:22 - and this is what the camera does
16:24 - so essentially we have our rectangle
16:27 - but now when we draw the surface we are
16:29 - adding a vector offset and only then are
16:32 - we drawing the surface
16:34 - so for example if the top left of our
16:37 - rectangle
16:39 - this point here let's say was a hundred
16:42 - and two hundred for x and y respectively
16:46 - and our vector
16:48 - let's say is something like let's say
16:52 - 150
16:56 - then our surface would be drawn at
16:58 - position 200 for x and
17:02 - 250 for y
17:06 - so even though our original rectangle
17:09 - had this position we are drawing the
17:11 - surface somewhere else in this position
17:14 - here because of the vector offset
17:19 - and the only thing we need now
17:21 - is to get this vector offset from the
17:25 - player position
17:27 - so for example if the player is walking
17:30 - to the right then we want this vector
17:32 - offset to move in the opposite direction
17:35 - because remember for a camera if you're
17:37 - working right you want all the other
17:38 - elements to move to the left so you have
17:40 - a counter movement
17:43 - and that is
17:45 - essentially all we needed so now we can
17:48 - start working on implementing all of
17:49 - this
17:50 - here we are back in the code and let's
17:54 - get to work on all of this now first of
17:57 - all
17:58 - i want to add a bit more comments to
18:01 - have this thing a bit more organized
18:02 - it's getting a bit messy
18:04 - that's looking better
18:06 - now
18:07 - what i really want to get
18:10 - is let's call it camera offset and this
18:14 - is going to be self dot
18:16 - offset and this is going to be a
18:19 - pygame.math.vector2
18:23 - and for now with position 0 and 0. so we
18:25 - can just leave it empty
18:28 - how we are going to use this offset
18:31 - is when we are drawing these elements
18:33 - here
18:34 - and this ground as well
18:36 - i want to add the vector to the
18:38 - rectangle so this rectangle here and
18:41 - this rectangle here
18:42 - and let's start doing this inside of the
18:46 - for loop
18:48 - and essentially what i'm going to do i'm
18:50 - going to create an offset underscore
18:53 - position
18:54 - it's not an underscore position
18:57 - and we are getting this with sprite dot
18:59 - rect dot top left
19:02 - plus
19:03 - self dot
19:04 - offset
19:05 - and then we're using this offset
19:08 - position
19:09 - to place the surface
19:11 - and the same thing we also have to do
19:13 - for the ground so let's call this one
19:15 - the ground offset
19:18 - and this one is going to be self.ground
19:23 - dot top left i am terrible typing today
19:27 - and plus self dot
19:28 - offset
19:30 - and right now
19:32 - since our offset is zero this should not
19:34 - be changing anything
19:35 - so let's run the code and indeed we can
19:38 - see nothing has changed
19:40 - which is generally a good sign
19:43 - however what i can do now is add numbers
19:46 - to this vector so let's say i want to
19:49 - give it 300 and 100
19:53 - now what we can see
19:54 - is that our entire window is moved 300
19:57 - pixels to the right and 100 pixels down
20:00 - although i just realized for the ground
20:02 - offset
20:03 - i actually have to apply it down here so
20:06 - now let's try this again and this is
20:08 - feeling better
20:10 - and let's really emphasize this let's
20:13 - say instead of 300 let's go with 800 and
20:16 - for y we're gonna go with zero
20:18 - now
20:19 - you can see all of our elements are way
20:22 - to the right
20:23 - we can still move the player but well
20:25 - the player starts already outside of the
20:27 - window
20:29 - so what we have to figure out now let me
20:31 - move those back to zero and zero what we
20:33 - have to figure out now is how to center
20:37 - this offset relative to the player and
20:40 - right now i want the player to always be
20:42 - in the center of the window
20:43 - and let me draw out how this is going to
20:46 - work
20:47 - let me minimize this method here so i
20:50 - have a bit more space
20:52 - essentially imagine that this here is
20:55 - our entire game window
20:57 - and inside of this window we have our
20:59 - player roughly here
21:03 - and the really important information i
21:05 - now have to figure out is this point up
21:09 - here
21:10 - because the top left is going to be the
21:12 - reference point where we are going to
21:13 - start
21:14 - and this also is going to be the offset
21:17 - we are going to move by default this is
21:20 - 0 and 0.
21:22 - so essentially we are going to add this
21:24 - vector to it and that way 0 and 0
21:26 - becomes whatever this offset is going to
21:29 - be
21:30 - and since i always want my player to be
21:32 - in the center of the window i want the
21:34 - player to be half
21:36 - the width of the screen so let's call it
21:38 - w
21:39 - on the x-axis
21:40 - and half the height of the window on the
21:43 - y-axis
21:44 - so let's call it h divided by 2 and with
21:47 - divided by 2. that makes more sense
21:50 - in terms of math then what i essentially
21:52 - want to do i want to get the center of
21:54 - my player and subtract either the width
21:56 - or the height from that and use that to
21:59 - get this position up here
22:02 - and let's implement this
22:04 - and the logic here i feel like can be a
22:07 - bit confusing i would really recommend
22:09 - you to play around with this but let me
22:11 - actually implement this then i think
22:13 - it's going to make sense
22:15 - and first of all let me minimize the
22:18 - tree
22:19 - and reopen the init method the first
22:21 - thing that we are going to need is the
22:23 - width and the height of the window or
22:25 - well half the width and half the height
22:28 - and let me do this
22:30 - below the offset and let's call itself
22:33 - half underscore w
22:35 - and we're getting this with self.display
22:38 - surface and then get underscore size
22:42 - and this returns a tubal with x and y
22:45 - and we only care about x
22:47 - and we want to divide this by two
22:50 - and for the height
22:51 - we can do the same thing with h and we
22:54 - need the first integer
22:56 - of this tuple
22:58 - so now we have half the width and half
22:59 - the height
23:01 - now
23:02 - when we are drawing this custom draw
23:05 - i want to apply this half width and half
23:08 - height to my offset
23:09 - and let's do this in a dedicated method
23:14 - so we can keep the different cameras
23:15 - apart from each other
23:17 - and let's call it the center
23:20 - target
23:21 - camera
23:22 - it needs self and it needs a target
23:25 - in my case it's going to be the player
23:27 - but it could be literally any object in
23:30 - your game
23:31 - and for this one i want to set myself
23:34 - dot offset and the x position
23:36 - and self.offset and y
23:39 - position
23:41 - and now we just have to apply what i
23:43 - just explained
23:44 - so i want to get myself.target.centerx
23:49 - and from that
23:51 - i want to subtract self.half
23:55 - with
23:56 - and for y i want to get
23:58 - myself.target.rect.
24:03 - center y
24:04 - and subtract self
24:07 - dot half
24:09 - ike
24:11 - and that was all we needed almost
24:14 - actually
24:15 - all we have to do now is call
24:17 - self.center target camera
24:20 - and place in a target in my case it's
24:22 - going to be the player
24:24 - right now we don't have the player so
24:27 - i'm going to create a parameter for the
24:29 - player
24:30 - and this player
24:34 - we don't really have accessible right
24:35 - now but we can just put it into a
24:39 - variable so player
24:41 - and then when we call custom draw
24:43 - i can add my player in here
24:47 - and now there's one more thing we have
24:49 - to do but let's just try it and see what
24:51 - happens
24:52 - we are getting an error ah because this
24:55 - shouldn't be self it should just be
24:57 - target because it's a parameter
25:00 - now if i run this our camera moves in
25:03 - exactly
25:05 - the wrong direction
25:08 - which is a very disorienting experience
25:11 - and the reason here
25:13 - is this line
25:15 - that this
25:17 - should be negative
25:18 - because if we are simulating a camera we
25:21 - want to move all of the elements in the
25:23 - opposite direction that our target is
25:25 - moving
25:27 - and if we're not doing that you well saw
25:29 - the results and now if we try this
25:32 - i realized i forgot
25:36 - we have two offsets we have this one and
25:38 - we have this one
25:40 - and if i try this now now it is working
25:43 - properly
25:44 - so i can just walk around and the camera
25:46 - always follows the player and
25:48 - the depth perception still works where
25:51 - our player is drawn behind or in front
25:53 - of the trees
25:54 - which is already a really useful camera
25:58 - cool
26:00 - and with that
26:01 - we have covered our second camera which
26:04 - wasn't actually all that bad
26:06 - so with that we can talk about the next
26:09 - camera the box camera and basically how
26:12 - this is going to work we have our player
26:15 - inside of our screen and we also have
26:18 - the camera box
26:20 - and if our player is moving to the left
26:22 - of that then we want to move this
26:25 - rectangle also to the left
26:27 - that way our player can move inside of
26:30 - this rectangle without moving the
26:32 - rectangle
26:33 - but once we are going too far down let's
26:36 - say then we're moving down the camera
26:38 - so our player basically can never leave
26:40 - this camera box
26:42 - and this is pretty much a 2d platformer
26:44 - kind of camera you also see it in a lot
26:47 - of top-down games as well it's a really
26:48 - popular one
26:50 - and how we are going to implement this
26:53 - is this camera box here is going to
26:56 - become
26:57 - a rectangle that we are then going to
27:00 - move along with the player and remember
27:03 - for our last camera
27:04 - we used the difference between our
27:06 - player
27:07 - and the top left for the offset to move
27:10 - all of the elements
27:12 - what we are now going to do is our
27:14 - player is going to move the rectangle
27:17 - and then the top left of the rectangle
27:19 - is going to influence the offset
27:24 - and that is probably kind of hard to
27:26 - follow let's implement all of this in
27:29 - code that should make more sense
27:31 - here we are back in the code and the
27:33 - first thing i want to do is to add
27:35 - another section to our camera and let's
27:38 - call this the box setup
27:41 - and in here
27:42 - we basically want to create what i
27:45 - called a camera underscore rectangle and
27:48 - this is the red rectangle i just talked
27:50 - about this is going to be moved by the
27:52 - player and determine the offset
27:55 - so this has to become a pie game dot
27:58 - rect
27:59 - but we now need a left a top a width and
28:02 - a height
28:03 - and we don't have that so we have to add
28:07 - a few more lines of code to create this
28:09 - kind of rectangle
28:11 - and the first thing i have
28:14 - is what i called camera borders and in
28:17 - here we have left right top and bottom
28:21 - and this is basically the distance from
28:23 - the border of the screen to the camera
28:25 - side when we should start moving the
28:27 - camera
28:28 - so
28:29 - if
28:31 - this here was our window
28:33 - and from the left we want this distance
28:36 - that's going to be left it will be
28:39 - 200
28:40 - and just for another example for the top
28:43 - is going to be this distance here 100
28:45 - pixels
28:46 - and these distances we can now use to
28:49 - create
28:51 - a left
28:52 - a top a width
28:54 - and a height
28:56 - and let's just go through them one by
28:58 - one first of all for the left side i
29:00 - want my camera borders and i just want
29:04 - the left side that one is really easy
29:06 - same with top actually
29:08 - we need
29:09 - self.camera borders and we just want top
29:14 - essentially what we have just done if
29:17 - this is again our window
29:19 - we have figured out the top left of the
29:22 - rectangle with the left and the top
29:25 - what we now have to figure out is the
29:28 - width of this rectangle and the height
29:31 - of this rectangle
29:34 - and this we are getting from the right
29:36 - and from the bottom
29:38 - and let's start with the width we know
29:40 - that the entire rectangle is 1280 pixels
29:44 - wide
29:45 - we also know that this distance here is
29:49 - 100 pixels and this distance here all
29:52 - the way on the right is 200 pixels
29:56 - that's the information we get from right
29:59 - which means all we really have to do is
30:01 - get 1280 minus 100 minus 200 and that
30:06 - way we only get
30:08 - this middle side here
30:10 - and then we can do the same thing for
30:11 - the y position and we are good to go
30:15 - which means all i really want to do
30:18 - is get myself dot display surface and
30:22 - get underscore size
30:25 - and i want to get the weft and from that
30:28 - i want to subtract
30:30 - myself.camera borders
30:33 - left
30:35 - and
30:36 - self.camera borders
30:39 - right
30:42 - and now we can just copy all of this
30:45 - for the height
30:48 - we need integer one to get the height
30:50 - and i want to add the top
30:53 - and the bottom
30:56 - and now we have a camera rectangle
31:00 - and this may still be
31:02 - a
31:03 - bit uncertain what we're actually doing
31:05 - here so let me draw this camera
31:07 - rectangle to illustrate what's going on
31:10 - all the way at the bottom i want to
31:11 - pygame.draw.rect
31:14 - on
31:15 - myself.displaysurface
31:16 - let's make it yellow
31:20 - and self dot camera
31:23 - wrecked
31:24 - and let's give it a border so we don't
31:26 - fill the entire window and now if i run
31:29 - this
31:30 - you can see here we have
31:32 - our camera rectangle and it moves along
31:35 - with the player oh well it doesn't
31:37 - really move along with the player it's
31:39 - just that we don't update the position
31:41 - but at the very least we know it's kind
31:43 - of working
31:45 - what i want to do now
31:47 - is that the top left of this camera
31:50 - rectangle
31:51 - should set self.offset meaning that this
31:54 - self.offset and this self.offset should
31:58 - both be determined by this camera
32:01 - rectangle
32:03 - and again let me comment out our center
32:05 - camera and put all of this in a separate
32:08 - function
32:09 - and i called this box target
32:13 - camera
32:14 - again we need self and target and
32:17 - nothing else
32:18 - at the end of this line i want to set my
32:22 - self.offset
32:23 - and let's separate this in x and self.
32:27 - offset
32:28 - that thing i think that makes it a bit
32:30 - easier
32:32 - and here again let me explain what we
32:34 - have to do
32:36 - we have our window
32:38 - and when we talked about the center
32:41 - camera so this one here
32:42 - we went from the center where the player
32:45 - is all the way to the top left
32:48 - but in this case for the box
32:50 - we
32:51 - have this rectangle and this rectangle
32:54 - in a second will be moved by the player
32:57 - now we want the distance from this top
32:58 - left point
32:59 - to the top left of the window
33:03 - so kind of the same principle except now
33:06 - our starting point is slightly different
33:09 - but essentially i want to get self dot
33:12 - camera rect dot left
33:15 - and from that i want to get myself dot
33:19 - camera borders
33:21 - and
33:23 - left
33:24 - remember here by default this should be
33:26 - zero until we move the rectangle
33:30 - and we can do the same thing for the top
33:33 - and for the top
33:35 - and now let's call
33:38 - self.box target camera
33:41 - and don't forget to call it and now
33:43 - let's try we are getting an error
33:45 - because we don't have a target needs to
33:47 - be player
33:49 - now let's try this and now we can see
33:51 - that well we don't really get anything
33:53 - because we are not updating this
33:55 - rectangle
33:57 - and let's do this straight in the
33:59 - function i think that's going to be the
34:00 - best way to think about it
34:02 - in this function all i really want to do
34:05 - is if
34:06 - my target.rect.left
34:10 - is for example smaller than self.camera
34:14 - rect dot left
34:16 - meaning our player is further to the
34:18 - left than the camera rectangle
34:20 - if that is the case i would set
34:22 - myself.camera
34:25 - rect.left
34:27 - where our
34:29 - target.rect.left is
34:31 - basically meaning here we have our
34:33 - player and we have
34:36 - the box around the player
34:38 - if the player moves outside of this
34:40 - rectangle we want to move the rectangle
34:43 - to the same position so that those two
34:46 - have the same x position
34:49 - and let's try this actually this should
34:50 - be working already
34:53 - now if i move to the left you can see we
34:56 - are moving the rectangle now the drawing
34:58 - here of the rectangle gets a bit
34:59 - confusing but the logic works just this
35:03 - drawing here is a bit strange so let me
35:06 - just get rid of it we don't need it
35:07 - anymore and now let's try it again
35:10 - and there we go this is working really
35:12 - nicely
35:14 - now all we have to do is copy
35:16 - this if statement to cover all the four
35:18 - directions
35:20 - so
35:21 - camera.right
35:22 - and camera.right
35:24 - except now we're checking if this is
35:26 - greater than
35:28 - but other than that we are just
35:29 - switching
35:31 - left to right
35:34 - and let's try this one
35:36 - now my player is moving right my player
35:39 - is moving left and this is working
35:42 - really well cool
35:45 - then next up
35:47 - we can do the same thing
35:49 - for camera rect let me just switch all
35:52 - of them at the same time
35:54 - so top
35:55 - and we have to check for smaller and i
35:58 - guess while we add it let's do also the
36:00 - bottom to have all the four directions
36:04 - so
36:04 - all of the tops here should be
36:08 - bottom
36:10 - and then we again need greater
36:12 - and now we should be done
36:16 - so
36:17 - this is working
36:19 - really well
36:24 - nice and i guess to make the trees a bit
36:28 - less confusing
36:29 - let's change this 0 to 1000 to 1000 to
36:34 - 2000
36:38 - and now let's try this again now we
36:40 - can't see trees over the water anymore
36:42 - and all the trees are here
36:44 - which is uh significantly more realistic
36:47 - but well you can see that you can place
36:49 - stuff basically wherever you want it
36:51 - still works just fine
36:54 - and all right with that we have our next
36:57 - camera sorted
36:59 - which means we can now work on the next
37:01 - camera and that is a keyboard controlled
37:04 - camera
37:05 - and this one is probably the easiest one
37:08 - of them all once we have the setup we
37:09 - already have because essentially all we
37:12 - have to do is to use our keyboard keys
37:15 - to influence the offset that's literally
37:17 - it we can do this straight in the code
37:19 - this shouldn't take long at all
37:21 - here we are back in our code and i want
37:25 - to create another method and let's call
37:28 - this one keyboard
37:30 - control
37:32 - in itself and nothing else first of all
37:35 - i have to get my keyboard input which
37:37 - happens with pygame dot key
37:40 - and get underscore
37:42 - rest
37:44 - and then i want to check different keys
37:47 - now since i already use up down left and
37:49 - right for my player i am going to use if
37:52 - keys and pygame.k
37:54 - underscore a
37:57 - i am basically going to use wasd for the
37:59 - controls
38:01 - and now we kind of have to make a
38:04 - decision how we want to influence the
38:06 - offset do we ever want to influence the
38:08 - offset immediately
38:10 - or use our camera rect and influence the
38:14 - camera with that
38:16 - let's actually do both and then you can
38:18 - see what i mean
38:20 - so
38:20 - if i press a i want to get
38:22 - myself.offset.x
38:25 - and move it in a certain direction
38:28 - the direction i want let me add another
38:31 - section in here
38:32 - and that could be let's call it camera
38:34 - speed
38:36 - and in here i want self dot keyboard
38:40 - speed
38:41 - we are later going to have a mouse speed
38:43 - as well and i do want to keep them
38:45 - separate and for this one let's go with
38:47 - five
38:48 - now if we are pressing to the left we
38:51 - want to decrease
38:54 - our self
38:55 - dot keyboard speed
38:59 - and well now we just have to duplicate
39:03 - this a couple of times
39:06 - let's say with d
39:07 - and now i want to add
39:10 - my keyboard speed
39:12 - then i want to get my up then we want to
39:15 - move in the y direction
39:17 - and it should also be negative because
39:19 - we are moving up
39:21 - and finally
39:23 - we have s and now we're moving down so
39:25 - this is plus
39:27 - so now i just have to call myself dot
39:30 - keyboard control
39:32 - run the game
39:34 - we are getting an error because this
39:37 - should be pygame dot key
39:40 - now let's try this again there we go so
39:42 - i can still move my player around but
39:44 - now if i use wasd
39:46 - i am moving the actual camera around and
39:49 - i can use those two independently of
39:51 - each other that one works totally fine
39:57 - and all the other elements still work
39:59 - just fine
40:03 - now you do have to be careful
40:06 - if you want to use the box camera as
40:09 - well
40:10 - you might
40:12 - get a problem if you use both the
40:13 - keyboard control and the box camera
40:16 - one way to avoid that is to not use the
40:19 - offset but instead to switch
40:22 - the offset to the camera rect
40:26 - and then at the end we can copy from
40:30 - our box camera
40:33 - these two lines here
40:35 - and paste them in here
40:37 - so now instead of having the player
40:40 - change the camera rectangle we use the
40:42 - keyboard to do all of that and let me
40:43 - clean this up a tiny bit i think if we
40:46 - put the if statements on one line this
40:48 - is a bit easier to read
40:52 - there we go this feels much better now
40:54 - we should have the same outcome
40:56 - and we can still move the rectangle
40:58 - around except now we are controlling the
41:00 - rectangle first and the rectangle
41:02 - influences the offset
41:04 - and that is a bit of a better way i
41:07 - think if you use both the box target and
41:09 - the keyboard control but both approaches
41:11 - are basically fine and if you combine
41:14 - different camera methods
41:16 - i would recommend to play around with
41:17 - this quite a bit it's very easy to get
41:20 - bugs in there
41:21 - but alright with that we have our
41:23 - keyboard control
41:25 - so next up we can work on the mouse
41:28 - control and
41:30 - this one is going to be a bit more
41:33 - complex let me explain what we are going
41:35 - to do first
41:36 - we set up our player and we have our
41:39 - screen and the basic logic is going to
41:41 - be
41:42 - that we still have our camera box we are
41:45 - actually going to reuse the same camera
41:47 - box we had earlier
41:49 - and now we are not going to check the
41:51 - player position at all
41:53 - instead we are going to check the mouse
41:55 - position on every frame of our game
41:57 - and if the mouse position goes outside
42:00 - of this box let's say our mouse is here
42:04 - then we are going to check this distance
42:07 - here
42:09 - then we are going to move the entire
42:11 - rectangle by this position
42:13 - and we are also going to disable our
42:16 - mouse position so it can't move any
42:18 - further to the left
42:20 - which by itself is pretty simple
42:24 - the one thing that makes this whole
42:26 - process a bit tedious is that we can
42:28 - only get the mouse position once per
42:31 - frame
42:32 - which means that we have to do a lot of
42:35 - if statements
42:37 - now we do have a problem with this
42:38 - approach though that we can only check
42:40 - the mouse position once per frame if you
42:43 - do it more than once it just stops
42:45 - working
42:46 - but that is kind of a problem
42:49 - we have this side here this side here
42:51 - this side here and this side here and
42:54 - all of those work by themselves we only
42:56 - have to check our mouse position once
42:58 - but we also have this corner this corner
43:02 - this corner
43:03 - and this corner here
43:05 - where we want to check both the x and
43:07 - the y position
43:09 - and as a consequence we have to write
43:12 - eight if statements in total
43:14 - or at least we have to cover eight
43:16 - different cases
43:18 - which gets a bit tedious but once you
43:20 - understand the logic it shouldn't be too
43:22 - difficult
43:24 - i guess let's implement it and let's see
43:26 - how far we get
43:27 - here we are back in the project and i
43:30 - want to create a new method
43:33 - let's call this one mouse
43:35 - control
43:36 - we need self and nothing else
43:40 - and in here first of all i want to get
43:42 - my mouse position and this we get with
43:45 - pygame.math.get
43:46 - [Music]
43:48 - underscore position
43:50 - and since we have to work with this
43:52 - quite a bit in terms of math i want to
43:54 - turn this position into a vector so
43:56 - pygame.math.vector2
43:59 - actually this shouldn't be math this
44:01 - should be mouse
44:03 - now we are going to need another vector
44:06 - which i called mouse offset
44:09 - vector
44:11 - and right now it's just going to be
44:15 - pygame.math.vector2 with 0 and 0.
44:18 - and what this vector essentially does if
44:21 - this is our entire screen
44:23 - and this one here is our camera
44:25 - rectangle
44:27 - if the mouse goes outside of it then
44:30 - this distance here
44:32 - is going to be stored in the vector and
44:34 - this could either be an x direction
44:36 - it could be a y direction or it could be
44:40 - both
44:41 - which is why we need this as a vector
44:44 - and now we have to figure out the
44:46 - borders of our mouse so at what point
44:49 - does the camera start moving and in my
44:52 - case i am going to use the camera
44:54 - borders
44:55 - i really want to emphasize we are using
44:58 - the camera borders not the camera
45:00 - rectangle
45:01 - and the reason is that our camera
45:03 - rectangle can be moved around in the
45:05 - world but the mouse isn't bound by that
45:08 - the mouse is always relevant to the
45:10 - original game window
45:12 - i hope that makes sense it's a bit
45:14 - confusing when you work with cameras
45:16 - just think about it for a bit i hope it
45:18 - makes sense
45:19 - but anyway
45:20 - since we're going to use those quite a
45:22 - bit i'm going to store all of this in a
45:23 - couple of variables to make it a bit
45:25 - more understandable so we have left
45:27 - border top border
45:30 - right
45:31 - border and a bottom
45:34 - border
45:37 - and the left border is just going to be
45:39 - self dot camera borders
45:42 - and
45:43 - left
45:44 - then we have self dot camera borders
45:49 - and the top
45:51 - and the right border is now going to be
45:53 - self dot display surface dot get
45:56 - underscore size
45:58 - we want to get the width and from that
46:00 - we want to subtract
46:02 - self dot camera
46:04 - borders and
46:06 - right
46:08 - which basically means if this is the
46:11 - entire width of our window we are
46:13 - subtracting the right let's say it's
46:15 - this distance here and then this point
46:18 - in our game is the right side
46:20 - so the rest of the game would be
46:22 - something like this
46:25 - and now we can do the same thing for the
46:28 - bottom border
46:30 - except now we need the height and we
46:33 - need the
46:34 - bottom
46:36 - now we have the borders of where our
46:39 - mouse is not supposed to go beyond what
46:42 - we have to do now is a ton of if
46:44 - statements and let me cover all of this
46:48 - let me minimize this method here so i
46:50 - have a bit more space because there's
46:53 - going to be quite a bit of drawing
46:54 - coming up
46:56 - here we have our entire game window
47:02 - and what i first want to check is if our
47:05 - mouse is inside
47:08 - of these two sides
47:10 - so this is the top and bottom of the
47:12 - left side and the top and bottom of the
47:13 - right side
47:15 - importantly now
47:16 - we are excluding the top so the top and
47:20 - bottom of both of these sides
47:23 - is
47:24 - not
47:25 - included
47:26 - because right now i only want to check
47:28 - the x dimension and not worry about this
47:31 - other position whatsoever
47:33 - and what that means is if the top border
47:36 - is smaller than mouse dot y
47:40 - which is the mouse we get from all the
47:42 - way up here
47:43 - and if that one is smaller than the
47:45 - bottom border
47:48 - then we know we are in this
47:50 - area and now i can check if my mouse dot
47:54 - x
47:55 - is smaller than the left border
47:58 - meaning now we are in this area here
48:02 - if that is the case i want to set my
48:04 - mouse offset vector and x
48:07 - then i want to get my mouse.x
48:09 - and from that i want to subtract my left
48:13 - border
48:14 - essentially what this is going to give
48:16 - us if our mouse is right here now
48:19 - we are getting this
48:21 - distance and storing it in mouse of side
48:24 - vector
48:25 - and once i have this distance
48:28 - i want to get pygame.mouse
48:30 - and set the position of this mouse and
48:34 - in here i have to specify an x and a y
48:37 - position
48:39 - now for the y position i want to put my
48:41 - mouse where my mouse used to be because
48:43 - i don't care about y right now
48:46 - but for the x position i want to place
48:49 - this at the left border
48:51 - this would then be the logic for the
48:53 - left side of the window
48:55 - all we would have to do at the end
48:57 - is set self dot
49:00 - offset
49:01 - and plus equal my mouse
49:04 - offset vector
49:06 - and let's actually try this
49:09 - and see what we get so in my custom draw
49:13 - i want to disable the keyboard and now
49:16 - self. how did i call it mouse control
49:22 - and let's see what we get
49:25 - we are well getting an error because
49:28 - this shouldn't be a double equal sign
49:31 - now let's try this again
49:32 - we're getting another error that
49:36 - self dot display i am losing the ability
49:40 - to type
49:41 - x attempt
49:43 - oh it should be display
49:45 - surface
49:47 - next attempt there we go now if i move
49:50 - my mouse to the left side there we go
49:53 - this is working
49:54 - very nicely
49:59 - all we have to do now is cover all of
50:02 - the other seven sides and we are done
50:05 - now first of all i want to check
50:09 - if my mouse dot x is greater than my
50:13 - right border
50:14 - and if that is the case let me copy
50:17 - all of this
50:20 - then i want to check my mouse x
50:24 - minus my right border
50:28 - and i want to set the right border
50:31 - as the position of the mouse
50:33 - let's try this i can move right i can
50:36 - move left
50:37 - and that is working really nicely
50:41 - all right this is working just fine so
50:44 - now
50:45 - we can also start working on the top and
50:48 - down movement which is going to work
50:50 - very similar compared to this line here
50:54 - so let me just copy it and now i want to
50:57 - check if my left border
50:59 - is smaller than mouse x
51:01 - and if that is smaller than my right
51:03 - border
51:04 - and if i draw all of this
51:06 - and let me clean this up a tiny bit so
51:08 - now
51:10 - we only care about
51:14 - the top line here
51:16 - and the bottom line here and again we
51:20 - are not including the right or the left
51:22 - side
51:23 - you actually gonna see in a second why
51:25 - that is
51:26 - but first of all i have to do a lot of
51:29 - similar logic i have done here so let me
51:31 - just copy the entire thing to save me
51:33 - some writing
51:34 - first of all i want to check if we are
51:37 - on the top of the window
51:40 - so if mouse.y is smaller than our top
51:45 - border
51:46 - and if that is the case i want to get
51:48 - the y position the y position again and
51:51 - this should be the top
51:54 - border
51:55 - and now when i set the position of the
51:57 - mouse
51:58 - i want to keep the same x position
52:02 - but the y position should be the top
52:05 - border
52:07 - and then the same for the bottom so now
52:09 - we are checking if we are greater or if
52:12 - the mouse position is greater than the
52:14 - bottom border
52:15 - and if that is the case i want to get
52:17 - the y position the y position again
52:20 - and from that subtract the
52:22 - bottom border
52:24 - and then again let me actually copy it
52:26 - from here
52:28 - we want to set
52:31 - the x position where the mouse used to
52:33 - be but we want to put the y position of
52:35 - the mouse on the bottom border
52:38 - and there we go now we have four sides
52:40 - covered
52:43 - so now i can move left and right i can
52:46 - move down and up
52:48 - but if i try to move
52:51 - both down and right my mouse just keeps
52:55 - on going outside of the window which is
52:58 - not great
52:59 - and this is the problem that happens in
53:01 - all sides
53:03 - and essentially what happens here is
53:06 - we are first checking the left and the
53:09 - right side and then we are setting the
53:11 - mouse position here once
53:13 - after we are done with that we are doing
53:15 - the same thing for up and down the
53:18 - problem is we can only set the mouse
53:20 - position once per frame
53:22 - so if we trigger both the second one is
53:24 - not working anymore
53:26 - so we basically have to add a couple
53:28 - more if statements
53:30 - and these if statements have to go
53:31 - inside of the first if statement because
53:34 - remember if we are setting the position
53:35 - of the mouse once this one down here
53:38 - doesn't seem to be running anymore so we
53:41 - have to add more if statements here for
53:43 - the edge cases and then
53:45 - if they're running all of this will be
53:46 - ignored
53:48 - so i want to get an else statement in
53:51 - here
53:53 - that else let's say mouse dot y
53:56 - is smaller than the top border
53:59 - and inside of that i want to check if
54:02 - mouse dot x
54:03 - is smaller than the left
54:06 - border
54:07 - and with that i know the mouse is on top
54:09 - and off the left of our borders so now
54:13 - i can get my mouse offsite vector
54:17 - and this one is going to be my mouse
54:18 - position
54:20 - and from that i want to subtract my left
54:22 - and my top border both of them from the
54:25 - x and y position respectively so in my
54:27 - case i turned both into a vector so math
54:30 - vector2 and here we have the left border
54:34 - and the top border
54:37 - meaning now we are setting both of these
54:39 - positions at the same time
54:41 - and then when we are resetting the mouse
54:43 - we are calling pygame.mouse.set
54:46 - underscore position
54:48 - and now
54:49 - we have the left border and the top
54:53 - border
54:54 - and with this setup we are only calling
54:57 - set position once we're not calling it
54:59 - twice
55:01 - and well now we just have to cover all
55:04 - the other cases so if mouse.x is greater
55:07 - than the right border
55:09 - now we're in the top right border
55:11 - which brings us in the top right corner
55:15 - and let me copy all of this so i save a
55:17 - bit of writing
55:19 - now we still get our mouse position but
55:21 - from that we are subtracting
55:24 - the right border but still the top
55:25 - border and then when we are placing the
55:28 - mouse i want the right border
55:30 - and that covers the top left and the top
55:32 - right now i want to copy this entire l
55:35 - if statement
55:37 - and now my mouse dot y
55:41 - is going to be greater than the
55:45 - bottom border so now we cover the bottom
55:47 - corners
55:49 - and in here we are still wanting to
55:51 - check the left side but now we can keep
55:54 - all of it except the top border should
55:56 - be the bottom border
55:58 - or both of these
56:01 - and now we're checking the bottom right
56:02 - so the right border and the
56:05 - bottom border and we are checking the
56:08 - bottom border when we are setting the
56:10 - position
56:11 - and you can kind of tell
56:13 - kind of an elaborate if statement
56:17 - but now if we try it off this
56:19 - oh it should be
56:22 - l if
56:23 - and l
56:25 - if
56:26 - it's been a long recording session there
56:28 - we go now if i move my mouse
56:30 - up down right and left oh you can see a
56:33 - problem already
56:35 - ah you can actually see it really well
56:37 - the problem here is twofold actually
56:40 - if we move the mouse too fast the game
56:43 - moves really really fast which is very
56:46 - bad
56:47 - so i want to give this mouse back to
56:48 - offset a certain kind of speed limiter
56:51 - which basically means i'm going to
56:53 - multiply it with self dot mouse
56:57 - and this self.mouse speed
57:00 - i am setting up here so self dot
57:02 - mouse
57:05 - speed
57:07 - and for me 0.4 felt the best
57:11 - but now we have one more problem that if
57:14 - i move my mouse really fast let's
57:15 - actually try it so if i move really fast
57:19 - my mouse goes outside of the window
57:22 - which well isn't the idea of the game
57:25 - but we can fix that kind of easily
57:30 - all we have to set in here
57:33 - is one line of code although really
57:35 - important before you write this code i
57:38 - do want to warn you after i write this
57:41 - do not run the code straight away you
57:43 - will not be able to close it because you
57:45 - can't press the close button anymore
57:47 - i'm going to fix that right after before
57:49 - i run the game please take care of that
57:51 - now the line we need is pygame dot event
57:54 - dot set underscore grab
57:57 - and this has to be true
57:59 - and this basically
58:02 - makes it so that our mouse cannot leave
58:04 - the screen anymore
58:06 - which is then preventing us from closing
58:08 - the game so we have to find another way
58:10 - to close the game and in my case i'm
58:12 - just going to check for another keyboard
58:14 - input
58:15 - if event dot type
58:18 - is equal to pygame dot
58:21 - down
58:23 - and then if event dot
58:26 - e
58:27 - is equal to pygm dot k underscore escape
58:32 - which basically means we're pressing the
58:33 - escape button and if that is the case
58:37 - i want to run pygm.quit and syste.exit
58:41 - and now you can run this
58:44 - now
58:45 - this is working really well and there's
58:47 - no way for the mouse to leave the screen
58:49 - in any way whatsoever this is working
58:53 - really nicely
58:54 - cool so with that we also have our
58:57 - player control and you can move them
58:59 - together although it gets a bit weird to
59:02 - do and if you press escape the game
59:05 - stops
59:07 - so with that
59:08 - we have our mouse control
59:11 - and with that we can start working on
59:13 - the final part
59:14 - zoom
59:15 - and the zoom is in theory not that
59:18 - difficult essentially what we have to do
59:21 - we are going to place all of our
59:22 - elements on another surface so some kind
59:25 - of internal surface of our camera group
59:28 - and then before we are drawing this
59:30 - surface on the actual game window we are
59:32 - going to scale it so the larger this is
59:35 - the bigger it's going to be the smaller
59:36 - it is the smaller it's going to be
59:38 - that's quite straightforward
59:40 - although we have to add another offset
59:43 - because this internal surface is going
59:45 - to mess with our positions
59:47 - i'm going to explain this when we get to
59:49 - that problem
59:51 - here we are back in our code and before
59:54 - we can do anything we need a way to
59:56 - actually influence our zoom level
59:59 - and this should be possible both with
60:01 - the keyboard and with the mouse
60:03 - and
60:04 - i put those in different methods well
60:07 - you have to use different methods
60:10 - first of all i want the zoom keyboard
60:14 - control
60:16 - here we need self and nothing else and
60:19 - again i want to get keys just like we
60:21 - have done earlier with the keyboard
60:23 - control
60:24 - so pygame dot key dot get underscore
60:28 - pressed
60:30 - and all i want to check now is if my
60:33 - keys
60:35 - are pygame dot
60:38 - a underscore q
60:40 - let's go q like that
60:43 - and then i want to set self dot zoom
60:46 - underscore scale
60:48 - and add
60:50 - 0.1
60:52 - now this self the zoom scale doesn't
60:54 - exist yet so let's create it
60:58 - i put this all the way at the end of my
61:00 - init method of the class so all the way
61:03 - to top of camera group
61:06 - and all i have to do now is create
61:09 - another if statement that if we are
61:11 - pressing e
61:13 - we are
61:14 - subtracting this
61:16 - and this would be the keyboard input
61:19 - and if you are sure you want to use this
61:22 - in your game and you also want to use
61:23 - this keyboard control you could totally
61:25 - combine the two
61:27 - i just want to emphasize that you can
61:29 - use all of these things independently
61:32 - so let's minimize this and now we have
61:34 - to get the mouse wheel
61:37 - and this has to happen inside of this
61:39 - event loop for some reason i'm not
61:42 - actually sure why but in the pi game
61:44 - documentation there doesn't seem to be
61:46 - anything else unless i missed it
61:49 - what we can do in here is event dot type
61:53 - is equal to pygame dot mouse
61:56 - wheel
61:58 - and this seems to be only available
62:00 - inside of this event loop
62:02 - but once we have that i want to get my
62:04 - camera group and i set the zoom scale
62:07 - again
62:09 - and in here we have to plus add
62:12 - and we want to get event dot y
62:15 - and this is the normal scroll wheel
62:17 - direction there's also x if you have one
62:19 - that can go left and right but i don't
62:22 - care about that
62:23 - and
62:24 - you want to limit this to a certain
62:27 - degree so i'm going to multiply this
62:29 - with 0.03
62:31 - that way we don't zoom too fast
62:35 - and all right now we have input let me
62:38 - run the code to make sure nothing went
62:39 - wrong something did go wrong
62:41 - oh zoom scale should be one
62:44 - now let's try this again
62:46 - and now i can use my mouse wheel i can
62:48 - press q and e but nothing is happening
62:52 - at the very least we don't get an error
62:54 - right
62:55 - now
62:56 - what we have to do
62:59 - we have to create what i called a self
63:02 - dot internal
63:06 - surface
63:07 - and for this surface we also want a size
63:10 - that we are going to reuse so let's call
63:13 - it self dot internal
63:15 - surface
63:17 - size
63:18 - and in here you want to be a bit careful
63:21 - in two ways
63:22 - number one you do want a pretty large
63:25 - surface because when you zoom out it
63:28 - should not be cutting off at the corners
63:31 - at the same time if you choose a service
63:33 - that's too large you are going to slow
63:36 - down your game so in here you have to
63:38 - experiment with what looks good in my
63:40 - case i'm going with 2500 and 2500
63:44 - a pretty large surface
63:47 - but now when i create the surface pie
63:50 - game dot surface
63:52 - i want self.internal
63:54 - surface size
63:56 - and important in here you want to set a
63:58 - flag
63:59 - which is pygame dot
64:02 - src alpha
64:05 - and this enables alpha on this surface
64:08 - and that is important because we want
64:10 - stuff that isn't being drawn to be
64:12 - transparent so you can see stuff behind
64:16 - we also want self dot internal
64:20 - underscore rect
64:24 - oh and let me call this serve instead of
64:26 - surface so we keep the naming a bit more
64:28 - consistent
64:29 - and essentially what i want to do in
64:31 - here let me draw this actually and give
64:33 - me a bit more space
64:35 - it is really important to understand the
64:37 - positioning here
64:39 - this one
64:40 - right now
64:41 - is our game window so this is 1280 by
64:46 - 720
64:49 - the internal surface is going to be
64:51 - something like this
64:55 - and this is then what we are either
64:56 - going to grow or shrink
65:00 - but it is really important here that the
65:02 - center of this surface is in the same
65:04 - center as our display window so those
65:07 - two have to match each other otherwise
65:10 - if you are scaling the center point of
65:12 - the internal surface is going to shift
65:14 - so you're not only scaling you would
65:16 - also move in any of these directions
65:18 - depending on what you do
65:20 - and only if they have the same center
65:22 - this is going to be avoided
65:24 - so for the internal rectangle we want to
65:27 - get self dot internal surface
65:30 - and get underscore rect
65:32 - spelling this properly
65:34 - and we want to set the center
65:36 - and here we already have half the width
65:39 - and half the height
65:41 - and these are the two points we do want
65:43 - to set
65:44 - so self
65:46 - half width and self half height
65:50 - nearly done there's one more thing we
65:52 - need and that is
65:55 - a self
65:56 - internal
65:59 - surface
66:01 - size underscore vector
66:05 - and this right now is just going to be
66:07 - pygame dot math
66:10 - dot vector 2
66:13 - and in here
66:14 - we are adding self dot internal
66:18 - surface size
66:20 - and let me change the surface to a serve
66:22 - so the naming keeps on being consistent
66:27 - and
66:28 - why do we need this vector
66:30 - i think the best way to show why we need
66:33 - it is to actually implement it
66:36 - so when we are all the way down here in
66:39 - our custom draw method
66:41 - let me add a bit of space
66:44 - i first have to self dot internal
66:47 - surface dot fill the entire thing and i
66:50 - want to fill it with the same color that
66:52 - i've used for my display surface
66:55 - and since we're updating this surface if
66:57 - you didn't fill the background and
66:59 - redrew everything you would always see
67:02 - the last frame so stuff would be looking
67:04 - weird
67:05 - and now when we are drawing the ground
67:06 - and all of the elements
67:08 - we are not putting them on the display
67:10 - surface we are putting them on the
67:12 - internal
67:14 - surface
67:15 - all the way at the end
67:17 - i want to get myself dot display surface
67:20 - and blit self dot internal surface and
67:24 - self dot internal surface rectangle if
67:28 - you run this
67:29 - we well we don't get an error we can
67:31 - still move around
67:32 - but
67:34 - it's not working and we can't move our
67:36 - player
67:38 - but at least we don't get an error i
67:39 - guess that's a good start
67:41 - now what we actually have to do
67:43 - is we have to create a scaled
67:46 - surface
67:48 - and what we are essentially going to do
67:50 - in here is pygame.transform.scale
67:54 - and in here we need two bits of
67:56 - information first of all the surface we
67:58 - want to scale which in my case is self
68:00 - dot internal surface
68:03 - and then we need a new size and this has
68:05 - to be x and y
68:08 - in my case i want to get myself dot
68:11 - internal
68:13 - size
68:14 - vector
68:15 - and multiply this with self dot zoom
68:18 - scale
68:20 - and that is the reason why i needed this
68:22 - internal size as a vector because that
68:25 - way i can just multiply it with the zoom
68:27 - scale and not worry about it anymore
68:30 - the last thing well almost the last
68:32 - thing there's a bit more we need
68:34 - we need a scaled
68:36 - rectangle i just want to get my scaled
68:38 - surface and get wrecked again
68:41 - and now the center
68:44 - is going to be self dot half width
68:47 - half width and self.half height
68:52 - and now i'm not splitting the actual
68:54 - internal surface i am splitting this
68:56 - scaled surface
68:59 - and this scaled rectangle
69:02 - and now let's try this i still can't see
69:05 - the player we're going to fix that in a
69:07 - second but if i now move my mouse we are
69:10 - zooming out and we are zooming in
69:12 - and i can use this also i can't use my
69:15 - keyboard because weak are occurring the
69:17 - method
69:19 - if you zoom out far enough you can see
69:21 - that our game is cutting off but i can
69:23 - still use my mouse to move around
69:25 - so
69:26 - here you mostly just have to be careful
69:29 - to move stuff around in the right way
69:32 - if we leave our zoom level at something
69:34 - like this
69:36 - then the player would never notice that
69:38 - stuff is being cut off afterwards
69:41 - so you basically have to play around
69:43 - with this and well we can still move our
69:46 - player nice and just for completion's
69:49 - sake i also want to call myself dot zoom
69:54 - keyboard control
69:55 - so now if i run this i can press e
69:58 - that was way too fast
70:00 - and i can press q i have to be very
70:02 - careful
70:03 - not to press it too fast
70:05 - so it definitely works
70:07 - and that leaves us with only one more
70:10 - problem and let me explain what the
70:12 - problem right now is
70:14 - here again we have our two surfaces the
70:18 - blue one is our display surface the
70:19 - yellow one is the internal one
70:22 - the issue we have right now is that
70:24 - those two have different origin points
70:27 - our internal surface has the origin
70:29 - point up here
70:30 - and the display surface has the origin
70:32 - up here
70:34 - which means that all of our stuff is
70:37 - basically going to be drawn somewhere
70:39 - here
70:40 - which leads us to have an offset that is
70:43 - this size here
70:45 - and since we know the offset we can just
70:48 - account for that with a second offset so
70:50 - we have a camera offset and an internal
70:52 - surface offset
70:54 - that's kind of all we need i hope it
70:56 - makes sense but essentially
70:59 - since our internal surface has a static
71:01 - size so this size here that one doesn't
71:04 - change
71:05 - we can
71:07 - just keep the same offset for any kind
71:09 - of movement
71:11 - and i want to create an internal
71:15 - offset and by default
71:18 - it is going to be a pi game.math.vector2
71:22 - with 0 and 0.
71:23 - and this internal vector
71:26 - we are going to add to every single
71:29 - element that we are blitting
71:32 - well in our case it's the ground and it
71:35 - is all of the other sprites
71:37 - but if you had more obviously added
71:39 - towards those as well
71:42 - and now we just have to figure out the
71:44 - right position for them
71:46 - let me reopen the drawing again to see
71:49 - what's going on
71:52 - let's start with
71:53 - self.internal offset dot x
71:57 - i essentially have to get this distance
72:00 - here
72:02 - and that is not a difficult thing to get
72:05 - i basically have to get i basically want
72:09 - to get myself dot internal surface size
72:13 - and the x part of that
72:16 - and divide this by two
72:19 - and then from that
72:21 - i want to subtract self dot off with
72:25 - and i want to do the same thing for y
72:28 - except now we care about the height
72:31 - and we care about the height
72:35 - and
72:36 - that should be all we need let's try
72:39 - this now
72:40 - and there we go now we're starting on
72:42 - the player
72:44 - and if the player runs around i don't
72:45 - have a camera right now right but now we
72:48 - can still zoom in and out okay except
72:51 - you have to be very careful with
72:53 - how big it's going to get
72:55 - but now you can zoom in and out
72:59 - and this is working really well
73:04 - a good idea would be to add a few more
73:06 - if statements in here that if the zoom
73:08 - scale gets too large or too small that
73:11 - you do want to limit it but that's
73:13 - something you can do by yourself i think
73:15 - we are good to go for here so i hope you
73:17 - enjoyed this tutorial and i will see you
73:19 - around

Cleaned transcript:

hello in this tutorial we are going to cover cameras in pygame and i have created six projects that should basically cover any kind of camera you would ever need so let's go through them before i jump into the code number one is a camera that dynamically places elements on top of each other so we have a proper drawing order and this is creating a nice fake 3d effect the next camera is going to be a camera that always centers on the player number three is a camera box so we do not center the player but if the player moves too far to the left to the right up or down we are moving the camera along with the player so the player never leaves the screen number four is quite simple we are controlling the camera with the keyboard and in number five we are using the mouse in the same way and finally number six we are going to give our camera the ability to zoom in and out and all of these cameras also work with each other if you really want to combine them and really quick for the setup we have all of our code inside of one folder that is going to contain all of our files and inside of that folder we have one subfolder called graphics and inside of that we have three different files we have the ground the player and one tree so my case there's not much variety but if you had a proper game obviously you would add a lot more graphics in here so with that let's get started with the project setup i already have a couple of things in the game to save some time and i guess let's have a look at them here we are in the code and we already have 64 lines of code so i do want to go over that but we only have a single python file so all of our code is going to be in this one file we will never create another one we are starting by importing the usual stuff for pygame and randint you will see why we need rent in in just a second after that we have two classes tree and player for now don't worry too much about them i'll go over them in just a second once we have those we are initiating pygame with the display surface and the clock nothing fancy is happening here after that we are creating our camera group this one is later going to become incredibly important but for now it is just a sprite group nothing more after that we are putting the player somewhere inside of this group so the player has a position and a group once that is done we are placing our trees in here so i just have a for loop and we are placing 20 trees i am using rand end to create a random position and then we are placing the trees in this line here so just like the player the trees get a random position and the camera group that's just about it and with that setup we have our game loop our event loop doesn't really do anything right now except for closing the game we are filling the game with a bluish watercolor then we are updating and drawing the screen and we are doing the usual pie game stuff and all of that gets us basically this we have a player and we have a couple of trees and a blue background and right now my player is always behind the trees and the reason why the player is always behind the trees is because the player is created here let's call it number one and all of our trees are created here let's say number two and because of that the trees are always on top which is well not ideal but we are going to fix that and let's have a really quick look at the classes they aren't that complicated the tree class is incredibly simple so we are giving them a position and a group they have an image and the image is always going to be the tree in our folder and then this tree gets position and the position is well wherever we want the tree to be and the player is a tiny bit more complex although not that much for the image we are still importing an image and we are giving it a position and that is the position we get from the parameters the one thing we have for the player as well is a direction and a speed and this speed we are using in the update method down here to move the player itself and how the movement works is from the input we are influencing the direction and then we're adding this to the rectangle center and that way our player is moving and all that the input method really does is we are checking for up down right and left and using that to influence the vector so if you have any idea of pi game this shouldn't be difficult speaking of if none of this made sense check out my introduction to pygame this one is going to explain all of this in quite a bit more detail and if you want to have more information on a topdown game i have made a full zelda game and a simplified zelda game so check out those as well if you're really interested so alright with that we have our setup so let's get started with the first camera and that camera is going to order which elements are supposed to be on top of each other and this kind of camera is called the y sword camera you're gonna see in a second why but let me explain the problem first so what we want to achieve is something like this that the player is dynamically on top of the trees if the player is in front of it but we also want the player to be behind the trees if the player is well behind the trees but we don't really have a concept of behind or in front in our game because we only have a x and a y coordinate we don't have a z coordinate so we have to figure out how to know when the player is supposed to be in front like this one or behind another element like in this one and the solution to figure this one out is actually quite simple and well like the camera name implies we are sorting all of our elements by the y sort position so if this here is the top of the window so y being zero the further down element comes in this the higher it should be drawn so for example for this player here let's say the y position is 10 and for the tree in both cases we have a y position of let's say 50. now because the tree has a higher y value than the player the tree is going to be drawn on top however now for the other player this one down here if this one has a y position of 100 then this y is going to take priority over this one here and that way we make sure that elements overlap in the right way although we do have a problem and the problem is where can we actually implement this kind of logic so where can we control the drawing logic for our game and the answer is quite simple that all of our drawing happens inside of the group in our case this is the camera group and this we are going to customize so we are going to take some parts of the group and change them to make them more useful for us and let's do this straighten code i think that's going to be the easiest way to approach this here we are back in our code and right now my camera group is this pygame.sprite.group and i want to overwrite this group so let's call it camera group to have a specific name and this camera group is still going to be a sprite group just one with more custom functionalities so let me create a new class that i called camera group and in here we have to inherit from pygame.sprite.group and the very first thing we need just like for the player and for the tree we need to create an init method and initialize the parent class so we again need define underscore init it needs self and nothing else and then we need super and dunder init and with that our camera group already has the same functionality as a sprite group so if we had to run the game now nothing should change and let's try and it is indeed working like any other pi game group so this is a good sign now what we can do is to overwrite functionalities in this class and what i essentially want to do is to create a custom draw method and for now this is only going to need self and nothing else and now we kind of have to understand how pie game actually draws something and this is remarkably similar if you have any idea of pie game in the normal draw method what basically happens is we are cycling through all the sprites in self.sprites in this camera group right now we have the player and all of the trees and they are stored in self.sprites and it's really easy to forget the brackets don't make that mistake and then all that pie game really does is it calls the screen then a chord split and then sprite dot image and sprite dot rect or i guess to be a bit more specific this screen here comes from a parameter so let's call it screen in here and this is the screen we have to pass in here and now we can use our custom draw method and use custom draw and if i run this we still get the very same results even though now we have created our own custom draw which is remarkably simple and now let's start to make some changes to this so we can use it a bit more easily the first one i would like to make is i don't really care about creating a parameter here i want to have my display surface available in my camera group immediately and all we have to do for that is create another attribute let's call it display underscore surface and to get the display surface we need pygame dot display dot get underscore surface and now we can use that display surface to draw on and because of that we don't need the parameter anymore and we don't need the argument down here anymore and still if i run out of this same result the game works just fine and with that we can actually already get our sprites sorted all we essentially have to do is when we are drawing all of our sprites here we have to sort them by the y position and this happens with the sorted method that is native to python and sorted takes two arguments it takes the list you want to sort so my case self.sprites and then it needs some kind of key on how to sort these elements so key and in here we have to extract the y position from each of the sprites and for that i'm going to use a lambda function with sprite is what i'm looking at and all i really want to return is sprite.rect.center y which basically means i am telling python to look at this list and sorted by the center y position of each of the sprites if you understand lambda functions this should be fairly straightforward and well that's actually all we needed so let's try this now and now my player is behind the trees but now it's in front and this works for all of the trees so now we have dynamically added the ability for our game to draw stuff on top or behind and this adds some nice fake 3d which i really like it makes the game look significantly better and cool this is working super well now you can actually work with this quite a bit more for example what we also have is a ground and the ground shouldn't be in this list at all the ground should happen before so we want to have the ground here and then let's call it active elements or something like that and to implement this logic we just have to draw elements here before this for loop that's all you need and in my case i have approached this in this way in the init method i have created self.ground underscore surface and this one is just pygame.image.load and we need to import graphics and ground dot png and don't forget to convert that and then we also need self.ground underscore rectangle and we need self.groundsurface.get underscore rect and the top left is going to be a tuple with 0 and 0. and that way we have access to a ground and a rectangle on where to place it and now we can just call self dot display surface dot blit and place in self.groundsurface and self.ground rect and if i draw this now we have a ground but something went wrong with the alpha but at the very least we have a ground that's always well on the ground and otherwise we are still having our player behind or in front of the trees depending on where we are and the one mistake i made is that this convert should be convert alpha so now the stress again that fits better so now this is still working really really well and that is already the first camera that we needed to create some fake 3d and with that we can come to the second camera and that is a playercentered camera so a camera that always follows the player and before we can implement that we have to address another question and that question is how does a moving camera work in the first place so how can we shift stuff around on the screen because our game window always starts at position 0 and then goes up to a certain point in our case 1280 and 720 and this window we cannot move no matter what we do so we have to figure out something else and let me explain how this is working usually when you use pygame you have a rectangle and you place a surface right in the middle of that rectangle so the position of these two elements are identical but they don't have to be you could totally draw the surface somewhere outside of that rectangle and this is what the camera does so essentially we have our rectangle but now when we draw the surface we are adding a vector offset and only then are we drawing the surface so for example if the top left of our rectangle this point here let's say was a hundred and two hundred for x and y respectively and our vector let's say is something like let's say 150 then our surface would be drawn at position 200 for x and 250 for y so even though our original rectangle had this position we are drawing the surface somewhere else in this position here because of the vector offset and the only thing we need now is to get this vector offset from the player position so for example if the player is walking to the right then we want this vector offset to move in the opposite direction because remember for a camera if you're working right you want all the other elements to move to the left so you have a counter movement and that is essentially all we needed so now we can start working on implementing all of this here we are back in the code and let's get to work on all of this now first of all i want to add a bit more comments to have this thing a bit more organized it's getting a bit messy that's looking better now what i really want to get is let's call it camera offset and this is going to be self dot offset and this is going to be a pygame.math.vector2 and for now with position 0 and 0. so we can just leave it empty how we are going to use this offset is when we are drawing these elements here and this ground as well i want to add the vector to the rectangle so this rectangle here and this rectangle here and let's start doing this inside of the for loop and essentially what i'm going to do i'm going to create an offset underscore position it's not an underscore position and we are getting this with sprite dot rect dot top left plus self dot offset and then we're using this offset position to place the surface and the same thing we also have to do for the ground so let's call this one the ground offset and this one is going to be self.ground dot top left i am terrible typing today and plus self dot offset and right now since our offset is zero this should not be changing anything so let's run the code and indeed we can see nothing has changed which is generally a good sign however what i can do now is add numbers to this vector so let's say i want to give it 300 and 100 now what we can see is that our entire window is moved 300 pixels to the right and 100 pixels down although i just realized for the ground offset i actually have to apply it down here so now let's try this again and this is feeling better and let's really emphasize this let's say instead of 300 let's go with 800 and for y we're gonna go with zero now you can see all of our elements are way to the right we can still move the player but well the player starts already outside of the window so what we have to figure out now let me move those back to zero and zero what we have to figure out now is how to center this offset relative to the player and right now i want the player to always be in the center of the window and let me draw out how this is going to work let me minimize this method here so i have a bit more space essentially imagine that this here is our entire game window and inside of this window we have our player roughly here and the really important information i now have to figure out is this point up here because the top left is going to be the reference point where we are going to start and this also is going to be the offset we are going to move by default this is 0 and 0. so essentially we are going to add this vector to it and that way 0 and 0 becomes whatever this offset is going to be and since i always want my player to be in the center of the window i want the player to be half the width of the screen so let's call it w on the xaxis and half the height of the window on the yaxis so let's call it h divided by 2 and with divided by 2. that makes more sense in terms of math then what i essentially want to do i want to get the center of my player and subtract either the width or the height from that and use that to get this position up here and let's implement this and the logic here i feel like can be a bit confusing i would really recommend you to play around with this but let me actually implement this then i think it's going to make sense and first of all let me minimize the tree and reopen the init method the first thing that we are going to need is the width and the height of the window or well half the width and half the height and let me do this below the offset and let's call itself half underscore w and we're getting this with self.display surface and then get underscore size and this returns a tubal with x and y and we only care about x and we want to divide this by two and for the height we can do the same thing with h and we need the first integer of this tuple so now we have half the width and half the height now when we are drawing this custom draw i want to apply this half width and half height to my offset and let's do this in a dedicated method so we can keep the different cameras apart from each other and let's call it the center target camera it needs self and it needs a target in my case it's going to be the player but it could be literally any object in your game and for this one i want to set myself dot offset and the x position and self.offset and y position and now we just have to apply what i just explained so i want to get myself.target.centerx and from that i want to subtract self.half with and for y i want to get myself.target.rect. center y and subtract self dot half ike and that was all we needed almost actually all we have to do now is call self.center target camera and place in a target in my case it's going to be the player right now we don't have the player so i'm going to create a parameter for the player and this player we don't really have accessible right now but we can just put it into a variable so player and then when we call custom draw i can add my player in here and now there's one more thing we have to do but let's just try it and see what happens we are getting an error ah because this shouldn't be self it should just be target because it's a parameter now if i run this our camera moves in exactly the wrong direction which is a very disorienting experience and the reason here is this line that this should be negative because if we are simulating a camera we want to move all of the elements in the opposite direction that our target is moving and if we're not doing that you well saw the results and now if we try this i realized i forgot we have two offsets we have this one and we have this one and if i try this now now it is working properly so i can just walk around and the camera always follows the player and the depth perception still works where our player is drawn behind or in front of the trees which is already a really useful camera cool and with that we have covered our second camera which wasn't actually all that bad so with that we can talk about the next camera the box camera and basically how this is going to work we have our player inside of our screen and we also have the camera box and if our player is moving to the left of that then we want to move this rectangle also to the left that way our player can move inside of this rectangle without moving the rectangle but once we are going too far down let's say then we're moving down the camera so our player basically can never leave this camera box and this is pretty much a 2d platformer kind of camera you also see it in a lot of topdown games as well it's a really popular one and how we are going to implement this is this camera box here is going to become a rectangle that we are then going to move along with the player and remember for our last camera we used the difference between our player and the top left for the offset to move all of the elements what we are now going to do is our player is going to move the rectangle and then the top left of the rectangle is going to influence the offset and that is probably kind of hard to follow let's implement all of this in code that should make more sense here we are back in the code and the first thing i want to do is to add another section to our camera and let's call this the box setup and in here we basically want to create what i called a camera underscore rectangle and this is the red rectangle i just talked about this is going to be moved by the player and determine the offset so this has to become a pie game dot rect but we now need a left a top a width and a height and we don't have that so we have to add a few more lines of code to create this kind of rectangle and the first thing i have is what i called camera borders and in here we have left right top and bottom and this is basically the distance from the border of the screen to the camera side when we should start moving the camera so if this here was our window and from the left we want this distance that's going to be left it will be 200 and just for another example for the top is going to be this distance here 100 pixels and these distances we can now use to create a left a top a width and a height and let's just go through them one by one first of all for the left side i want my camera borders and i just want the left side that one is really easy same with top actually we need self.camera borders and we just want top essentially what we have just done if this is again our window we have figured out the top left of the rectangle with the left and the top what we now have to figure out is the width of this rectangle and the height of this rectangle and this we are getting from the right and from the bottom and let's start with the width we know that the entire rectangle is 1280 pixels wide we also know that this distance here is 100 pixels and this distance here all the way on the right is 200 pixels that's the information we get from right which means all we really have to do is get 1280 minus 100 minus 200 and that way we only get this middle side here and then we can do the same thing for the y position and we are good to go which means all i really want to do is get myself dot display surface and get underscore size and i want to get the weft and from that i want to subtract myself.camera borders left and self.camera borders right and now we can just copy all of this for the height we need integer one to get the height and i want to add the top and the bottom and now we have a camera rectangle and this may still be a bit uncertain what we're actually doing here so let me draw this camera rectangle to illustrate what's going on all the way at the bottom i want to pygame.draw.rect on myself.displaysurface let's make it yellow and self dot camera wrecked and let's give it a border so we don't fill the entire window and now if i run this you can see here we have our camera rectangle and it moves along with the player oh well it doesn't really move along with the player it's just that we don't update the position but at the very least we know it's kind of working what i want to do now is that the top left of this camera rectangle should set self.offset meaning that this self.offset and this self.offset should both be determined by this camera rectangle and again let me comment out our center camera and put all of this in a separate function and i called this box target camera again we need self and target and nothing else at the end of this line i want to set my self.offset and let's separate this in x and self. offset that thing i think that makes it a bit easier and here again let me explain what we have to do we have our window and when we talked about the center camera so this one here we went from the center where the player is all the way to the top left but in this case for the box we have this rectangle and this rectangle in a second will be moved by the player now we want the distance from this top left point to the top left of the window so kind of the same principle except now our starting point is slightly different but essentially i want to get self dot camera rect dot left and from that i want to get myself dot camera borders and left remember here by default this should be zero until we move the rectangle and we can do the same thing for the top and for the top and now let's call self.box target camera and don't forget to call it and now let's try we are getting an error because we don't have a target needs to be player now let's try this and now we can see that well we don't really get anything because we are not updating this rectangle and let's do this straight in the function i think that's going to be the best way to think about it in this function all i really want to do is if my target.rect.left is for example smaller than self.camera rect dot left meaning our player is further to the left than the camera rectangle if that is the case i would set myself.camera rect.left where our target.rect.left is basically meaning here we have our player and we have the box around the player if the player moves outside of this rectangle we want to move the rectangle to the same position so that those two have the same x position and let's try this actually this should be working already now if i move to the left you can see we are moving the rectangle now the drawing here of the rectangle gets a bit confusing but the logic works just this drawing here is a bit strange so let me just get rid of it we don't need it anymore and now let's try it again and there we go this is working really nicely now all we have to do is copy this if statement to cover all the four directions so camera.right and camera.right except now we're checking if this is greater than but other than that we are just switching left to right and let's try this one now my player is moving right my player is moving left and this is working really well cool then next up we can do the same thing for camera rect let me just switch all of them at the same time so top and we have to check for smaller and i guess while we add it let's do also the bottom to have all the four directions so all of the tops here should be bottom and then we again need greater and now we should be done so this is working really well nice and i guess to make the trees a bit less confusing let's change this 0 to 1000 to 1000 to 2000 and now let's try this again now we can't see trees over the water anymore and all the trees are here which is uh significantly more realistic but well you can see that you can place stuff basically wherever you want it still works just fine and all right with that we have our next camera sorted which means we can now work on the next camera and that is a keyboard controlled camera and this one is probably the easiest one of them all once we have the setup we already have because essentially all we have to do is to use our keyboard keys to influence the offset that's literally it we can do this straight in the code this shouldn't take long at all here we are back in our code and i want to create another method and let's call this one keyboard control in itself and nothing else first of all i have to get my keyboard input which happens with pygame dot key and get underscore rest and then i want to check different keys now since i already use up down left and right for my player i am going to use if keys and pygame.k underscore a i am basically going to use wasd for the controls and now we kind of have to make a decision how we want to influence the offset do we ever want to influence the offset immediately or use our camera rect and influence the camera with that let's actually do both and then you can see what i mean so if i press a i want to get myself.offset.x and move it in a certain direction the direction i want let me add another section in here and that could be let's call it camera speed and in here i want self dot keyboard speed we are later going to have a mouse speed as well and i do want to keep them separate and for this one let's go with five now if we are pressing to the left we want to decrease our self dot keyboard speed and well now we just have to duplicate this a couple of times let's say with d and now i want to add my keyboard speed then i want to get my up then we want to move in the y direction and it should also be negative because we are moving up and finally we have s and now we're moving down so this is plus so now i just have to call myself dot keyboard control run the game we are getting an error because this should be pygame dot key now let's try this again there we go so i can still move my player around but now if i use wasd i am moving the actual camera around and i can use those two independently of each other that one works totally fine and all the other elements still work just fine now you do have to be careful if you want to use the box camera as well you might get a problem if you use both the keyboard control and the box camera one way to avoid that is to not use the offset but instead to switch the offset to the camera rect and then at the end we can copy from our box camera these two lines here and paste them in here so now instead of having the player change the camera rectangle we use the keyboard to do all of that and let me clean this up a tiny bit i think if we put the if statements on one line this is a bit easier to read there we go this feels much better now we should have the same outcome and we can still move the rectangle around except now we are controlling the rectangle first and the rectangle influences the offset and that is a bit of a better way i think if you use both the box target and the keyboard control but both approaches are basically fine and if you combine different camera methods i would recommend to play around with this quite a bit it's very easy to get bugs in there but alright with that we have our keyboard control so next up we can work on the mouse control and this one is going to be a bit more complex let me explain what we are going to do first we set up our player and we have our screen and the basic logic is going to be that we still have our camera box we are actually going to reuse the same camera box we had earlier and now we are not going to check the player position at all instead we are going to check the mouse position on every frame of our game and if the mouse position goes outside of this box let's say our mouse is here then we are going to check this distance here then we are going to move the entire rectangle by this position and we are also going to disable our mouse position so it can't move any further to the left which by itself is pretty simple the one thing that makes this whole process a bit tedious is that we can only get the mouse position once per frame which means that we have to do a lot of if statements now we do have a problem with this approach though that we can only check the mouse position once per frame if you do it more than once it just stops working but that is kind of a problem we have this side here this side here this side here and this side here and all of those work by themselves we only have to check our mouse position once but we also have this corner this corner this corner and this corner here where we want to check both the x and the y position and as a consequence we have to write eight if statements in total or at least we have to cover eight different cases which gets a bit tedious but once you understand the logic it shouldn't be too difficult i guess let's implement it and let's see how far we get here we are back in the project and i want to create a new method let's call this one mouse control we need self and nothing else and in here first of all i want to get my mouse position and this we get with pygame.math.get underscore position and since we have to work with this quite a bit in terms of math i want to turn this position into a vector so pygame.math.vector2 actually this shouldn't be math this should be mouse now we are going to need another vector which i called mouse offset vector and right now it's just going to be pygame.math.vector2 with 0 and 0. and what this vector essentially does if this is our entire screen and this one here is our camera rectangle if the mouse goes outside of it then this distance here is going to be stored in the vector and this could either be an x direction it could be a y direction or it could be both which is why we need this as a vector and now we have to figure out the borders of our mouse so at what point does the camera start moving and in my case i am going to use the camera borders i really want to emphasize we are using the camera borders not the camera rectangle and the reason is that our camera rectangle can be moved around in the world but the mouse isn't bound by that the mouse is always relevant to the original game window i hope that makes sense it's a bit confusing when you work with cameras just think about it for a bit i hope it makes sense but anyway since we're going to use those quite a bit i'm going to store all of this in a couple of variables to make it a bit more understandable so we have left border top border right border and a bottom border and the left border is just going to be self dot camera borders and left then we have self dot camera borders and the top and the right border is now going to be self dot display surface dot get underscore size we want to get the width and from that we want to subtract self dot camera borders and right which basically means if this is the entire width of our window we are subtracting the right let's say it's this distance here and then this point in our game is the right side so the rest of the game would be something like this and now we can do the same thing for the bottom border except now we need the height and we need the bottom now we have the borders of where our mouse is not supposed to go beyond what we have to do now is a ton of if statements and let me cover all of this let me minimize this method here so i have a bit more space because there's going to be quite a bit of drawing coming up here we have our entire game window and what i first want to check is if our mouse is inside of these two sides so this is the top and bottom of the left side and the top and bottom of the right side importantly now we are excluding the top so the top and bottom of both of these sides is not included because right now i only want to check the x dimension and not worry about this other position whatsoever and what that means is if the top border is smaller than mouse dot y which is the mouse we get from all the way up here and if that one is smaller than the bottom border then we know we are in this area and now i can check if my mouse dot x is smaller than the left border meaning now we are in this area here if that is the case i want to set my mouse offset vector and x then i want to get my mouse.x and from that i want to subtract my left border essentially what this is going to give us if our mouse is right here now we are getting this distance and storing it in mouse of side vector and once i have this distance i want to get pygame.mouse and set the position of this mouse and in here i have to specify an x and a y position now for the y position i want to put my mouse where my mouse used to be because i don't care about y right now but for the x position i want to place this at the left border this would then be the logic for the left side of the window all we would have to do at the end is set self dot offset and plus equal my mouse offset vector and let's actually try this and see what we get so in my custom draw i want to disable the keyboard and now self. how did i call it mouse control and let's see what we get we are well getting an error because this shouldn't be a double equal sign now let's try this again we're getting another error that self dot display i am losing the ability to type x attempt oh it should be display surface next attempt there we go now if i move my mouse to the left side there we go this is working very nicely all we have to do now is cover all of the other seven sides and we are done now first of all i want to check if my mouse dot x is greater than my right border and if that is the case let me copy all of this then i want to check my mouse x minus my right border and i want to set the right border as the position of the mouse let's try this i can move right i can move left and that is working really nicely all right this is working just fine so now we can also start working on the top and down movement which is going to work very similar compared to this line here so let me just copy it and now i want to check if my left border is smaller than mouse x and if that is smaller than my right border and if i draw all of this and let me clean this up a tiny bit so now we only care about the top line here and the bottom line here and again we are not including the right or the left side you actually gonna see in a second why that is but first of all i have to do a lot of similar logic i have done here so let me just copy the entire thing to save me some writing first of all i want to check if we are on the top of the window so if mouse.y is smaller than our top border and if that is the case i want to get the y position the y position again and this should be the top border and now when i set the position of the mouse i want to keep the same x position but the y position should be the top border and then the same for the bottom so now we are checking if we are greater or if the mouse position is greater than the bottom border and if that is the case i want to get the y position the y position again and from that subtract the bottom border and then again let me actually copy it from here we want to set the x position where the mouse used to be but we want to put the y position of the mouse on the bottom border and there we go now we have four sides covered so now i can move left and right i can move down and up but if i try to move both down and right my mouse just keeps on going outside of the window which is not great and this is the problem that happens in all sides and essentially what happens here is we are first checking the left and the right side and then we are setting the mouse position here once after we are done with that we are doing the same thing for up and down the problem is we can only set the mouse position once per frame so if we trigger both the second one is not working anymore so we basically have to add a couple more if statements and these if statements have to go inside of the first if statement because remember if we are setting the position of the mouse once this one down here doesn't seem to be running anymore so we have to add more if statements here for the edge cases and then if they're running all of this will be ignored so i want to get an else statement in here that else let's say mouse dot y is smaller than the top border and inside of that i want to check if mouse dot x is smaller than the left border and with that i know the mouse is on top and off the left of our borders so now i can get my mouse offsite vector and this one is going to be my mouse position and from that i want to subtract my left and my top border both of them from the x and y position respectively so in my case i turned both into a vector so math vector2 and here we have the left border and the top border meaning now we are setting both of these positions at the same time and then when we are resetting the mouse we are calling pygame.mouse.set underscore position and now we have the left border and the top border and with this setup we are only calling set position once we're not calling it twice and well now we just have to cover all the other cases so if mouse.x is greater than the right border now we're in the top right border which brings us in the top right corner and let me copy all of this so i save a bit of writing now we still get our mouse position but from that we are subtracting the right border but still the top border and then when we are placing the mouse i want the right border and that covers the top left and the top right now i want to copy this entire l if statement and now my mouse dot y is going to be greater than the bottom border so now we cover the bottom corners and in here we are still wanting to check the left side but now we can keep all of it except the top border should be the bottom border or both of these and now we're checking the bottom right so the right border and the bottom border and we are checking the bottom border when we are setting the position and you can kind of tell kind of an elaborate if statement but now if we try it off this oh it should be l if and l if it's been a long recording session there we go now if i move my mouse up down right and left oh you can see a problem already ah you can actually see it really well the problem here is twofold actually if we move the mouse too fast the game moves really really fast which is very bad so i want to give this mouse back to offset a certain kind of speed limiter which basically means i'm going to multiply it with self dot mouse and this self.mouse speed i am setting up here so self dot mouse speed and for me 0.4 felt the best but now we have one more problem that if i move my mouse really fast let's actually try it so if i move really fast my mouse goes outside of the window which well isn't the idea of the game but we can fix that kind of easily all we have to set in here is one line of code although really important before you write this code i do want to warn you after i write this do not run the code straight away you will not be able to close it because you can't press the close button anymore i'm going to fix that right after before i run the game please take care of that now the line we need is pygame dot event dot set underscore grab and this has to be true and this basically makes it so that our mouse cannot leave the screen anymore which is then preventing us from closing the game so we have to find another way to close the game and in my case i'm just going to check for another keyboard input if event dot type is equal to pygame dot down and then if event dot e is equal to pygm dot k underscore escape which basically means we're pressing the escape button and if that is the case i want to run pygm.quit and syste.exit and now you can run this now this is working really well and there's no way for the mouse to leave the screen in any way whatsoever this is working really nicely cool so with that we also have our player control and you can move them together although it gets a bit weird to do and if you press escape the game stops so with that we have our mouse control and with that we can start working on the final part zoom and the zoom is in theory not that difficult essentially what we have to do we are going to place all of our elements on another surface so some kind of internal surface of our camera group and then before we are drawing this surface on the actual game window we are going to scale it so the larger this is the bigger it's going to be the smaller it is the smaller it's going to be that's quite straightforward although we have to add another offset because this internal surface is going to mess with our positions i'm going to explain this when we get to that problem here we are back in our code and before we can do anything we need a way to actually influence our zoom level and this should be possible both with the keyboard and with the mouse and i put those in different methods well you have to use different methods first of all i want the zoom keyboard control here we need self and nothing else and again i want to get keys just like we have done earlier with the keyboard control so pygame dot key dot get underscore pressed and all i want to check now is if my keys are pygame dot a underscore q let's go q like that and then i want to set self dot zoom underscore scale and add 0.1 now this self the zoom scale doesn't exist yet so let's create it i put this all the way at the end of my init method of the class so all the way to top of camera group and all i have to do now is create another if statement that if we are pressing e we are subtracting this and this would be the keyboard input and if you are sure you want to use this in your game and you also want to use this keyboard control you could totally combine the two i just want to emphasize that you can use all of these things independently so let's minimize this and now we have to get the mouse wheel and this has to happen inside of this event loop for some reason i'm not actually sure why but in the pi game documentation there doesn't seem to be anything else unless i missed it what we can do in here is event dot type is equal to pygame dot mouse wheel and this seems to be only available inside of this event loop but once we have that i want to get my camera group and i set the zoom scale again and in here we have to plus add and we want to get event dot y and this is the normal scroll wheel direction there's also x if you have one that can go left and right but i don't care about that and you want to limit this to a certain degree so i'm going to multiply this with 0.03 that way we don't zoom too fast and all right now we have input let me run the code to make sure nothing went wrong something did go wrong oh zoom scale should be one now let's try this again and now i can use my mouse wheel i can press q and e but nothing is happening at the very least we don't get an error right now what we have to do we have to create what i called a self dot internal surface and for this surface we also want a size that we are going to reuse so let's call it self dot internal surface size and in here you want to be a bit careful in two ways number one you do want a pretty large surface because when you zoom out it should not be cutting off at the corners at the same time if you choose a service that's too large you are going to slow down your game so in here you have to experiment with what looks good in my case i'm going with 2500 and 2500 a pretty large surface but now when i create the surface pie game dot surface i want self.internal surface size and important in here you want to set a flag which is pygame dot src alpha and this enables alpha on this surface and that is important because we want stuff that isn't being drawn to be transparent so you can see stuff behind we also want self dot internal underscore rect oh and let me call this serve instead of surface so we keep the naming a bit more consistent and essentially what i want to do in here let me draw this actually and give me a bit more space it is really important to understand the positioning here this one right now is our game window so this is 1280 by 720 the internal surface is going to be something like this and this is then what we are either going to grow or shrink but it is really important here that the center of this surface is in the same center as our display window so those two have to match each other otherwise if you are scaling the center point of the internal surface is going to shift so you're not only scaling you would also move in any of these directions depending on what you do and only if they have the same center this is going to be avoided so for the internal rectangle we want to get self dot internal surface and get underscore rect spelling this properly and we want to set the center and here we already have half the width and half the height and these are the two points we do want to set so self half width and self half height nearly done there's one more thing we need and that is a self internal surface size underscore vector and this right now is just going to be pygame dot math dot vector 2 and in here we are adding self dot internal surface size and let me change the surface to a serve so the naming keeps on being consistent and why do we need this vector i think the best way to show why we need it is to actually implement it so when we are all the way down here in our custom draw method let me add a bit of space i first have to self dot internal surface dot fill the entire thing and i want to fill it with the same color that i've used for my display surface and since we're updating this surface if you didn't fill the background and redrew everything you would always see the last frame so stuff would be looking weird and now when we are drawing the ground and all of the elements we are not putting them on the display surface we are putting them on the internal surface all the way at the end i want to get myself dot display surface and blit self dot internal surface and self dot internal surface rectangle if you run this we well we don't get an error we can still move around but it's not working and we can't move our player but at least we don't get an error i guess that's a good start now what we actually have to do is we have to create a scaled surface and what we are essentially going to do in here is pygame.transform.scale and in here we need two bits of information first of all the surface we want to scale which in my case is self dot internal surface and then we need a new size and this has to be x and y in my case i want to get myself dot internal size vector and multiply this with self dot zoom scale and that is the reason why i needed this internal size as a vector because that way i can just multiply it with the zoom scale and not worry about it anymore the last thing well almost the last thing there's a bit more we need we need a scaled rectangle i just want to get my scaled surface and get wrecked again and now the center is going to be self dot half width half width and self.half height and now i'm not splitting the actual internal surface i am splitting this scaled surface and this scaled rectangle and now let's try this i still can't see the player we're going to fix that in a second but if i now move my mouse we are zooming out and we are zooming in and i can use this also i can't use my keyboard because weak are occurring the method if you zoom out far enough you can see that our game is cutting off but i can still use my mouse to move around so here you mostly just have to be careful to move stuff around in the right way if we leave our zoom level at something like this then the player would never notice that stuff is being cut off afterwards so you basically have to play around with this and well we can still move our player nice and just for completion's sake i also want to call myself dot zoom keyboard control so now if i run this i can press e that was way too fast and i can press q i have to be very careful not to press it too fast so it definitely works and that leaves us with only one more problem and let me explain what the problem right now is here again we have our two surfaces the blue one is our display surface the yellow one is the internal one the issue we have right now is that those two have different origin points our internal surface has the origin point up here and the display surface has the origin up here which means that all of our stuff is basically going to be drawn somewhere here which leads us to have an offset that is this size here and since we know the offset we can just account for that with a second offset so we have a camera offset and an internal surface offset that's kind of all we need i hope it makes sense but essentially since our internal surface has a static size so this size here that one doesn't change we can just keep the same offset for any kind of movement and i want to create an internal offset and by default it is going to be a pi game.math.vector2 with 0 and 0. and this internal vector we are going to add to every single element that we are blitting well in our case it's the ground and it is all of the other sprites but if you had more obviously added towards those as well and now we just have to figure out the right position for them let me reopen the drawing again to see what's going on let's start with self.internal offset dot x i essentially have to get this distance here and that is not a difficult thing to get i basically have to get i basically want to get myself dot internal surface size and the x part of that and divide this by two and then from that i want to subtract self dot off with and i want to do the same thing for y except now we care about the height and we care about the height and that should be all we need let's try this now and there we go now we're starting on the player and if the player runs around i don't have a camera right now right but now we can still zoom in and out okay except you have to be very careful with how big it's going to get but now you can zoom in and out and this is working really well a good idea would be to add a few more if statements in here that if the zoom scale gets too large or too small that you do want to limit it but that's something you can do by yourself i think we are good to go for here so i hope you enjoyed this tutorial and i will see you around
