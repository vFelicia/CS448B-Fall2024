With timestamps:

00:00 - hello in this tutorial I'm going to show
00:02 - you how to make a pong game that looks
00:04 - something like this I'll be using Python
00:06 - and PI game for that purpose and it
00:09 - should be fairly straightforward because
00:10 - pong is quite easy after all I'll be
00:13 - going for all of these steps if you want
00:15 - to jump to specific parts let's jump
00:17 - right in
00:18 - if you are new to Python pay game is a
00:21 - module that doesn't come with Python but
00:23 - you can download it for free that is
00:26 - done idle with the powershell of the
00:28 - terminal depending on your operating
00:29 - system so start the one you need just
00:32 - like any other program and you type pip
00:34 - install PI game you should now be seeing
00:36 - a little animation where you can see
00:38 - things of being installed once that is
00:41 - done open your code editor of choice and
00:43 - type import PI game and if you can
00:45 - execute that code without an error you
00:47 - are good to go
00:49 - before we actually get into the code
00:52 - let's talk about how Piegan works on a
00:54 - conceptual level to oversimplify things
00:56 - a little bit every pygame code consists
00:59 - of two parts one part where you set up
01:02 - all your code you need for the game so
01:04 - your classes functions and variables
01:06 - that carry the logic of the game that is
01:08 - the part that works like any other code
01:10 - but to actually run the game you need a
01:13 - loop which is the second part inside of
01:16 - this pi and continuously cycles through
01:18 - a while loop updates the code and draws
01:21 - the resulting picture and since that
01:23 - happens many times per second we
01:25 - perceive this as a moving image for a
01:28 - simple example imagine you want to move
01:30 - a rectangle from the left to the right
01:32 - of the screen in the setup part you
01:35 - would create a rectangle and give it a
01:37 - starting position and a movement speed
01:39 - and then in the loop you would run a
01:42 - function to make the rectangle move to
01:43 - the right by the movement speed once per
01:45 - loop cycle with all of that established
01:49 - let's create a basic setup and we'll
01:51 - work ourselves up from there the code to
01:54 - create a basic window looks like this
01:56 - first we import PI game and sis why we
02:00 - need PI games should be obvious at this
02:02 - point since if you haven't encountered
02:04 - it yet it's a module to access some more
02:07 - functionality on your system in our case
02:10 - though we're only going to use it to
02:12 - close the game once we're done with it
02:13 - which happens further down here
02:17 - next we have two lines that are
02:18 - important for the general setup pygame
02:21 - in it initiates all the pygame modules
02:24 - and is required before we can run any
02:26 - kind of game and you always need it for
02:29 - any kind of PI game code after that we
02:33 - have a clock method that we store in the
02:34 - variable clock I will come back to this
02:37 - in a couple of minutes so keep with me
02:39 - for now and in the next few lines we
02:41 - create the actual window the important
02:44 - line here is PI game not displayed of
02:47 - set underscore mode which returns a
02:49 - display surface object which we store in
02:52 - the screen variable this method can
02:54 - accept a number of arguments for more
02:56 - advanced games but we only want to
02:59 - create a basic game all we pass in is a
03:02 - tuple with the width and a hype of the
03:04 - window both of which are defined in
03:06 - their own variables in this case I
03:08 - create a window that is 1280 pixels wide
03:11 - and 960 pixels high and the next line is
03:15 - purely to give the window a title I
03:17 - called it pong but you could put in any
03:20 - string you like once that is done we get
03:23 - to the loop which is just a simple wire
03:25 - loop that runs perpetually for now this
03:28 - loop is incredibly basic and only really
03:30 - checks if the user has pressed the close
03:32 - button at the top of the window how
03:34 - would that works is that on every single
03:36 - cycle of the loop we get a list of all
03:39 - the user inputs with PI games or event
03:41 - or get
03:44 - pygame calls all user interactions
03:46 - events
03:48 - so an event could be a click of a button
03:50 - the moving of the mouse or even just
03:52 - closing the window and we loop through
03:54 - all of those with a for loop so
03:58 - effectively we have a while loop that
04:00 - updates the game and inside of that loop
04:02 - we have a for loop that checks for all
04:04 - the user actions for now all we want to
04:07 - check is whether the user has clicked a
04:09 - little X at the top of the screen which
04:11 - is a certain type of event that pagan
04:13 - cults quit and if the event type equals
04:16 - PI game not quit we call two methods PI
04:19 - game that quit and initializes the PI
04:22 - game module and system exit closes the
04:24 - entire program all you really need to
04:27 - know is that both of these combined
04:29 - close the game reliably
04:32 - pagon has lots of keywords to check for
04:35 - different kinds of user input these are
04:37 - called locals and they are always
04:39 - capitalized I'll put a link in the
04:41 - description for all the options and
04:43 - after the input we have pi gamma dot
04:46 - display dot flip this methods entire
04:49 - purpose is to take everything that came
04:51 - before it in the loop and draw a picture
04:53 - from that well now since we haven't
04:56 - drawn anything yet it only draws a black
04:58 - screen and finally we have clock tick
05:02 - the same clock we defined earlier in the
05:05 - code it is essentially what this one
05:07 - does is that it limits how fast the loop
05:09 - runs in this case 60 times per second
05:12 - this is necessary because the computer
05:15 - will try to run the code as fast as it
05:17 - can so if you don't control the speed
05:19 - the computer might just try to run it at
05:22 - 10,000 cycles per second and you
05:24 - wouldn't be seeing anything and that's
05:27 - it we have created a basic setup when I
05:30 - run the code now we get a black window
05:32 - with a title so let's talk about how to
05:34 - draw on that
05:38 - to draw stuff in pygame you have to
05:40 - understand the hierarchy of four
05:41 - different concepts the most basic
05:45 - element is the display surface object we
05:47 - already created this one in the code
05:49 - with PI Gambler displayed at set mode
05:51 - and stored it in the screen variable is
05:54 - this going to be the main screen that we
05:56 - draw all our shapes on and there can be
05:58 - only a single one so even if you created
06:01 - lots of shapes and images unless they
06:04 - are on the display surface they would
06:06 - not be shown now you could draw it
06:09 - directly on this display surface with PI
06:11 - games or draw and you have the option to
06:13 - draw all kinds of shapes however there
06:16 - are two more elements that make it
06:18 - easier to organize and manipulate all
06:20 - the shapes and images the first is a
06:23 - regular surface or just a surface think
06:26 - of it like an extra layer that holds
06:28 - material which is quite useful to keep
06:30 - your game organized the difference
06:33 - between the display surface and a
06:35 - regular surface is that you can have as
06:37 - many regular surfaces as you like but
06:39 - you need to attach them explicitly to
06:41 - the display surface otherwise they would
06:44 - not be shown but besides that you can
06:47 - basically do the same thing with both
06:49 - kinds of surface like adding drawings or
06:52 - putting pictures on them the second
06:55 - element is a rectangle or a rect
06:58 - and that is literally what it is a
07:00 - rectangle what you do with this
07:02 - rectangle is that you can put it around
07:04 - shapes and regular surfaces which makes
07:07 - it much easier to measure them and to
07:09 - manipulate them as well
07:12 - which becomes really handy when you
07:14 - actually make a game and that is it for
07:17 - this game I won't be making any services
07:19 - besides the display surface I will
07:22 - however use rectangles for the shapes
07:24 - let's put all of that into code I will
07:27 - start by defining a rectangle for the
07:29 - ball
07:29 - this is done with pygame direct which
07:32 - takes in the X&Y position along with the
07:34 - height and the width of the rectangle
07:37 - keep in mind that the X and the y
07:39 - position is for the top left of the
07:41 - rectangle and also that the origin of
07:43 - the window itself is on the top left so
07:46 - if you want to go down you have to
07:47 - increase Y the ball itself is going to
07:50 - be 30 pixels wide and 30 pixels high
07:53 - that part is easy to place it right in
07:56 - the middle of the screen we do need a
07:58 - little bit of math though I couldn't
08:00 - just put it at half of the screens width
08:02 - and half of the screens hype because I
08:04 - am moving the top left and if I placed
08:07 - it like that it would be slightly off
08:09 - the center but that can be fixed by
08:12 - subtracting half of the width and half
08:13 - of the hype of the ball itself and if we
08:16 - do that the ball is perfectly centered
08:18 - next I define a rectangle for the player
08:20 - that I put in the middle of the right
08:22 - side that is 10 pixels wide and 140
08:25 - pixels high and a place it's top left on
08:31 - the coordinates screen with minus 20 and
08:33 - I get height with the same method that I
08:35 - get the height of the ball I divide the
08:38 - height of the screen by 2 and I subtract
08:41 - half of the players length from that and
08:43 - then I define another variable for the
08:45 - opponent that holds a rectangle at the
08:48 - coordinates 10 and the same height as
08:50 - the player and it would also be 10
08:52 - pixels wide and 140 pixels high for now
09:00 - these are just free empty rectangles to
09:03 - actually draw them we need to get the
09:04 - loop and use pygame dot draw which is
09:07 - the module with all the different
09:08 - options to draw shapes to use that one
09:12 - we usually three arguments the service
09:14 - to draw on a color argument and a
09:17 - rectangle since I'm drawing directly on
09:19 - the display surface that one is easy and
09:22 - I also have two rectangles I need so
09:25 - let's talk about colors then there are
09:27 - two ways to create colors and pygame the
09:30 - most common one is with a tuple of RGB
09:33 - values RGB stands for red green and blue
09:36 - and you can set the value of each of
09:38 - these colors and if you mix the
09:40 - different values of each of these colors
09:42 - you can create basically any color
09:44 - essentially we have a tuple that we can
09:47 - pass breve values into the first one for
09:50 - red just like
09:51 - one for green and the third one for blue
09:53 - and you can choose the values from 0 to
09:55 - 255 with 0 being the absence of the
09:59 - color and 255 being the pure color so
10:03 - for pure red it would be 255 0 and 0 for
10:07 - pure black it would be 0 0 0 and for
10:11 - pure white it would be 255 255 and 255
10:15 - the other way to create colors and
10:17 - pygame is with a color object this one
10:20 - is created with the command pygame code
10:22 - color and you pass in the string of the
10:24 - name of a color you can find all of the
10:27 - available color names online and that's
10:30 - basically it for this one let me use
10:32 - both methods so you guys have an idea of
10:34 - how it looks in the code I will make the
10:36 - background with a color object and use
10:39 - an RGB tuple to make a greyish white
10:41 - that I will use for all the other shapes
10:43 - so below the rectangles I declare a
10:46 - variable BG underscore color and assign
10:49 - it pygame blood color and pass in the
10:51 - string gray 12 and on the next line I
10:56 - create another variable called light
10:58 - gray and I assign it a tube of 200 200
11:02 - and 200 which gives us a light gray with
11:06 - all of that done we can get into the
11:08 - actual drawing in the loop I start by
11:11 - drawing the two players since both are
11:13 - plain rectangles pygame the draw the
11:15 - direct fits really well I passed on the
11:18 - surface to draw on the light gray color
11:20 - and the rectangle and then I do the same
11:23 - thing for the opponent next is the ball
11:29 - this we draw with pygame the draw the
11:31 - ellipse which also takes a surface a
11:34 - color and a rectangle but instead of
11:37 - filling the whole rectangle it uses its
11:39 - frame to draw an ellipse into it and
11:41 - since all our sides are the same length
11:43 - this ellipse becomes a circle
11:46 - and that covers all the main shapes but
11:49 - I will add two more elements that don't
11:51 - need a rectangle the line that separates
11:53 - the two sides of the field and the
11:55 - background color especially the
11:58 - background color is important because
11:59 - without it you would still be able to
12:01 - see the previous frame which would make
12:03 - the game impossible so I add the
12:06 - background color by filling the entire
12:08 - display surface this is done by calling
12:10 - dot fill on the variable that holds the
12:13 - surface screen in this case and into
12:16 - that I passed the color I want to use BG
12:19 - and ESCO color in this case
12:22 - and finally I create a line that
12:24 - separates the two sides this will be
12:26 - done with pygame the draw lat a a line
12:29 - which stands for anti aliased line this
12:32 - one needs four arguments its service to
12:34 - draw on the color and the tip of the
12:37 - start point and a tuba with the end
12:39 - point so I pass in the screen light gray
12:42 - for the color the first tuple will be
12:44 - half of the screens with and zero for
12:47 - the middle of the table window the
12:49 - second tuple will be half of the screen
12:51 - Swift and the screen height for the
12:53 - middle of the bottom of the window and
12:55 - one thing to pay attention to is the
12:58 - order of the code successive elements in
13:01 - the loop are drawn on top of each other
13:02 - so the first element called in the code
13:05 - will be at the bottom of the frame and
13:07 - the last one will be on the top if I put
13:10 - screen note fill below the other
13:12 - elements we would only see the
13:14 - background so do be careful with that
13:17 - but if I run the proper code now we can
13:20 - see that all the basic shapes are there
13:22 - and with that one done we can get to the
13:25 - animations I will start with the ball
13:27 - right now the code works like this we
13:30 - define a rectangle with coordinates and
13:32 - dimensions and later we draw a rectangle
13:35 - on the surface with a color the way we
13:37 - do animations is that we add a step in
13:40 - between that tells pygame to move the
13:42 - coordinates by number of pixels every
13:44 - cycle in the loop and for that purpose
13:47 - the rectangles are incredibly useful
13:51 - essentially in and around each rectangle
13:54 - there are these points that we can
13:55 - influence and measure and if we move a
13:58 - single point we move the entire
14:00 - rectangle so for example if I wanted to
14:04 - move this rectangle to the right by 5
14:06 - pixels I could use x + equals 5 or right
14:10 - plus equals 5 or even left plus equals 5
14:13 - they would all achieve the same result
14:15 - and that result would be that on every
14:18 - cycle this rectangle would move to the
14:20 - right by 5 pixels so to get the ball
14:23 - moving I start by defining two speed
14:25 - variables one for horizontal speed and
14:28 - one for the vertical speed respectively
14:31 - called ball speed X and ball speed Y
14:34 - and I set both to seven Y we need to
14:39 - will become clear in just a second now
14:42 - in the loop we want the ball to move
14:44 - every frame by the ball speed we defined
14:47 - earlier that is super easily done with
14:49 - ball dot X plus equals ball speed X and
14:52 - bolded y plus equals post lead Y so on
14:56 - every single cycle this ball will be
14:59 - moved by the speed we defined in the
15:01 - speed variables and since we're doing
15:03 - this 60 times a second we get a moving
15:06 - image let's run the code now and see how
15:09 - this looks
15:09 - we can see that we have a moving ball
15:12 - but the problem is that the ball moves
15:14 - out of the frame since we never told it
15:16 - to stop for that we need some collisions
15:19 - just to get this started and we let the
15:22 - ball bounce around the four sides of the
15:24 - screen and later we had more code when
15:27 - the ball hits left or the right side the
15:30 - basic logic we need is something like
15:32 - this if the top of the ball is zero
15:38 - the bottom of the ball is equal to the
15:39 - height of the screen then reverse the
15:45 - vertical ball scale and if the left side
15:50 - of the ball is zero or if the right side
15:54 - of the ball is equal to the screen width
15:58 - then reverse the horizontal ball speed
16:00 - and the reason we have to speed
16:03 - variables is to be able to reverse the
16:06 - speed for each axis separately and since
16:10 - we can access all of those attributes
16:11 - this is actually a really simple if
16:14 - statement to reverse the ball speed all
16:16 - we need is to multiply the speed by
16:18 - negative one and since we don't care if
16:21 - this goes from positive to negative or
16:23 - from negative to positive we only need
16:26 - one if statement for each axis
16:31 - and when I execute the code now we have
16:33 - a bouncing ball one thing to be careful
16:38 - of is that you shouldn't use the equal
16:40 - comparison as you can see in my if
16:43 - statement I use greater or equal or
16:46 - smaller or equal the reason for that is
16:48 - that we need to be careful of what
16:50 - points we are measuring if the ball
16:52 - moves seven pixels per cycle and it
16:55 - happens to be at the position 955 and
16:58 - then it would move to 962 in the next
17:01 - frame since that wouldn't be equal to
17:04 - the height of the screen the ball would
17:06 - just continue and we would have a
17:07 - gamebreaking bug if we use greater or
17:10 - equal to then this problem wouldn't a
17:12 - cure at all so this is why I'm using
17:13 - greater and equal or smaller and equal
17:16 - to
17:17 - but anyway I also want the ball to
17:20 - collide with the two-player rectangles
17:22 - and directs are great for that as well
17:24 - because they have lots of methods to
17:26 - measure collisions we only need the
17:29 - simplest one but we just check if two
17:31 - rectangles are colliding the method for
17:34 - that is called collide rect and you call
17:37 - it on one rectangle and pass in the
17:39 - other rectangle and if they collide it
17:42 - returns true and with that all we need
17:45 - is an if statement with two conditions
17:47 - so if ball dot collide rect player or
17:51 - ball dog collide direct opponent and
17:55 - inside of that we just tell the ball to
17:57 - reverse the horizontal speed just like
18:00 - we did for when it hits the left or the
18:01 - right side of the screen
18:04 - and with that we have all the collisions
18:06 - we need
18:08 - I will do some housekeeping before
18:10 - continuing adding too much logic in the
18:13 - loop is going to become quite confusing
18:15 - and also difficult to maintain and it is
18:18 - usually better to keep all the logic in
18:20 - the set apart and used to loop primarily
18:22 - to draw and update the shapes so to make
18:25 - things a little cleaner I will put the
18:27 - ball movement inside of a function and
18:29 - call that function where the code used
18:32 - to be and I will call it ball animation
18:35 - and put it at the top of the code
18:41 - however if I run the code now we get an
18:45 - error message about some local variables
18:48 - this can be fixed by including global
18:51 - ball speed X ball speed Y at the top of
18:53 - the function and let me add a small
18:59 - intermission to explain why this is
19:01 - necessary in most programming languages
19:05 - including Python it is really important
19:08 - where a variable is declared in Python
19:11 - you have two major spaces also called
19:13 - scopes the global and the local scope if
19:17 - you declare a variable inside of a
19:19 - function you create a local variable
19:21 - that isn't available in the global scope
19:24 - this applies even if a variable of the
19:26 - same name already exists in the global
19:29 - scope so when we try to update the ball
19:31 - speed we try to update a local variable
19:34 - that Python did not yet initiate so it
19:37 - threw an error there are a couple of
19:40 - ways to get around that one way like I
19:42 - did in the code is to declare global
19:44 - variables inside of the function
19:47 - unfortunately this is only a good
19:49 - solution in simple programs if you
19:52 - attempt this approach in more complex
19:54 - code you will end up with adding more
19:57 - and more names to the global namespace
19:58 - and make things quite confusing a better
20:02 - way would be to use either return
20:04 - statement or to use a class especially
20:06 - if you use a class in the global
20:08 - namespace then its attributes can be
20:10 - updated within the local scope as a
20:13 - matter of fact when we move the ball who
20:15 - did just that hope that clarifies things
20:18 - a little bit back to the game now
20:21 - next up is the input there's one input
20:24 - command already that you can close the
20:26 - program by clicking on the little X at
20:28 - the top I will expand this and what I
20:32 - want is that by clicking the up and down
20:34 - arrow it moves the player in those
20:35 - direction this requires to check two
20:38 - events actually first that a button is
20:41 - pressed down to start the movement and
20:43 - second that a button is not pressed
20:45 - anymore and that the movement should
20:47 - stop pygame can handle both of these
20:50 - easily we just need to check the event
20:53 - type for pi game key down and PI game
20:56 - key up I will start with key down which
20:58 - is for pressing a button down but this
21:02 - one only checks if any key on the
21:04 - keyboard has been pressed down to check
21:07 - for a specific key need another if
21:09 - statement inside of this if statement
21:11 - that checks for event key and the down
21:14 - arrow is called K unless code down in PI
21:17 - game and inside of this if statement we
21:21 - can add code to execute when the down
21:23 - key has been pressed you might be
21:26 - tempted to just add something like
21:27 - player dot y plus equals 7 but that
21:30 - would not work you see PI gam only
21:33 - checks if the button changes to state
21:35 - from unpressed to pressed so if you keep
21:38 - it pushed down it will not trigger the
21:40 - event you would need to continuously
21:42 - press the button to move in tiny steps
21:44 - which would not be fun at all
21:47 - there are a couple of ways to solve this
21:49 - the one I found the best is the
21:52 - following you declare a variable player
21:54 - underscore speed and at this speed to
21:57 - the player rectangle on every single
21:59 - cycle of the loop regardless of what
22:02 - button is pressed that being said if no
22:05 - button is pressed this variable is zero
22:07 - so the player effectively doesn't move
22:11 - however when the up or down key is
22:14 - pressed this variable becomes positive
22:16 - or negative and then the player will
22:19 - move so let's put that into code
22:22 - I first declare the variable player
22:24 - underscore speed and assign it to value
22:27 - zero
22:28 - so back in the loop I have player dot y
22:32 - plus equals player speed
22:37 - now to the input back in the event key
22:39 - if statement I change player and ESCO
22:42 - speed to plus equals seven and at a
22:46 - second if statement checks if event key
22:48 - equals K and let's go up for the UP
22:51 - button if this one triggers the player
22:55 - speed should be minus equals seven and
22:58 - after all of that I add the if statement
23:01 - for releasing the button I can just copy
23:04 - the entire statement from key down
23:06 - actually all I need to change is that we
23:08 - reverse the operation I change key down
23:11 - to key up so negative 7 becomes plus 7 +
23:14 - + 7 becomes negative 7 and with that
23:18 - we're done if I run the code now we can
23:21 - move the player but there's one small
23:25 - problem
23:25 - the player can move outside of the
23:27 - window which is a little bit annoying so
23:30 - let's fix it all the logic I need is
23:35 - that if the players top is more than 0
23:39 - to put a player's top at the location 0
23:42 - and if the players bottom is greater
23:46 - than this Green's hype then you put the
23:49 - bottom at this green side that way the
23:54 - player will always be placed back at the
23:56 - border if it tries to go over it we
23:58 - basically teleport him by such small
24:00 - numbers that it looks like that there's
24:02 - no movement at all and again this starts
24:06 - to look a bit messy so I put all these
24:08 - lines into a function like Hall player
24:10 - underscore animation
24:13 - and no need to declare global variables
24:16 - all of this should still work perfectly
24:18 - fine and with the player input animation
24:22 - we almost have a game but we still need
24:25 - an opponent I will keep this one simple
24:27 - if the opponent's top is above the
24:30 - center of the ball move the opponent
24:32 - down and if the bottom of the opponent
24:34 - is below the center of the ball move the
24:36 - opponent up and the speed of the
24:38 - opponent will be used to determine the
24:39 - difficulty it's pretty simple actually
24:42 - in the code I declare a variable called
24:45 - opponent underscore speed and I set it
24:48 - to seven and in the loop I add if
24:51 - opponent or top is smaller equal than
24:54 - balls at Y then opponent or top plus
24:58 - equal opponent speed and if opponent at
25:04 - bottom is greater or equal than ball at
25:06 - Y then the opponent of Y - equal
25:12 - opponent speed I also want to prevent
25:16 - the opponent from leaving the screen so
25:19 - I implement the same logic that I use
25:21 - for the play at just a second ago and
25:26 - again I put all of that logic into a
25:29 - function and call the function and the
25:31 - main loop running on off that basically
25:38 - gives us a working game it's not much
25:43 - because nobody can lose so let's finish
25:45 - the game of that one
25:49 - I really want is that once the ball hits
25:51 - over the left or the right wall I wanted
25:53 - to return to the center and restart in a
25:56 - random direction we already have code
25:59 - that checks whether the ball hits the
26:01 - left or the right side it's in the ball
26:03 - movement function within that I removed
26:06 - the line that reverses the speed of the
26:08 - ball and replace it with a function I
26:10 - called ball and let's go restart and
26:13 - further down the code I create that
26:16 - function and add the details the first
26:19 - thing we need is to teleport the ball to
26:21 - the center this is actually quite easy
26:23 - we did similar things already loads of
26:25 - times you see for now we only ever added
26:29 - small increments to a number by using
26:31 - plus equal or minus equal but we don't
26:34 - need to use that we could just assign a
26:36 - number immediately and teleport the ball
26:38 - or out exactly what I want to do here so
26:41 - on the first line of the function I add
26:44 - ball but Center equals screen worth
26:46 - divided by two and screen height divided
26:49 - by two
26:49 - note that this one needs a tuple and
26:51 - that we move to center of the ball not
26:54 - the top left like we did in the
26:55 - beginning which makes the math a little
26:57 - bit easier and running that code already
27:00 - gets us kind of a working game but the
27:02 - bog keeps the same direction after a
27:04 - goal was scored to fix that I need to
27:07 - random module so at the top of the code
27:10 - it is import random and back in the
27:13 - function after the ball was centered at
27:16 - a vertical ball speed and type
27:18 - multiplied equal randomly choice and
27:21 - insert a tube of positive and negative
27:24 - one and after that I did the same thing
27:27 - for the horizontal speed Brennan the
27:30 - choice selects a random element from a
27:32 - list that is passed into it basically
27:35 - after the ball is teleported to the
27:37 - center each speed variable is multiplied
27:40 - with 1 or minus 1 does randomize in the
27:43 - direction the one thing we need though
27:46 - is to clear both speeds as global
27:48 - variables don't forget that and while we
27:52 - add it I can also multiply both speeds
27:54 - when they initially set with positive or
27:56 - negative 1 so that the ball starts in a
27:59 - random direction at the beginning of the
28:00 - game
28:01 - that being done we can run the game and
28:04 - we have really basic pong game
28:06 - and granted it's pretty basic and you
28:09 - could add lots of things like a timer
28:11 - before the boat starts or score and some
28:14 - sounds might be a good idea as well but
28:17 - it is a working game to get things
28:19 - started so I hope you like this tutorial
28:21 - you can download the source code from
28:23 - the links in description and if you want
28:26 - me to explain how to add these parts as
28:28 - well just let me know in the comments
28:30 - otherwise for next week I'll be showing
28:33 - you how to make a calculator in Python
28:35 - I'll see you then

Cleaned transcript:

hello in this tutorial I'm going to show you how to make a pong game that looks something like this I'll be using Python and PI game for that purpose and it should be fairly straightforward because pong is quite easy after all I'll be going for all of these steps if you want to jump to specific parts let's jump right in if you are new to Python pay game is a module that doesn't come with Python but you can download it for free that is done idle with the powershell of the terminal depending on your operating system so start the one you need just like any other program and you type pip install PI game you should now be seeing a little animation where you can see things of being installed once that is done open your code editor of choice and type import PI game and if you can execute that code without an error you are good to go before we actually get into the code let's talk about how Piegan works on a conceptual level to oversimplify things a little bit every pygame code consists of two parts one part where you set up all your code you need for the game so your classes functions and variables that carry the logic of the game that is the part that works like any other code but to actually run the game you need a loop which is the second part inside of this pi and continuously cycles through a while loop updates the code and draws the resulting picture and since that happens many times per second we perceive this as a moving image for a simple example imagine you want to move a rectangle from the left to the right of the screen in the setup part you would create a rectangle and give it a starting position and a movement speed and then in the loop you would run a function to make the rectangle move to the right by the movement speed once per loop cycle with all of that established let's create a basic setup and we'll work ourselves up from there the code to create a basic window looks like this first we import PI game and sis why we need PI games should be obvious at this point since if you haven't encountered it yet it's a module to access some more functionality on your system in our case though we're only going to use it to close the game once we're done with it which happens further down here next we have two lines that are important for the general setup pygame in it initiates all the pygame modules and is required before we can run any kind of game and you always need it for any kind of PI game code after that we have a clock method that we store in the variable clock I will come back to this in a couple of minutes so keep with me for now and in the next few lines we create the actual window the important line here is PI game not displayed of set underscore mode which returns a display surface object which we store in the screen variable this method can accept a number of arguments for more advanced games but we only want to create a basic game all we pass in is a tuple with the width and a hype of the window both of which are defined in their own variables in this case I create a window that is 1280 pixels wide and 960 pixels high and the next line is purely to give the window a title I called it pong but you could put in any string you like once that is done we get to the loop which is just a simple wire loop that runs perpetually for now this loop is incredibly basic and only really checks if the user has pressed the close button at the top of the window how would that works is that on every single cycle of the loop we get a list of all the user inputs with PI games or event or get pygame calls all user interactions events so an event could be a click of a button the moving of the mouse or even just closing the window and we loop through all of those with a for loop so effectively we have a while loop that updates the game and inside of that loop we have a for loop that checks for all the user actions for now all we want to check is whether the user has clicked a little X at the top of the screen which is a certain type of event that pagan cults quit and if the event type equals PI game not quit we call two methods PI game that quit and initializes the PI game module and system exit closes the entire program all you really need to know is that both of these combined close the game reliably pagon has lots of keywords to check for different kinds of user input these are called locals and they are always capitalized I'll put a link in the description for all the options and after the input we have pi gamma dot display dot flip this methods entire purpose is to take everything that came before it in the loop and draw a picture from that well now since we haven't drawn anything yet it only draws a black screen and finally we have clock tick the same clock we defined earlier in the code it is essentially what this one does is that it limits how fast the loop runs in this case 60 times per second this is necessary because the computer will try to run the code as fast as it can so if you don't control the speed the computer might just try to run it at 10,000 cycles per second and you wouldn't be seeing anything and that's it we have created a basic setup when I run the code now we get a black window with a title so let's talk about how to draw on that to draw stuff in pygame you have to understand the hierarchy of four different concepts the most basic element is the display surface object we already created this one in the code with PI Gambler displayed at set mode and stored it in the screen variable is this going to be the main screen that we draw all our shapes on and there can be only a single one so even if you created lots of shapes and images unless they are on the display surface they would not be shown now you could draw it directly on this display surface with PI games or draw and you have the option to draw all kinds of shapes however there are two more elements that make it easier to organize and manipulate all the shapes and images the first is a regular surface or just a surface think of it like an extra layer that holds material which is quite useful to keep your game organized the difference between the display surface and a regular surface is that you can have as many regular surfaces as you like but you need to attach them explicitly to the display surface otherwise they would not be shown but besides that you can basically do the same thing with both kinds of surface like adding drawings or putting pictures on them the second element is a rectangle or a rect and that is literally what it is a rectangle what you do with this rectangle is that you can put it around shapes and regular surfaces which makes it much easier to measure them and to manipulate them as well which becomes really handy when you actually make a game and that is it for this game I won't be making any services besides the display surface I will however use rectangles for the shapes let's put all of that into code I will start by defining a rectangle for the ball this is done with pygame direct which takes in the X&Y position along with the height and the width of the rectangle keep in mind that the X and the y position is for the top left of the rectangle and also that the origin of the window itself is on the top left so if you want to go down you have to increase Y the ball itself is going to be 30 pixels wide and 30 pixels high that part is easy to place it right in the middle of the screen we do need a little bit of math though I couldn't just put it at half of the screens width and half of the screens hype because I am moving the top left and if I placed it like that it would be slightly off the center but that can be fixed by subtracting half of the width and half of the hype of the ball itself and if we do that the ball is perfectly centered next I define a rectangle for the player that I put in the middle of the right side that is 10 pixels wide and 140 pixels high and a place it's top left on the coordinates screen with minus 20 and I get height with the same method that I get the height of the ball I divide the height of the screen by 2 and I subtract half of the players length from that and then I define another variable for the opponent that holds a rectangle at the coordinates 10 and the same height as the player and it would also be 10 pixels wide and 140 pixels high for now these are just free empty rectangles to actually draw them we need to get the loop and use pygame dot draw which is the module with all the different options to draw shapes to use that one we usually three arguments the service to draw on a color argument and a rectangle since I'm drawing directly on the display surface that one is easy and I also have two rectangles I need so let's talk about colors then there are two ways to create colors and pygame the most common one is with a tuple of RGB values RGB stands for red green and blue and you can set the value of each of these colors and if you mix the different values of each of these colors you can create basically any color essentially we have a tuple that we can pass breve values into the first one for red just like one for green and the third one for blue and you can choose the values from 0 to 255 with 0 being the absence of the color and 255 being the pure color so for pure red it would be 255 0 and 0 for pure black it would be 0 0 0 and for pure white it would be 255 255 and 255 the other way to create colors and pygame is with a color object this one is created with the command pygame code color and you pass in the string of the name of a color you can find all of the available color names online and that's basically it for this one let me use both methods so you guys have an idea of how it looks in the code I will make the background with a color object and use an RGB tuple to make a greyish white that I will use for all the other shapes so below the rectangles I declare a variable BG underscore color and assign it pygame blood color and pass in the string gray 12 and on the next line I create another variable called light gray and I assign it a tube of 200 200 and 200 which gives us a light gray with all of that done we can get into the actual drawing in the loop I start by drawing the two players since both are plain rectangles pygame the draw the direct fits really well I passed on the surface to draw on the light gray color and the rectangle and then I do the same thing for the opponent next is the ball this we draw with pygame the draw the ellipse which also takes a surface a color and a rectangle but instead of filling the whole rectangle it uses its frame to draw an ellipse into it and since all our sides are the same length this ellipse becomes a circle and that covers all the main shapes but I will add two more elements that don't need a rectangle the line that separates the two sides of the field and the background color especially the background color is important because without it you would still be able to see the previous frame which would make the game impossible so I add the background color by filling the entire display surface this is done by calling dot fill on the variable that holds the surface screen in this case and into that I passed the color I want to use BG and ESCO color in this case and finally I create a line that separates the two sides this will be done with pygame the draw lat a a line which stands for anti aliased line this one needs four arguments its service to draw on the color and the tip of the start point and a tuba with the end point so I pass in the screen light gray for the color the first tuple will be half of the screens with and zero for the middle of the table window the second tuple will be half of the screen Swift and the screen height for the middle of the bottom of the window and one thing to pay attention to is the order of the code successive elements in the loop are drawn on top of each other so the first element called in the code will be at the bottom of the frame and the last one will be on the top if I put screen note fill below the other elements we would only see the background so do be careful with that but if I run the proper code now we can see that all the basic shapes are there and with that one done we can get to the animations I will start with the ball right now the code works like this we define a rectangle with coordinates and dimensions and later we draw a rectangle on the surface with a color the way we do animations is that we add a step in between that tells pygame to move the coordinates by number of pixels every cycle in the loop and for that purpose the rectangles are incredibly useful essentially in and around each rectangle there are these points that we can influence and measure and if we move a single point we move the entire rectangle so for example if I wanted to move this rectangle to the right by 5 pixels I could use x + equals 5 or right plus equals 5 or even left plus equals 5 they would all achieve the same result and that result would be that on every cycle this rectangle would move to the right by 5 pixels so to get the ball moving I start by defining two speed variables one for horizontal speed and one for the vertical speed respectively called ball speed X and ball speed Y and I set both to seven Y we need to will become clear in just a second now in the loop we want the ball to move every frame by the ball speed we defined earlier that is super easily done with ball dot X plus equals ball speed X and bolded y plus equals post lead Y so on every single cycle this ball will be moved by the speed we defined in the speed variables and since we're doing this 60 times a second we get a moving image let's run the code now and see how this looks we can see that we have a moving ball but the problem is that the ball moves out of the frame since we never told it to stop for that we need some collisions just to get this started and we let the ball bounce around the four sides of the screen and later we had more code when the ball hits left or the right side the basic logic we need is something like this if the top of the ball is zero the bottom of the ball is equal to the height of the screen then reverse the vertical ball scale and if the left side of the ball is zero or if the right side of the ball is equal to the screen width then reverse the horizontal ball speed and the reason we have to speed variables is to be able to reverse the speed for each axis separately and since we can access all of those attributes this is actually a really simple if statement to reverse the ball speed all we need is to multiply the speed by negative one and since we don't care if this goes from positive to negative or from negative to positive we only need one if statement for each axis and when I execute the code now we have a bouncing ball one thing to be careful of is that you shouldn't use the equal comparison as you can see in my if statement I use greater or equal or smaller or equal the reason for that is that we need to be careful of what points we are measuring if the ball moves seven pixels per cycle and it happens to be at the position 955 and then it would move to 962 in the next frame since that wouldn't be equal to the height of the screen the ball would just continue and we would have a gamebreaking bug if we use greater or equal to then this problem wouldn't a cure at all so this is why I'm using greater and equal or smaller and equal to but anyway I also want the ball to collide with the twoplayer rectangles and directs are great for that as well because they have lots of methods to measure collisions we only need the simplest one but we just check if two rectangles are colliding the method for that is called collide rect and you call it on one rectangle and pass in the other rectangle and if they collide it returns true and with that all we need is an if statement with two conditions so if ball dot collide rect player or ball dog collide direct opponent and inside of that we just tell the ball to reverse the horizontal speed just like we did for when it hits the left or the right side of the screen and with that we have all the collisions we need I will do some housekeeping before continuing adding too much logic in the loop is going to become quite confusing and also difficult to maintain and it is usually better to keep all the logic in the set apart and used to loop primarily to draw and update the shapes so to make things a little cleaner I will put the ball movement inside of a function and call that function where the code used to be and I will call it ball animation and put it at the top of the code however if I run the code now we get an error message about some local variables this can be fixed by including global ball speed X ball speed Y at the top of the function and let me add a small intermission to explain why this is necessary in most programming languages including Python it is really important where a variable is declared in Python you have two major spaces also called scopes the global and the local scope if you declare a variable inside of a function you create a local variable that isn't available in the global scope this applies even if a variable of the same name already exists in the global scope so when we try to update the ball speed we try to update a local variable that Python did not yet initiate so it threw an error there are a couple of ways to get around that one way like I did in the code is to declare global variables inside of the function unfortunately this is only a good solution in simple programs if you attempt this approach in more complex code you will end up with adding more and more names to the global namespace and make things quite confusing a better way would be to use either return statement or to use a class especially if you use a class in the global namespace then its attributes can be updated within the local scope as a matter of fact when we move the ball who did just that hope that clarifies things a little bit back to the game now next up is the input there's one input command already that you can close the program by clicking on the little X at the top I will expand this and what I want is that by clicking the up and down arrow it moves the player in those direction this requires to check two events actually first that a button is pressed down to start the movement and second that a button is not pressed anymore and that the movement should stop pygame can handle both of these easily we just need to check the event type for pi game key down and PI game key up I will start with key down which is for pressing a button down but this one only checks if any key on the keyboard has been pressed down to check for a specific key need another if statement inside of this if statement that checks for event key and the down arrow is called K unless code down in PI game and inside of this if statement we can add code to execute when the down key has been pressed you might be tempted to just add something like player dot y plus equals 7 but that would not work you see PI gam only checks if the button changes to state from unpressed to pressed so if you keep it pushed down it will not trigger the event you would need to continuously press the button to move in tiny steps which would not be fun at all there are a couple of ways to solve this the one I found the best is the following you declare a variable player underscore speed and at this speed to the player rectangle on every single cycle of the loop regardless of what button is pressed that being said if no button is pressed this variable is zero so the player effectively doesn't move however when the up or down key is pressed this variable becomes positive or negative and then the player will move so let's put that into code I first declare the variable player underscore speed and assign it to value zero so back in the loop I have player dot y plus equals player speed now to the input back in the event key if statement I change player and ESCO speed to plus equals seven and at a second if statement checks if event key equals K and let's go up for the UP button if this one triggers the player speed should be minus equals seven and after all of that I add the if statement for releasing the button I can just copy the entire statement from key down actually all I need to change is that we reverse the operation I change key down to key up so negative 7 becomes plus 7 + + 7 becomes negative 7 and with that we're done if I run the code now we can move the player but there's one small problem the player can move outside of the window which is a little bit annoying so let's fix it all the logic I need is that if the players top is more than 0 to put a player's top at the location 0 and if the players bottom is greater than this Green's hype then you put the bottom at this green side that way the player will always be placed back at the border if it tries to go over it we basically teleport him by such small numbers that it looks like that there's no movement at all and again this starts to look a bit messy so I put all these lines into a function like Hall player underscore animation and no need to declare global variables all of this should still work perfectly fine and with the player input animation we almost have a game but we still need an opponent I will keep this one simple if the opponent's top is above the center of the ball move the opponent down and if the bottom of the opponent is below the center of the ball move the opponent up and the speed of the opponent will be used to determine the difficulty it's pretty simple actually in the code I declare a variable called opponent underscore speed and I set it to seven and in the loop I add if opponent or top is smaller equal than balls at Y then opponent or top plus equal opponent speed and if opponent at bottom is greater or equal than ball at Y then the opponent of Y equal opponent speed I also want to prevent the opponent from leaving the screen so I implement the same logic that I use for the play at just a second ago and again I put all of that logic into a function and call the function and the main loop running on off that basically gives us a working game it's not much because nobody can lose so let's finish the game of that one I really want is that once the ball hits over the left or the right wall I wanted to return to the center and restart in a random direction we already have code that checks whether the ball hits the left or the right side it's in the ball movement function within that I removed the line that reverses the speed of the ball and replace it with a function I called ball and let's go restart and further down the code I create that function and add the details the first thing we need is to teleport the ball to the center this is actually quite easy we did similar things already loads of times you see for now we only ever added small increments to a number by using plus equal or minus equal but we don't need to use that we could just assign a number immediately and teleport the ball or out exactly what I want to do here so on the first line of the function I add ball but Center equals screen worth divided by two and screen height divided by two note that this one needs a tuple and that we move to center of the ball not the top left like we did in the beginning which makes the math a little bit easier and running that code already gets us kind of a working game but the bog keeps the same direction after a goal was scored to fix that I need to random module so at the top of the code it is import random and back in the function after the ball was centered at a vertical ball speed and type multiplied equal randomly choice and insert a tube of positive and negative one and after that I did the same thing for the horizontal speed Brennan the choice selects a random element from a list that is passed into it basically after the ball is teleported to the center each speed variable is multiplied with 1 or minus 1 does randomize in the direction the one thing we need though is to clear both speeds as global variables don't forget that and while we add it I can also multiply both speeds when they initially set with positive or negative 1 so that the ball starts in a random direction at the beginning of the game that being done we can run the game and we have really basic pong game and granted it's pretty basic and you could add lots of things like a timer before the boat starts or score and some sounds might be a good idea as well but it is a working game to get things started so I hope you like this tutorial you can download the source code from the links in description and if you want me to explain how to add these parts as well just let me know in the comments otherwise for next week I'll be showing you how to make a calculator in Python I'll see you then
