00:00 - today we're going to be solving another
00:01 - lead code coding exercise this is going
00:04 - to be an interesting one to find a fast
00:06 - solution for and I'm also going to talk
00:07 - a little bit about the thought process
00:09 - behind coming up with the solutions for
00:12 - these sorts of problems but first thanks
00:13 - to mailgun for sponsoring this video
00:15 - mailgun is how modern companies work
00:18 - with email mailgun is easy to use has
00:20 - amazing 24 7 customer support and simple
00:23 - but powerful apis that smart developers
00:26 - can use to reach their customers at
00:28 - scale so their organizations can grow
00:30 - faster you can use mailguns API to send
00:32 - an email with just a few lines of code
00:34 - with whatever language you're using of
00:36 - course including Java it really couldn't
00:38 - be easier today mailgun is used by over
00:40 - a hundred thousand companies and top
00:42 - brands around the world to provide
00:44 - personal connected experiences through
00:46 - email and drive smart results you can
00:48 - send and track transactional and
00:50 - marketing messages remove invalid emails
00:52 - from your list or prevent fake signups
00:54 - in the first place easily mailgun also
00:57 - has an awesome send time optimization
00:59 - feature that automatically finds the
01:01 - perfect time to send to each and every
01:03 - individual on your list at the exact
01:05 - time that they're most likely to engage
01:07 - they also have a team of email experts
01:09 - ready to work with you to improve your
01:11 - email deliverability and also Drive
01:13 - higher conversion rates with its
01:15 - intuitive email Marketing Solutions and
01:17 - Powerful API mailgun Works through the
01:19 - whole email lifecycle from
01:21 - pre-development all the way to the inbox
01:23 - for more than 240 billion emails a year
01:26 - for companies like Wikipedia DHL toast
01:29 - Lyft and Microsoft helping them solve
01:32 - complex communication problems and build
01:34 - connected experiences through email so
01:36 - thanks again to mailgun for sponsoring
01:38 - this video try mailgun today by using my
01:40 - link which you can find down in the
01:42 - description mailgun.com John now let's
01:46 - get to it so this is lead code problem
01:48 - number three and it's a medium
01:50 - difficulty problem it's called longest
01:52 - substring without repeating characters
01:54 - so basically we're going to be given
01:56 - some string we'll call it s and our task
01:59 - will be to to find the length of the
02:02 - longest substring within that string
02:04 - that doesn't repeat any characters so
02:07 - they've got a few examples here so if
02:09 - our input string is a b c a b c b b well
02:13 - the longest substring within this string
02:15 - that doesn't repeat any characters is
02:18 - just ABC so if we were looking through
02:21 - this string we would go okay A B C all
02:24 - right we haven't repeated any characters
02:25 - yet and so far we've got a substring
02:28 - length of three but if we were to try
02:30 - and add the next character well that's
02:32 - an A and we already have an A so that's
02:34 - not a valid solution so the longest
02:36 - substring without repeating characters
02:38 - in this example is ABC and that has a
02:40 - length of 3 and so our output would be
02:43 - three one thing to note about this
02:44 - example is that technically the solution
02:46 - could have been BCA also or c a b those
02:51 - are also substrings that don't repeat
02:54 - any characters but they also just have a
02:56 - max length of three anyway so it doesn't
02:58 - change what our output is still the
03:00 - longest substring that doesn't repeat
03:02 - any characters in this string is just
03:04 - three so if we scroll down to the bottom
03:06 - here we can see that we have a couple of
03:08 - constraints on the string input that
03:10 - we're going to receive so one thing is
03:12 - that it'll only consist of English
03:13 - letters digits symbols and spaces that
03:16 - just means there's nothing really crazy
03:17 - for us to deal with as far as the
03:19 - characters go and it also says that the
03:21 - length of our string is going to be
03:24 - greater than or equal to zero so we
03:26 - won't have a negative number of
03:27 - characters in our string and the length
03:29 - of the string will be less than or equal
03:31 - to 5 times 10 to the fourth okay Elite
03:34 - code you're trying to be real fancy
03:35 - there with the scientific notation this
03:37 - is just fifty thousand ten to the fourth
03:40 - is ten thousand times five is fifty
03:42 - thousand and that really shouldn't be
03:44 - big enough to cause any sort of problem
03:46 - with any kind of solution that we might
03:47 - come up with as far as memory goes or
03:49 - anything like that so let's start
03:51 - thinking about the solution for this
03:53 - problem so with a lot of these leak code
03:55 - problems there's often like a Brute
03:57 - Force solution that most people come up
03:59 - with first and then often there's a more
04:02 - clever answer that's a little bit more
04:04 - tricky to come up with but leads to a
04:07 - much more efficient and fast solution
04:09 - now the same thing is the case here so
04:12 - to start let's look at an example string
04:14 - that we might be given and talk about
04:16 - what our Brute Force solution to this
04:18 - problem will look like basically we're
04:20 - just going to Loop through every single
04:22 - possible substring of this string until
04:25 - each of those substrings repeats a
04:27 - character and then keep a running
04:29 - maximum of the largest substring that we
04:31 - find that doesn't repeat any characters
04:33 - that might sound a little bit confusing
04:35 - so let's just walk through a quick
04:37 - example of what it's going to look like
04:38 - so what we'll do is start by looking at
04:40 - all the substrings of this string that
04:43 - start with the first letter A of course
04:46 - just the letter A by itself has no
04:49 - repeating characters so as of right now
04:51 - the maximum substring that we found that
04:53 - doesn't repeat any characters is of
04:56 - length one and then we say okay we
04:58 - haven't run into any repeating
05:00 - characters yet let's add the next
05:02 - character to our substring and the next
05:04 - character is B so now our substring that
05:07 - we're looking at is a b and so we say
05:10 - okay we're adding B does B already exist
05:13 - anywhere in our substring no it doesn't
05:15 - so there's still no repeating characters
05:17 - so now the maximum substring that we
05:19 - found that doesn't repeat any characters
05:21 - is of length two next we go ahead and
05:23 - add the C to our substring the C already
05:27 - exists anywhere in our substring no so
05:29 - we still don't have any repeating
05:30 - characters in this substring so our new
05:32 - maximum is three so next we look at the
05:35 - next character which is a does a re
05:37 - exist in our substring yes it does so
05:41 - now this substring contains repeating
05:43 - characters and so it doesn't count as a
05:46 - valid substring that we're looking for
05:47 - so now that we've run into a substring
05:49 - that has a repeating character we know
05:51 - that the largest substring that starts
05:53 - with this first a that doesn't repeat
05:55 - any characters is just a b c you know
05:58 - that has a length of 3. so next we have
06:01 - to look at all the substrings that start
06:03 - with the second letter of our string b b
06:07 - by itself doesn't contain any repeating
06:08 - characters but it's only of length one
06:10 - which is not greater than three so our
06:12 - maximum is still three and then we move
06:15 - this over to include c b c also doesn't
06:18 - contain any repeating characters but it
06:19 - only has a length of two so it's not
06:21 - bigger than the maximum we already have
06:23 - so we move over and look at BCA it also
06:26 - doesn't have any repeating characters
06:28 - but just has a length of three so
06:30 - there's no need to change our maximum
06:31 - and then when we move this over to
06:33 - include B now we have repeating
06:35 - characters and this isn't a valid
06:38 - substring anymore so then we move the
06:39 - beginning of the substring that we're
06:41 - looking at over to the C and do the same
06:44 - thing all over again so that would
06:46 - eventually get to c a b with no
06:48 - repeating characters which is still just
06:50 - a length of three and then when we add
06:52 - on the next C it now has a repeating
06:54 - character but then we will move on to
06:56 - starting with this a and this can
06:59 - proceed all the way to the end of our
07:01 - string without repeating any characters
07:04 - a b c d has a length of four and doesn't
07:07 - repeat any characters so when our
07:09 - program sees that it will update this
07:11 - maximum to four and then it'll Loop
07:13 - through all the rest of these characters
07:15 - in exactly the same way but it won't
07:17 - find any non-repeating substring that's
07:20 - any longer than four which is this a b c
07:23 - d and so we'll find that the solution is
07:26 - four so next let's go ahead and copy
07:29 - this over to IntelliJ so we can do our
07:31 - coding there and let's get to
07:34 - implementing that Brute Force algorithm
07:35 - so first a good thing to have is just
07:38 - going to be an INT variable a max length
07:41 - that we're going to use to keep the
07:43 - maximum length of the non-repeating
07:45 - substring that we've identified so we'll
07:47 - eventually return that as our solution
07:49 - and we'll initialize it to zero next
07:52 - we're going to want a loop that will
07:54 - look through each individual character
07:56 - of our input string and use each
07:59 - character as the start of the substring
08:02 - that we're looking at and we'll just
08:03 - keep that simple and use a for Loop this
08:05 - will be a pretty simple for Loop so for
08:07 - INT I equals zero we're going to keep
08:10 - looping while I is less than s dot
08:13 - length and each iteration through the
08:15 - loop we're going to increment I but now
08:17 - nested within that as We're looping
08:20 - through each character in our string
08:22 - being the start of each substring that
08:24 - we want to look at we then have to have
08:26 - an inner loop that adds on each
08:30 - subsequent character to our substring
08:33 - and you know keeps doing that and adding
08:35 - characters until we find one that
08:39 - repeats so in order to do that we're
08:41 - actually going to need a nested for Loop
08:44 - within this one or int J we'll call it
08:47 - and we'll actually start it not at zero
08:50 - but we'll initialize it to I because we
08:53 - don't necessarily want to start our
08:55 - inner loop at the very beginning of the
08:57 - entire string we want to start it at the
08:59 - beginning of the substring that we're
09:01 - looking at and that will always start
09:03 - with the ith character we will still
09:06 - Loop while J is less than s dot length
09:10 - we'll go to the end of the string with
09:12 - our inner loop as well and in the Inner
09:14 - Loop we will increment J each time but
09:17 - actually just within our outer loop we
09:20 - want to create something that we can use
09:22 - to build our substring something that
09:25 - for each iteration of our inner loop we
09:28 - can add to in order to build the
09:30 - substring that starts with a certain
09:32 - character now there's a bunch of
09:34 - potential ways you could do this but one
09:35 - decent way is with a string Builder now
09:38 - string Builder if you've never used it
09:40 - before is kind of what the name of it
09:42 - says it's an object that you can use to
09:44 - build strings and often we'll use it in
09:47 - situations like this where we want to
09:49 - add to a string in iterations through a
09:52 - loop so here we'll create a string
09:54 - Builder and call it let's say current
09:56 - substring we'll just initialize it to a
09:59 - new string Builder so now what we're
10:01 - going to do is in each iteration of this
10:04 - inner for loop we're going to be adding
10:06 - each subsequent character to the
10:10 - substring that we're building and along
10:11 - the way as we're building the substrings
10:13 - as long as the current substring we are
10:16 - looking at doesn't have any repeated
10:17 - characters we're going to be seeing if
10:19 - it exceeds our current max length and if
10:22 - it does we will update the max length to
10:25 - be the current large substring that
10:27 - we're looking at and we're going to keep
10:28 - looping through adding the next
10:29 - character to the substring that we're
10:31 - looking at until we find a repeated
10:33 - character and then once we find a
10:35 - repeated character we're going to break
10:37 - out of this inner for Loop and then
10:39 - start looking at every substring that
10:41 - starts with the next character in the
10:44 - string so for example as the outer loop
10:47 - is looking at this first character a our
10:49 - inner loop is going to be looping
10:51 - through each subsequent character after
10:54 - that a adding it to the substring that
10:57 - it's building that string Builder that
10:58 - we created it and it's going to do that
11:00 - until it adds a character that it
11:03 - identifies as being a repeat and so when
11:06 - we do find a character that repeats like
11:08 - that the outer loop is going to
11:10 - increment by one and we are going to
11:12 - start looking at all substrings that
11:15 - start with the next letter of our string
11:18 - and then our inner for Loop is going to
11:20 - do the same thing it's going to use that
11:22 - string Builder to add on each subsequent
11:26 - character in our string onto the string
11:29 - Builder until it identifies a repeat
11:32 - character so here's how we're going to
11:34 - implement that functionality into our
11:36 - inner for Loop first we're going to
11:38 - check whether the next character that
11:40 - we're about to add on our substring
11:42 - already appears in our current substring
11:46 - and if it does well we have a repeated
11:48 - character and we want to break out of
11:50 - our inner loop to do that we can say if
11:53 - so what we'd like to do is take our
11:56 - current substring and see if it already
11:59 - contains the next character that we're
12:02 - about to add to it but unfortunately
12:04 - string Builder doesn't actually have a
12:06 - contains method that just returns a
12:08 - simple Boolean so what we have to do is
12:10 - instead we have to call the index of
12:14 - method on it so the next character that
12:16 - we would add to the substring is the
12:18 - character that's at the jth position in
12:21 - our original string and so to get that
12:23 - we can just call s dot Char at and then
12:26 - pass in the index we're looking for J
12:28 - now again unfortunately this index of
12:31 - method can't take a character you have
12:34 - to pass in a string but luckily it's
12:37 - easy to convert a string to a character
12:39 - all we have to do is call string dot
12:42 - value of and then pass in our character
12:45 - like this so now what this index of call
12:47 - will return is it will return the
12:50 - position of this next character that
12:52 - we're about to add in the current
12:54 - substring if it already exists there and
12:57 - if it doesn't already exist there it
12:59 - it'll return a negative one when it
13:01 - returns a negative one that's its way of
13:03 - telling us I didn't find that character
13:06 - in this string Builder what that means
13:08 - is if the index of this character is
13:12 - anything except for negative one that
13:16 - means that that character already exists
13:18 - in our substring and we have a repeated
13:20 - character and as we said once we find a
13:23 - repeated character we want to break out
13:26 - of our inner for Loop so that is
13:29 - accounting for the situation where you
13:31 - know we're adding more things to our
13:33 - substring making sure there are no
13:34 - repeated characters but then once we do
13:37 - that and we're about to add a character
13:39 - that would be a repeat so in this
13:41 - situation when we're about to add an A
13:43 - but we already have an A that would
13:45 - break out of our inner for Loop and then
13:47 - it would start looking for substrings
13:49 - that start with the next character in
13:52 - the original string however if it gets
13:54 - past this point then we know that the
13:56 - next character that it's about to add is
13:58 - not already in the current substring
14:00 - that we're looking at so in that case
14:01 - great let's go ahead and add it to the
14:04 - current substring that we're building
14:05 - and to do that we just call current
14:07 - substring dot append and we want to
14:10 - append that same character at the jth
14:13 - position of our string so all this
14:15 - append method does is take the character
14:18 - that we're passing in and add it onto
14:20 - the end of our current substring so now
14:23 - we know that the current substring that
14:24 - we're looking at doesn't have any
14:26 - repeated characters so what we want to
14:27 - do is if that current substrings length
14:31 - is greater than the current maximum
14:34 - length non-repeated substring that we
14:37 - found so far then we want to set our max
14:39 - length to be the length of our current
14:42 - substring current substring dot length
14:45 - kind of a cooler way to do this though
14:46 - instead of having to okay let's check to
14:48 - see if the length is greater than the
14:50 - max length and if it is then we'll set
14:52 - the max length to be that one that works
14:54 - just fine but if you want to be really
14:56 - cool about it instead you can do
14:57 - something like Max length equals math
15:01 - dot Max and then pass in as the two
15:04 - parameters the current max length and
15:07 - also the length of the current substring
15:10 - and then you can get rid of this because
15:12 - this line of code is doing the exact
15:14 - same thing this math.max method will
15:17 - just return whichever one of these two
15:20 - parameters is larger so what that means
15:23 - is if the maximum length is already
15:25 - larger than the current substrings
15:27 - length it'll just get set to that max
15:29 - length again but if our current
15:31 - substrings length is larger then it will
15:34 - set max length to be that instead so
15:36 - it's just a little bit more of a concise
15:38 - way to do the same thing so then after
15:40 - all of that after it does all those
15:43 - Loops through all the possible
15:44 - substrings and maintaining that maximum
15:46 - length of the non-repeated substring
15:48 - that it finds at the very end of this
15:50 - method we actually have to return that
15:54 - maximum length that we found I think
15:56 - that should do it let's go ahead and
15:58 - copy this solution and paste it back
16:01 - over here into leak code and submit it
16:04 - and see what happens okay here we go
16:07 - alright so we see that our program is
16:09 - successful awesome right well yes but
16:12 - let's look at some of these facts here
16:14 - so our run time was a 433 milliseconds
16:18 - which says it's faster than
16:21 - 5.94 of all Java submissions for this
16:25 - problem that's not great right that
16:28 - means that 94 of all Java submissions
16:32 - for this problem were faster we're more
16:34 - efficient than our solution from the
16:36 - last leak code video I heard that a lot
16:38 - of people struggled with techniques for
16:41 - coming up with a faster more efficient
16:44 - solution to these sorts of problems now
16:46 - what should I consider what kind of
16:47 - things should I know how should I even
16:49 - start thinking about it so first let's
16:51 - talk about why our current solution is
16:54 - probably so slow so what we're doing in
16:56 - our solution is We're looping through
16:57 - each character in the string and then
17:00 - within that Loop We're looping through
17:02 - each subsequent character in the string
17:05 - so to do that that meant that in our
17:07 - algorithm we had to use a nested for
17:10 - Loop to do that so that means that the
17:12 - time complexity the Big O complexity of
17:15 - our algorithm is going to be Big O of N
17:18 - squared usually when you have in your
17:20 - algorithm a nested for Loop that Loops
17:23 - through your data set in both of those
17:25 - Loops usually that means that you have a
17:28 - quadratic time complexity a big O of N
17:30 - squared so literally like the bigger
17:32 - that this string s is that gets put into
17:35 - our program so as that s gets larger and
17:38 - larger with just a little bit of
17:40 - increase to the size of our input our
17:43 - program will take dramatically longer to
17:45 - run so what we want to do to try and
17:47 - make this run faster is to of course
17:50 - just lower the time complexity of our
17:53 - solution now that could mean a couple of
17:55 - things there could be various ways to do
17:57 - that but the main thing in this
17:59 - situation what we want to do is get rid
18:02 - of this inner for Loop one way or
18:05 - another if at all possible so if we can
18:07 - accomplish our task just by looping
18:10 - through our string one time then that's
18:13 - what we want to do but then of course we
18:15 - have to think well how can we do that
18:17 - there are a few things that you can keep
18:19 - in mind when you're trying to come up
18:20 - with that sort of a solution a big part
18:22 - of what you want to keep in mind is just
18:24 - the different types of data structures
18:26 - that you have available to you so that
18:29 - could be things like lists cues sets
18:32 - Maps trees and and knowing how each of
18:36 - them work what they're all useful for
18:38 - and the properties of each of those
18:40 - helps you to know what could be helpful
18:43 - to use in various situations but
18:46 - honestly a lot of it is just doing a
18:49 - whole lot of these challenges coming up
18:50 - with your own Solutions and when you
18:52 - struggle look up what other people's
18:55 - Solutions are and what they came up with
18:57 - see which ones are faster and try and
18:59 - understand why but for this specific
19:02 - problem what do we need to do in order
19:05 - to be able to get the solution with one
19:09 - pass through our string well we need to
19:11 - know the whole substring that we're
19:13 - looking at at any given moment but we
19:16 - also need some way to determine at each
19:19 - character in our Loop whether that
19:21 - character already exists in our
19:24 - substring but we want to do that without
19:26 - looping through all of the other
19:29 - characters in our substring because then
19:31 - we'll be right back in the situation
19:32 - where we have that inner loop now one
19:35 - way I can think to do that is with a
19:37 - hash map and we actually did use a hash
19:40 - map in kind of a similar situation in
19:43 - the last leak code video in this
19:45 - situation we can use a hash map to
19:47 - remember the index that we last found
19:50 - each character that we run into in our
19:52 - string so it'll be a map where the keys
19:55 - are the characters that we find in our
19:58 - string and the value associated with
20:00 - each of those keys with each of those
20:02 - characters is going to be an integer
20:04 - that represents the last position that
20:07 - we encountered that character here's
20:10 - what I think we can do let's walk
20:11 - through an example so in this case we'll
20:13 - actually use two pointers don't worry
20:15 - we're not going to use two for Loops but
20:18 - we are going to use two pointers a left
20:20 - pointer and a right pointer and we're
20:22 - going to start with both of those
20:24 - pointers pointing to the first character
20:26 - in our string so right now our substring
20:28 - is just the Single Character a we look
20:31 - at that character and we say okay does
20:33 - that character exist in our map yet and
20:37 - of course our map is empty we haven't
20:38 - done anything with it yet so no it
20:40 - doesn't so that tells us that there's no
20:42 - repeats in our current substring so what
20:44 - we can do is we check the length of that
20:46 - substring which happens to be just one
20:48 - there's just one character and then we
20:50 - go ahead and set our Max to one but then
20:53 - before we proceed we add that character
20:56 - we add that a to our map so what we're
20:59 - saying in our map is the last time I saw
21:02 - the letter A it was at position zero so
21:06 - a is the a key in our map and 0 is the
21:09 - value so what this means is later if we
21:12 - encounter the letter A again we can just
21:15 - look it up in our map and say oh the
21:17 - last time that an a appeared was at
21:20 - position zero and then we don't have to
21:21 - Loop through the entire string to find
21:23 - that out we can just do a constant time
21:27 - lookup in our map so that map is going
21:30 - to be the key here the map is going to
21:31 - be how we're going to essentially get
21:34 - rid of our inner for Loop and improve
21:36 - the time complexity of our algorithm so
21:39 - after we add the a to our map we then go
21:42 - to the next iteration of our Loop but we
21:45 - don't move the left pointer we only move
21:47 - the right pointer so that increments to
21:51 - the next character in our string so what
21:53 - we do first is we look up B in our map
21:55 - does it exist in our map no it doesn't
21:57 - so that's cool that means we don't have
21:59 - any repeated characters so we look at
22:01 - the length of our current substring
22:03 - which is 2 so we can update our maximum
22:06 - substring length to B2 and then we want
22:08 - to do the same thing we did before and
22:09 - we want to add B to our map now so we'll
22:12 - say okay the last time that we
22:13 - encountered the letter B it was at index
22:16 - one and then we moved to the next
22:18 - iteration of our Loop and the same thing
22:20 - goes for C is C in our map no it's not
22:23 - so we update our maximum to 3 because
22:26 - that's the current length of our
22:27 - substring and we add that to our map as
22:29 - well the last time we saw C was at index
22:32 - two and then we move on to the next
22:33 - iteration of our Loop and we look up a
22:36 - in our map does a already exist in our
22:38 - map yes it does so that means yes we've
22:42 - seen it before but another thing that we
22:43 - do want to check is did we see it before
22:47 - inside the current substring that we're
22:49 - looking at and we can know that pretty
22:51 - easily just by checking the index where
22:54 - we've seen it before so in our map we
22:56 - look up a and we say oh that a was last
22:58 - encountered at index 0. and we can see
23:02 - that judging by our left and right
23:04 - pointers our left pointer is at position
23:07 - 0 and our right pointer is at position
23:09 - three and that means this a at index 0
23:13 - is within our current substring so
23:17 - because of that we know that we
23:18 - definitely have a repeating character
23:21 - inside our current substring so we have
23:24 - to fix that before we move on we have to
23:26 - set our substring to be something that
23:29 - doesn't contain a repeating character
23:31 - and we actually fix that by moving our
23:34 - left pointer so this is the situation
23:36 - where we do move our left pointer so
23:39 - we're looking at an a currently with our
23:41 - right pointer and we can see okay the
23:42 - last time we saw an a was at index 0. so
23:45 - in order for our current substring to no
23:48 - longer contain that repeating character
23:50 - we're going to move our left pointer to
23:53 - be one past where we last saw that
23:57 - letter so we'll just do this so now
24:00 - we've shifted that substring that we're
24:02 - looking at to where we now know that it
24:05 - no longer has that repeating character
24:07 - now before we move on we still want to
24:10 - update our map because now the last time
24:13 - that we encountered the character a was
24:16 - not at index 0 and now we last
24:18 - encountered it at index three now as
24:21 - before we move on to the next iteration
24:23 - of our Loop which means moving the right
24:26 - pointer one character over so now we're
24:28 - looking at the letter b and we look that
24:30 - up in our map to see when we last
24:32 - encountered it and we last encountered
24:34 - it at the index one and one is within
24:37 - our current substring also so that means
24:40 - okay our current substring has repeating
24:42 - characters and so what we want to do is
24:44 - move again our left pointer to one past
24:48 - where we last found that character so
24:51 - our left pointer will move over here and
24:54 - then again same as before we still have
24:55 - to update our map to show that the last
24:57 - time we encountered B was at index four
25:00 - now in the next iteration of our loop
25:02 - we're looking at the letter c c does
25:05 - already exist in our map and it's in
25:06 - index of 2 is within our current
25:08 - substring so we want to move our left
25:11 - pointer to one past that to make sure
25:13 - there's not a duplicate and update our
25:15 - map to show that the last time we
25:17 - encountered a c was at index 5. and then
25:20 - we'll iterate through our loop again to
25:22 - uh for our right pointer to point to the
25:24 - letter D does d exist anywhere in our
25:26 - map no it does not so we know that our
25:29 - the current substring that's contained
25:30 - within our left and right pointers does
25:32 - not have any repeating characters and it
25:34 - has a length of four which is bigger
25:36 - than our current Max so we can update
25:38 - our Max to be four and it will go ahead
25:40 - and add that D to its map also it'll say
25:43 - okay the last time we encountered a d
25:45 - was at index six but at that point the
25:48 - right pointer has reached the end of our
25:51 - string and so our Loop finishes and our
25:53 - program finishes and we get the solution
25:55 - that the maximum was for one thing to
25:58 - notice about this particular solution is
26:00 - that it as it's going through the string
26:02 - there's always a particular section a
26:04 - particular window that we care about at
26:07 - any given time and it kind of slides
26:10 - right and grows and shrinks as it
26:12 - processes the string and there's
26:14 - actually a name for that kind of
26:15 - algorithm called a sliding window
26:17 - algorithm that's why if you're looking
26:19 - up solutions for this problem you'll see
26:21 - a lot of things about a sliding window
26:23 - algorithm and also notice that even
26:25 - though we do have two pointers we only
26:27 - have one Loop through the string and
26:30 - that makes this algorithm a linear time
26:33 - algorithm or a big O of N and also since
26:36 - we'll be using a hash map to do the
26:39 - lookups for the last time we encountered
26:41 - each character those lookups will
26:43 - actually be in constant time so they
26:45 - won't affect the linear time complexity
26:48 - of our algorithm so now let's go ahead
26:51 - and implement this sliding window
26:53 - hashmap algorithm and see how much
26:56 - faster it is all right so we're going to
26:58 - get rid of a lot of this but we are
27:00 - going to keep our max length variable
27:02 - declaration and our outer loop we still
27:05 - need that but we are are going to change
27:07 - a couple of things about this Loop to
27:10 - make our code a little bit easier to
27:11 - read with how our algorithm will now
27:13 - work so instead of just calling this
27:15 - variable I let's call it right because
27:19 - it's going to represent the right
27:22 - pointer in our algorithm so we'll change
27:25 - I to right in each of those places and
27:29 - also if we want we can go ahead and
27:31 - declare our left pointer here also and
27:34 - have it start at index 0. but remember
27:37 - we'll only be changing our left pointer
27:39 - if we find repeats while we're
27:41 - processing substring we only want to
27:43 - increment the right pointer in every
27:46 - iteration of our Loop now remember as a
27:49 - part of the solution we need to have a
27:51 - map that will hold the last position
27:53 - that we saw each character so let's
27:55 - create a map and remember this is going
27:57 - to be a map where the keys are
28:00 - characters and the values are integers
28:04 - we'll call it I don't know visiting did
28:07 - characters that's not my favorite name
28:09 - for a variable that I've ever come up
28:11 - with but let me know if you have a
28:12 - better one in the comments we're going
28:14 - to initialize that to a new hash map so
28:17 - now inside our for Loop where We're
28:19 - looping that right pointer through the
28:22 - string we want to check whether the
28:25 - character at that right pointer is
28:27 - already in our map so we can do that
28:29 - with if visited characters dot contains
28:32 - key and then passing in the character
28:35 - that's found at our right pointer so
28:37 - that's just s dot Char at right one
28:41 - thing to remember though is that even if
28:43 - we find the character that we're looking
28:45 - at is already in our map it doesn't
28:48 - necessarily mean that that character is
28:49 - within the current substring that we're
28:52 - looking at so once we find it in the map
28:54 - we still have to check whether the index
28:57 - that we found it in the map is actually
29:00 - a part of our current substring but
29:02 - luckily that's not too complicated to
29:04 - add so we just want to add another
29:06 - condition to to our if so yes we've
29:08 - already found that it's in the map but
29:10 - we also want to get the index where we
29:13 - last encountered that character so we'll
29:16 - get s dot Char at right and we can know
29:20 - if it's a part of our current substring
29:23 - if the last place that we found it is
29:25 - greater than or equal to our left
29:29 - pointer and if this whole condition is
29:31 - met if the result of this whole thing is
29:34 - true that means yes we saw this
29:36 - character before and it's within our
29:39 - current substring so our current
29:41 - substring has a repeated character and
29:43 - remember if that's the case then we need
29:45 - to move our left pointer to be one past
29:48 - where that repeated character is we can
29:50 - do that just by setting our left pointer
29:52 - to be the position where we last
29:55 - encountered that character so visited
29:58 - characters dot get s dot Char at right
30:02 - and we want it to be one more than that
30:04 - so we get just past that repeated
30:07 - character so we just add one now one
30:09 - thing I'm noticing as I'm writing this
30:11 - algorithm is that I'm using this s dot
30:14 - Char at right three times and it's kind
30:17 - of starting to look a little verbose so
30:19 - I think what I might do is create a
30:21 - variable for this so I'll go ahead and
30:24 - create a Char variable we'll just call
30:26 - it current character and we'll set it
30:28 - equal to that s dot Char at right and
30:32 - then we'll go ahead and replace
30:33 - everywhere we're making that call
30:35 - with that variable there we go so now
30:40 - it's a little bit easier to read and
30:41 - also might perform just a little bit
30:43 - better because it doesn't have to do
30:45 - this lookup three different times so at
30:47 - this point in the algorithm we know that
30:49 - either the substring that we're looking
30:51 - at either didn't contain any repeat
30:53 - characters so it didn't have to adjust
30:54 - the left pointer or if it did contain
30:57 - repeat characters it did adjust the left
30:59 - pointer so that it no longer has any
31:01 - repeated characters so now what we can
31:03 - do is update our max length and we can
31:06 - do that in the good old fancy way again
31:08 - by using a math dot Max and we'll take
31:12 - the maximum of either the current max
31:14 - length or the length of our current
31:16 - substring and we can get the length of
31:19 - the current substring that we're looking
31:20 - at by using our left and right pointers
31:24 - so what we can do is take right minus
31:27 - left and then add 1 to get the current
31:31 - length of our substring adding one might
31:33 - seem a little bit weird but it makes
31:35 - sense if you think about it because
31:36 - let's say right and left were both
31:38 - pointing to the same index they were
31:40 - both pointing to an index of zero the
31:42 - very first character well that of course
31:44 - has a length of one but if you took 0
31:46 - minus zero you'd have zero and that's
31:49 - not correct so you have to add one to
31:51 - right minus left in order to get the
31:54 - correct length of the substring that
31:55 - you're looking at now the only other
31:57 - thing that we have to do is we don't
31:59 - currently have anything that's actually
32:01 - putting the characters that we encounter
32:04 - onto the map we still have to do that so
32:06 - after all this processing we want to put
32:08 - on the map okay here's the last place
32:10 - that I saw this current character so
32:13 - we'll just call visited characters dot
32:15 - put to put a thing on the map and the
32:17 - key that we're putting on the map is
32:19 - going to be the current character and
32:21 - then the value is going to be the
32:22 - position where we're encountering that
32:24 - current character and that's just the
32:27 - right pointer okay so after our for Loop
32:30 - exits we'll just return the max length
32:32 - that doesn't change from our last
32:33 - algorithm I think that should be it so
32:35 - let's go ahead and copy this over paste
32:38 - it into lead code and we'll see if this
32:41 - is any faster so here we go
32:44 - okay so uh we have 12 milliseconds so we
32:48 - went down from what was it 400 something
32:50 - milliseconds down to 12. that is a
32:53 - dramatic difference it's a huge
32:55 - difference and that's probably largely
32:57 - because the complexity of our algorithm
32:59 - went from quadratic to linear and we
33:02 - also use quite a bit less memory maybe
33:04 - less than half of the memory that we
33:06 - were using before however you might
33:08 - notice that it looks like there's still
33:10 - some room for improvement of our
33:12 - algorithm of course we're way faster
33:14 - than what we were before but we're only
33:16 - faster than about two-thirds of other
33:18 - entries there are still plenty of
33:19 - entries that are faster than this one so
33:22 - that was kind of bothering me that you
33:23 - know a third of solutions were faster
33:25 - than this one so I was looking up other
33:26 - potential Solutions and one that I found
33:29 - that did end up being faster than this
33:31 - really caught my eye and I wanted to
33:33 - share it now remember back in our code
33:35 - we're using uh this map of visited
33:39 - characters to look up when we last
33:41 - encountered a certain character now this
33:43 - other solution that ends up being faster
33:45 - is structured in a very similar way
33:47 - except it doesn't use a map at all and
33:50 - so of course without that map all this
33:51 - other code that uses that map doesn't
33:54 - really apply anymore but then of course
33:55 - you might ask okay well how are they
33:57 - doing that look up to see when we last
34:01 - encountered the the current character
34:03 - that we're looking at and actually it's
34:04 - done in a very simple way let's just
34:07 - call it this is an awful name but
34:09 - location of first appearance in
34:13 - substring so all they're doing with this
34:15 - is looking for the index of that current
34:18 - character that the right pointer is
34:20 - looking at so s dot Char at right but
34:24 - they're not searching through the entire
34:26 - string to see where that character first
34:28 - appeared they have it start at the left
34:31 - pointer and that makes sense right you
34:33 - only need to know if that character
34:35 - already existed just in your current
34:39 - substring not in the entire string and I
34:41 - guess a better name for this might be
34:42 - just index of first appearance in
34:45 - substring okay so now we know where this
34:48 - particular character that we're now
34:49 - looking at first appears in the
34:52 - substring that we're looking at and so
34:53 - all we have to do is say Okay if that
34:56 - index where that character is is
34:59 - different from the right pointer it
35:03 - exists somewhere already in the
35:04 - substring because of course it exists
35:06 - where the right pointer is pointing at
35:08 - right now but if it appears any other
35:11 - time then that means we now have a
35:13 - repeated character and so if we do have
35:15 - a repeated character we essentially do
35:17 - what we did in our other algorithm which
35:19 - is just move the left pointer to be one
35:23 - past where that repeat character was
35:26 - found so we'll set left to be the index
35:28 - of the first appearance and the
35:30 - substring plus one and other than that
35:33 - the algorithm is all the same we still
35:35 - set the max length the same way as we
35:37 - did before and return it at the end of
35:39 - the algorithm and that's it but let's go
35:42 - ahead and copy this and put put it into
35:45 - leap code and see what our performance
35:48 - is like here we go
35:50 - five milliseconds and that's better than
35:51 - almost 95 percent of all Java
35:55 - submissions so it's just about twice as
35:58 - fast as the other solution and of course
36:00 - if you submit this a few times you do
36:03 - get a little a little bit of variability
36:05 - in the amount of time that it takes so
36:06 - at that time it took four milliseconds
36:08 - better than
36:10 - 97.75 percent of all Java submissions
36:13 - um so that's really interesting it was
36:15 - it was faster than our map based
36:18 - solution so that really got me wondering
36:20 - why that might be and I'm interested
36:23 - um what you all think in the comments of
36:26 - why this particular solution is faster
36:29 - than the map based one the reason I
36:31 - think that's interesting is because our
36:33 - map should give us a constant time look
36:36 - up to see where that character last
36:38 - appeared in our substring but the way
36:40 - that they have it doing the lookup here
36:43 - in this solution is it has to use an
36:47 - index of and I believe index of just has
36:50 - to Loop through each individual
36:53 - character in the particular substring
36:55 - that it's told to look at to see if that
36:56 - character exists anywhere in there so I
36:58 - would think at a glance that that should
37:01 - give you a worse time complexity than
37:04 - the map solution but it performs much
37:07 - faster two three times faster than the
37:10 - map solution the only thing that I could
37:12 - think of is that even though the time
37:14 - complexity might not be as good
37:16 - technically as the map solution perhaps
37:19 - given the particular strings that leap
37:21 - code uses to test the algorithms it
37:24 - could be that just index of performs way
37:27 - better than Maps do for just for that
37:30 - particular input even though the time
37:31 - complexity isn't as good there are
37:33 - definitely situations and some
37:35 - algorithms where certain inputs could
37:38 - perform better on algorithms that
37:41 - technically have worse time complexity
37:43 - so this could definitely be one of those
37:45 - situations so even though I didn't come
37:47 - up with this particular solution I
37:49 - wanted to share it because I thought it
37:51 - was so interesting so as always let me
37:54 - know what you think if you like this
37:55 - video learn something want to see more
37:57 - things like this let me know and give
37:58 - the video a thumbs up and of course if
38:00 - you're interested go check out my full
38:02 - Java course which you can find in the
38:04 - link down in the description it's a
38:05 - great way that you can support the
38:07 - channel and get a ton of value and Java
38:10 - knowledge in return so thank you all so
38:12 - much as always for watching and I'll see
38:14 - you next time