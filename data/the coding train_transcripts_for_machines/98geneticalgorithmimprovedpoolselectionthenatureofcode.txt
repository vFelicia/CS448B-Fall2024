hello I'm back for another genetic algorithms video although this video actually that you're watching right now is not just a video about something you could do for genetic algorithms this video is ultimately about picking from a list of things randomly but picking some things more often than other things and this is a thing that you do have to do oh where's my Eraser over here I'm coming I'm coming this is a thing that you have to do um in in genetic algorithm because we want to we want to have a population of elements and we want to pick certain members of that population that have scored a higher Fitness score to uh have their genetic information more likely passed down to the Next Generation but let's let's let's let's erase our minds of the Wonder that is genetic algorithms and just start with a very simple scenario I'm going to create a JavaScript object um and this this marker has a very interesting smell uh and it's going to have uh things in it like uh mango five uh blueberry three uh Cherry uh one and apple one so what I want to be able to do is I want to be able to pick one I want to pick a fruit fruit randomly I want a function that says pick fruit and I call that function I'm going to get out of it returned a particular fruit maybe mango maybe blueberry maybe Cherry maybe apple and I am going to get mango five times as often as I'm going to get apple I'm going to get mango and I wrote These numbers very specifically to add up to 10 because it's very easy for me to just sort of do the math here but I'm going to get mang I want to get mango 50% of the time blueberry 30% of the time Cherry 10% of the time and apple 10% of the time this relates to so many different kinds of scenarios that you might do in computer programming if that makes sense okay so how do we do this now you've if you've been watching some of my other genetic algorithm videos or other videos I've done this a number of different ways one way that I've done this is I've built a separate array and i' what I've done with that array is I've put I just said hey let's put mango in it five times I'm just going to write m mang goes in this array five times and then I'm going to put blueberry in this array three times and then I'm going to put a cherry in at once and apple in it once so if I had a bucket full of all these letters and there's five M's in it three b's one c one a and I shuffle it around and pick one out randomly I'm going to pick M more five times as often as I'm going to pick a so um that's one way of doing it now there's a bit of an issue with this way of doing it this works really nicely for this but if I I have thousands of elements and thousands of different Pro and like a vast array of probabilities some of which are very very very very small probabilities I did have to build this array that just has so much stuff in it it's not a really efficient performance good performance solution and that's actually if you look at a lot of my examples that's the solution I'm using doesn't work so great so I'm going to propose I'm GNA I'm not proposing this I didn't invent this I'm just talking about it I'm going to look at another solution now there is another solution to this problem which is a Mech a way that you could sort of pick random numbers twice so what two random numbers so each one of these zero one 2 3 so on the one hand I'm just picking a random number 0 1 2 or three and I could do that easily by saying it depends you know in JavaScript or in processing actually floor um uh random four and this will give me zero one two or three so this is one way that I could do this but if I do that I'm just going to get each one of 25% of the time but if in addition to picking one of these randomly I picked another random number just between zero and one so this is the fruit that I'm picking and then this is kind of my like test number if I pick another random number that random number has to be less than the probability in order for me to for this first random thing to qualify so I might have to do this a bunch of times like I might pick three than 7 and then 2 and4 and then 1 in8 and then 0 and 6 and then 3 and 01 or you know ah Apple qualifies so you can see mango is going to be able to qualify if I pick zero 50% of the time this second random number is going to be fine but if I pick Apple only 10% of the time is this second random number going to be fine so that's one way the problem with this way is I you know again with a lot of elements and a lot of probabilities I can be stuck doing this over I can you know that Loop can take many many many many times before it finds a qualifying random number so this video I'm going to program an entirely different algorithm uh it was suggested to use this algorithm in a GitHub issue I will uh link to that GitHub issue in this video's description which is hello description down there I'm get trying to get used to where things are over there is some no maybe over there is like an ad I don't know what you don't if I don't know if don't click on it maybe click on it I don't know now now I'm all stressed out okay uh never mind all that there's stuff around me I'm a person in a YouTube video but um there was a point to all this wasn't there ah okay so uh I will also in a moment bring up that GitHub issue to look at it um on the on the computer because I do have a computer over there which I will get to eventually okay so what is this other algorithm well one way you could imagine is let's say I created I don't know what this is a tube a pipe a rectangle some sort of twodimensional space and I said ah 50% of that space is Mango's space and 30% of that space is blueberry's space and uh 10% of that space is Cherry and 10% of that space is Apple and this down here is zero and up here is one so what if I just pick a random number now between zero and one and it's almost like throwing a dart I could be over here and I'm going to throw a dart let's do it ready one two 3 I missed but actually it landed over here blueberry I'm going to be more likely there's more space for me to hit with mango than there is for blueberry than there is for cherry and apple now I don't I'm not going to build some whole entire like dart throwing simulation thing in my sketch so I need a mechanism to do this to pick the random number and figure out where I am and actually a way that I could the way that this could work is I can actually start up here uh you can pick a random number and then start subtracting values and find out at what point do I sort of exit this space so hopefully I'm going to program that algorithm we'll look at it hopefully it'll work and we'll come back here and sort of see if this makes more sense to us then okay um I'm going over there now okay here I am back in this uh VI this screen with my computer um so this is the GitHub issue that I was referencing there's a link to it in the video's description uh spectron thank you for this original suggestion and then also uh Sinclair z81 this is from a while ago it took me a while to get to this um uh has a very like fancy crazy oh look at this unicorn uh uh implementation of it that uses like es6 and all sorts of cool interesting JavaScript syntax that I don't fully understand uh oh but I will understand someday okay so um I'm gonna do my own so let me close those and let's let's write some code okay so first of all let's quickly I should have done this in advance okay uh there's a little pause there where I decided actually what I want to do is write the information I want to pick one of the I it's easier for me to put it in an array because what I want to do is pick one of these elements from the array and then I want the probability of how I pick it to be something relative to its score so the first thing that I need to do by the way is I need to normalize all of these scores to values between zero and one and so that they all add up to one I want them to be a percentage and um so the first thing that I'm going to do is I'm going to just Loop through every single fruit and what I need to do is I need to add up all the scores I need to find out what do they all add up to sum equals zero and I'm going to say sum plus equal um fruits index i. score then the next thing I'm going to do now here's the thing I might want to retain that score value or I might I be could just overwrite it but ultimately what I want to do I'm going to say fruits indexi doore equals fruits index I and I know I could say divide equals but I'm just going to write this all the way out fruits index i. score divided by Sum so the idea is I want to normalize all of those scores so all I need to do is add up the total and divide each one by the total that's exactly what I would have done here I get 10 five divided by 10 is 50% 3 divid by 30% you know and the math is never going to work out this perfectly but who cares because the computer's doing it not us okay so um what I'm going to do here is I am going to go back to the browser and I'm going to refresh you know this canvas is here for no reason um I'm just and I'm going to look at fruits and we can see here that now the scores are normalized 0.5.3 and I could if I want to it might make sense to say actually I'm going to add a new property to each one of these objects I'm going to say like Norm score for like or I'm just call it probability for probability fruits index i. probability so now I'm going to hit refresh I'm going to look at that fruits array and I'm going to see here now it retained the score and has a probability of 05 and as you can see if I were to go here and add you know one other fruit like uh melon and give it a score of you know 7.7 then then if I hit refresh and look at fruits you can see now I've got five and it's worked it out like it's the math isn't so clean because it doesn't add up to 10 but mango now has a 29% chance of being picked and melon has a 41% chance of being picked so this is good so now how do I pick one of these randomly according to its probability this now now it's time for me to write an algorithm that implements this particular write some code that implements this particular idea this I algorithm throw a d Dart and find a place in here so the way that I'm going to do that is first I'm going to write a function I'm going to call it uh pick one and it's going to receive a list so I'm going to have a generic function that could work with any list of things now it's going to be set up to work in such a way that the list of things is made up of objects that have a property called prob for probability but you know obviously I could make this more generic in other ways as well okay so the first thing that I'm actually going to do is I'm going to say VAR index equals z so I'm going to sort of assume that the one that I'm going to pick is the first one then I'm going to pick a random number between zero and 1.0 and I'm going to say as long as R is less is greater than zero then I'm going to say R equals R minus that particular object's probability so let's think about this for a second what I'm saying is that let's say I have something with a probability of N and I have something with a probability of 0.1 okay I shouldn't draw this right time out I shouldn't draw it right next to this because I'm going to do something different now so I'm going to use where is I don't have any space I'm going to come over here this is fine let's just say a simplified Arrangement where this is my like bar here and I have something that has a as a probability of 0.9 and B as a probability of 0.1 the first thing that I did is I picked a random number somewhere between zero and one and then I'm going to subtract 09 from it because 0 n is first how often am I going to pick a number between zero and one where I subtract 0.9 and now I have a value less than zero 90% of the time right only if I pick a number greater than 0.9 if I pick 095 and I subtract 0. n I'm going to have a value of 0.5 so 90% of the time I'm when I subtract this I'm going to be less than zero when I'm when I'm out when I'm done when I'm out I'm out you're out when I'm below zero that's the thing I'm left with 10% of the time I'll pick that number like .95 and then I go and subtract 0.1 and I'm out so 10% of the time I'll be left the last place I was I'm starting up here I pick some random number somewhere I subtract this am I already below zero or or should I keep going if I'm subtract this then I'm that less so this idea of just I keep subtracting these values and it doesn't matter what order right even if this was B was first and I'm always subtracting 0.1 first I'm only going to be less than zero if I happen to pick a random number that's less than 0.1 so hopefully this kind of makes some intuitive sense to you I feel like there's a very smart way to diagram this that I'm not doing but I've said it enough times I'm hoping it makes sense let's come back to the code so what do I need to do let's say so if so what I need to do now is say index Plus+ so I'm going to just keep doing this I want to go through the list until I have now gone below zero now there's a little bit and then I want to say return list index except for the fact that this isn't exactly right this isn't exactly right because um I like how this bracket is highlighted down here but anyway forget about that um this isn't exactly right because um I actually want to I want if if I say index Plus+ I'm going to go one past um the one that was actually the one that I wanted to pick if that makes any sense so I've got to very quickly just say index minus minus let me talk you through that right in the scenario where I just have 0.9 is the probability the first of index zero is 09 so I pick a random number I pick 08 I say r equal 8 minus .9 so that's negative .1 then I say index plus plus so I go to one and I go back to loop I don't loop again because I'm now below zero so I didn't I don't want to pick one I want to pick zero so going up is just if I'm continuing but if I'm not continuing I've got to back up one so this should work I hope um and so I'm going to hit refresh here and I'm going to say pick one fruits and I got mango and I got mango and I got melon and I got Cherry like cherry and I got melon I'm G to get melon most of the time right and so what I could do right now just to sort of verify that this is working I am going to say I'm going to write a little Loop here for VAR J equals z I don't know I I can use I again uh I equal 0 I is less than 100 i++ and I'm going to say VAR fruit equals pick one fruits and I'm going to say I'm going to do VAR melon count and if fruit uh fruit do what was it name fruit. name equals melon melon count actually you know what I'm just going to do that's fine I I something I could do is I could actually just create a count fruit. count Plus+ so I'm going to give all these um while I'm over here I'm also going to say fruits index I'm going to give them all a count of zero so I'm going to count how many times they've picked and if this is correct doing it 100 is a small sample size we should see that they're picked proportionally to their probability so let's take a look at that let's run it and let's look at fruit so fruits the first one is mango which was picked 30 times at a probability of 29 that makes sense blueberry was picked 10 times you know it probability was 17 Cherry was picked seven its probability was 5% uh melons picked 47 so this is this to me is working uh obviously with just picking it a 100 times it's not going to map so perfectly you know I would suspect if I made this 100,000 then those probabilities are going to over time going to even out and be the counts are going to be much closer to the probabilities okay so hopefully you have enjoyed this particular video which is just about how to pick elements from an array with different probabilities uh and this might uh work in a and oh what the nice thing about this particular algorithm is two things one is I didn't have to create a separate array with lots of duplicate versions of all these objects in it and I didn't have to do this thing where I have to pick random numbers multiple times and hope that one qualifies and it could get stuck in an infinite Loop this is going to happen every single time this is going to always uh pick and return a value you know sometimes it's going to have to run through this Loop a few times sometimes just once but it's going to this is this is a pretty efficient and fast algorithm for doing this okay so what did I miss what questions do you have did you apply this in something uh I'm going to apply this in something in just a moment so if if you look at this video's description there's a link to a video where I uh program a solution to the traveling salesperson problem solution is a little bit strong I don't know if it's really going to be a solution an attempt at a solution to the traveling salesperson problem uh in uh JavaScript with a genetic algorithm so thanks for watching I will see you in another video goodbye