[MUSIC PLAYING] I'm sorry. Am I still recording a video here? [AUDIO LOGO] A coding challenge idea that has been suggested to me many times is a falling sand simulation. And today is the day that I'm going to tackle it. Now, I have to confess, this is not the first time that I've tried to make a falling sand simulation. If you're familiar with the initiative called Genuary, which is a month of generative art in January, it's probably happening right now because I think it's January 2024. In 2022, I made a falling sand simulation for Genuary. I have no recollection of how I did it. But hopefully, there's some muscle memory or deep within the recesses of my brain that will help me through today. A really excellent, wonderful reference if you're like, what are you even talking about, is the game Noita. It's built on top of the Falling Everything Engine, which is this incredible game engine, where every single pixel is simulated. I'd also love to highlight Max Bittker's Sandspiel. It might not be how it's pronounced. But I choose to pronounce it Sandspiel, where you could just create this world of sand and water and fire and smoke and fungus all out of pixels. My previous coding challenge, if you happened to watch it, was about cellular automata. And in fact, this falling sand simulation, this idea of any pixel having a state is it sand? Is it water? Is it fire? And changing its state based on what its neighbors are doing, I believe this can be done with CAlike rules. Now, maybe you want to keep watching this video. But I do want to just mention that there is this wonderful tutorial online by Jason, at jason.today, about making a falling sand simulator with p5.js. So we'll see. We'll compare and contrast. Maybe at the end, we'll see. How does my version work? How does Jason's version work? But you could also go check that out. Make your own version. Submit it to the Passenger Showcase. And we'll see what kinds of amazing projects this community can make out of falling sand simulated. Let's first establish the world that I intend to create. So the Wolfram elementary CA was a onedimensional CA where every cell had a state of a 0 or a 1. Coding Challenge 105, I think, was the Game of Life, which is a twodimensional CA, meaning the grid lives in two dimensions. And every cell has a state of 0 or 1. For the falling sand simulation, a twodimensional grid makes more sense. Let's say this is my p5.js canvas, and I decide that I'm going to place a grain of sand on the canvas. That means maybe this particular cell's state is 1. And all the other states are 0. I want the sand to fall, meaning the rule will be if there is a cell with a state of 1 that has a cell with a state of 0 below it, then that piece of sand will move from its current location to the location below. If it so happens that there is already a cell with a state of 1 below it, then it can't move. It stops. That way, the sand will pile up. Let's begin by implementing only that. To make my life a little easier, I'm going to grab this make2DArray function from the Game of Life coding challenge. Then let's call the space that I'm going to create a grid. And let's establish the resolution of every grain of sand. Now, at some point, it might be fun to try having a grain of sand be a single pixel. But for now, let's have a 10 by 10 rectangle. So I need to establish the number of columns and rows. The number of columns is the width of the canvas divided by the width of one of those little squares so in this case, 40 divided by 10 400 divided by 10 would be 40. So I'm going to have a 40 by 40 grid. So that's what I need to size my twodimensional array as. So I'm using a nested loop to set every position, every column i, every row j, to 0. I can then use that same nested loop to draw every square. Maybe if it's 0, it's black. If it's 1, it's white. And just so we can see it, let me give it a stroke of 255. Oh, and the x position would be the column times the width of that square. There we go a grid of black squares. That's exactly what I expected to see. What happens now if I set one particular cell on this grid to have a state of 1? Look at that. Column 20, row 10 is now white. I am ready to implement this logic. I need to run a loop over every single one of these cells and look for any 1's, then check what is the surroundings of that particular 1. Now, while I'm doing this analysis, I cannot change the values in the original grid. So I need another twodimensional grid that can act as the next grid, the next generation, the next frame of animation of this falling sand simulation. Let's get the state of the current cell we're looking at. If the state is 1, I need to look below and see what is there. This is not cols, rows. This is i, j, the state of the current cell that I'm on. And the cell below is j plus 1. If the state below has a value of 0, then the cell i, j should now have a state of 0 in the next generation. And below should have a state of 1. And now the current grid is the next grid. I've missed some steps here, but let's see what we how far we get. OK, so everything went white. So why? Well, one issue is when I make this new 2D array, it doesn't have any values in it. And I'm only assigning the value 0 or 1 if and when I find a 1 in the previous grid. I need to set all the values of the next grid. However, if I'm checking all the cells and I get to here and I say, like, oh, in the next generation, this one should be a 0 and this one should be a 1, I'm going to keep checking. And eventually, I'm going to get to here and find that it was a 0 and probably say it should stay a 0. So what I think would work I'm not 100% sure about this is if I just start in with the new grid, the next generation having all 0's in it, and I'm just setting the values of 1 based on where the 1's are in the previous generation. A way I can address this is by having the make2DArray function just fill everything with 0's. That way, I'm only moving the 1's around. And the 0's are going to be there by default. I should mention that the way that I'm doing this, where the first index grid, i, is the column and the second index, j, is the row is be a little backwards, depending on your point of view and your experience. If you're used to matrix math, a 2D array, you'd often be saying row, column, instead of column, row. But this is just the way I did it in the Game of Life. And as long as I'm being consistent, it will work. And it's fine. It's fine, it's fine. So now what I'm going to do is add another little j in here. Oh, look at that. It works now. Amazing. It disappeared when it hit the bottom. So I need to account for the edge. If below equals 0 or if j plus 1 is greater than the number of rows. If j plus 1 is greater than the number of rows minus 1. Oh. No, less than. If below is 0 and j is not the bottom row. [BUZZER] I have an OR there, and I said AND. If below is less why am I getting this wrong so many times? Oh! Otherwise, it needs to stay as 1. I might have had it right all those times. Otherwise, nextGrid i, j should stay as 1. And in fact, if everything is going to be set initially to 0, I don't have to explicitly set it to 0. So I'm basically deciding if I should move it down or leave it where it is. Let's add some mouse interaction. When I click the mouse, I'll add a grain of sand. So if I take the mouse position divided by the size of each cell, the width of each cell every cell is a square that should give me the column and row index into my grid. Look, I'm piling up sand. Let's change this to mouseDragged. All right, we're cooking. However, I want to add some more sophistication here. What if I have a grain of sand and below it is a 1 so it can't move down? However, there is a space open to the left or the right. It could move to one of those empty spots. The sand would be falling down to the right and left building up a little hill. So let's look at below right and below left. Now, I should say, do I even need this? Because wouldn't it be undefined otherwise? Yeah, it works. I don't even need that. Some better error checking. Yes, good. But why not? Otherwise, I could check if below right is 0. And then if that's the case, nextGrid i plus 1, j equals 1, else if below left equals 0, i minus 1. Oh, boy. OK, all right. I did forget. It's kind of scooting across there. I do need to ignore the bottom row. So I only want to check if j equals rows minus 1, keep it the same. This if statement has gotten really out of control. I will refactor this later. [MUSIC PLAYING] I will refactor. So if it hits the bottom, don't do anything. Oh, it's going to keep going. Wait. Oh, I have to go down one. Oh, I'm only going to the right. I also have to go down one. Well, of course. So I actually don't have this problem. Welcome to a coding challenge where I didn't plan this in advance. OK, let's come back to this. OK, this is better. OK, there we go. Look at my falling sand simulation. Now, we do have a little bit of a problem. Notice how it's always going to go to the right first. What would be a nice way of having that be random? I'm going to call it belowA and belowB plus dir, minus dir. dir is either negative 1 or positive 1. How do I figure out that? Well, dir is 1. If random of 1 is less than 0.5, then multiply dir times negative 1. Oh, I can't wait to hear your better way of doing that in the comments. So A is going to be plus or minus. B is going to be the opposite of that. And then if belowA is 0, we're saying plus dir. And if belowB is 0, we're saying minus dir. So now it should randomly go left or right. Oh, oh! Now I need to handle the left and right edges. How do I do that? Oh, whoops! Ah! I forgot the plus 1 here. I need the plus 1 here also. OK, this looks more like falling sand now. It's not jump bouncing off like it was before. But why do I get an error here? I'm accessing a nested array. So it's fine if this is undefined. If the first part is undefined, I can't get the second part. That will throw an error. Well, I think I could just check to see if I'm on an edge. Let's just do that. All right, I'm going to say let belowA and belowB. Let's let them be undefined. I just need to check the left and the right. And I only need to check i. OK, only if i is greater than 0 and i is less than columns minus 1, then try to actually get a real value. I still got an error. As long as i plus dir is greater than or equal to 0 and i plus dir is less than or equal to the number of columns minus 1, then I can do belowA. This is me doublechecking that that's a valid spot. Oh! It's just because my mouse went off the screen. This is correct now, as clunky and terrible as it is. But my mouse is going off the screen. OK, let's take out this initial grain of sand. Let's review. I want to add grains of sand but only if my mouse is within the canvas. Then I want the grains of sand to move down or to the left or right if down is filled but not if it's on the bottom edge or the left or right edge. It can't leave the canvas. Let's improve a few things about this. One is we can make it more efficient because I don't need to draw all of the black squares. Now this is much faster because I'm only drawing the white squares. I'm skipping drawing and just filling the background with black. Let's give ourselves a bit more space. And instead of dropping just a single grain of sand, what if I drop a small collection of sand particles around the area where the mouse is? So I have the column and row. And we could make a little matrix. How about 5 by 5? So I could write another little loop where I want to go from negative 2 to 2. That would be 5 by 5. So I have to say, the extent I don't know if that's a good word to use would be divide the matrix by 2. So I'm going to go from i is negative extent. i is less than or equal to positive extent, i++. j, j, j. And I'm going to call this the mouse column and the mouse row because the actual column now is the mouse column plus i. And the actual row is the mouse row plus j. And then here, I can take this and put this in here. So as long as this 5 by 5 area, any one of those cells is within the canvas, I should be dropping sand. And you can see I'm dropping a much larger amount of sand now. Nice little stripes striping effect. Now, here's the thing. I don't actually want to do 5 by 5. First of all, that was much bigger than I thought. So let's make this 3, for example. But also, maybe they shouldn't always all be dropping. So what if I were to actually introduce some randomness here. Only if random 1 maybe there's a 75% chance that I'm going to drop that little grain of sand there. Let's go back to 5. So it's a little more amorphous. OK, now we're dropping some sand. This is just lovely. How about adding some color? So one thing that I've done here is that everything is based off of the state being a 0 or a 1. But what if I think of the state as being 0 or anything that's not 0? As long as it's greater than 0, draw the what if I used its color? Oh, I have an idea. What if I have a hue value equal to 0. And let's say this is a little bit nuts colorMode, because I have to make everything a rainbow, clearly, HSB, 360 is the default, 255, 255. So this is hue, saturation, and brightness. So what I'm going to do is I'm going to set the grid to a hue value. Then I'm going to fill it with that hue value and a full brightness and saturation. As long as the state is greater than 0, everything else should be the same. Equals not 1 but the current state. So I'm passing the color around. Let's see what happens. [BUZZER] I don't see anything. Oh, the hue value is 0. I forgot I can't use a hue value of 0. Oh, my goodness. Let's give it a hue value of 200. There, OK, it's blue. The reason why I was doing this is I was thinking, what if the hue changed over time? So hueValue plus equals 0.1 as I'm dragging the mouse. OK, I guess I should have it change a little faster. Ooh, I love this. OK, well, it's going to stop at 360. So if hueValue is greater than 360, set it back equal to 1. [MUSIC PLAYING] Coding challenge complete. However, I don't know if I can release this code without fixing it up just a little bit. Let's write a function to help with this logic down here, a function that returns true or false if a column is within the bounds or not. What should I call this? withinColumns i. return i is greater than or equal to 0 and i is less than or equal to the columns minus 1. So now I can check here. withinCols, the column. And let's do one for rows. So that cleans up this code just a little bit. I can also now clean this code the state of the current cell. Ah, look at this. I have that variable, state. So I can use that here. This will make things a little bit nicer also. I'm checking a random direction. That's fine. I don't love just making them undefined. Let's start with them as negative 1. Then if it's within, then I'll give it the actual value. And then these won't trigger unless they're 0, which is not negative 1. I don't know if that's better. A little bit better. Maybe I'll put some comments in the code. That'll help a little bit. Just hold that thought for a second. [MUSIC PLAYING] I don't need this anymore. Do I dare try this now with the sand smaller? It's divided by half. So this is lovely. But it's missing a kind of critical thing. Notice how the sand is falling at a constant speed. It just so happens I've written this entire book called Nature of Code all about physics simulation. And chapter 2 is all about velocity and acceleration. And what is a force but a vector that causes an object with mass to accelerate? Is there a way that I could apply a gravitational acceleration to these little bits of sand as they fall? That would be a little tricky because the sand should be falling more than just one cell at a time. This is a challenge I'm going to leave to you. I'll address it maybe at a live stream and showcase any of you who submit your falling sand simulations to the Passenger Showcase. I also want to remind you to read jason.today. Well, that's not their last name. But that's their URL jason.today's blog post all about making a falling sand simulator. And you can see here that there is a Grid class, ooh, with a higher order function like fill and this swapping function that allows you to swap two particles. Oh, and they're just using a onedimensional array. You might like this strategy. Oh, and you can see there's different colors. So there's some other things you could learn by following this post. But hopefully, you enjoyed this coding challenge. This was technically another cellular automata, though, in truth, it's a stochastic one because of the way that I'm randomly moving the sand left or right as it's falling. And I can't wait to see what you make. Have a great day. [TOOTING] [MUSIC PLAYING] [BLIPS AND BLEEPS]