hello welcome to a followup on my previous perceptron coding challenge so if you happen to watch the previous one and if you hadn't you probably should go back and watch it Link in the description I created a simple perceptron a perceptron is a model of a single neuron that receives inputs and then produces an output and this is a very simple scenario where the output is only trying to guess whether a point is on one side of the line or the other is it above the line or below this line so in this followup video what I would like to do is really just refine this example nothing really about the mechanics of the perceptron itself but make this example a bit more sophisticated and allow for some more cre hopefully some possibly some more creative uh possibilities so um first thing I I got a bunch of things I'm going to do I would list them all but I can't remember what they are so I'm just going to tell you what the first thing is the first thing is let me come over here to the Whiteboard um so what I did with the first perception was just used the raw pixel coordinates of the processing window I can't remember what size it was but you know it was like a 640 by 480 window and 0 0 is over here and you know this turned out to be the line and I was looking for points over here but the idea of using a neural network based system is typically to get some kind of data input that's not based on pixels so what I think that I want to do here is uh just redo this example and consider a cartisian plane with 0 0 in the center and Y pointing up so whereas this is zero and this is 480 down here you know 480 would be kind of up here so I would like to just redo this whole example and then the line y equal x we should see as appearing like this the reason why I want to do this is the next thing that I'm going to do is create a perceptron that will learn any uh division of data points so it doesn't just have to be a DAT a division that's slicing it right down the middle so first let's make that change okay so how do I make that change H well where do I make the points I think I had this I had this point object and the point object makes a random point a random point with a random x value and a random yvalue what I'm going to do and I think you know I'm going to just make these now random values between negative 1 and onega 1 and one okay so the random values are between negative 1 and one in in some ways that's it done aha but now right before I show them what I want to do is I'm going to say PX for like pixel X and I'm going to Map X which has a range between negative 1 and one to zero and width map is a builtin function in processing that takes a value with one range and Maps it to another it's very simple math and I actually have a whole other video which I will try to link to that goes over the map function and Y I can do the same exact thing so let's look at this ah except for with Y right what I want is why when the Y value is high I want it to be low in terms of you know when it's high I want it to be it's flipped right Z 0 instead of positive pointing down and points up so I want to reverse that mapping and the map function does that for you by saying hey when Y is negative 1 it should be at the bottom and when Y is one that's a nicer way to say it it should be at the top zero okay now what happens if I were just to run this uh kind of looks like a whole lot of nonsense right didn't seem to work well first of all I forgot I forgot a major thing I did the mapping but I'm still drawing the ellipse at those NE at those values I'm going to say PX py okay good look at this there are all the points and you can see how they're divided but the line is drawn in the wrong place so where do I draw that line so I'm just going to change the coordinates I'm going to hardcode new coordinates for the line we'll deal with that later but um so I'm going to say uh uh Z comma height to width comma zero and we should see there we go there are all the points now what's going on before I had this thing in it in this program where I would draw a red or green ellipse whether or not the perceptron had guessed correctly um and that's not working anymore because I am not doing the mapping anymore so I need to also just take the same exact math and probably I should package that into a function or make a part oh you know what I should do I should make aha the point object should just have a function that's called get uh get pixel X is a little bit of an awkward naming get pixel y let's just call it forget about pixel X and pixel y so I'm just going to calculate these on the fly whenever I need them and pixel X will do this return that mapping and pixel y will return that other mapping there we go and then I can just get those values here and get those values here here this should be the same but at least I took that mapping and put it into a separate function that way when I need it here I can say pt. pixel X and point. pixel y so rather than draw the ellipse at that points X and Y I can trigger those pixel X and pixel y functions oh I like that that was a nice little uh nice little addition I had there this is exactly the same program the only thing that's different is is uh the points now live in a sort of traditional cartisian plane and then I'm mapping those points on into the pixel space when I want to draw them great so that's step one of this followup video complete let's do step two so what is step two I want to change um what I want to change here is this if x is greater than y I want to be able to have let's come over here any particular uh function so I could say y = 3x + uh or you know plus two right that would mean if x is zero then if x is zero then Y is going to be at two if x is one y is going to be at five so you can see this is that particular line so I want to be able to train the perceptron to recognize this versus this and I want to be able to change this formula I can make it 2X 3.7 I want to be able to have any generic uh formula for a line work with this example so let's add that into the code so I think the easiest thing for me to do and I'm just going to put it in this tab is to write a function I'm going to call it it's going to return a float and I'm actually just going to call it f is that like a terrible thing to do F of X being the function for I maybe I'll call this like line whatever I'm going to call it f ofx and I'm going to say return what did I say 3 3 * x + 2 so this function basically represents the formula for the line and I'm going to say y = m MX plus b right that's the formula for a line we've seen this in other so funny how all these examples have this like twodimensional space with a line in it because this is the simplest way way to start working with data and visualizing that data but ultimately as I get further along in these machine learning examples we're going to have these you know end dimensional spaces that we can't even fathom or visualize okay okay so um now the one thing that's a little bit of an issue with this is my mapping is between negative 1 and one and negative 1 and one I want to make sure the line isn't kind of off and out of our view so what I'm actually going to do is I'm going to have this be Z 0.3 * x + 0. again I could have changed the mapping between 10 and 10 but I kind of like this idea of between 1 and 1 for whatever reason so I'm going to change it to that and now what I'm going to do I at least just want to draw that line so I'm actually not going to change any of the code in this example I'm just going to see can I draw that line so this is where I previously drew the line so what I want to do is I want to draw a line from NE from where I want to draw I want to get the Y value for when X is Z when X is Nega 1 and the Y value for when X is one and then I can draw a line between those two points so okay so I'm going to say 1 F so let's I'm just going to say x = 1 Y = F ofx this is X1 y1 and then the second point is uh X = positive1 and Y = F of X2 Y2 is f of X2 so I'm going to draw a line from X1 y1 to X2 Y2 and you know this is a perhaps a very long winded way of writing this but just to see what I'm using is that formula for a line to get the corresponding corresponding y to a certain X okay let me run this uh H what's wrong with this function oh whoops I have to say float X I I I lived in JavaScript land for a second I must set the type for that variable probably everybody in the chat was probably shouting at me about that okay where's the line I don't see it why don't I see that line ah guess what guess what I forgot I have to do that mapping H all right all right everybody settle down I'm going to do it I'm going to reuse I'm going to reuse that pixel y so I'm G to say Point P1 equals a new point which is at 1 F of1 I'm going to do I'm going to write this in a bit of a a crazy way P2 is a new Point ah new point between at one F of one okay and then I'm going to draw the line from P1 pixel X ah can I please type today um P1 pixel XP fast forward this part I'm typing here P1 pixel Y and then P2 pixel X P2 pixel y but look at this why am I getting an error here I want to make a point at a specific X and Y what do point do what does the point object do I can make a point at a random point but I can't seem to make one at a specific point well guess what guess what in Java processing is Java you can do something called overloading just so happens I'm going to cover overloading Constructor overloading in this case I can say I want to have another way of creating a point and I'm going to use the underscore kind of ugly underscore notation but what I want to do is pass have some arguments to the Constructor I don't want to call them X Y because the point objects variables are X and Y so I'll call them xcore and that's going to be a way that I can do this I could ALS also figure out the label but I'm not going to worry about the label in this case cuz I'm not using I'm not labeling these points I'm using them just to draw the line okay so now that went away and I should be able to there's that line so there's the line boy this was a lot of work just to draw that one line and you can see though I can change the formula for the line if I say you know minus .2 now the line is further down if I say Min .3 now the line is pointing the other direction so I can now create any formula for the line and visualize that in the window okay so now what's going on here this is now so now that I have this formula for the line I need to uh change this no longer do I want to check just is X greater than y how do I determine and I'm I'm looking for my Eraser how do I determine whether a given point is above or below a line so let's say I have this line and the line is y = 3x + 2 I know it should be all right let me try to be more accurate about this I'm going to point it up more and I have some point so let's say I have the uh um this is the cartisian plane here oh kind of drawing this as a mess okay so let's say I have the Point uh x uh X comma um X is uh three so if x is 3 then this point is 3 comma 11 right I think cuz 3 * 3 is 9 + 2 is 11 so if I had the point 312 it's above if the Y is greater than the Y that would be on the line and if I have the point like 3 comma 3 it's below if the Y is less than the Y that would be on the line so I can do that for any value of x so if I take any value of x all I need to do is calculate the point that's on the line and see whether it's greater than or less than so let's add that into the code so here what I want to do is I want to say l I'm going to say line Y equals F ofx right I'm going to calculate the actual y value for this particular X on the line then all I need to do is ask is the Y value above it then it's a one or is it below it then it's a negative one so hey that was easy that's done now and there we go so we should be able to see this perceptron over time learning to figure out whether points are above or below that line it's a little bit stuck right now you can see that it's and and this probably has to do with learning rate and you know how it's started how the initial weights were started but so I want to kind of figure out like why is it kind of stuck so why is this get one Reon here's the reason why this is getting stuck and I mentioned it in the previous coding Challenge and I completely forgot about it until now the bias so let's talk about why does there need to be a bias here's the thing let's consider the point 0 0 when I say well this is the point 0 0 y = 0 * x + 2 the corresponding y value is two so zero is below the line here's the thing with my perceptron as I send in the x value and the yv value if I send in Z 0 no matter what these weights are If I multiply the inputs by the weights and sum them I'm always going to get a zero coming out which can't be right and this actually in this formula for a line y = m x + b these weights are actually dis deter are describing the rise and the run is that those the right terms of the line the slope the numerator and the denominator you can almost think of this as I think weight 1 / weight 2 * X plus b for bias the bias being the Y intercept of that line where is it so what the bias is in a perceptron is another input that always has the value of one but has a different has its own weight you can call it the bias weight and now you can think of this formula as y equals weight for y divided by weight for x or is it the other way around somebody's going to tell me in the chat plus times X plus weight for the bias times 1 so hard this is sort times x does this make sense so this is really what the perceptron is learning we know the formula for the line and could do all this with math a neural network is often referred to as a universal function approximator thank you to the chat who just posted that terminology right we with a simple like twodimensional space in a formula for a line we can do the math directly but here uh you can imagine once our data inputs that gets once we have all this data with lots and lots of inputs beyond that are in end dimensional space we want to be able to approximate a function to work with that data and and this is we're seeing just beginnings of that here okay so let's go now and implement the bias in the code all right so for the bias there's a couple things I want to do number one is I'm just going to add that to the point I'm going to say it has float B for bias let's just call it bias and bias is always equal to one so every point is going to have an X and Y and a bias and then um the perceptron now needs to have three weights needs to have the weights for the two inputs the X and Y and the bias and one thing I might do is um give the perceptron Constructor a number of arguments so that we could have a sort of more generic p perceptron and I can say weights equals new float n and then when I create the perceptron I want to say perceptron uh three and then here oh this was just something I had to test the code um now the inputs should always be an array of three things and is there another uh here training do I should always make sure to include that bias I think I was able to get all of the and so let's run this again we can see that it's still a little bit stuck I'm pretty sure that I have the correct code now but here's a way that I'm going to be able to determine whether it's working or not um what I want to do now is also visualize what the perceptron currently thinks is the line so remember this is where I drew the the actual line the correct formula for the line what I want to do now is um let me I think I could do this with the perceptron so I can say Point P1 equal new point 1 and I'm going to say uh what did I call the perceptron brain brain. guess y1 so I'm going to ask the and P2 is one brain. guess Y and then I'm going to draw the line oh uh let's call this P3 and P4 so I am going to attempt to draw the ver original line that the perceptron thinks and this should be one so now if I go into the perceptron and I say I already have a function called guess guess y it's a little bit awkward here naming wise guess why and I have an x value the formula for the line so the slope should be weights index 0 divided by weights index one and the Y intercept should be weights index 2 so I should return x m * x + B so something's happening here but I think I'm off right maybe what I meant to say was weights one divided by weight zero so this this is the line trying to learn boy it's really not doing a very good job so I think I need to take a closer look at this and figure out what's if this is really right I was just kind of trying to guess so there's a way we can actually do the math for that properly um remember the perceptron right the x is multiplied by a weight the Y is multiplied by a weight the bias is multiplied by a weight all those are summed so the formula for the line that it's learning is actually the Z weight * X plus weight index 1 * y plus weight index 2 * B all of this should equal zero so that means weight index 1 * y should be weight index 2 * B minus weight index 0 * X and then y should equal weight 2 / weight 1 * B minus weight 0 divided weight 1 time x I think that's right that's pretty different than what I have let's take a look oh there's a major error here even before I got to this thank you to Ethan Elliott in the chat I forgot to initialize the bias in this Constructor what a disaster so probably do save me from for myself I'm just going to initialize it up there Wonder that's really going to so I never actually even had a bias so I think this is actually working but I'm not visualizing this line perhaps correctly so let's go back now and let's see where do I want to do that I'm going to say uh y equals um so let me let me use the formula that I just used return so let me do this I'm just going to create some shorter variable names to make this easier to look at and I'm going to say uh return uh I'm looking over here at that formula I wrote over here I'm going to say return uh W W2 ided W1 time B time sorry times bias oh times one the bias is always one so W2 um divid One Plus w0 / W1 times that x value now let's take a look and see now if things are working as they perhaps should I think you can see that that it's actually I flipped somewhere do am I missing a negative oh this should be negative switched this to negative this looks very close but it's kind of off right thank you to the chat somebody in the chat just told me that my equations are wrong and they are this should be negative right because this all of these add up to zero so I need to take if to make this equivalent y1 * y equal y W2 W1 * y = W2 minus w0x that's going to fix it okay so now I'm going to say negative here and we're going to run this and we're going to watch the perceptron over time and you can see as it's correcting all those circles are turning green uh with this learning rate slowly over time the line is converging to the correct spot perceptron learn the line so um you know there's going to be a part three and a part four to this because I think I'm going to wrap up this particular video there are some other things that I wanted to add to this but at least now in this video I've added the bias I've made it so that I have a cartisian space I can work with and I can work with any formula for a line as you can see life is just one big refactoring and there's so many things I could do to refactor this and Visually I still don't necessarily love what I have here in terms of explaining what's going on but at least now let's just before I go let's make a new formula shout out your numbers to me nobody can shout out to me uh 8 n * X +2 or let's do minus 2 .1 let's just have a different formula for a line and see that this again works we can also probably have a much better sense of what learning rate is doing like look what happens if I make the learning rate 0.2 right now you can see how it makes these very large movements so it gets to the the correct answer very quickly but it can't do the fine detail to really find the correct spot and if I make the learning rate really ridiculously small you know you can't even see I mean it is in theory this line is moving it's so small that I can't even see it let's not be so crazy let's do that why I can't even find the line the line currently isn't even in the space because remember it starts with something random let's run this again so this line is moving but it's just really really really slow so it's all about finding and that learning rate can change over time I could start with a large learning rate I should make a slider to adjust the learning rate I could start with a large learning rate so it gets close look at that it just locked right in um and then I could uh lower the learning rate for those refined uh Mo movements okay so I have a couple things I want to do I think I'm going to make a couple followup videos on this they'll appear at some point um but there was a great comment in the original first version of the coding challenge about adding data that is not part of the training set which of course is very important in machine learning so I'm going to do that in the next uh followup to this perceptron coding challenge thanks for continuing to watch watch