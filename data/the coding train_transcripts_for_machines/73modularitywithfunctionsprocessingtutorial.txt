Okay, so the last program in the last video. We kind of talked in general about... we could define a function, we could call a function. I want to put that into practical use in the simplest possible way right now. The simplest possible way we can do that is to just look at a program. We've written in Processing. I'm going to take this program right here. Which I'm about to run. What does it do? It's our... tadaa... bouncing ball program which we've looked at five zillion times. Which you're hopefully not too tired of I know okay, so the balls bouncing around. This is very hard to do yeah. I can't do those good. Follow the ball. It's backwards. I'm like okay... I just can't really do it, okay. Sorry anyway, the ball is bouncing around. So what we want to do first looking at this program is think to ourselves... What's going on here? Well, I would say there are three things going on here. Number one every frame of animation we have to draw that ball, we have to draw that circle on screen. Every frame of animation we have to advance the circles position. We have to move it and every frame of animation we have to check to see if it's hit the edge of a program and if it's hit the edge of a program we have to make it turn around. So we could say to ourselves. This is our goal We want our draw function to look like this We want our draw function to say something like display Ball Maybe we want our draw function to also say move Ball And perhaps I'm going to say check edges. Could have called that bounce. I could call it anything we want. So this is what we want our draw function to look like look. It's lovely. It's three lines of code There's so many advantages to this the fact that we can say our program is modular. It's in three parts It's readable we kind of understand it We don't have this gobbledygook all throughout draw(). We can you can start to organize our thoughts together nicely And I'm going to show you in a moment, how we can turn these kind of sections on and off very easily to allow ourselves to debug to find problems in our program more easily. So how do we do this? Well these functions don't exist in Processing? We need to define them. We need to define display ball, move ball and check edges. So let's go over and do that in our program here. So, looking at this code. What do we got? Well, let's scroll down below draw() and say okay We want to add a function called display ball. remember our syntax return type function name parenthesis for arguments, open curly bracket close curly bracket. The same syntax we use to define the function draw(), a special case in Processing that we have to define to... to say what code should happen in that loop. We're doing here. display ball... move ball check Edges Now we've now written these three functions. Well, what do we want to do with these three functions? We want to say "Okay, here is the code. This is the code right here, that is all the code for displaying that circle for drawing that circle. I can cut that out and put that all in here Here this is I would say is the code which moves the circle, whatever x and y increment by their speed it moves. So we're going to take that code and put it down here in move ball. Now here is the code that where we check, has it hit an edge? Is it greater than width? Is it less than zero? Should we reverse its direction? This is the code that deals with checking the edges. So now you can see we've made our program nice and modular. There are three functions. Display ball, move ball and check edges and this allows us to easily let's say we work on, we've worked on this, we spent days and days creating this beautiful program just about bouncing this ball around the screen it's our finest work and we're thrilled. But then we go on vacation or we are busy with other projects or something else happens, and we come back to this a month later. This is the same thing as writing comments in your code. Functions allows you to quickly say "You know what I wanted to have a rectangle." Forget that circle going to have a rectangle bouncing around the screen you can easily find it by saying "Ah it's the display function. That's the code I need to edit." Now this seems of course all very silly with such a simple kind of trivial example. It's ball bouncing around the screen. But as you get further on with larger more complex programs once we start having objects you'll see how this can really be of help. Okay, so let's run this again If you're thinking something's going to go wrong something is What happened to my bouncing ball? It's I wrote this perfect program. setup(), draw() displayBall() moveBall() checkEdges(). What's going on? Nothing is happening. Well, you could define a function. If you define a function But don't call it explicitly somewhere within the flow of the program. It's not going to be executed. None of this code is happening. It's just all floating in there. It's a function defined in a forest where there's nobody to hear the clapping sound or something. Anyways if you define a function but don't call it does it exist? It exists, but it's not happening. So, yes, we defined setup() and draw(), but setup() and draw() are functions that Processing actually executes for us. Setup() in the beginning, draw() over and over. We need to call these functions somewhere in one of those and we know specifically what we need to do. We need to call them in draw(). That's what we define in setup(). Okay. So if now I add display Ball We can run this program and see... We've got the ball in display, but it's not moving or it's not bouncing off the edges. So I can now write move ball and check edges and run this and we see Okay, that was... something fell. Everything's okay. It was just a small little tiny thing nobody has to worry. Oh it was my clock six minutes, so far we're doing great. Okay. Oh my goodness. We could see the ball's bouncing around. No one was hurt. No animals were hurt during the filming of this how to make your functions video. Okay, so... You can see this is working. So this has a lot of in... This is a very, very simple first step, but this has a lot of advantages for example... Let's say something was going wrong in this program I'm going to make something go wrong in this program Let's run this again. Hmm. I don't see my bouncing ball. What is happening? What's going wrong in this program? Well, let me just check I just want to turn off moving it and checking the edges to make sure that's not causing the problem. Oh, I still don't see it. So there is a problem. The only thing that's happening is ellipse the problem has to be in the display ball function. Oh, so maybe what, should I do... Let me print out the value of x so I can see what it is. Oh the value of x is ten hundred thousand, ten thousand. Uou can't see that but it's at the bottom of the screen and the console. Something really is going wrong here. So what I'm kind of emphasizing here in it in a somewhat silly way is that... I'm going to fix it... Put x back to zero. Is that in addition to making your program more modular so it's readable on... What we've done here is we've allowed to easily sort of define the various pieces of functionality, sort of conceptual pieces of our program. Turn them on and off easily by commenting out whether we're calling a function or not. It just has so many advantages that I could go on and on and on. So this is step one. We've made our program reusable. I mean I said exactly the wrong thing we haven't made our anything reusable in our program We've made our program modular. Which is divided into three modular pieces. The next thing we want to do... What if we wanted to display another ball? We need some way of making our code reusable. And that... The way we're going to make something reusable is through the use of arguments to a function. So that's what's going to come up in the next video. We're going to look at arguments to a function the video after that. What does it mean to have a return type that's not void. What does it mean when we define a function to not have a void return type? So if you're looking for an exercise to do right now at the end of this video before you get to the next one and this is what I said the last video, but now you could really do it if you got stuck. Is take something you've written in Processing that has a lot of code in setup(), a lot of code in draw(). Just say what are the conceptual pieces of what's happening in this program. Divide it up into those sections... write a function for each one of those sections and call those functions in setup() and draw(). See if you can just reorganize your thoughts. Reorganize your program. Refactor your program so to speak. In a way that's a little bit easier to follow. Okay, so that is the end of this video.