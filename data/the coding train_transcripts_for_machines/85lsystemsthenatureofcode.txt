welcome this is the last video in chapter 8 about fractals and in this video we're gonna kind of cap everything off by looking at another way to generate fractal patterns and this we're gonna use something called an lsystem what is an lsystem lsystem is named for the L for arrested Lindenmayer Hungarian botanist who I think in around 1968 introduced this idea of an L system while he was studying plant growth algae fungi how do them these sort of cellular systems how did all that stuff grow and get attached to itself so there's a wonderful book I believe it's out of print but I will show it to you right here called the algorithmic beauty of plants if you're interested in this stuff you must get this but you don't even need to buy it I should point out that this book in book is in its entirety is available online for free so I will include a link to that below but we're gonna we you know so this is a very rich topic in the sense that there are tons of different owl systems that you can make but we're gonna just look at the core elements of an lsystem what is it how does it work and a couple examples in processing and from there that might launch you into all sorts of different possibilities so one of the things that's super interesting about L systems in terms of what we're doing is they in many ways have nothing to do with computer graphics whatsoever we're going to use them for as as to generate instructions for drawing but at their core and L system is really a grammar it's a rewriting system it's a way of looking at strings of characters and rewriting those strings of characters over and over go over and over again in a wait for it recursive way right we're going to apply recursion to text which by the way if you're interested in things other than computer graphics and algorithmic text this is an interesting thing for you to look at as well so an L system has an alphabet so we're gonna start with a simple one and alphabet is what are the characters that are allowed in this particular L system and we'll start with a very similar with just a and B it also has an axiom which is what is the original what is the generation 0 sentence that we're going to start with we're going to recursively make sentence after scent from generation to generation just like we've done with all these drawing things we do it with text so what do we start with we're gonna start with a and then it has a rule set right just like when we did the Cantor said the tree the Koch curve we had these production rules a line has two lines attached to the end those lines have two lens attached the end we're going to have the same production rules but for text so what what are some rules we're gonna say hey the character a should turn into a B a and we couldn't have one or more rules gonna do a slightly complicated one for dramatic effect as you're gonna see in a moment we could say the character B should become B be V so let's look at what happens when we start with a so a is generation zero now we're gonna do this once generation one a becomes it looks doesn't look like a 1 a becomes a be a we all right we're on okay hey becomes a be a a be a now we're gonna do generation 2 okay be a becomes a be a write this big this is that b becomes b b b and a becomes a the a oh come on let's do it one more time generation 3 gonna start over here a becomes a B a B becomes b b b a becomes a be a oh my goodness B because b B I can do this I can do this right I've got 9 B's and then a b a b b b I probably I ran out of space you can't see me anymore but look we can see what we're doing and okay great this is not I mean sometimes it can be fun like if you know a lot for me this is fun to do with a marker but you can see here how a computer program that's gonna work with strings and make new strings from generation to generation is gonna be much more effective but I just want to pop say for a moment what remember we're you know as much as there are tons of applications of this we are looking at this in particular for draw patterns in our processing window so what how are we gonna get a pattern from all this text the thing we need to think about is what if these characters were instructions for drawing for example what if I said to you a means draw a line and what if I said B means move forward without drawing so let's look at what this is a translates to this a ba translates to this a b a b b b b ba ba translates to I really didn't need to go to the third generation line move forward line the forward before before line before before word look familiar to you this is generation 3 this is generation 2 this is generation 1 right does this look familiar to you it should what we are doing is making the Cantor set so we can actually have correct that was kind of roundabout but what we did is we just define the Cantor set in terms of strings of characters right you could see these strings of characters exhibit the pattern that the Cantor set exhibit whenever a is aligned and B is a blank space and I didn't necessarily draw this to scale perfectly one of the things in else isms that we're gonna see is if we're using these instructions for drawing from generation to generation each line segment needs to get a little bit shorter right so we have this you can see how the line segments are getting shorter from generation to generation if I'm if this is really if I were to kind of have done this slightly better so this is where I think to myself I'll just start this video over and I'll make it more perfectly aligned on the board but I think you get the idea right so what this is pretty exciting we now have an lsystem which is these strings of characters which we can translate these characters into instructions for drawing and generate these patterns now this isn't accidental this you know this was designed to generate the Cantor set you can come up with all sorts of random alphabets and random axioms and random rule sets and see what results we you get but what I'm going to show you are some particularly some known L systems that will give you fractal patterns well so let's briefly talk about how the code implementation for this needs to work I don't know if you remember if you watched a couple videos ago we talked about this ArrayList technique where we kind of put an object in the ArrayList and then we iterate through any objects that are in the ArrayList and create new objects that go in that same ArrayList or going to a new ArrayList we've done it gets replaced right this idea of recursively iterating through a list of things that make more things is the same list okay so that's what we did before we're going to do the same thing with strings right we have some ArrayList essentially that has one character in it and now the next generation we need to say hey there's one character in it let's put these three characters in it oh then we need to do is say for this one we're going to put those three characters in it for this one we're going to put those three characters in it and for this one we're gonna put these three characters in it so the couple of the things that I should note is the order of the characters actually matters right because things are ultimately gonna be instructions for drawing but it's just we're using the same exact technique this list with information and each piece of information kind of gives birth to new pieces of information and the ArrayList grows and grows and grows but instead of using an ArrayList we're gonna actually use something called a string buffer now in truth you know this probably merits me pointing towards a video and there's a tutorial in the processing website that I'll try to link to about how to work with strings and processing you don't really need a string buffer you could just use a regular string a string as an object to describe an array of characters but this is a moment in time we're using a string buffer could makes good sense because even though as we do this on the board our string might only have like 50 characters in it as soon as we go and run the processing sketch you're gonna see the string could have thousands and thousands up to you know hundreds of thousands of characters in it potentially if it's a very elaborate drawing stead of drawing instructions a string buffer is very very efficient for manipulating strings and what it has in it it has a method called append which is kind of going to be like adding to an ArrayList so we'll start we have a string we create a new string buffer for every string for every character in our original string we start appending to that string buffer new strings of characters so let's take a look at how this actually works in code so here I have that method by the way which is that we start with we start with a current string right we have a current string a this is exactly if you look at all of our previous examples we had an ArrayList current for all the Koch lines and then we made an ArrayList next for the next generation of Koch lines we're doing the same thing here the difference is the the thing that's next is a string buffer so as we go through the current string we say hey did we find an a give us an a B did we find a B give us an A and you know I should probably make this the same thing we just did on the board right if we find an a give us an a B if we find a B give us a BBB right and then at the very very end when we're done the current becomes that next string buffer so the string buffer to convert it back to a regular old good oldfashioned string we just say the string buffer dot to string and we set that as current and increase the count of generations so if I run this I'm gonna scroll down all this only does stuff in the console but we can see here let me zoom way more in on this so you can see it you can see here generation 0 is a I'm gonna kind of stand over here and I'm gonna click generation 1 is a be a then we have that and we can see like very quickly you know 10th these are massively huge like long strings so the point of this isn't necessarily what we're doing is to use the text although you could really imagine are you constructing some type of kind of poetic like text or some algorithmic text through some set of logic are these are the characters were is the L system a series of words instead of characters the could use iconography in some type of way there's so much you could do with Elsa but again we want these to be instructions for drawing so I haven't taken this further and exercise you might take up on yourself as actually render the Cantor set from these L systems if the character is a draw a line if it's B move forward without drawing the line but we have to ask ourselves a question what do we mean by draw a line or move forward without drawing a line turns out that a lot of the L systems have these this type of language draw line move forward and turn the turtle graphics the language of turtle graphics so let's take a moment to talk about that and see how that works in an L system so okay so let's not use a and B anymore so let's let's remember back to a time which I don't know that I ever actually did this I remember learning like basic I did a lot of Basic programming when I was a kid but you or if somebody in the world definitely used the logo programming language and move Turtles around the screen what were some things that Turtles could do turtles could draw a line alright so if this is the window what that means is here's my I can't draw a turtle here's my turtle it might move forward and draw this line while it's moving forward and now it's here turtles could also just move forward which means they move forward but don't actually draw a line so you can imagine that as just moving forward and now the turtles here so the line was drawn here now before other things they can do is they can turn right or they could turn left so turning right we mean go this way turn left would begin this way that that turn right could be at an angle 90 degree angle 45 degree angle etc so these are the basic elements of turtle graphics an lsystem could have as its alphabet and F which means draw a line a G which means move forward without drawing line a plus which means turn right look a which means turn left we could use these as the characters in our health system and we could create rules that generate various patterns that a turtle could draw that are fractal but this is like a basic a turtle graphics engine but it would be nice to be able to if you imagine for a second a turtle taking this path to be able to maybe remember various points along the path and if it's over here it could then pop back to here and start going in this direction right so a turtle as it's going could save where it was draw a little bit further then come back and draw a little bit further the other way after all if we're gonna draw if we're gonna draw some type of fractal pattern we might need to branch off one way come back branch the other way this is exactly what we did with with our tree example previously so we might like to introduce this character which means push matrix or really I kind of like change the language here which means save where you are save look state which means where you are and what direction are you pointing and this could mean these this characters mean restore state so now if we if these are the characters in our L in our L system if these are the the members of the alphabet of our L system we need to write a turtle object that can parse a string and call the right processing functionality do each one of these things right this would call line and translate this would also just call translate this would call rotate rotate push matrix pop matrix let's take a look at that so I'm back over here and now this by the way was example eight point eight and now I'm going to example eight point nine which is already open and I'm just gonna go to the turtle class and what I want to look at is this set of code right there is a string called to do dot length let's look at every character in the string and I guess I didn't do this correctly now we have to fix this example if that character is an F in my scenario if it's an F or a G it's drawing a line and transit and moving forward so technically speaking if I wanted to be accurate according to what I just did on the board over there else if C equals G move without drawing the line and it needs to go there okay right so f means draw a line and move to the end of the line G means just move that length C is rotate minus sorry plus is rotate minuses rotate the other direction and open square bracket push matrix close square bracket is pop matrix so you can see this and you could probably make the argument that this should be a switch statement but I which is another type of syntax for a conditional statement but just to kind of keep these examples very basic I'm just using if elseif so this is parsing that string look at all of the characters and calling the correct drop piece of drawing functionality so this example is essentially the previous example which makes those lsystems strings but it adds on one layer the turtle can then read that string and draw according to it so what is an lsystem that we might use there's a lot of stuff in the comments here which I'm going to remove let's look at this so this by the way is how this example defines an lsystem we have a rule object and we have an array of rules and we have you can see this rule takes an F and turns it in this crazy string so how did I come up with that crazy string I found that in that book or I think actually I found a lot of these from the computational beauty of nature book chapter over the correct chapter number which which has a nice section about L systems in a whole lot of example scenarios okay so this L system if we run it we can see okay there is F right that's just an F draw a line straight from the bottom up and you know what I would like to do I apologize I would like to set the stroke weight to two just to make it a little bit thicker I think you'll be able to see it better right this is the this is just plain old F now look that's the first generation which you can imagine is f maybe rotate draw a line wrote it the other way draw a line wrote to the other dry line pop back then row to the left draw line rotate up draw a line rotate to the right draw line right now let's look at another generation oh we can see how this is being applied over and over here now as I click the mouse that go from Jenner generation and we can see we have a fairly sophisticated tree like pattern which is much more complex than what we did without the L system so even though all of these examples we could do it's just a recursive function or we could do with an L system sometimes the kind of mechanics of the L system allow us to more easily generate this pattern the great thing about the L system too is we have the entire instructions for drawing this encoded into a string so I'm drawing the whole thing at once but there's no reason why I couldn't draw it character by character and animate that for you to show how this tree grows which would be also a great exercise to do or another example that I should make okay so now that we've seen this there are this is just one scenario and you know I guess I should mention right what what is an L system object it has a string which is its current sentence it is an array of possible rules which say what characters become what and it has a generation it's keeping track of the count and a rule is really really simple a rule is just a character that becomes a string this is a becomes a b a b becomes b b b so these are some simple classes to manage the elements of the L system I'm going to open up a couple other ones just so you can see here is another L system right maybe this looks kind of similar to you it's pretty different you can see also the axiom is F minus F minus F minus F so when I run this one we actually can't see it but there is an axiom which is drawing a big square right if we start if we say move forward turn left move making a big box that's what that axiom does but as I click we can see what are we getting take a look at this and like you know try to make this fractal pattern without an lsystem you could do it but the L system is is a nice way of doing it I forget what this is called maybe it has sponge some that some sort of sponge merge and mercer spun somewhat correct me ok and the last one I'll show you is just the sierpinski triangle here are the rules for making the sierpinski triangle where we have F and G and and we can see what we get right and there's our serpents triangle which we have now done a zillion different ways we did this with cellular automata we did it with like this crazy recursive circles that that actually made that pattern now we're doing it with an lsystem so you can see all of these systems can generate these patterns and it's less about again I guess I should finish with this what's important here is not hey you can use the sierpinski triangle as a design element and everything you make it's more about here are a bunch of strategies and techniques for using recursive functions to create designs it's up to you now to figure out what design do you want to make could you actually create your own rules for an lsystem and interesting idea is actually to generate random lsystems right random alphabets random rules you'll see you mostly get a lot of noise and junk but in there there might be some gems is there a way you could find those gems maybe you could evolve lsystems which is kind of a little foreshadowing to the next chapter we're gonna look at genetic algorithms and evolutionary systems okay so hopefully you found this helpful and I will provide a lot of links below and things to the stuff that I talked about that will hopefully also be helpful and there we go