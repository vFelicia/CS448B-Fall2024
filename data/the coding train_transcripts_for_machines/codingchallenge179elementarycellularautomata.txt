autom autom autom autom autom all right everyone I'm here for a coding challenge I don't know what number coding challenge this is for 2023 but I'm certainly not above one hand here no more than five have I done it's been a slow year I've been working on the nature of code book the original version was published in 2012 I've been working on a new version of the book you know basically ever since that first version came out but finally finally I have completed writing it you can actually preorder it there's going to be a physical version of the book the whole thing is available online I'm still working on the design for the website I'll show you some samples here but maybe even if you go to the URL natureof code.com right now you might see something new a newer design maybe let me know let me know in the comments when you're watching this I hope that in 2024 I will be able to return to making more regular coding challenges and I'm going to start today by attempting to code without a lot of practice mind you and I haven't looked at this example in well over a year so we'll see how it goes the Wolfram Elementary cellular oh dear I have to pronounce this word now automata automata I think that's right automata now I have completed a coding challenge About Cellular automata before uh namely coding Challenge number 85 The Game of Life the game of life was famously written about in Martin Gardner's 19 19 70 Scientific American article describing it as recreational mathematics fast forward 30 plus years later and Steph Wolfram published the 1,280 page Tome a new kind of science wolfram's book discusses how cellular atoma aren't simply neat tricks but are relevant to the study of biology chemistry physics and all branches of science okay let's let's first Define what a selller automaton is adada adada adada the song The Core foundational element of a CA which will make my life much easier if I just say ca from now on is a cell this is the cell in cellular the cell has a state typically some finite number of options and the most barebones basic version of that would be just a zero or a one the cell exists inside of a neighborhood in the case of a onedimensional CA that cell is just going to have a neighbor to its right and a neighbor to its left in the case of a twodimensional CA like with the game of life that particular cell might have neighbors that surround it in all directions you could imagine how you could have an idea of a cube being a particular cell inside of a threedimensional CA but the simplest version of this the elementary Cellar automata is in one dimension with a cell that has neighbors to its left and its right so these are the elements the cell with a state and the fact that it has a neighborhood this over here is a CA it is a grid of cells in one dimension each with a state now it might be interesting to think of this as infinitely long that would be in a the retical space but the fact that I'm going to try to visually represent this in a p5.js sketch and then I have a a limited amount of actual whiteboard space I'm going to just right now I'm picking my CA has 1 2 3 four 5 six seven uh cells what's missing what I haven't drawn yet here on the board a huge missing piece of what really makes a CA exciting are the rules what happens to the cells and their states over time but before I even get into that let's look at how am I going to code the elements of a CA and represent visually a single generation let's represent that as an array now just for cleanliness here my canvas is 400 by 400 what if I had 10 cells across so each one would be 40 pixels wide let's make up a variable for the width of each cell and I'll hardcode that now at 40 and and inside draw let's visually represent those cells how about a one will be black and a zero will be white well that's 10 cells across if I were to say fill with cell's index itimes 255 so now when there's a one the cell is white when there's a zero the cell is black I could invert that perfect so the next question is how do we determine the states of the cells in generation one remember a neighborhood of cells is three cells together how many ways are there to configure three cells if each cell can only have a state of zero or one if I did this correctly I should have eight possibilities this is like a three bit number 2 to the 3 power is eight wolfram's rules for an elementary CA specify an outcome a new state for every single possible configuration of a neighborhood of three cells this is what's known as a rule set let's take these first three cells their configuration is one0 0 I can look that up here one0 has an outcome of one this particular neighborhood yields this particular new state value okay let's look at 0 01 one and I don't know why I'm drawing some ones like this and some On's like that it's confusing 0 one 0 one 0 1 0 one 0o so for any given cell looking at its state along with its left neighbor and Its Right neighbor State yields the result defined by the rule set so this brings up a couple of questions one I skipped these cells what do I do with the edges one approach is that for this cell which has a state of one I could consider its neighbor to the right as as having a state of zero and it's neighbor to the left being the one on the other end wraparound so to speak I could also ignore those cells and just copy their values or maybe Define a different set of rules let's not worry about that for right now and let's just copy their values the other thing you might be asking is why did you pick these numbers 0 1 0 0 1 1 01 why are those this new States based on these configurations well hold that thought I just picked those numbers out of thin air arbitrarily let's just see if with any particular defined set of rules if we can make the code work to go from generation zero to one to two to three Etc and then I'll Circle back and talk about why it is you might want to pick certain values over other values let's create another array I'll call it next cells or next Generation then I'm going to iterate over all the cells and I need the cell's new state to be a function of its current state along with its neighbors to the left and the right all right so I made up variable names for the neighborhood the left cell the right cell and then I'm just using State for the current cell the middle one if you will then I'm imagining that there's some function that's called calculate state it takes those three states and then gives me a new state which I put into the next array so I need to write that function fun and it receives three arguments I'll just call them a b and c and then I need to return a particular value based on that configuration if I have a is zero B is zero C is zero then I should return a zero and for reasons which I'll explain in a minute I think it'll make more sense if I actually start with checking 111 first now for all of you who are screaming at whatever device you're watching this on I know I know I'm going to do this a different way in a minute I just want to write this out in the longest most ridiculous handmade way as possible to understand the mechanics of what's going on and I should also put something in here to handle the edges so let's have the loop ignore the edges and hardcode those values in so now I'm creating a new array I'm copying in the edges just so I don't have to worry about them and then starting from index one I am calculating the all of the new States based off of the rule set once I'm done the old cells are now the new cells all right so while this is working I'm not visually getting any kind of results let's make the cells much smaller if the cells are only 10 pixels wide I need to uh have more of them I'll start by having it just be an empty array and I'll fill it in and let's fill it in randomly this will give me a zero or a one okay great now this is a moment where you could choose to be very creative how are you going to visualize the generations of the ca system the class classic way to do so the way that wolf does in a new kind of science to visualize them is by stacking them and this is what I've drawn here generation zero and then go down a row to display generation one and so on and so forth let's add that into the code so I need a variable called y we'll call it we're going to draw all the cells at X comma y now and then after we're done rendering a generation of cells we'll just go up by the size of the square oh that looks fun but I'm going to need to not erase the background and there we go fascinating now this is what I got with this arbitrary set of rules that I picked out of thin air with the first generation generation zero if you will of all the cells having a random State the typical way the way that wolm would demonstrate of 1dca is to actually have the first generation all with zero and only the middle cell having a state of one so let's set them all to zero and then let's set the middle State oh I have an even number of cells there 40 of them let's make the canvas 410 that'll be fun okay look what we've got there I have now in however long this video has taken programmed an element Wolfram CA looking at wolfram's math World website the page about the elementary seller automaton you'll see that there are 256 rules and if I scroll around here I think I should be able to find the one I just made rule 186 that really looks like the one I just coded rule 242 also looks suspiciously similar as well as rule 250 I am going to take this number and I'm going to write it as follows horizontally this is an 8bit binary number two to the 8th power is 256 that's why there are 256 possible rulle sets remember it's a little confusing because there's zeros and ones everywhere the state values are zeros and ones the elementary CA could be 100 cells long a th000 cells long infinitely long but a neighborhood is only three cells meaning there are only eight possible neighborhoods each possible neighborhood needs a new state value meaning there are eight new state values there are only 256 ways to configure eight new state values this is one of them what is the decimal equivalent of this number well do I have to do this math now I can just go use a calculator let me I'm going to do it I can do this 178 is that right I got 178 converting this from binary to decimal hey look at that rule 178 let's see what happens if I try rule 182 looks kind of cool how do I write 182 as a binary number one 0 1 1 0 1 1 0 I think that's right 1 0 1 1 0 1 1 Z looking pretty good let's make it quite a bit wider and maybe the cell's a little bit smaller we don't need to have the stroke and look at that do you recognize that that is the serinsky triangle fractal this system which is a system of cells that only have States zeros and ones there are only little neighborhoods of three zeros and ones there are only 256 ways to configure a rule set somehow with this simple system the serinsky fractal triangle emerges isn't that amazing I want to examine this further but let's make some improvements to the code first I could have the rule set be represented like this a string of zeros and one ones I'm going to do an array though because that'll make my life easier now all I need to do is take the three values and convert them to the index into the array if this is the array 0 1 2 3 4 5 6 7 so this is a little bit tricky here this zero place is the 111 value so this is 0 1 2 3 4 5 6 7 but I'll worry about inverting get later all the whole thing that I need to do is just take three bits and convert them to a decimal number and actually in JavaScript that's pretty easy to do actually I don't remember how to do this I can make a string joining them and then I could say okay so this is the neighborhood and then I'm going to say value equals I think I could just use parse int parse int the neighborhood in base two it's a binary number and then return rule Set uh value well I got a different visualization but that's because once again I'm inverted so when the states are 0 0 0 I want the last element of the array when the states are one one one I want the first element of the array so I should just be able to say uh 7 minus and there we go let's make this rule set a global variable and let's look at some other rules just to make sure things are working let's do rule one oh rule one will be fun pretty I love it in wolfram's a new kind of science he categorizes every rule into one of four possibilities the first is uniformity where all of the cells tend over time towards one particular state rule 222 is an example of that you know I would like to be able to put the rule into the code as a decimal number now how do I convert it the other way if I parse in the rule value oh no can I do uh what if I do it this way as a string rule value to string base two does that work in JavaScript I'm just totally making up code am I supposed to actually do this ah yes that worked okay I need the number I have the number it converts it to a string let's have the rule set be a string and then change this function to return uh parse int okay great awesome rule set 222 uniformity the next category is repetition a rule set by which the cells oscillate repeat some pattern over time rule 246 let's try that one there we go those are what you might expect with such a simple system the next two categories are where things get a little bit more interesting the third categorization is random and one of the more famous rules for the wolf from CA is Rule 30 remember there's no random numbers here this is a fixed discrete deterministic system yet let's put in rule 30 what did I do wrong oh because I don't have the leading zeros okay so this is a problem I guess I can add the leading strings uh while the leading zeros sorry while rule set. length is less than eight rule set this is a terrible way to do it equals a zero plus rule set somebody will suggest for me a better way of doing this in the comments I'm sure okay but great here we go rule 30 now I'm only seeing a fraction of this let's give myself a lot more space and the fact that I'm clamping the side is a bit of a problem should we add the wrap around let's add the wrap around so left is i1 plus let's just call length equals cells. length that's the total number of cells cells so if I add the total number of cells and then apply modulo with the length this will give me a wraparound oh but I have to actually look at all of the cells now and I don't need this anymore try to find the pattern here could this be a pseudo random number generator what a question but there's more let's look at possibly the most famous rule of them all rule 110 look at this is it random hard to predict yes is there structure yes this is something of a mix between repetition and Randomness and this I would say is the essence of the beauty of the cellular automata system look at this textile cone shell look at this Wolfram rule 110 I would love for you to make your own version of this what can you do if you think about the ca system in terms of color what if you invent your own system with more than just two states what if the states are not discrete values but continuous floating Point numbers what other things can you do to visualize the ca system could you have it be an infinite scroll could you have the rules change over time there's too many possibilities for me to even think of I hope that you will consider making your own creative version of the wolf from Souther automata submit it to the coding train passenger showcase and stay tuned because this is just the beginning what do you want to see next what from the nature of code book do I not have a video about that you would like to see one on the coding train see you next time ch