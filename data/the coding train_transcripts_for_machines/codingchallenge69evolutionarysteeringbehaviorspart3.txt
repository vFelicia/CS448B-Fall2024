okay welcome to part three so so far we have this system of agents they get a random set of weights which are visualized by these lines are they attracted to food or they are attracted to poison they're repelled by food or they're repelled by poison we're going to try to evolve these to some optimal weight but I need to do a bunch of things number one is a little bit of an issue where they sometimes kind of leave you know they're also dying out kind of quickly so let's let's try it up let's make it easier for them for a second let's increase the amount of nutrition for each piece of food I'm going to probably make it too easy right now which is maybe a bit of a problem let's decrease the amount of health that they lose so now this makes it easier for them we should see at least something that randomly gets some pretty good weights make its way around the screen I should also notice that when I took a break in between parts two and three that I I just made the or initial weights like within a lower range so okay so now this that one seems to be doing three well it does kind of like leave so one thing that I think is going to help it help these is to keep them within the window and I have an example that I made previously which is this example which is a steering behavior where it's desired velocity is to go back towards the center of the window if it ever gets within some range of the edge so I'm going to grab that code for that example which is on github right here and that bit that behavior is in this function called boundaries and I'm just going to copypaste this function you know again I'm kind of moving away from the code everything from scratch in this particular video because I'm trying to stay with the core idea but you can see this is yet another so you can pause go find the link to that code and paste it in yourself but you can see is like if the exposition is within some distance so there must be what is d so D must be something that is a global variable in this example because I don't see it defined here like it's D must be let's look at that because we're going to need this let's let's go back to sketch KS bar D equals 25 so I want to be a little bit more thoughtful about this just going to put that in here it's a local variable and I'm going to call this I guess we'll just leave it called deke looks like that's distance from the edge that it wants to stay away and so it makes the vector that points away from the edge if it's within if the X or Y is near the edge and why is this if this top position is long oh yeah or if it's sorry if it's within less than D or if it's greater than height minus D so top and bottom okay so let's just go back to the sketch and add in now if I add this as another behavior boundaries is another function this should also have that boundaries function let's just see if that works let me clone these are clean that open anymore whoops something else up okay I've got an error what is this error boundaries is not a function vehicle index I'd boundaries this dot bo you know what I put it after the constructor so I have my brackets out of place so now it should be within there and attached as a function to each object and there we go so we can see let's see do they turn around you can see they're turning around now when they get the edge now the repulsion force might be stronger and it's like boundary force but we can tune that later but I think this is a little bit better we should see hopefully oh yeah you know what it is look at it this one can't even get this food because it's so repelled by this particular piece of poisonous over here so that's really giving them a struggle so this is why we need to add this other aspect with it which is a perception radiance so let's do that okay so I'm going to add that as two other pieces of DNA so what I want to do right now is I want to say in the constructor Scroll scroll Scroll scroll the scrolling song okay I am going to now add DNA to and DNA three and so this is I'm going to put some comments in here food attraction I'll just call this food weight poison weight I'm going to call this food perception poison perception and these should be some radius and let's just say arbitrarily right now within somewhere between ten and a hundred pixels somewhere between 10 and 100 pixels so these are can it see so now let's let's visualize that so let's go into the display function and also now say also draw an ellipse zero zero with a size of this DNA index two times two because the radius times two is the diameter and now I'm realizing my number should probably be smaller but let's just do this anyway and this is DNA three so I want to see a green circle for how close it can perceive food and a red circle for how close it can perceive poison okay here we go oh boy look at that too crazy so one day I need to say is no fill and now we can see that so there's a lot of debugging information here so I'm going to probably want to create a little interface where I can turn that off but you can see now I think these these thresholds look kind of reasonable although I do want to I think actually oddly enough I want to let them basically have there's no reason for me to really I'll give them a maximum to start with but I'm going to just give them no minimum to start with okay so you can see now now it's not actually doing anything with this information I just added those rid those properties to the object and visualize them but I need to go and look at that algorithm where I found the closest piece of food and it should only be affected by the closest piece of food which is within that visual threshold okay so let's look and say here where am i doing that eat so this is where I'm looking for the record a little bit of a tricky thing here we're going to figure this out but because the way I have the DNA and I'm trying to reuse this function but if the distance is less than record and the distance is less than this DNA let's just use index two right now right so if it only had one radius for both food and poison that's what we say as long as right it's within that it could only see it if that distance is less than that perception radius really easy thing to add problem is I need it to be two for the good food and you know what I could do is I could just do I'm just going to add an argument called index again maybe there's another for thoughtful way that I could I could actually no you know what I could do is I could pass in even better I'm going to pass in a variable called perception perception so as long as the distance is less than infinity and it's also within its actual perception then it counts as something you can see and up here what I'm going to do in the eat function now where is that each function please use a couple behaviors function is I'm going to say this DNA index two and this DNA index three so it's going to get like the weights the good weight applies to that steering force the bad way to flies to this during force the good perception goes to this eat function the bad perception goes to this eat function again I'm just showing you a framework imagine an object with all sorts of properties parameters that could that could be evolved these are just a few so now let's run this again and we should see that it's going to have it this one this one looks really really good so my suspicion here is that what it actually wants to be able to do is see food very far away but only see poison if it's within a short distance because let me tell you why I have this suspicion because it Maj ins a scenario imagine a scenario where there is a piece of food and there's a piece of poison and the vehicle is right here and it's coming here well if it can see that poison before at the same time it sees the food it's kind of just like turn around and go away but if it can actually if the poison right if the food radius is very very big but the poison radius is very very small its could it be able to get all the way up grab the food then suddenly no he's notice the poison and turn away so again I think we're just going to when I evolve evolve a kind of obvious result that I could design but the point of this is what if there's a much more complex scenario where you can't easily imagine what all the optimal weights and perception radius radii and all sorts of properties might be because there's so many different things at play then this evolutionary system is probably more useful or interesting to watch okay I'm going to go back I think we've now actually done everything but add to evolution okay look so this one has survived quite a long time it hasn't died it weirdly enough it's got this big perception radius for the poison but a very tiny perception radius for the food but there's here's the thing there's just so much food right I'm adding new food randomly but I'm not adding new poison randomly and there's only three poisons oh we've got it we've got to first make this a little bit harder for them so we're almost to the evolution let's make this a little bit harder and let's add let's say there's a 5% chance of every frame adding a new piece of food let's make there a 1% chance of adding a new piece of poisoned piece of poison every frame so again there's a probably much nicer way I could write this and we capsulate that into a reasonable function but we'll keep that for now so let's run this again and let's just let this go for a little bit I know maybe I'll edit right now and come back in a minute I'm going to edit and come back in a minute okay I'm back and let this run for a while and this seems to be the one that's survived and you can see that it's certainly got a optimal quality that I had described which is the ability to see the food farther than it can see the poison on the one hand I think it's just so much food for it because it looks like I don't see any red line coming out of the back I think it's barely not attracted to the poison but at least it's not attracted to it like it's not forward unless although it's drawing the red and the green I'm you know one thing that might be doing is drawing we're not able to see I'm drawing red and then green so there's an issue with my visualization let's fix that I think they're going to be a part four which is adding the evolution try to fix up some stuff right so I think there's a little bit of an issue here which is that I didn't really think about when I'm drawing my debugging stuff I draw the green stuff and then I draw the red stuff so interestingly enough that's not the problem I think it's weight is actually zero but as a little worried that if it has a forward fit you know I probably should do the green just go say the green is like stroke weight three just for the line and then the red has stroke weight everything else stroke weight too because then I should probably be able to see like if I can I can see like if they're both there the green kind of peeks out a little bit behind so that's sort of good to say oh so nothing survived there so I'm assuming ah something like got to run this a few times this one looks pretty good although I would prefer for it to the red to be sort of it that's it okay let's try to make it a little bit harder this one is this one looks great let's try to make it a little bit harder for them let's go back to the health in update boy up going down a little bit faster now okay and let's let's give it just to start a little bit less food and a little bit more poison so let's see and let's run this okay let's see if anything survives and then we're going to be ready nothing survived let's try to get because I only right now here's the point I got to talk about why we do watch what why aren't I done well if I could just make millions of these and put them into a really large world maybe there's like so few parameters here that the optimal one might just kind of appear but the reason why I want to use evolution is only just starting with like ten of these or twenty of these and I want to be able to allow them to create copies of themselves to pass along their genetic information to the next generation so to speak and to have this possibility of mutation when they do that so maybe one that's doing a really good job but you know so it's copying itself and every time we copy itself it like it makes its read weight a little bit bigger or it's read weight a little bit smaller so it just makes subtle little tweaks and then those copies are better and so over time the ones we might hopefully see a sort of optimal result okay so I'm going to add that feature to this in the next part what part of my on the fun part 3 part 4 will be the final part where I will add the evolutionary aspect to this particular coding challenge and sort of talk about what it is and some future possibilities for you so see you in the fourth part you