hello again okay welcome to this second video in my new series about genetic algorithms and evolutionary computing in general so in this particular video I am going to talk through the actual algorithm itself now if you can't remember what I'm using as my demonstration to demonstrate this idea of a genetic algorithm I'm looking at the problem of finding the phrase to be or not to be that is the question in a sea of random to be or not to brand phrases so to demonstrate this idea I have this particular p5 sketch running in the browser and it's just generating random phrases over and over again randomly now at some point after some gajillion Gillian Gillian gajillion amount of years we might movie could happen right now this could be the moment where we could be so unbelievably lucky and we just all go by our Powerball tickets we're to be or not to be actually uh appears right here but I would I'm pretty sure that it's not going to so this is the bruteforce problem the solution to this bruteforce problem I'm going to refresh this here is to use a genetic algorithm and you can see that this is now the example that I'm going to get to of the genetic algorithm running and you can see it took you know a matter of five to ten seconds to find this phrase to be or not to be that is the question it took a number of generations there's this concept of fitness there's this idea of a population there's this thing called a mutation rate so this is what I need to cover what are all the pieces of the genetic algorithm how do they work what is the order in which they happen and then after I do that we'll start looking at how all those things are implemented in actual code and I'll look at both JavaScript code that you can run in the browser as well as Java code that you can run in the processing programming environment okay so um coming back to the algorithm let's check out our car by the way so this by the way I'm just letting this run in the background you can see that these cars from boxcar 2d are really evolving quite nicely I would have credit whoever made boxcar 2d because I really love this project so I don't know it off the top of my head so I'll mention it in a future video and I'll make sure that it's in the description of this video but you can also go to the website itself and find it okay so we'll check back in on our cars in a little bit our cars but right now I want to go back to this kind of presentation so now I don't usually use slide presentations of my videos so feel free to complain in the comments if you want to but before I even get to the algorithm itself I want to talk about now I want to mentioned something as with most of my videos that are part of the nature of code series I'm doing a thing where I'm kind of saying you know this nature stuff this physics stuff this biology stuff it's really interesting and I want to be inspired by it and try to kind of approximated in software to create compelling and interesting and unique creative projects but I'm not actually here saying to you I'm a kind of like formal rigorous scientist who's trying to do a formal experiment about evolution and you know model evolutionary processes precisely in software to study some type of actual biological process the idea of the genetic algorithm is simply like this idea inspired by actual effects but based on a true story this genetic algorithm takes ideas from actual biological evolution and applies them in software but you know I'm just one of the sort of a disclaimer saying I'm always kind of scratching the surface of actual the actual topics of genetics and evolution but if you read Darwin there and think about Darwinian natural selection there are three key principles that need to be in place for evolution to happen and those principles I want to make sure are in the genetic algorithm that I demonstrate to you so first I want to just talk to you what those principles are the first one is per editing so if we're going to have this idea of elements of a population that evolved from generation to generation there must be some mechanism in the algorithm in our code that allows data from one generation to be passed from one to the other so that's one thing that's going to have to be there variation right let's say I want to evolve whiteboard markers and this is my population of whiteboard markers I only have blue ones and these whiteboard markers are going to somehow make children whiteboard markers this is getting a little bit weird but the point is there's no variation here these are both blue so they could make a child and pass down their traits their data to the next generation and they would be blue and then there'd be more blue in there more blue and I want to have some pink ones and some purple ones some orange ones and all the colors with the rainbow I'm off track here but you get the point there's got to be some variation and what's the mechanism in order for there to be a variety of traits either in the population when it starts or as the population involves over time so that's another key principle variation the last principle which must be present in the genetic algorithm is selection selection there has to be some way of saying here's my I can't believe I was using white board markers I should have thought about this in advance and brought some like stuffed stuffed animals have been great lots of stuff that would have also been weird stuffed animals weird yeah okay but anyway this is my population of white board markers right if I ever if I just say every single one of these white board markers has an equal chance of passing its genetic information down to the next generation next generations next generation oh my god then there really won't be evolution at play because nothing will the the makeup of the population the quality of the population will not really change over time however if I were to say something like brighter colors or more likely to have their genetic information passed to the next generation then I might be more likely to pick red or more likely to pick this green I don't have any bright colors darker colors whatever the point is that there must be some product of a process of selection I just read this to you mechanism by which members of the population have the opportunity to be parents at best so this is by the way typically refer to as survival of the fittest right this idea of fitness and this idea of Fitness will play a big role in the genetic algorithm and fitness will actually become a mathematical function which is somewhat absurd and not how think things don't work in the real world really we're all walking around with a hat on and then there's a number on our hat that gives us it says our fitness as a numeric quantity and the higher our fitness is the more likely we are to pass our genetic information right but this is this idea of this kind of almost cold algorithmic version of this kind of beautiful and amazing natural process I'm using some mathematical function to to to design to calculate fitness okay so this is the idea we must make sure these three principles are present in the genetic algorithm so I'm going to come up that's our car we're checking on our car again it's not it's not one car by the way it's been actually maybe it is I wonder if it pauses actually when I take the window out of focus but whatever it is it's certainly evolving to do cool and amazing things I want to go back to this so I want to talk through how this algorithm works and I'm going to use natural selection to pick this purple marker and then I have to press a button but that button to come over here and let's talk about now what I want to do I really want to use unicorn but unicorn is too many letters in it also maybe I could use I'm going to use unicorn gosh darn it I always just use cap let's just say we want a simpler phrase to Yvonne could use rainbow by the way but I'm going to use unicorn I want to evolve the phrase unicorn out of every single pod summary a phrase the word the sequence of characters unicorn out of every single possible random sequence of characters so the very first thing that I must do in a genetic algorithm in the traditional computer science genetic algorithm I don't know I just said computer science I have to put like a quarter in my computer science jar I love computer science this is just not a computer science YouTube channel it's something else I don't know what it is okay um step one is create a create a population I'm going to write just popped for short can you read this create a population of n elements and let's remember also down here what are those three principles I must have heredity I must have a variation and I must have selection I'm disappointed with myself I wish I had written variation first in this order because ultimately this is where we get in this step we get our first principle variation now the way I wrote this create a population of n elements I don't necessarily have variation there yet I really should say create a you know random and I think this might be cut off at the top but I just wrote the word random there create a random population of n elements and really I didn't write that very well I should say create a population of n elements with random genetic material now what is this genetic material this idea of like sort virtual DNA digital DNA we're gonna have to look at how that's encoded in code and stuff later but you can think about it again what what let's think about it in the context of trying to evolve this phrase unicorn the population might be a whole lot of seven character words with random characters like Yuna Jorm and cake has the right number of characters ah this is really much harder than I thought it would be I think I might have to anyway so you get the point right this could be our population Yuna Jorma pancake and ah bug dude so this is a population has variation now does this have enough variation with this idea that we're going to somehow mix and match these four over generations could I actually get I have you I have a/c here but I've nothing with an O in this spot nothing with it are oh maybe I do have an R nothing with an N in that last spot so the variation there's going to be there's more to variation than just that initial population which I'll get to but that's sort of a key principle okay so that's step number one great and actually you can think of this in this sort of p5.js and processing world of we have a sort of initialization and then a forever loop this step one is actually the setup function this is what will happen in the setup function okay step two which I'm going to draw a line here because this is what's going to happen in the draw function meaning step two is going to happen over and over and over again jet for generation generation generation evolving evolving evolving step two a is calculate fitness for you know n elements so we want to calculate the fitness of every single member of the population this by the way is playing role now this idea of selection Fitness is going to be a means a mathematical function to determine which members of the population are more likely to be selected to pin a pass their genetic material down to the next generation so that's this idea of calculating and fitness so there's going to be some sort of loop that will go through all the elements of population call a function that will calculate the fitness and give you some number back so let's think about what could be so so one of the key factors in a genetic algorithm is the Fitness function so what could be think about it what could be a fitness function here for this particular problem well I have these three my population has three elements instead of n it's three right and I could calculate the fitness for these I could say the fitness function for each element of the population is the number of characters that match the target phrase one two three four five so this has a fitness of five one this is a fitness of one oh boy this one's a terrible this is a fitness of ceará okay might it's a different example in a second I got one for you a pop corn and this one has a fitness of four there's actually gonna work out beautifully for me so Yoona Jorm pancake ah and popcorn hopefully I did that right so you can see that these all have a fitness score now ultimately there are many things that one needs to do to refine fitness and make a genetic album perform more efficiently in faster or less fast or whatever but this is kind of a simplistic version of fitness function okay great now what we now need to do is this so that's step a the next step I'm really just going to call kind of reproduction or selection I think actually the sort of whole thing is that so this step B has now two parts to it a B a lowercase a B one I don't know whatever I have a terrible numbering system here but the first thing that we need to do this also needs to happen n times so what needs to happen n times and that says reproduction section that should say excuse my hand your selection the ultimate goal of this genetic algorithm is to end up with another population of n elements right this idea is we start with this random population we calculate their fitness this next step of reproduction at the end we should have a new population of n elements and then go back to calculating their fitness again and doing this over and over and over again their fitness scores over time should be getting higher and higher and higher as a whole as a population whole so this reproduction selection step is a multistep process the first thing that I need to do is pick two and for lack of a better word I'm going to call them parents and I'm is somewhat arbitrary so there's a lot of parts of this genetic algorithm that you can kind of play around with certainly you say that the way that reproduction works in your genetic algorithm is a single element just makes an entire copy of itself another way of saying that is that two elements come together and mix that genetic information and make a new member of the population you could say that three elements come together this is all just sort of made up as an algorithm and you might have some kind of creative takes on this but the sort of classic genetic algorithm kind of follows this idea of two parents so how are those two parents picked well this is an interesting thing and by the way we're really talking about selection here we're now in the third principle here the way that those two parents are picked there's a bunch of different ways by the way first of all you could just say you know what I'm just only going to ever pick the top two scoring parents so I'm going to pick unit Jorm and popcorn and I'm going to make all the children from you know joram and popcorn and we're going to have a lot of popcorns I love pop joram it's my favorite snack pop door and pop joram gonna mix those two up and make a lot of you know Jordan popcorn children but really pancake even though it only got a score of one we wanted a different way of doing this a kind of better those sort of more traditional way of doing this with a genetic algorithm is not just to pick the top two to actually pick from the entire population but assign the probability of an element being picked to its fitness score so the reason why these numbers worked out so nicely is I could write them a different way I could say fifty percent forty percent ten percent zero percent so you could think of this as possibilities what I'm going to do is I'm going to pick out of a hat and add out of that hat I have a fifty percent chance of picking unit germ it's going to be picked five times as much as pancake popcorn is going to be picked four times as much as pancake so I could use those Fitness scores to assign them to probability another way of thinking about this I've kind of run out of space on this white board but I'm going to use this spot right down here is I could think of a kind of wheel of fortune' spinning wheel so unige or gets 50 percent of the pie popcorn gets 40 percent of the pie this is pop born this is uniform and this is pancake so the strangest breakfast ever and you could think of this sort of spinning wheel here so I'm going to spin the wheel and I move most of the time it's going to land on you to joram some mores often also land on popcorn but every once awhile to land on pancake and that's how I'm going to pick those two parents so the higher the fitness the more likely that element is to be selected so that's step one once I have those two parents I'm going to make a new and I'm using the word element just to be like sort of word for a member of the population to creature element thing but I'm going to make a new element and making the new element is a twostep process one step is called crossover and another step is called mutation and this is by the way where we get our last key principle from Darwinian evolution so we had variation because we create an initial population of random elements we have a selection in that we calculate the fitness of each element and we use the fitness as a probability it's sort of selection probability it's probability being selected as a parent and now to make that new element we have to have some mechanism by which the genetic information of one element gets passed on to the next generation so I'm going to come back up here this is my weird paper towel white board eraser slightly wet with water because that seems to work well and I'm going to describe to you the technique of crossover so let's say we have unige or and we have popcorn right I don't know why I drew this line here right these are two members of the population the mechanism of crossover says take half of the genetic information and the genetic information is really just this sequence of characters take half of the genetic information from one like uni and then take half from the other there seven so I'm splitting up three and four take half of the other like corn combine those two and look we get unicorn now of course that's not going to happen magically instantly with the first two things you pick on this is artificially designed to give me the right answer but this is the idea here that to make the new manager the population you take to that got a high fitness you combine those taking two with a high fitness to make a new one you have a good chance of getting a child with an even higher fitness score for that next generation so this is the idea now there's a lot of different ways that you can do crossover you can actually just pick a random mid point so sometimes you just take one from the other and six from one or five from one and three from the other you could do something where you're like alternate take you than oh then I then see right or you could flip it you can have a 50% probability for each one you could you know you could turn this into binary information and mix up the zeros of the ones and then convert those back into characters there's all sorts of ways that you could do crossover but you'll see what I'm doing it in my example which is kind of a you know conventional way of doing it is picking out midpoint taking half from one and half from the other and as you'll see these characters are stored in a right that's what I'm going to get to it soon as soon as we look at the code so that's crossover now we could say that I'm done this is it this is a genetic algorithm make the random population calculate all the fitness create a new generation with crossover calculate the fitness again create a new generation crossover calculate the fitness again create a new generation to crossover over and over and over again we that could be it however there's a problem in the key in the case of not having enough variation in the initial population which is quite a reasonable thing to have it is often useful to artificially introduce additional variation into this process so two members the two elements of the population are combined with crossover but before that child is finished a mutation is applied and mutation is typically referred to yeah as a sort of percentage rate so I might say there's a 1% mutation rate that means for each one of these characters that was that was selected that was combined with crossover there's a 1% chance that I'm actually going to mutate these characters what is mutating mean it could be that I just pick a new character it means that I could go up or down in the alphabet in this case none of that would really matter my mutation is just going to say 1% chance that a random character is selected instead of the character that comes from crossover and this keeps variation in the system this mutation rate as I'll show you in a little bit when I run the example again really really affects how that how the algorithm behaves is there a lot of randomness less randomness that sort of thing so this really completes the genetic algorithm this is the fold we have heredity as part of crossover that's the mechanism of heredity we have variation in the way that we create the initial population and the way that we use mutation ask that last step of making the next generation and selection as this way of calculate using a mathematical function to assign a fitness score to each element of the population as well as as well as that using that Fitness score as a probability for a probability for what how that how that element of population whether or not will be picked as a parent for to pass this genetic material down to the next generation so I'm in the next video I'm going to say a few more things but and then I'm gonna save looking at the code for the next video so I've been moving a fan here in this over here um so I'm gonna come back over here oh my computer went to sleep come back there it is so I want to run this example actually let's check on the car again and let's think about this for a second what are some of the steps of the population here so you can see one thing that's a little bit different is it's kind of doing them all one at a time so we're seeing one member of the population but you can sort of think of certain pieces here like what is the fitness function in this particular simulation I would assume the fitness function which you can see here is represented as score none of these have really gotten a score yet come on let's get so you can see it got a scores probably how far did it travel in a certain period of time so that I would soom and you can see as the score for these so that's one thing then so you could see like as you look at any example of a genetic algorithm as it applies to evolution you can find the pieces of the algorithm so let me let me just look here and see how did we do here this is a representation of the algorithm you can freezeframe this if you want it's also on the nature of code website but you can see this is basically everything describe to you step one is initialized create a random population of n elements each of the random DNA step two a selection evaluate the fitness of each element of the population then step three is reproduction pick two parents apply crossover apply mutation add the child to the new population and then step four is replace the old population with the new population and return to step two so setup this everything happens initialized draw happens over and over again and this is what I'm gonna look at in the code in the next example great so actually I'm gonna I'm going to end this video now I'm and in the next video what I'm going to do is look at how the code works play with some of the parameters and see how the genetic algorithm behaves okay thanks for watching