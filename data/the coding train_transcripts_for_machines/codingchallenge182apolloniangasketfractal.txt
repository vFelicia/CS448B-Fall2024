It's frozen. No. No. No. No, wait. Please, I don't want to lose all my code. [SOMBER MUSIC] Oh, god. [MUSIC PLAYING] Hi, everyone. It's Pi Day. I've been making videos to celebrate the number pi on March 14 for quite a number of years now. Typically, I'll do something where I'm trying to approximate the number of pi, or even do some kind of visualization of the digits of pi itself. This year, I'd like to just celebrate the circle for Pi Day. I've been working very hard on the new version of The Nature of Code book, published by No Starch Press, coming out this summer. Preorder today. Read the whole thing online today for free as well. And my coding challenges in 2024 have been extensions of topics in that book. So I thought for today I'd like to take a look at a particular fractal pattern called the Apollonian gasket. When I first saw this, I thought, great, this could be a nice extension, exercise, additional example for chapter 7 in The Nature Of Code book, all about fractals. It'll be easy. See now, you draw a circle in P5 and do a little recursion. You put some other circles. I've also done videos on circle packing before. Easy peasy, lemon squeezy. No problem. I like to not try to do too much before I come here and record the coding challenge. But you know, I should do a little reading, reading up on what the Apollonian gasket is, its history, what's the math behind it. There's a wonderful article here by Dana Mackenzie in American Scientist that was a terrific reference. This set of blog posts from the Math Less Traveled from 2016 on the Apollonian gasket was very helpful. I wandered into this paper called Beyond the Descartes Circle theorem. And then I started to realize oh, no oh, no this is going to be a lot harder than I thought. But guess what? Bonus for you. In this video, you will learn about not just the position and radius of a circle, but something called the curvature or the bend and how that relates to something called the Descartes theorem. And then I might even wander into using the Descartes theorem, but applying it not just with numbers but with complex numbers, imaginary numbers. And so we're going to have to solve/use the complex number Descartes theorem. This is probably going to go off the rails. But if I can make that Apollonian gasket fractal, hopefully you'll have learned something new about math. And you might be inspired to make your own artistic version of this fractal, varying it with color or some other kind of shape, or tweaking the algorithm however you want. And muah, won't that be a wonderful celebration of Pi Day. Strangely enough, this all begins with a poem, a poem by Frederick Soddy, an English radiochemist who won the Nobel Prize for chemistry in 1921. Frederick Soddy was fascinated with something called Apollonius' problem, named for Apollonius of Perga, the Greek astronomer. Let's say you have three circles, any three circles, nonoverlapping. How could you find a fourth circle that is tangent to all three of these circles? Two circles are tangent if they meet at a single point along their edges. And that tangent can be expressed as a line. This is actually referred to as a kissing circle because they're like, [KISSING SOUNDS] I love you circle. And there typically isn't just one solution to the Apollonian problem. Let me try to draw one in here. No I can't. I'm not really drawing this correctly, but you get the idea. Maybe I could also could I get a circle that kind of like This is also tangent to this circle, this circle, and this circle. The solution to this problem lies in something called Descartes' theorem. Soddy rediscovered Descartes' theorem independently in 1936. Found it so beautiful, he wrote an entire poem about it. The Kiss Precise. For pairs of lips to kiss maybe involves no trigonometry. 'Tis not so when four circles kiss, each one the other three. To bring this off the four must be as three in one or one in three. Since zeros bend's a dead straight line and concave bends have minus sign, the sum of the squares of all four bends is half the square of their sum. Kiss the other four the square of the sum of all five bends is thrice the sum of their squares. So the problem of Apollonius is for any three circles. But Descartes's theorem, and as it relates to the Apollonian gasket, is actually a problem that's for a more specific scenario, where the original three circles are mutually tangent. I'm going to begin by drawing a kind of classic example of three mutually tangent circles that is symmetrical. And this is going to be terrible, but I'm going to do my best. The first thing that I need to define for Descartes' theorem is this idea of the curvature of a circle. Now the curvature is the inverse of the radius. A smaller circle is going to have a much tighter curvature, whereas a bigger circle has a much wider curvature to it. So curvature, typically written as K, is equal to 1 divided by the radius, and vice versa. The radius is equal to 1 divided by the curvature. Now the curvature, however, is signed. It can be positive or negative. The radius, of course, is always positive. So we might say, the radius is equal to the absolute value of 1 over the curvature. Now what makes the curvature positive or negative? I mean, all the circles, they bend the same direction. Well, this particular circle, which is an outer circle it is enclosing these two circles has a negative curvature, whereas these two circles here have a positive curvature. If I were to draw three mutually tangent circles where none of them enclose each other, they would all have a positive curvature. Here are three mutually tangent circles, all with a positive curvature. So what is Descartes' theorem? And how does it relate to the Apollonian gasket? The process for drawing the Apollonian gasket is to start with your three mutually tangent circles and find their fourth, the kissing circle. What is the fourth circle that is mutually tangent to all three of these? Well, once again, there's more than one possibility. Now if I found those two, what if I took all the triplets that are available to me here and found the fourth mutually tangent circle that goes with those? Maybe I'd find one here, and here, and here, and here. And then I might find one here, and here, and here, and here. So I've done a rather poor job at drawing the Apollonian gasket. But you see how you are recursively finding the next circle and the next circle that is mutually tangent to triplets, the triplets that you're creating through this recursive process. Descartes' theorem is expressed in the poem as the sum of the squares of all four bends is half the square of their sum. So if this is circle 1, 2, 3, how do I find circle 4 that's inside there? The sum of the squares of all the bends is equal to 1/2 of the square of the sums. So if I could somehow take this equation, knowing the curvature for circles 1, 2, and 3, could I solve for curvature 4? K4 equals what? This is a quadratic equation. It can be solved. It will, as you see, have multiple solutions. I'm not going to derive the solution. But I will put a reference hopefully I can find one that shows the derivation of the solution. Let me show you what it is. Curvature 1 plus curvature 2 plus curvature 3 plus or minus multiple solutions the square root of K1 times K2 plus K2 times K3 plus K1 times K3. No more question mark. So this is now something we can actually start to implement in our code. Whoops, I forgot about the 1/2 here. So plus or minus 2 times the square root of this summation. How long has it been in this video and I haven't written any code yet? Don't worry. Now's the time. The first thing that I want to do for this is create a circle class. The circle class will hold on to the position of the circle, its radius, and its curvature. So if I'm giving it a bend, its radius is the inverse of that, or the absolute value of the inverse of that. Let's write a function for the circle to draw itself, make sure I add it to the HTML file. And let's create three circles. What should their curvatures be? Well, on this diagram of the Apollonian gasket, this is one of my circles, this is one of my circles, and the big circle is one of my circles. So if the radius of this circle was something like 200, the curvature would be 1 divided by 200. But remember, the outer one is negative. And then the inner ones would have a curvature of 1 divided by 100, 1 divided by 100 if they're half and they're positive. So the curvature is negative 1 divided by 200. And it's x, y is at 200, 200. And I'm just hard coding this now. Later, it's my goal to create a random arrangement of three mutually tangent circles. We'll see how well that goes. But I'm just going to hard code an initial location that is kind of a classic version of the Apollonian gasket. Where are those circles? Oh, I have the background in draw. Let's get rid of that. There we go. There are those three circles. Now let's see if I can write a function that will calculate that fourth curvature, passing in the three circles. And eventually I might want to work with arrays and kind of store the circles in different ways. But this should be good enough to get me started. Now it's time for me to take that formula on the whiteboard and implement it here. So first, let's get K1, K2, K3. Let's divide the formula into two parts. First, the sum. Let's call the second part I don't know the root because it's the square root of the products of the different curvatures. And I need to multiply it by 2. And now I need to return the sum plus or minus the root. How do I return a value plus or minus? Well, I could just return both values. Let's at least see if the radius that I'm getting back from the function is approximately the right side. I mean, the really complicated part here, that I'm going to get to soon enough, is to figure out where the circle goes. But for right now, all I need to do is check the radius. So radius 4 is the absolute value of 1 divided by the fourth curvature. And if I were to just draw a circle at mouse x, mouse y with radius 4 times 2 and I guess I need to put this into draw. And these circles will need to be global variables. What am I missing here? Not a number. Oh, right, of course. I've got to pick one of them. I went through this whole thing about how I'm returning two values. And I need to have two r4s. So r4 could be let's just pick 0. Let's just pick that first value. And we can see, does this circle fit there? Look, it fits there. So I definitely got the radius right. Let's look at the second value. Second value is also the same. So that's good to see that I'm getting both. The correct values, probably one is going to go down here somehow. And one is going to go up here. So if I have a function it's called Descartes here and it returns the curvature for all possible fourth circles, all I need next is a function that returns the position of that fourth circle or all possible fourth circles. This is where things get a little bit extra hairy. The solution to finding the centers of those circles is in this paper Beyond the Descartes Circle theorem. Right here at the beginning, you can see how the authors are referencing the Descartes theorem. The bends, the curvatures, satisfy the relationship where the sum squared equals 2 times the sum of the squares. In this paper, they show if you take the centers of those circles, express them as complex numbers, they also have the same relationship, essentially yielding what could be called the complex Descartes theorem. Now I'm not going to prove this or derive this. If you want to go deeper into the math, this paper will have that for you. But let me just explain to you what a complex number is and how I can take the Descartes theorem and solve for an xy pair instead of a single curvature value. A complex number is a number that has a real component and an imaginary component. What do I mean by imaginary? Well, hold that thought. It's written in the form a plus bi. And "i," like imaginary, is a representation of the square root of negative 1. Now the last time I probably referenced complex numbers was maybe in my Mandelbrot set coding challenge or perhaps the Julia set coding challenge. And remember how I was really in love with talking about imaginary numbers and playing around with the idea of them being imaginary. But it's a little bit of a misnomer. This is very much a number, a kind of number incredibly important in all sorts of applications of mathematics. And it is necessary when solving certain kinds of polynomial equations, especially if you've got something like x squared equals negative 1. How do we express the solution for an equation like that? What is kind of magical here is because a complex number has two components, A and bi. This a and this b can be mapped to what's called the complex plane. This might be aaxis. This might be the baxis. So if I put a point over here, maybe it's the point 5 plus 4i. Well, this might look kind of similar to you. I mean, aren't we in a p5 canvas? And maybe I have this point here, which is the xy point, 200, 200. Why not express that as a complex number where x is the real component and y is the imaginary component? So this point could be expressed as 200 plus 200 i. So this is the Descartes theorem, which expresses the relationship between the curvatures of four mutually tangent circles. Well, it so happens, if I think of the centers of all of those circles expressed as a complex number maybe I'll call them z1, z2, z3, z4, each of these being of the format x plus yi, x plus yi. This would be x1 plus y1i, x2 plus y2i. The same equation applies if I take those complex numbers and multiply them with the bends. So in other words, the product of the bends and the centers satisfy this exact equation. Let me try to write this out. Z1 squared times K1 squared. This is the new equation. So what's known? I know z1, z2, z3. I know all of the curvatures. I even know k4 because I was able to solve for the fourth curvature through the regular, oldfashioned Descartes theorem. So now all I need to do is somehow solve this equation for z4. Again, not going to derive the solution. I'm just going to write it out for you. Here we go. I just spent some time staring at the Wikipedia page. We'll see if I remember it. z4 equals the sum of the bends times the circle centers plus or minus the square root of the products of all that stuff, like before. [LAUGHS] I got to go look at it again. The curvatures times the centers plus the curve all the configurations. Plus or minus 2 times the square root of z1k1 times z2k2. I'm just going to write it this way k1 times k2 times z1 times z2 plus oh, no, I'm going to run out of room plus k2k3. Oh, no, no plus there. These are all multiplied. Then the whole thing divided by the fourth curvature because, remember, we're kind of solving for what's over here. So this whole thing divided by k4. So all we got to do is put this formula into our code. Easy peasy, lemon squeezy. We've got a bit of a problem, though. Look at my beautiful function for the Descartes theorem. It uses the plus operator, and the multiply operator, and the minus operator, because I'm just taking a number and multiplying it by a number, and another number, and adding it to a number. You can't do that so easily with complex numbers. In fact, I'm using the square root operator. How do you take the square root of a complex number? This is going to require at least 5 to 10 minutes of this video, just to implement that math. And the way that I'm going to do it is much like there's a p5 vector class in p5, which stores an x and a y and performs all sorts of vector math. I'm going to create a complex number class. And I'm sure I could use one like get one from some JavaScript library. But I think it's worth just quickly, "quickly" implementing my own. So this is the core idea of a complex number. I need to have both the real component and the imaginary component, a and b. The first thing that I might do is write an Add function. And I think what I'll do for ease is every single one of my functions will return a new object instance. So let's start with the Add function. That's the easiest one. And I'll use the word "other" for another complex number. So what do I need to do? Return a new complex number, which is this dot a plus other dot a and this dot b plus other dot b. This is adding two complex numbers together. Let's do a subtract. Let's do a scale, which is different than multiply. I'll get to that in a second. But let's say I want to just take a complex number and I don't know multiply it by 2? So I'm scaling it by a value. And that is a new complex number with this dot a times that value and this dot b times that value. I'm doing the easy ones first. OK. Let's do multiply. This is where things get a little bit tricky. And we need to return back to the whiteboard. Now you might be wondering, why can't you just use p5 vector? After all, you're storing a complex number, like you're storing a vector. And p5 vector already has functions like multiply and add. And this is why. It's this pesky little square root of negative 1 thing. So let's work out the math. And I've done this before, I think, in the Mandelbrot video. But let's do it again. A1 plus b1i times a2 plus b2i. This would be multiplying two complex numbers together. So a1 times a2 plus a1 times b2i plus b1 times a2y. So I'll say a2b1i. Did I say "y" when I meant to say "i?" And this is b1 oh, this is hard plus b1b2i squared. Remember, i is the square root of negative 1. So what's i squared? Negative 1. So this is actually a1a2 minus this turns into a minus because I take i squared minus b1b2 plus look at this a1b2, a2b1i a1b2 plus a2b1i. So this is my new complex number. This is the real component. And this is the imaginary component. This is how I multiply two complex numbers together. Now when I go back to the code, remember, it's not a1, b1, a2, b2. It's this dot a, this dot b, other dot a, other dot b. Let's see if we can make that happen. Now let's do multiply other. So let's just say the a is this dot a times other dot a minus this dot b times other dot b. And then the b is this dot a times other dot b plus other dot a times this dot b. Then I'm returning a new complex number with those a and b values. I have a plus for complex numbers. I have a scale for complex numbers, for a complex number times a scalar. I have a multiply now. I don't have a square root. How do I do the square root of a complex number? I think that since this is a video for Pi Day, we should use this formula because it's taking the complex number and converting it from rectangular form to polar form. So the idea here for taking the square root is if this complex number, instead of thinking of it as a comma b, I think of it in its polar form, where I have some magnitude I'll call that m and some angle I'll call that theta. Well, if I take this, I can find the square root by taking the square root of the magnitude and then half the angle. That works out. So in my code, square root. I first need to convert the complex number to its polar form. So in that sense, I would say let m, its magnitude, equal the square root of a times a plus b times b. Then its angle and this, by the way, is where I could use p5 vector. Its angle is equal to a tan 2, the inverse tangent this function is beautiful I've explained it in Chapter 3 of Nature of Code happy Pi Day, everybody of b comma a. That would be the angle. Then I need to say, the new magnitude is the square root of that magnitude. The new angle is that angle divided by 2. And then I can just say, return a new complex number with m times cosine of that angle, m times sine of that angle, converting it back to its nonpolar form. If you don't want to rely on my code, you could use this Complex.js library, which has a lot of complex number arithmetic already done and completed in JavaScript. I should probably be using it. But, you know, I like to learn this stuff, like get my hands in as much as possible. Now that I have a fully functional complex number class, I can adjust my circle class to store the xy center in a complex number. I'll call that center. What broke here? Oh, it's a and b. There we go. OK. I am ready to implement the complex Descartes function, which will take in three circles plus the curvature for the fourth circle and calculate the xy position of that fourth circle. And I'll use that same notation with z. All right. I need the sum and the root again. But I have to use the complex number math. And actually, if I'm looking at this formula, z1 through z3 are only ever used in combination with multiplying it by their corresponding curvature. I'll call it zk1. So zk1 is equal to z1 scale by k1. OK, so let's do that. Zk2, zk3. Then the sum is equal to zk1 add zk2 and I can chain these add zk3. So this right here should be now this part of the formula. Next, I want to do this part of the formula. So the root is equal to zk1 multiply zk2 add oh, god zk2 multiply zk3 add zk1 multiply zk3. OK? I think that's right. So this I know it's a little bit hard to look at but this should be everything that's in here. Now I just need to take the square root of that and multiply it by 2. So I should say root equals root square root. And then I need to multiply that by 2. And then I need to get the plus or minus. So I have two options. Remember down here when life was so simple, I just said some plus root or some minus root. So those are my two options. I have some add root or some subtract root. But then I also need to divide both of those by k4. So that would be, scale those by 1 divided by k4. These are my two possible complex numbers. All right. One issue right now is that k4 is actually two values. So let's pick one of them. I need the center for the new circle. We'll call that z4, should equal complexDescartes c1, c2, c3, k4 index 0. So I'm just going to pick it with one. And then I should be able to say z4 dot a, z4 dot b. Oh, what's the chance? What's the chance that works? Darn. Oh, well, that needs an s. Oh, this dot. This dot. It's been a while since I made a good thisdot mistake. OK, I still have an error down here. OK, console.log z4. Let's see what we got here. oh, because I got two of them. I forgot that I'm getting two for everything. And let's look at both of them. Let's put in no loop. Not a number, not a number. OK, so something went wrong somewhere with my complex number math. Probably, this is a good reason why I should have just used an existing complex number JavaScript library. But let's see what I can figure out. Oh, mult, mult. It's scale by 2. It's not multiply by 2. It's scale by 2. There we go. Look. Look. There's a circle in the right place. I've never been so happy to see that before. Woo, that was exciting. OK, we're getting somewhere. It was just a simple error. I used multiply instead of scale because it's scaling by a scalar not multiplying by a complex number. I really should be now finding both circles. I guess I could return two complex numbers. What if I give it k4 that's an array with two options. And then my complex oh, my god. oh, but I'm already getting two back. Wow, so there's actually four possibilities. Let's just do it twice. So let's get z4. I'll call it z40. And I'm going to send in k4 0. Oh, look at this. Look at this. I had a mistake there. I put a 4 instead of the k4. But now that I'm realizing it, it would make more sense to just return all four of them as an array. Let's see. So now I can put this one in here with add and this one in here. So I can get all four in this way. So I think this is going to make more sense, that basically I'm getting the two components of the formula, the sum and the root. Then I'm going to plus and minus those. So I have two possibilities. And then divide it by both k4 0 and k4 1. This is much better because this is just giving me all four. And now I can actually just say this. And this is kind of like all centers. All centers is the result of the complex Descartes function with all three circles and both possible bends. And I wonder if what I can do is like unpack those. I've got an idea. I want it an array because I'm going to say, let c of allCenters. And then what am I going to do? I'm going to make a new circle, equals a new circle with k4 index 0. Do I do all the [INAUDIBLE]? I'm so lost here. This isn't going to work. You know what I should do? Let's actually make the circles in the complex Descartes function because I need to know which bends go with which circles. So if I go back here. What I'm actually doing is I have four centers. I'll call those c1. Those are all my centers. Oh, I already used that variable. OK. Now I need to return an array of four circles. New Circle k4 0 with cente1.a, center1.b. So k4 0 goes with these first two. And these go with one. These are all the possibilities. So now I'm actually returning the four circles. Where I got them now I should be able to say, allCircles I could obviously loop through it. But I just want to look at them one at a time. 0 dot show. That one. All circles one dot show. That one. Hey, those are the right two circles. So then I don't want the other two. Oh, that one's maybe one of the same ones? Oh, actually, maybe I'm fine. They're just duplicates. Good work, everybody. They're duplicates. I think that I am through with the hardest part of this video, which was all of this math. And now the problem becomes, once I have the two new circles, I just need to look at all of the new triplets of three mutually tangential circles and get the next new circles, and so on and so forth. This is where the recursion comes in. This is where I'm more connected to chapter 7 of The Nature of Code. Now recursion can be done with a recursive function. And that's what I use in many of the fractal designs that are outlined in that chapter. What I think I'd like to do here instead, though, is use an array as the kind of foundational data structure for the recursion. So if I somehow had an array acting as like a queue of all of the possible triplets that I need to evaluate, then I could run through all those, throw it away, make a new queue, and keep going. So essentially the array is the recursion. Everything in the array will get processed, which will make a new array, which will get processed, which will make a new array, which will get processed. So that means, what I actually want to do is create an array called allCircles. And I'm going to push these circles into that array. You know what? I'm going to keep the c1, c2, and c3 because I'm going to need to make the queue as well. But I'm going to make those local variables. So all circles should get c1, c2, and c3 to start. And then the queue I need a queue. This is where it's connected to more to things that I've actually done before. The queue should have in it all the triplets, which is only this right now. So it's going to be an array of arrays. And let's just comment this out for a second. The same math is going to apply, but I need to figure out how to process that array. So the first thing I'll do is just in draw I'm always going to just show all the circles. Let's get rid of no loop. And let's go from generation to generation by clicking the mouse. So I'm going to add the mousepressed function. I could use a button or some other form of interaction or do this automatically, but I think this will help me figure this out. So what do I want to do when I click the mouse? I want to process the queue. I'll call it a triplet of queue. So I want to go through every triplet that's in queue. I'm going to need this. And can I do something like, say, let c1, c2, c3 equal that triplet? So I would get those three circles out of the thing that's in the queue. I would calculate k4. Then I would get all of the circles. I know that this [INAUDIBLE] allCircles returns four circles. But let's just use the first circle for a second. Let me think about what I'm doing. Oh, I don't want to call this allCircles. NewCircles, this is called newCircles. And what I want to do is say like, allCircles push, newCircles 0. So let's just first put in the new one. So if I click the mouse, I get that new circle going in. This is good. Now with that new circle, I need to make a new queue. So I need to have a new queue. Our nextQueue, I'll call it, is an empty array. And newTriplet is equal to c1, c2 with new circles 0. Basically, this new circle is mutually tangent to those first three. So I have three new triplets. I have it with c1 and c2. I have it with c1 and c3. So newTriplet1, newTriplet2. I might not need all these separate variables. And newTriplet3 is with the new circle. And c2 and c3. So these are all the possibilities. And then the queue should get nextQueue equals nextQueue concatenated with and let's just call this t1, t2, and t3. Those are my triplets that I'm getting from there, t1, t2, t3. And then the queue should equal next Queue. So again, I'm only doing this with that first new circle. But in theory, it should now get that new circle, make all the new triplets. Process them. Process them. Process them. OK, this is working. This is very exciting. One thing I need to do. There's two things I need to do. I need to make sure that the circles I mean, they're going to get infinitely small. First of all, one thing I can do is I can say and let me hit you can already see, it's really slowing down for let newCircle of newCircles. So don't even need that index anymore. I'm going to do it with all of them. There we go. For all the new circles, put them in the array, and make the new triplets, and add them into the queue. Great. But before I do that, I need to check some stuff. Like, if newCircle dot radius is greater than I'm going to give it a big number like 10. But you can see I'm getting some bad circles. So I'm pretty sure that and I don't know exactly why this is the case. But in all of the possible combinations of curvatures and centers that I'm getting out of these equations, not all of them are valid. So I think what I need to do is check for that, throw away circles that aren't valid. So let's validate the circles. There's two aspects to validating the circles. One is a lot of times these equations will produce the same circle twice. And I don't want to add it again because that's just going to compound itself. Let me work on that first. Let me write a function that's like called if validate newCircle. So I'm going to write this function, function validate and I'll just call it c for circle. So the first thing I want to do is check if it already exists. So let's look at the distance between this circle's center and the other circle's center. If that distance is less than like 0.1 pixels, that's how I'm going to know that they're the same. Return false. OK, it's invalid if it's distance to another circle is too close to it. And we'll just put a return true at the end. So that's good. You can see this is working. But I'm still getting a bunch of invalid circles. I need to make sure that it is actually mutually tangent to c1, c2, c3. So I can actually add these here. So basically, this function, first, is going to check to make sure it doesn't exist already. And I could call it c4. That's really what it is. It's the fourth circle. And now I need to write a new algorithm. Check if all four circles are mutually tangential. So how do I know if two circles are mutually tangent? I think I have an idea how to do this. OK. There are two ways for two circles to be tangent to each other. One is for one circle to be inside another. The other is for them to be next to each other. Now let's think about the radii, the two radius values, for each of these scenarios. And I didn't mean for this to be right in the center. So I'm just going to pretend the center is over here. So this is r1. And this is r2. This would be r1. And this would be r2 here. Now the important value is to look at the distance, the distance between the two circles. So in this case, if they're tangent to each other, the distance should equal r1 plus r2. And in this case, the distance should equal the absolute value of r2 minus r1. Look at that. You can see how I think I drew this in a weird way that's making me unsure. And that's the distance. This is r1. That's r2. So if I were to take r1 minus r2, I would have the distance. That was right. I was right. I just had to look at it a different way. Now it's going to be very hard again with this sort of precision of floating point numbers in JavaScript. Basically, I want to look at the absolute value of the difference between d minus r1 plus r2 and make sure that's less than some epsilon value. And the same thing for this. I basically would say d minus the absolute value of r2 minus r1 and make sure that's less than some epsilon value. So if either of these is true, then the circles are tangent. So let's write a function. IsTangent c1 and c2. And I'm basically saying, first I need to check difference one is I should really write a function inside of the circle class for distance. So now I have a function here in the circle class that will calculate the distance between two circles. That makes life much easier in this code. And I need to do the same thing. The distance equals c1 distance c2. And r1 equals c1 dot radius. R2 equals dot radius. And I need like an epsilon value. So now I'm going to say, return d minus r1 plus r2 is less than epsilon, or d minus the absolute value of r2 minus r1 is less than epsilon. Let's put these as separate booleans, just because I think it'll make it easier to read the code. So these are the two booleans that I need to check. And I'm basically saying, if either one of these is true, then the circles are mutually tangent. If isTangent this is a terrible way to do it. But I'm going to do it right now. If it's not tangent, c4 and c1, return false. And I'm going to do that against all the other possible ones. And then return true if I get to the end. I'm not 100% sure about this. So first I'm checking, is it a circle that already exists? It's invalid, return false. Then if it's not tangent to those other circles I don't know where it came from. It's wrong. That one, throw it away. I'm not getting any circles now. Let's just say it's always going to be true. Every two circles are tangent. Let's now look at this. Is my distance let me check my distance function. Oh, look at this. My distance function is wrong. It's a and b. It's a and b, not x and y. That's how I named my complex number naming. Oh, so that's not going to give me results that make any sense. OK. Look at that. Invalid circles are gone. Look, we have the Apollonian gasket. All right. Before we move on, one thing I did forget is these distance checks should really have the absolute value because I could be getting some weird stray negative numbers. So these should be absolute value, is less than epsilon. And then here I had this old calculation for the fourth radius, which is no longer needed, because the circles are calculating their own radii in this new algorithm down here. And also, you can see that at some point I'm clicking, and it stops. So I'm not getting any more new circles once I get to a maximum. Or maybe I am. Oh, no, did I just freeze things? Everybody just hold on. It's frozen. No. No. No. No. Wait. No. No, please, please, I don't want to lose all my code. Oh, god. Just keep waiting. It's fine. Keep waiting. I mean, I probably had saved somewhat recently. I had it saved, so actually I'm fine. Oh, you know what? I didn't check to see if the circles got too small, below a threshold. Oh, so also, invalidate if c4 radius is less than 2 let's just stop at two pixels return false. So that's also an invalid and actually, let me just make it 10 just to be sure. Now it stops. Aha. I feel much better about everything now. So I think I'm actually good. Let's put that at 2. I suppose, yes, there are arrangements where two circles like if there were a circle that were smaller in the center. So let's check radiusDiff equals I mean, there's no reason not to just check this c4 dot radius minus other dot radius. So if the delta, the distance, is less than epsilon, and the radius difference is less than epsilon, then they're the same circle. I think now I have a fully functioning Apollonian gasket algorithm visualization. And the exciting part is now here, where I believe I should be able to start with any arbitrary arrangement of three mutually tangent circles and get a new pattern. How do I get three random mutually tangent circles? Let's start actually with the first circle being the larger one. And then now the second circle, I'll pick a random radius between, let's say, like 20 and c1's radius divided by 2. And then c2 would be 1 divided by r2. Its position would be 200 minus I need to get to the edge of the circle, which would be c1's radius, plus this new r2. So this is now a random circle like this. But I would love to position it at a random vector. So let's use some vector math. And let me get an angle you know what? I'm going to make a vector. V equals p5 vector random 2D. And v should have the magnitude of c1's radius minus r2. And then c2 is just at 200 plus v dot x and 200 plus v dot y. So every time I do this, I'm going to get a random circle somewhere tangent to the outside. Now I need to get the other one. So the next radius I'm just making this up on the fly. The next radius is c1's radius minus radius 2, the magnitude of v1. It's actually the magnitude of that vector. And then where is it positioned? I would basically position it on the other side. So I would rotate the vector by pi and then set its magnitude how far away should it be by c1's radius minus Oh, that's the same thing. What if I just rotated it? And then just said, is this really going to work? The next circle is no, this doesn't make sense. Something is wrong here. But let's just try it. Oh, and I need to put it in here. That's kind of right. But it's not in the right place. You can see that's the right circle. It's just not in the right place. So where does it go? I need to rotate it. And then it just needs to go out I think I need the whiteboard. I have a circle. It's radius is r1. I have another circle right here. Its radius is r2. And then I made another circle like this. Its radius is r3. So r1 should equal r2 plus r3. So how do I find this center point? I just have to go from wherever this is, r2 plus r3. OK, that's its magnitude, r2 plus r3, or r1. The vector rotates. And then its magnitude should be c1 dot radius. Oh, but I'm doing it from the center. c1 dot radius oh, of course minus r3, of course. There we go. So now I'm always going to get three mutually tangent circles. Let's pick this one. Oh, no. Where's my gasket? Oh, there we go. I'm trying to figure out why some starting points, I don't get any circles. So let's try to debug this. Let's see if I can reproduce arrangement that doesn't work. And I can use randomSeed to do that. So if I put randomSeed in setup, and I'll just pick the number 5 well, that one actually works. Let's try the number 4. So with this one interestingly enough, it's different each time because my p5 vector it doesn't really matter. But let's just use from, Angle random TWO PI. The p5 vector is somehow not taking my randomSeed. I don't know if that's a bug in p5 or if I've made a mistake. But now it's going to be the same every time. Let's console.log k4. Not a number. So something's going wrong in that initial Descartes calculation, which is here. I have a feeling that this value here is a negative number. So you can't take the square root of a negative number. It is negative. I mean, can I just make it the absolute value? Can I call that product and take the absolute value of it? I don't know if that would work. That wasn't in any of the pages I read to understand this. Oh, there we go. Look at that. So now I can go back to getting rid of randomSeed. Let's give ourselves a bigger space to work with. And let's have it automatically create the gasket. So what do I do now? So I'll just call this like nextGeneration. And if I call in draw nextGeneration, it should automatically make the gasket. There we go. Eventually it'll stop. Look at all of these possible Apollonian gaskets. I feel like I should probably have the first circle allowed to be a little bit bigger. So let's have it be at minimum 100 pixels. Challenge complete. Let's think about what you could do next. First of all, I have a feeling that I'm kind of fudging some math stuff here. So if you happen to be a mathematician or somebody who's gone deeper and read these papers, please let me in the comments. What did I miss? What did I get wrong? What are some ways I could optimize the way that I'm doing this? But for you, the creative coder, I'm wondering, what kind of visual possibilities can you make? What if you think about color? What if, instead of using circles, you use a different kind of origin shape? You could also recursively put gaskets inside of other gaskets. So I hope that you've learned something from watching this. I hope that maybe you can take my code. I certainly need to clean it up and improve it, make it a little bit easier for you to build on top of. I will do that to the best of my ability and include that in all of the links to all the references and resources that are in this video description. So Happy Pi Day. If for some strange reason, the way you spent your day was watching this incredibly long and convoluted video, trying to make the Apollonian gasket in p5.js, then thank you. I appreciate you. I'm glad that you are here. I really want to see some creative Apollonian gaskets. So share them with me in the passenger showcase. And I'll see you next time on The Coding Train. [BLOWS WHISTLE] [MUSIC PLAYING]