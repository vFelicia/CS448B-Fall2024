welcome to another coding challenge in this coding challenge I'm going to tackle diffusion limited aggregation so what is diffusion limited aggregation well I encourage you to take a look at two references there's always of course a Wikipedia page you can kind of find out a little about the history of this algorithm where how it was thought of what it's appli to what it kind of uh um what it's what it can be used for um the reference that I'm using here uh uh that I read right before making this video or actually earlier this morning couple hours ago at this point uh is a page on the internet from June 1991 written by Paul bour which describes the algorithm uh you can see that diffusion describes among other things the diffusion of the aggregation of zinc ions in an electrolytic solution o that sounds kind of exciting but anyway the point of what we can do with this algorithm is to create certain kinds of fractallike tree like crystallike growth patterns and you can see there's a variety of possibilities and I there's one down here that I particularly like this one which I might try to rec create by the end of this video but let me um rather than read to you as much as you might enjoy me just reading that web page to you in this video um why don't I describe to you a little bit about how this algorithm works at least how I think it works and then the internet can always correct me and once I start to write the code for it we'll see if I'm thinking about it correctly because honestly I don't know I should have practiced this in advance something is definitely going to go wrong in this video okay so let's say we pick a point at the middle of the screen and then we just say oh hello I don't know saying hello to but uh there's this thing called a random Walker and the random Walker starts here just starts to randomly move around the screen and at some point it hits this point now obviously it's not going to take that exact path although it could randomly and once it hits an existing point it gets stuck and then we release a new random Walker and it starts to walk around and when it hits an existing point it also gets stuck and then we release another random Walker and it gets stuck and another one gets stuck and another one gets stuck and another one gets stuck and as they get stuck we start to see this Fanning out pattern so this is what I want to do now I think it would be really interesting to actually animate the full process there's kind of a spectrum here we could write code to animate the whole thing like we see these random Walkers moving around the screen and getting stuck we could also not animate anything and just see the final image or we could do something in between I think I'm going to try to do Point by Point um but not animate the random walk itself that's what I'm going to attempt so let's go back over and we need some code to start with which I have here no no code I mean I have a p5js sketch with a canvas and a background and if I go back to the browser I think I have it running here in the browser I can open up the console which I'm definitely going to need for debugging um and so let's first start what do I need I want I think I want to have an object no you know what let's just start right now first let's do this rather simply I'm going to say uh I'm going to call the thing that's finished the tree I don't know if that's a good name for it but all of the points that are in the pattern I'm going to call the tree uh I'm going to need a walker the thing the point that's moving around and uh that's just about it really and what I want to do is and I need a size like the size the radius for each one of these points which by the way you could do it on a per pixel basis so that always could be one but I'm going to try I'm going to try something like 16 just to have it be bigger to start with so um the first thing I'm going to do is I'm going to create I'm going to say tree index0 equals create Vector a point in the middle of the window and then what I'm going to do in draw is I'm going to say for all the points in the tree uh uh say stroke weight R and stroke 255 and I'm just going to draw a point tree indexi dox tree indexi doy so and let's not worry about this walker for a second so I'm going to refresh it well okay I don't need to refresh it it's live I'm using this adom package called live reload so there's the point okay so now what I want to do is I want to create something that I'm going to call a walker and I'm going to create it I I don't know if this is such a good idea but I'm just going to put it completely randomly anywhere in the in the sketch window it probably should start along the edge or something or actually if you read Paul bork's Page I remember now reading a point that you can make the algorithm more efficient by cleverly picking it close to where you think it might need to be but I'm just going to create a random Walker and I'm going to say I'm going to see if that Walker should be stuck so first thing I need to do is check again all of the points of the tree and I want to see I want to know uh the distance between that walker and a particular point in the tree and if that distance is less than some threshold R I guess oh no r r * 2 right because I just want to know if those two circles are touching so if the circle if the two circles are touching the distance is less than twice their radi radius um if distance is less than R then uh stuck equals true so I'm going to create a Boolean variable assuming stuck is false and then I'm going to go through all of the points and if stuck is true I can say uh break and now what do I do here I'm going to say uh and actually what I want to do is like keep going until you get stuck so as long as you're not stuck keep checking all of the points and as soon as you get stuck set stuck equal to true and what happens if you get through this Loop and you're still not stuck then Walker should it should randomly walk by some amount let's and you know I could probably be more thoughtful about this walker dox should change and walker. Y should change the other thing I really need to do is I should make sure it stays on the I don't want it to walk randomly Far Far Away off the window so I should constrain it to um to between zero and the width of the window so let's see and now once it finds a part point when it's stuck um then what do I do I say tree. push Walker there we go and now uh let's see what happens here so I've got some infinite Loop problem this always happens uh with live reload I shouldn't be like there we go oh look at that so I missed up like something good is happening but boy did I mess something up this is interesting so I must have used an X and A Y ah okay that should help yeah so interestingly enough this doesn't look so totally crazy is this correct though very hard to tell so let's do a couple things one is um The Stroke weight should really be half the radius um they should be right up against each other uh let's move them by let's move it by just one one thing I want to do is create um uh I'm gonna I'm going to just make a random unit Vector to be a little bit more controlled about how they're moving uh and then I'm just going to say uh walker. add that velocity so this is a little bit better just to make a random vector and add that to the walker uh I I got to I think this live reload thing doesn't work for me because um um because okay that's good and actually maybe I meant for this to be times two yeah there we go okay so this is definitely looking kind of right right now uh let's the basic idea let's make this much smaller yeah so you can see this is actually working although it's quite of the slow algorithm can speed this up so I think I've got the basics of the algorithm correct actually it's just kind of slow to do this one point in time let's do it this way um one thing I want to do wow this maybe this isn't as bad as I thought let's uh let's let's think about this let's do um I think we could release a bunch of walkers at a time so let's try um let's try releasing 10 walkers at a time and uh just to see if we can kind of get this going a little bit faster oh you know what the Walkers I think need to um to start from an outside point right well let me let me do this though anyway and then we're going to pick how where the Walkers start differently which is going to be much better I think so um so all right so I just want to see something if I I'm going to create a bunch of these Walkers and then now uh actually I can just do this as a loop right uh while you're not stuck okay if I'm back and um I thought of something which I think it might make a little bit more sense to be able to play with this a bit more by having the Walker itself be an object so I would like the uh instead of just being a vector I want it to be an object that can store both where it is on the screen it's size I can call functions on it that's going to give us more ways of playing with this algorithm and make it perhaps a bit more efficient so let me go here and what I'm going to do is I'm going to create a new file and I'm going to call that file walker. JS and I'm going to make a walker object a Constructor function and I'm going to say uh I'm going to say this. position equals create Vector uh random width random uh height so I just want to take a lot of this functionality um and that I've written out here and I want to also whoops I want to create a variable called uh this. stuck and I want that variable to be uh false when it starts I want to have a function um that's called walk so I want to um going to the I want to have a function I want to have a function called walk where I implement this algorithm where I pick a random Vector I add it to the Walker so it moves somewhere on the screen I can strain where it is in the window um and I want to have a function that says check uh what What's a better name for that function like uh update no uh uh stick I can't think of a good name whatever uh check sticky check stuck whatever that's going to be the name of the function check stuck and in that function what I'm going to do is I'm going to take this particular algorithm uh and I am going to and I actually kind of want to see them walk but I think I have I actually kind of want to do this without the while loop so what I want to for a second what I want to do is check all of the points on the tree and see if if the distance between this Walker's position right which is actually uh this pause now dot right the Walker is no longer The Walker is now an object with a position um is near anything that's in the tree's position because everything in the tree are Walkers that are stuck oh you know what I didn't do is I'm not delete anyway so okay keep so um and then if it's stuck I'm going to do something obviously okay so what I want to do here now is create an an array of Walkers and actually tree uh index zero is going to be a new Walker that is in the middle of the window uh then and that is stuck so what I'm going to do in the object is I'm going to have some optional arguments I'm going to say x y y stuck and I'm going to say um uh I'm going to say uh X um I'm going to say X or this is a way of doing optional arguments so if I pass in an X I'm going to create the vector at that X but if I don't X will be undefined then I'll get a random value y or or random height okay and then uh same thing here I'm going to say this stuck equals stuck and if it's undefined that's the same thing as saying false um and then I Need To Say by the way this do stuck is true and this is this. pause tree. pause okay and I should really check against uh some other array like the others I'll call that which is called tree so what I want to do right now is I want to create one Walker in the tree and then I want to create in the Walkers I want to put just a random Walker so I have tree and I have walkers and I I might as well do that the same way in index spot zero and then what I want to do is I want to see uh and you know what I should do is I should uh now I can also have a function which is called uh this doow and I can take all this code I should have done this at the beginning I can take all this code and put it in the object so I can um set a stroke weight set a stroke and this. pause and draw the point at this. pause doy and and I you know I could be a little smarter about this and actually just make this an ellipse so I could be more precise about the radius and I could say R * 2 R * 2 which is a global variable at some point but I can have them be variable sizes at some point okay so now I have this object I have a walker object which can move it can check to see if it's sticking to anything else in some other array and it can also um it can also draw itself so what I want to do first is I just want to say let me display everything in the tree and let me display everything in the Walker's array okay ready so if I if I reload this sketch Walker is not defined oh uh sketch line seven it's not defined because I have to remember to add a reference to it in my Javascript file uh to walker. JS and missing walker. JS line 25 has an error so let me go down and see uh this do ellipse this. .x this.y I don't see any error here on line five 25 oops I had a period there not a comma there we go great so I should see here whoops I should see this is this and this is the Walker so let's now have let's just now in sketch let's also have walkers indexi do update oh update was not it walk so you can see there it is moving randomly it's going to take a while to randomly intersect that but it is walking randomly uh I could obviously make it uh walk faster so what I want to do now actually just as an experiment is I want to this is not at all I've gone off the beaten path here from the actual probably algorithm but I want to put 100 Walkers into the space right okay so they're all moving around randomly and what I want for them to do is if if Walkers index I check stuck others then Walkers uh then I what I want to do is say walkers. splice I want to take it out of there and I want to say tree. push Walkers index I so I want to uh whoops what I want to do is I want to anytime one of those Walkers gets stuck I want to put it in the tree and I want to take it out of the Walker's array because it's not something that's moving anymore so uh we let's check this do stuck equals true so actually um let's make a function uh is stuck actually so I don't need a I don't need this variable I can just say return true and if it kind of gets to the end return false so let's look at that um and see what happens others is not defined oh tree right I have to pass in the tree there we go you can see them getting stuck go go Walkers go go go go Walkers go so you can see how this takes a very long time I I'm kind of curious to try a few things let's try a thousand Walkers and I and this isn't what Paul bour describes what to do um on the website at all but I kind of like and so I kind of want to um highlight them differently so uh I should actually by the way I should have that be a particular variable uh because what I would like to do when I draw them uh is if if this do stuck I want to give him a different color uh so let's uh so we can see which one are stuck um so now though I think better more than better than adding a ton such still add a let's actually do this particular algorithm multiple times per frame like let's let it try to move all the Walkers 100 times per frame whoa why are they all clustering near each other am I oh I'm drawing them 100 times I don't want to I don't want to do this show so I just want to show them once there we go this is what I was sort of hoping to see so now there finally okay so now we can kind of see the algorithm happening which I think is kind of interesting it's it's going to happen very slow this is a complete and total brute force method um but I finally got something that I like here um and because at least it's sort of interesting to watch it is happening kind of slowly I want to try a few things to make it happen faster let's increase to 200 Walkers and let's increase the number of times uh to 250 um the frame rate is a little bit slower now I kind of like to keep the frame rate up so let's go down to 200 um there we go so we could obviously um and the other thing I could do uh it's interesting oh it's slowing down over time so the reason why it's slowing down over time is there's more distance checking so one thing that I could do that I would hopefully um help this run a bit faster um which normally I wouldn't care about but it is kind of bothering me how slow that it's running is let's see if we can eliminate the square root calculation um and to see if that makes it run a lot faster so one thing that I'm doing here in the check stuck function is using this distance function and I want to write my own distance function I'm going to call it distance Square ukian distance um and I want to take it I want it between two vectors A and B so what I want is the difference in X which is BX minus a a.x I want the difference in Y which is B Yus a doy and now normally if I were I would say return the square root of DX * DX + Dy * Dy this would be regular old fashioned ukian distance right uh a um the square root of you know the hypotenuse of a triangle a squ plus b squal c squ or c equal the square otk of a square plus B2 so what I actually want to do here is just write this algorithm but take out the square root and then what I can do now is not use this but but use my own distance squared function and then I can actually have that distance be uh R * R * 4 which is what I want now is for the distance to be did I did I mess something up here yeah I'm missing a parentheses uh what I want is the distance to be instead of checking if the distance is less than R * r i want the distance R 2 or R * 2^ 2 is R * R * 4 so this now uh distance uh dist squared this should hopefully be a lot faster um you know uh did I wow good okay so boy just eliminating that square root you can see how much faster this is now okay now here's the other thing is every time I remove a walker oh this is kind of nice actually just to like Let It Grow with a fixed number of Walkers I'm kind of enjoying that back there was a technical glitch there but hopefully you're still seeing me I seem to be I see myself again so you can see here that I have this kind of nice finished pattern which I really quite like actually um so some other things that I can do here are one is whenever I remove a walker uh I could say like I always want to have 200 Walkers so um uh I can I can always say like while walkers. length is is sorry is less than 200 um walkers. push um walkers. push uh new Walker so this is even when they get stuck I add new Walkers so I never oh and by the way I started with so let's make a variable called uh Max Walkers equals uh 200 200 and we're going to start with uh that's we're going to do it oh no no no that's a different value Max Walkers I kind of made and then I'm going to make another variable which is uh iterations which I'm also going to make 200 let's make these variables I think is kind of nice right we can see how it behaves and we can see how it behaves so now I'm always keeping um 200 Walkers so I want I want this really to happen pretty fast so let's see if I can up the iterations a bit um and see if we can get this screen now it is uh it is sort of slowing down so I think we're we're in we're in pretty good shape now here's the thing I think what's interesting oh you can see it really slowing down um so if I go back to oh and you know what there's also a problem here which is that I shouldn't be creating random Walkers anywhere in the window I should only be creating them around the edges so let's also make that Improvement okay I think it's worth making that Improvement so I'm going to make I'm going to go back into the Walker and instead of doing random width random height I need a function uh make Rand uh let's do a random point and I'm going to give it that X and Y right I want to have some separate function somewhere that's going to take care of this for me uh actually I'm going to say if x this. equals create Vector at that X and Y so uh if you get an X and A Y um otherwise let's pick a random point now I'm sure there are lots of clever ways I could write a function to give me a random point along the edge but the way I'm going to do it as as follows I want four possibilities top right bottom or left so if if I'm picking something along the top I want a random X and I want to return create Vector uh that random X comma 0er else if I equals 1 let's just say that's the bottom uh and again we could make this more efficient let's make that along the height else if I equals 2 I want a random Y and I'm going to along the left side and in all other cases I want a random Point uh along the right hand side so let's run this now you can see that I'm only picking random points that are coming from the edge which I think is also going to work a lot better because I don't want to pick random points kind of inside the thing that I'm already creating so here we have now uh diffusion limited aggregation go go go I wanted to finish um so one thing that I kind of miss so this I I got to come up with a clever solution to figure out when it's done because you can see it's kind of uh it's now like just infinitely picking points along the edge and it kind of went crazy a little bit when it kind of got to the edge so but I kind of like the idea of actually just for right now um never not adding um not adding any more Walkers and starting with a fixed number of points so I'm going to start with 1,000 points and yes it is running kind of slow but when those points are removed we got to get our first point to get stuck randomly there we go I think it's going to kind of speed up over time is my belief but uh and you know one thing I could probably do which might also help it run faster is draw less stuff uh or what might be better is to just add you know add one point at a time uh so I think really the way that you would do this is I might let's just do five but like have like a thousand iterations here's another way to doing it yeah I like this this is nice I like looking at it this way too so there's so many different ways you can visualize this I'm kind of stuck on it um and I encourage you to uh sort of enjoy coming up with ideas on your own but what I what I do want to do is um what I do want to do is uh let's let's go back to this um what I do want to do is kind of look at how um how you can vary this algorithm to get different star different kinds of patterns so let's go back and look at the Paul Bor website and let's first sort of see a couple things one is how right now this is essentially what I'm getting you know I could do a better job of kind of thinking about the layout of the space and making the algorithm more efficient or that you know let it run for a long time I encourage you to do all that um I'm going to release a processing version of this which maybe runs for a while and like renders the final version to an image somebody remind me in the comments if that doesn't exist so we can make a version of it it looks like this in the browser it'll kind of I don't want to like shut down a browser window but let's at least first think let's try to see how we create this pattern so this pattern is all about the seed points what if I fill the tree with points along the bottom so let's let's fill the in the beginning instead of having one Point what if I say for VAR I equals I'm going to say VAR x equals 0 x is less than with X plus equals R time 2 and what I want to do is say tree. push new Walker at X comma height so I just want to create a whole bunch of points that I start with at the bottom and you can see what happens when I do that now what if I want I think I want all my Walkers actually just to start at the top so let's go now to the Walker file and what if I basically say uh you know what let's just all always have I'm going to comment all this out and let's always have all the Walkers start at the top so I just changed this function have all the Walkers start at the top whoa what did I do wrong I'm back there was a major problem with my code which is right here remember how I was saying I'm so clever and I can check to see if the user gives it an X and A Y so if x and if there's an X and A Y make a vector out of the X and the Y otherwise make a random Point well it turns out that if you give it the value zero right zero evaluates to false so when I say make a walker at zero comma zero for example or zero comma height it's actually going to not make it at that point but give me a random point so what I actually need to do here is say as long as X is not undefined and I'm sure there's a more elegant way of doing this but I'm just going to fix it right now and saying n y is not undefined do this and that should I think I have some sort of uh browser having crashed problem infinite Loop problem and also I think I can do away with this third argument stuck and just say this dot you know it's if if I'm making it at a particular point it's automatically stuck otherwise it's automatically not stuck just to be clear about that and now we should see okay so here we go now we have starting all the points at the top and they're going to go they're going to kind of get glued at the bottom so this we should see some kind of pattern as this runs for a little bit you know Speed Ahead in this video if you want you know listen to some music while you're uh waiting come on trees grow so um so we should see a pattern that's coming much more like what we've got here in oops I'm in the wrong place what we've got here in this particular example so here's another so come up with your own scenario what if you start with points all along the edges what if you start with points along a radial path in a circle or have points moving ah you have points starting around the edges of a circle and your random Walkers all start in the center you get something like this um now but I do want to add something else here which is um oops I got too much music playing okay I do want to add something else here uh let's just see how it's going you can see oh it's it's moving along here we're growing our trees I want to go I want to go back to Paul Bor site and you can see something here which is interesting look at this particular image now as I scroll down look at this particular image and look at this particular image there's a kind of density or fuzziness or almost hairiness to it and you can what you can actually do is uh it's called stickiness you can have a probability you can think of when it touches something that's part of the uh part of this tree this this diffusion limited aggregation thing that's growing you could have a probability that it gets stuck rather than automatically getting stuck um so I think that's something interesting to add for example if it's within this threshold Jo don't just automatically have it get stuck but pick a random number between zero and one and if that random number like our stickiness is now 10% uh then I could actually have it get stuck and unfortunately we didn't get to see how that was going um let me see if I can make this run a little faster um there's a couple things um so I'm going to uh I'm going to give it more iterations and more max random Walkers um the other thing that I could do actually that I think would really help is I could have the uh Walkers as they walk not just I could have them only ever walk down so I could actually say I'm just going to comment this out uh VAR velocity equals create Vector some random amount between ne1 and one and then some uh random amount between zero and one so that these uh the the random Walkers only ever move down boy they they move down much too fast I guess I should maybe I should weight it just a little bit something like that who okay hold on too many this was a nice idea that I had that doesn't seem to be working out very well there you can sort of see I don't know if this was a good idea or not but you can sort of see how if I have them randomly moving down why do they always uh go back up to the top am I oh I'm adding them back in again that's making it run slower so um uh uh yeah so I I wanted to take that out actually and you can sort of see anyway you can see that by varying lots of the algorithm I'm going to when I when I publish the code for this I'm going to make you a nice clean version that works really well because there's so many variables you can play with here okay I want to play with one last variable so uh look how slowly like come fall Walkers go to the bottom stick to the aggregation pattern oh um okay so let's do one last thing um what I'm going to do now which I think will be particularly interesting and uh is try to recreate this pattern notice how the walkers at the center are larger than the ones on the outside you can see this one as well um I didn't get to do the the the probab didn't get to see that the probability thing play out uh let me take that out for a second and so what I want to do now before I leave you if you're still watching is I don't want to have r as a global variable anymore I want to have each Walker have its own variable so I'm going to make r 32 uh and I need to look for anywhere that I reference it this. R uh other. R right now I'm also importantly checking my own radius against another radius or others index i. R and then I also want to draw it with this. r this.r so one thing that I could do which is and then I want to go back to the center ver the version where it's uh all um where it's starting in the center which I think is a bit easier to kind of work with right now so I'm going to take out this tree that starts off the bottom let's just make sure this still works whoa look at these so if I make them really quite big that was kind of interesting uh let's make this eight okay so you can see what this looks like now and this is working again now with um with uh with just sort of larger circles and I kind of would like to to uh just also when I draw them I would like to give it a little bit of alpha here I think would be worth seeing uh uh let's just a little bit of alpha okay so okay so now we have the basic core algorithm happening and you can see all of these uh Walkers getting stuck so what I want to do I think which I think would be interesting is I'm going to I'm going to make the maximum number of Walkers just 10 but I'm going to increase the iterations by 10 to a th so these are the Walkers now sticking uh one at a time now there were only 10 of them so 10 of them are going to get stuck that's all we're going to see but now what I'm going to do is I'm going to each time I delete one from the array uh I am going to add a new one with a smaller radius so what I want to do is let me get the oops let me get the radius of the uh last one in the array this might be a and I'm going to make a new Walker with uh oh boy uh I want to make a new Walker with a that that radius times 0. five so half the size the problem is now I need to make the Walker be able to be created now with a radius but at a random point so I think one thing I need to do one thing I could do actually this is better is I could say if arguments.length equals two that means I've gotten two arguments in X and A Y then create the then create a a walker with a radius of eight otherwise then create it with the radius of and then otherwise if if um yeah otherwise create the AER with the radius of the first argument so if you have less than two arguments so this is another way I could just check that arguments array I have a video tutorial about that otherwise I can uh I can get it I can make one with a particular radius and so let's see uh let's see what happens here um uh okay so where am I making Walkers ah so this is with I forgot no no no no know so with wait or else if arguments.length equals one else now with no arguments right then the position is random the radius is eight and stuck is false so uh now the other whoa what just happened here back I realized there's a problem here where I have actually I'm passing into three arguments because I had an extra straight true from before so let me take that out and you can see this is working now strangely enough though uh the um the Walkers are getting like really really really small really fast and I just realized that's because um what I want to do is get that before I start adding a whole bunch of them I want to get the radius of the last one there because when I add one and get the radius of the last one they're getting smaller and smaller and let's let's just make them uh go down by 75% so you can see here that the Walkers are getting smaller as they add in them back in and maybe that's like too much they just get smaller so quickly so let's see what this does am I yeah so you can see over time as I'm adding more and more walkers in they're getting smaller and smaller and smaller uh we could also do something now while we're here let that run for a little bit um let's let's see if I give it 50 at a time will it kind of perform okay um so one thing that I want to do is uh and I actually could just have every Walker in sequence be actually a little bit smaller than the previous one that might actually be a better way to do it um because I could have like a radius counter uh and and and that's kind of uh yeah let's do it that way actually let's try this I want to have a radius of starting radius starting R uh I actually just say radius equals uh I can have a starting in radius just for that Center one no that's fine radius so I want to have a starting radius of eight and whenever I make a a walker I say radius times equals 0.99 so shrink it a little bit shrink it a little bit and then there's another place where I make new ones which is here shrink it a little bit and then actually I can take out this idea of the argument because I just going to use a global variable I don't love this anymore I'm just use a global variable radius that's always shrinking uh to go back and um put that in here uh and have this always be radius radius so there is no there is only back now I have I'm sort of simplified back to just two cases I either I'm getting an X A Y and this. R is always just equal to that Global variable rate I I don't like now how I've done this but we're going to do it this way anyway so you can see every single one is like 1% smaller than the previous one which it's kind of interesting because we're getting sort of they're actually not exactly in order so that's not what I intended to happen but we are seeing sort of an interesting result from this and they're getting smaller and smaller and smaller and then I could also say what I like about this is I couldn't I now have sort of like a ter point where I can say if the radius is less than one um only oops only bother to do this if radius is greater than two so now we actually like I don't want to have circles where the radius is less than one so now we actually have a terminal condition for this algorithm and I also now want to add one last thing which is coloring them so uh and you know I could actually uh so the other thing we could do is I could have a um I could map their Hue I could map their Hue uh so I could say it I could say uh color mode HSB and in the Walker object itself got to add this in I could say Phil I could I could say the Hue is mapped to the radius which goes kind of between like 0 and eight to between 0 and 360 and I could give it that that color and I think I'm actually going to say no stroke and let's forget about the coloring it based on whether it's stuck or not and I have an error somewhere so we can see now and they're not actually so I probably should order their color based on when they get stuck but this is kind of interesting nonetheless and you can see as they're getting smaller and bigger and you know uh I don't know what just why it just stopped right there oops but you could see I'm going to clean up this code and give you a working version I might change the order around the colors I'm going to um uh I'm very good at crashing Chrome but you can see sort of the ideas behind this particular algorithm I don't really I time is up I think because this has G on for way too long I don't have a good perfect version of this to show you but um I will uh I will include that in the the link from this video to the source code I'm going to make both a P5 Jaz and a processing version of this so I can do kind of like a higher resolution one that kind of generates it and just saves it to like a JPEG so you can see how that works maybe I'll come back and do another video followup about that but now you can see sort of the basic idea and the implementation behind this particular algorithm that's on Paul bork's website okay thank you for watching and I'll see you in another coding challenge back for a quick addendum I actually I kind of cleaned up the cat a little bit and it's making it work a little better now um I had two big things that I missed one is that um it was it was crashing the browser I think I need to point this out because I had this wild Loop that was always trying to fill it I was trying to fill it if it ever got less than a certain amount but I didn't allow myself to add any if radius was below a certain amount so it got stuck in that while loop so I fixed it to just say only do the while loop if radius is greater than one and the other thing that I did is I added a hue variable so that each time it gets stuck I increase this sort of global Hue variable and you can see now the Hue is sort of assigned to the order in which it gets stuck so this isn't doesn't exactly match um what you see on the uh these particular scenarios but I bet you with a little bit fiddling and tweaking of the algorithm you could get something like that so um give that a try and uh if you can if and as you make more beautiful and interesting versions of this uh think about ways of optimizing of where you start the Walkers how many you use how you check to see if they're near something um we'll come back and I'll make some improvements to this okay this is really the end now goodbye