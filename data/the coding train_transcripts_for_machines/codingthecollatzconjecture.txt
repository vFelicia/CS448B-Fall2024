Welcome back to another episode of Coding in the Cabana. I'm going to head into the cabana. I've got an exciting topic called the Collatz conjecture that I'm going to do today. And I can't wait to get started. Come on. [MUSIC PLAYING] I'm here in the cabana, and I'm ready to start coding the Collatz conjecture. The Collatz conjecture is a conjecture in mathematics related to a number sequence, and the number sequence goes like this. Take any number n. If the number is even, set it equal to itself divided by 2. If the number is odd, set it equal to itself times 3 plus 1. So why is this conjecture, why is this sequence interesting, meaningful, mysterious? Let's start with a number. Let's say I'm going to start with the number 5. So following this, 5 is odd. Multiply it by 3. 15 Add 1, I get 16. OK. Ah, that's even. Divide it by 2, I get 8. Cool. The scratching on the chalkboard's bothering me. Now 8. Oh, that's even. Divide it by 2. [MUSIC PLAYING] We're going to get this looping sequence. Once we get down to 1, it's always going to go 4, 2, 1, 4, 2, 1, 4, 2, 1. And the conjecture is, any number that I start with, I started with 5 here, it's always going to end up as 1. It might take a very long time, but it's always going to end up as 1. I should note that n is in this conjecture is a positive number. So not a negative number and not 0. You can see here on the Wikipedia page, the conjecture stated with arithmetic notation. You can see some examples here. For n starting at 27 takes 111 steps, and you can graph the value as it takes those 111 steps. So this idea was originally suggested on as a topic suggestion on August 8, 2016. And there's some wonderful links here that I'll include in this video's description for you to look at and see different code examples and visualizations of it. I'm going to attempt to do my own here. And what I am looking and hoping to create is inspired by the number file video about the Collatz conjecture, which uses a particular visualization technique. One way to visualize it is as a tree. And you can sort of like think about all the different with any given number, the path that it's going to take. So 25 becomes 76, becomes 38, becomes 19. You know, 18, if you start with 18, it's going to eventually end up as 22. So if you start with 25, you're eventually going to reach 22, but you'll also reach 22 if you start with the number 18. So you can kind of visualize as this branch, this graph, this tree all converging eventually every sequence all the way down to one. But I'm here in the cabana in the sun, with the garden outside, and I want to see I'm inspired by this particular number file video, which creates a visualization of the Collatz conjecture that looks like this. It's a seaweed or a plant, it's so organic. Why and how out of this very mathematical algorithm do we get this seaweed like pattern? The visualization that I'm going to try is directly from that number file video, and the rules for it were designed by Edmund Harris. A link to the number file video and more about Edmund Harris's work will be in this video's description. This is how the visualization works. If I start with a number, the next number in the sequence is going to be either even or odd. If the next number in the sequence is even, I'm going to go slightly to the right. If it's odd, I'm going to go slightly to the left or clockwise versus counterclockwise. So let's say I start with the number 10. 10 is an even number, so it's divided by 2. So I'm going to go slightly to the left to get to the next number, 5. And then 5 is an odd number, so it's multiplied by 3, and then I add 1, which gives me 16, which is an even number. So now I have 16. I'm going to go slightly to the right. And then 16, I divide by 2. I get 8. That's an even number. I'm going to go slightly to the right again, and so on and so forth. I'm going to attempt to program this sequence in processing Java based creative coding environment. One of the things I love about processing is there's a library in processing that allows you to render out a drawing to a PDF that you could blow up to large scale and print as a nice poster. So maybe I'll make a nice, beautiful Collatz conjecture Coding Train poster. First thing I need is a function that's going to do the number sequence. So let's just call that collatz, and it'll be a function that will receive any number. And one way we can test for even or odd is using the modulo operator. If n modulo 2, meaning the remainder of n divided by 2, is 0, this is an even number. And then otherwise, this is an odd number. OK. So what do I do? If it's even, I say, return n divided by 2. If it's odd, I'm going to say n times 3 plus 1. So now that I have this function, let's just test it out. I'm going to use the console here. I'm going to bring the console up a little higher. And I'm going to just say let's say we start with the number 5, and let's say print line collatz 5, right? What should I get? I should get 16, right? 16. There it is, down there in the corner. OK, that's good. If I start with the number 10, I should get 5. Now let's think about putting that into a loop, right? Let's see how long it takes for the number to get back to 1. This is like a weird scenario where maybe I might actually need to use a do while loop. [MIMICKING SCREAMING] [BELL RINGS] Here is a do while loop. I really think this might be the first time in my entire life that I've used a do while loop. Do. The statement I want is n equals collatz of n, and I want to do this while n is not equal to 1. I think this is right. And then, let's just print n. So we should see we should just see an n come out. 1, perfect. And then here, what we could do print line n here, and we should see the full sequence. 5, 16, 8, 4, 2, 1. Perfect. So now we can test the Collatz conjecture. Let's say n equals 100. We got 1. N equals 1,000. We got to 1. N equals 835291. Oh, I need my book of random numbers to try to start with a random number. We got to 1. Cool! The Collatz conjecture seems to be true based on my simple processing code. Lets, just out of curiosity, see the number of steps it takes. That equals 0, and then every time I call the Collatz function, steps goes up by 1. Now, rather than print out the sequence, let's just print out the number of steps. 175 for that particular number. If I go back to the Wikipedia page, I can test to see if my code is performing correctly by picking let's just say let's pick this number that's less than 1 billion, this number, and that takes 986 steps. Don't want the commas, just an integer. I'm going to run it. Uh oh, it's stuck. I think what might be going wrong here is there's a limit to the largest size number you can store in an integer. The largest number in Java that an integer can store, using 32 bits of memory, is a little over 2 billion. So I think I've gone probably way above that. So somewhere in the sequence. Even though I started with a number around 670 million, I went way above the range probably of a 32bit integer. So I think a way that I could probably fix this is by changing this to a long. Long is a data type in Java that also stores numbers, but uses more memory than 32 bits. I believe it's 64 bits. And I'll correct that if that's wrong, somehow. So I need to change the function also to return a long and to accept a long. Let's run it again. 986, that's the number of steps. 986 steps. Great. I'm going to do this visualization with all numbers up to 10,000. So I can go back to using integers without a problem, because I don't think I'll get out of the range. Now it's time to try to add some drawing. I'll use i as my number. I starts at 1, and I want to go all the way up to 10,000. And I want to create a canvas. I'll just make it 600 by 600, and set the background to 0. So right now, I'm going to do all of the code in Setup, because I'm just going to have the whole thing drawn all at once. But, and maybe this is a challenge I'm going leave to you, I would really love to see this pattern grow, emerge over time. So that animating it, using the draw loop might be a wonderful would be a wonderful thing to try. So just so we know something's happening, let's put a print statement at the end to make sure this loop can actually finish and doesn't get stuck. Finished. So it actually did that incredibly quickly. Running through the full Collatz conjecture algorithm for every single number from 1 to 10,000 happens a computer can do that super quickly. Let's see what happens if I start drawing. So I think an effective way for me to do this would be used to translate function. So the translate and the translate and rotate functions. So in processing, the translate function takes an x and a y and will move the origin point along a path according to that x and y value. So that x value, that y value, 0, 0 is translated to here, potentially. So let's say what I want to do is start the visualization at the bottom, right here. The first thing that I would do, I would translate to width divided by 2, or in this case, 300, and then all the way to the bottom of the canvas, the window, which would be height. So let's say, with each iteration of the Collatz algorithm, I want to move up. So I'm going to say translate, and let's create a variable here, like length, which equals let's just say 60 as a kind of arbitrary decision. I want to translate by 0 comma negative length, which would move up like this. But I want to move slightly to the right or slightly to the left by some angle. So I could use vector math and I could figure out, OK, well, if I'm moving 60 a distance of 60 pixels to the right at 30 degrees, I could use sine and cosine. And I've done this to like calculate the difference in x and the difference in y, but this is what the rotate function can do. The rotate function like the translate function moves the origin. It kind of shifts your view of the entire canvas. The rotate function rotates. So in other words, if I were to just like tilt this chalkboard and then still draw relative to where I am straight up, and then tilt it back down, I've gone that way. So visually, the viewer is seeing it slightly off to the left, because I've rotated the orientation of the window, but I'm still drawing 0 by that same path, 0 comma negative 60. So in theory, what I should be able to do, I want to say if n, this new n, is even, rotate and let's pick an angle. I don't know what angle was used in the number file video. I'm going to pick 30 degrees somewhat arbitrarily. Or that's but if pi is 180 degrees, this would be pi divided by 6. And I should also make this a variable, so let's call this angle, and let's say that's pi divided by 6. So we're going to rotate by the angle in one direction. Otherwise, rotate by the angle in the negative direction. For every number I'm going to I want to I'm about to move along this path, I want to check if it's even or odd. So I want to rotate this way or that way, and then I want to move in that direction. But I need to draw something. So let's before I translate, let's say, stroke 255, and let's draw a line from wherever I am 0, 0 to 0 comma negative length. And then I'm going to move to the end of this line. This is very similar to what I did in the fractal tree coding challenge. So actually, I think to test this out I've got two things going on here. I've got this like outer loop. I think I want to comment out the outer loop for a second, and I just want to test this idea out by starting with any given number. So let's start with the number 500 and see what happens. OK. This is something kind of interesting. So now let's try doing it for all the numbers. And I think, though, what I have to sort of like figure out here, which is pretty different, is that I want all of the numbers to start back at start at the same place. So if I'm doing this in a loop, all of these translate and rotate, and when I come back to the next number, I'm going to be picking up from where it left off. So one way to deal with this is actually just call this function reset matrix, which will reset everything just back to the original orientation, and then I can put that original translation right there. N equals i. Uh, this is taking a very long time. Whoa! [LAUGHS] And I got the visualization hairball. I think that I've made a major error. I think the idea is that we're visualizing everything that converges back to 1. So 1 is the starting point here. So while I'm starting with the number 100, I'm not starting with 100 and going right or left with the Collatz conjecture. And I know that I said that incorrectly earlier in the video, so hopefully you kept watching. Even though I got these kind of interesting patterns, I want to start with the end and see how that sequence is. So how am I going to do that? I think I'm going to need to do two passes. Oh, this is going to be fine. So here's how we're going to do this. Here's how I'm going to do this. I'm going to create something called a float list. A float list in processing and I'm going to call that sequence is just a sequence of numbers. And I could just use a plain array or an array list, but the float list is nice, because it just works really easily with floating point numbers, and it's completely realizable. And I can iterate, I can reverse it. I can do all sorts of things. So I want to create a float list, and I'm going to take all of this drawing stuff out. Let's just put it down here. Comment it. So now I'm going to take that float list, and every single value of n, I'm going to say, sequence.append n. I think I should also add 1 to it at the end. Oh, you know what, this is so silly. This shouldn't be a float list, it should be an int list. It's just numbers. I don't know what I said float list. It's just integers, so it can only be integers in the C Collatz sequence. Now I can visualize the list. I want to visualize the list with the end from the end all the way up to the beginning. Sequence.reverse, and now I just want to and then iterate through the entire list. Int j equals 0. J is less than sequence.size. J plus plus. And then I can say int n equals I'm going to have a problem here, because I used n up here. Let's just say value equals sequence. I might want to rethink some of my naming stuff, but sequence.get j, OK? And then now this is where all this stuff comes in. So what I'm going to do here first, right, I'm about to iterate over it is I want the parameters and I want to start from the bottom. So length and angle, start from the bottom. Then I need this, exactly the same stuff, based on the value. I'm going to rotate one direction or another based on whether it's even or odd, but I'm doing that according to value. Let's see what happens now. Ooh, I'm excited! Let me try this once again with just one number. That seems right. So I'm just going to try different numbers to sort of get the feeling of it. Let's try let's try pi divided by 12. So I'm going to have that. Yeah, this is I think it's probably like a very small amount. So we can see that's what's happening with the number 100. I also might want to think about like which way am I going. That could it's kind of going to orient this whole pattern. And maybe actually I'm starting in a direction that's not straight. But all that aside, I think I'm ready to now just see what happens with all of the numbers from 1 to 10,000. Drum roll please. [LAUGHS] Is my path just way too long? I took a little break. One camera died. One memory card filled up. I'm still sort of figuring out this video stuff. I also took a moment to ping the Slack channel for a Coding Train members and patrons, in case you want to join, and ask if anybody had done this before and what I might be missing. And one and something that I'm missing here is actually suggested in a different number file video about the Collatz conjecture. Any time I apply the algorithm for when I have an odd number, 3n plus 1, that is always going to result in an even number. So what's the next step? Divide by 2. So I could actually, in the Collatz conjecture code, sort of speed up the process of getting to 1. It's not going to compute the exact number of steps, but it could speed up the process of getting to 1 by just taking this down here oops, by just taking this down here. And by the way, I changed the font size also here. Hopefully this will I don't know why had it so big before. I could just take this, n times 3 plus 1, and divide that by 2. I'm still going to get the same sequence. Now, if I run this with my visualization, I can get something that's quite a bit more controlled and, in a way more, closer to what the result in that number file video is. So I think there's a bit more that I can do with this. Number one is let me instead of moving up, let me give myself more space to work with and move in a horizontal direction. So I'm actually going to start at 0, height divided by 2, and I'm always going to translate along the xaxis. So translate by length comma 0, and draw the line to length comma 0. This means I'm always going to be moving across, starting from here across. The other thing that I could do is then I'll give myself much more space to work with by having the size of the window be 1,200. And like I can even move further. I can move like 10 pixels per look at this. Interesting. The other thing about what's going on here is all since everything converges to 1, ultimately, there's a lot of repeating patterns. So I think this could have a more organic like feel if I start to give the line some alpha so that the repeating patterns become much brighter, and as it branches out, it sort of fades away. So let me just give everything an alpha of 50. What happens if I make that angle really, really small? And maybe I should stop dividing by pi and just do something like 0.0, 0.02. Think this is starting to look a little bit more similar. Obviously, mine is doing some more stuff. Maybe it's going further or maybe the length is changing. I don't know what I'm missing to get this exact drawing, but I'm pretty darn close. Just take a minute to ponder the fact that this very formal, mathematical, highly repetitious pattern can somehow be turned into this feeling of seaweed, of growth, of organic nature like the plants that are right outside this window. What kind of beauty can you make out of this algorithm? I would love to see. Let me show you one more thing very quickly. Let me have this rendered to a PDF so I can blow it up and make it a very big poster if I wanted to. Let me show you how to do that. So I'm here on the PDF export page, on the processing website, and there's a bunch of different ways to do it. This is actually what I want to do here, single frame actually, I want to see it on screen. So let me do it this way, single frame with screen display. So this is a nice case where I want to render the PDF, but I also want to see it in the window. But I don't have an animation, I'm not layering, so this way makes it quite simple to do. I just want to import the processing library the PDF library that is. Then I just need to call begin record, right here at the beginning of setup. Begin record collatz.pdf. I'm going to do all this drawing stuff, which is what I'm doing. And then at the very end, I'm going to call and record. That was really easy to add that. Hopefully this is going to work when we run it. Might take a much, much longer now. Didn't take that much longer. I can open it up. It's taking a while for it to load, but what's nice about this it's vector graphics. So you can see my machine and the Mac preview app is having taken a while to render, but I can blow this up very, very large and it won't be pixelated. So make a version of this. Make a PDF vector file of it, print it. I'm going to hang one of these up back here in my office somewhere, in the studio at NYU, or here in the cabana. Who knows? Thank you for watching this second episode of Coding in the Cabana. I'm going to go water the plants. [MUSIC PLAYING] Hey. Thanks so much for spending your time with me. And I hope to see you next time on Coding in the Cabana. Bye. [MUSIC PLAYING]