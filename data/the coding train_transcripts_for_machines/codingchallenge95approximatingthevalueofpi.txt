[TRAIN WHISTLE] [BELL RINGS] Hello. Happy Pi Day. I admit this is take number two. I messed up the first time. I'm going to do a coding challenge, where I am going to approximate the value of pi. Now what's running here right now is the actual number pi. I mean someone should fact check that this is correct. You can go compare it to PiDay.org/million, which I think has the first million digits of pi. But this is a processing sketch using a particular algorithm to calculate all the digits of pi one at a time. It will go on forever. It will get very, very, very slow pretty quickly. I will come back to this in a future video. But what I'm going to do in this video is look at a way to approximate the value of pi. Now this came in as a suggestion originally from across akraus53 on GitHub, for how to look at random particles that end up in a circle or outside of a circle, interesting. It has something to do with the area of the circle. So I'm going to diagram this out. I should also mention thank you to the STEMcoding YouTube channel, and STEMcoding Project which has a ton of videos in various topics using programming and coding to teach different types of STEM related topics. It's wonderful. They have a video. You can find a link to it in this video subscription, basically, doing exactly the same thing that I'm about to try to do, probably better. But I'm going to do my best. I'm going to give it my all. And I'm going to do this in Processing, which is a Java based programming environment. If you're not familiar with it, I'm sure I'll link to some video where I talk about what processing is. OK. I'm going to let this run. And I'm going to come over here to talk about a method that I'm going to use to approximate the digits of pi. Now, there is something in our world known as a circle. It is a beautiful, round shape. It is a shape that I'm not going to be able to draw, but I'm going to attempt to. I'm going to move over here, just to give myself more room. Here is a circle. Now, if you were to look up a formula for circumference of a circle, you would find that it's equal to something called 2pir. This is the formula for the circumference of a circle. Now what are these things? Well 2 is the number 2. r refers to the radius center to the edge, r. This is the same length anywhere from the center of circle to any edge point. And pi, well this magic number 3.1415926 that's all that's all I can remember. I might not have even gotten the 2 in the 6 right. Good. We're going to approximate it. We're going to see if we can get better than my memory tells me. So how can I use this fact to calculate the number pi? Well, one thing I could do is I could get a piece of string and I could wrap it around here in my perfect circle. Then I could undo the string, I could get a tape measure. And I could measure it. And then whatever that is, if I knew the value of r, I could solve for the value of pi. That would work. I should mention, by the way, just because I know someone's going to say something in the comments, and it's not tau day. Today is not tau day. I'll come back and do this with tau. But tau, is a number the Greek letter tau, or TAU. Pi being spelled with English letters or Roman letters PI. Is essentially, well pi is half tau, or tau is 2 pi. I don't want to get into which one is which. But this is often used, because then we could say the circumference is just tau r. But anyway, this opens up a big can of worms that I don't want to go down. So I'm not going to do the string method. Let's look at another two formulas from geometry. So one thing is what's the formula for the area of this circle? It looks quite similar, and there's a special relationship there. That's a topic for another time. But pi r squared. So pi r squared is the area of the circle. Now let's think something. What if I put a square as a bounding box to that circle, a perfect square? And I can draw that over here with this idea of r being here. So the sides of this square are twice the length of r. Area of a rectangle is the width times the height, a square just being the side squared. So the area, so this is the area of the circle. The area of the square is for 4. 2 times 2 is 4 r squared. So look at that 4r squared, pi r squared. Now imagine something. There's a relationship here, right? There's a relationship between let's say the area of the circle to the area of the square. That relationship can be expressed as a ratio. I could say the area of the circle pi r squared to the area of the square, 4 r squared. The r's cancel out the ratio. Is pi divided by 4. Or I could say that pi equals 4 times that ratio in a way. But what do I mean by this exactly? Well, why am I here? Why are we even here? How am I going to use this to approximate? So in the original GitHub post it said, well, simulate it with physics. So we could imagine one physics scenario is throwing darts. What if I were to just throw random darts at the wall. Well, they would go all over the place. Some darts would land within the square but not in the circle. And some darts would land within the circle but not within the square. So in a way, I can imagine the ratio of the area of the circle to the area of the square as the number of darts that land within the circle divided by the number of darts that have landed in the square. Now 4 have landed in the circle and 4 have landed in the square. So I could say pi, in this case pi is approximately 4 times the circle count divided by the square count, which is equal to 3 divided by 4. 4 times 3 divided by 4 is what? 3. So there is my approximation of pi 3.0. Da dada dada! [BELL RINGS] So that's right. I mean it's not very good, but I only through four darts. The more darts that I throw, if I did this infinitely and filled the entire space I would get closer and closer and closer to a better approximation of the number pi. So this is what I'm going to implement in code. Now I really, really want to just use for my dart throwing the numbers from this million random digits book. I'm tempted to use the random.org API. But I think I'll probably just use the processing random function which is a pseudo random number generator. That's another topic that I will come back to. OK, so let's go over to the code. Actually, before I go to the code, I wrote this in such a weird way. What I mean is 4 times the circle count over the square count. This equal sign was sort of a problem there. I'm replacing the circle count with 3, the square count with 4, so it's 4 times 3 over 4. And that's how I get 3. Apologies for that. All right, so I'm back in the code. Look at this. We're still getting digits of pi here slowly over time. Unfortunately, I'm going to stop this program. And I'll be running again later, and I'm going to go to a blank sketch. Whoops. I'm actually just going to close this. And I'm going to go to a blank sketch. OK, so what are the first things that I need to do? Let's create a window that's 400 by 400. Let's give it a background of 0. 0, that's fine. Stroke 255, then let's call the ellipse function, and I think our life might be easier if I just do translate to the center to put the 0, 0 at the center. Yeah, why not? And so the ellipse is going to be at 0, 0, with a radius of 200. The ellipse function expects a diameter. So the radius is 200. The diameter is 400. And then I'm going to say no fill. And I'm going to say rectangle, also 0, 0, 400, 400. And let's say stroke weight 4. Whoa. Oh rect mode, and I want to say rect mode center. OK. And let's make the size actually a little bit bigger, so I can sort of see the outline. What I want to do now is I want to start throwing the darts. So I'm going to use the Processing's random number function which is random. And I'm going to do this at the end. Let's do this at the end of draw. Draw is a loop that happens over and over again, if you haven't used Processing before. And this is a Java programming language, with an extra set of functionality for drawing. x equals random. And let's make a variable, a global variable called r, which is equal to 200. So I'm going to say r times 2, r times 2, r times 2, r times 2. I'm going to make a random number between negative r and r, and a y which is a random number between negative r and r. Then I'm going to draw a point at that x, y. So let's do our dart throwing. OK, look at that. So one thing is I'm getting some starry flickering thing. So I really want to just draw this in setup as kind of the initial background. And then I don't want to redraw the background again. But I think I probably will need the translate in both places. There we go. So now you can see I am filling the space with dots. So now, what I need to figure out is I need to count the dots. Well, I know the total dots. And actually, all of the dots, I don't have to test if dots are within the square, because I've set this up in such a way that it basically can only create dots that are within the square. So what I need to do is determine how many dots are within the circle. So let me do this. So first, I need to get the distance. What is the distance between 0, 0, and x, y? So this is how far from the center is that point. To be honest I weirdly, in every case of life, I would use the distance function. But for some reason, right now I feel like it's worth noting that pi is not being used here, that the distance function is actually using the Pythagorean theorem. Because if I know the x offset from the center and the y offset from the center, then this hypotenuse of this right triangle, x squared plus y squared equals h squared. That's the Pythagorean theorem. h is the square root of x squared plus y squared. So I want just for some weird arbitrary sense of purity, to say a square root of x times x plus y times y. And if that distance is less than or equals or just less than? Let's say less then. This is just an approximation. Anyway less than r, I'm going to say stroke, let's make it a greenish color. Here we go. Otherwise stroke 255. Here we go. Whoops, and I need another curly bracket. Here we go. So we can see now. And let's make it I don't know. I'm going to pick some arbitrary colors that are going to not look very nice. But I'm going to do my best. And here we go. So we have two different colors. We have this green, I picked colors that are quite similar. By the way, I could do this without randomness. I could just check all of the pixels. But I like the random method. And let me make these colors quite a bit more different. There we go. So we can see I've got some blue ones. And you can see if they're on the line, depending on where they are, because I have a stroke with a 2, they're either blue or green. So that could use some finesse. In the chat, the live chat that's going on, I see someone's asking what is float. Float is the data type. So unlike in JavaScript which a lot of my other tutorials are in, I would just say let x or VAR x or context, depending on how I feel on any given day, float is a floating point decimal number. OK. So now what we need to do, is we need to count. So what I'm going to do is I'm going to say int. I'm going to use an integer. Total equals 0 and int circle equals 0. So this is going to be total is going to mean the total number of dots, circle is going to be the number of dots that are in the circle. And what I'm going to do is I am going to say now, I'm going to look back at my formula, pi equals 4 times the total number of circles divided by the total number of total. So pie, and I'm going to say PIE, just not to be confused with the actual. There is a constant called pie that's available in processing. I guess I could do lowercase pie in processing. But I'll just say pie, because pie is delicious. And maybe that's really going to upset people. float pi equals 4 times circle divided by total and let's put those in parentheses just for fun. Now here's the thing. There's a couple of problems with this. Number one, total, I don't want total to be 0. It will never be 0, because I'm going to immediately say total plus plus, as soon as I pick a point. I'm increasing, so at least the first time it runs through this total will be 1. And then of course, if it's within the radius, circle is plus plus. And so let me say print line pi. So let's just look, and let's run this and see what we get. I keep getting zero 0. Why do I get 0? I don't get anything. So this has to do with integer arithmetic. So integer math, these are both integers, circle and total. So even if I say 10 divided by 20 that's 0 remainder 10, or 19 divided by 20 is 0 remainder 19. So it's always going to give me the 0. So I need to explicitly convert one of these to a float. And I think I might change this to double, for more precision. But this should now give me, you can see here I am slowly and slowly getting closer and closer, perhaps to the value of pi. Let's let this run for a little bit. OK. I'm back. I've let this run for just a couple of minutes. You can see that I'm not really I'm kind of getting something that looks like pi, and a little bit higher than pi. So I have to ask myself the question. What's going wrong here? Well, one guess that I have is that I haven't been so exactly thoughtful about my distance check. Maybe that sort of border of what's on the line versus not on the line is something that I need to think about more deeply. The resolution is an issue there. But the other issue might be just the way that floating point math works in the Java programming language. And I might need a different data type that allows me for more precision. So hold on. I'll be right back. I'm going to make some adjustments in the code. Look at this nice drawing, first of all. One issue is certainly that I'm spending all this time drawing, just to get like one point at a time 30 frames or 60 frames per second. So one thing I can absolutely do is there's no reason why I couldn't just put a little for loop in here, and say, hey, let's do 100 points per frame. And want what I'm going to do is I'm going to say a let's make pi a variable outside of that loop, just so when the loop finishes, I can take a look at what the value of pi is. So now I can do 100 points at a time. And you can see how much faster this is sort of filling up the drawing. And we can now go look, and see what have I got here. Yeah. So I think we just have a lot of randomness here. And now I'm getting 3.14 we're converging as best we can. So I think we've done a pretty good job at approximating pi. I think maybe I could actually be done. A couple of things that people noted. One is I could actually get rid of the square root from this program, and just look at r squared. That could be my comparison. Square root is a very slow, expensive calculation. I could fix some whitespace here. Another thing that I could do is let's just try this with like 10,000, and see what we get. Pretty good, pretty, pretty, pretty, pi. All right. Thank you, everybody. This is me. Oh! Whoa, whoa, whoa. No, no, no, no, no. Let's go a little step further. Let's use doubles. Let's see if using double actually does anything. So what is a double? So Processing natively actually doesn't really support the double data type. Any number that you have in a variable is stored in memory. And so floating point numbers, there's an infinite amount of decimal numbers between any two integers. But we don't have an infinite amount of memory on our computer. So we allocate certain number of bits. So floating points allocate a certain number of bits. Doubles allocate more. So if we really need to do precise mathematics, and then there's other Java classes and implementations for really big numbers. But let's at least change this to double. Let's change this to double. And I'm going to have to use casting because double is not and I'm going to change this. I'm just going to change this to double as well. I'm going to overdo it. I don't think I need to change all of these. And by the way, I don't need to calculate it. I don't know why I did that. I can just calculate it once there. And I wrote float, and let's make this double. So now let's take a look at this. And one thing we can see is already there are more digits appearing in the print line statement. And maybe, maybe, I think there's just so much randomness that's part of this, that ultimately I'm not so sure that we're going to get anything that's really that accurate out of this method. But it is nice to see we've consistently got 1.41 now, which is right. If only we could get a 5 here, 0.1415. Let's see we if we can get a 5 here. Come on get a 5. Yeah, I saw a 5, A 5 consistently, so maybe over time as we do this over and over again. Now one thing, could we make this drawing any prettier? I mean one thing that I might choose to do is make a stroke weight that's more like 0.1, so a very light stroke. Maybe you can't see that at all. So it makes a stroke weight of 1, but maybe give some alpha, so some transparency. There we go. I don't know. It's kind of interesting. It looks like I'm looking under a microscope. I'm going to let this run for a while. And I'll just be back in a couple of minutes to check where it got to. Actually, I'm back, because I got a good comment from the chat, which is that I could choose to try to make this test a bit more precise. So I can make this a double. I could cast the x as a double. And again, I'm going to just overdo it and cast everything. So let's cast all those as doubles, and let's run this one more time. We can see it filling up here. And it seems to be running at a perfectly reasonable frame rate. So I'm actually going to try to do this 10,000 times per frame. No. It's a little bit slow. So I want my animation to be fast. Oh, that was 100,000. Let's just go with 10,000. So let's take a look. OK. I'll be back in a minute. Let's see how many digits we can get, and see how close we're doing. Hey, I'm back again. So you could see this kind of algorithm, it's not going to converge very quickly. There's a lot of noise in it from the randomness. But one thing I could do to add to this program is try to keep track of which one is the best. So there is in Java natively, let me take out this print line for a second. And what I'm going to do, so Processing natively has the constant PI, but Java also has the constant PI that is in the math package. So let me look at both of those. And you can see that that one is a double. So this is actually what's stored. It's not that many digits in math.pi in Java. So what I'm going to do is I am going to create. I'm going to create a variable called record_PI. And I am going to set record_PI equal to 0, just as its initial value. I don't need to set it down there. So I can just set it up here. Then what I'm going to do is I'm going to look at double the difference between Math.PI minus record_PI, and let's take the absolute value of that. And I also need to oh, I guess I have to do math.absolute, because I have doubles. So I'm going to take the difference between Math.PI and the record_PI. So this is actually really the record difference. Then I'm going to look at the difference between the pi I just calculated. Math.PI minus the pi I just calculated. So if the difference is less than the record difference, if we've gotten one that's closer, then the record difference is now the difference, and the record PI, why did I use an underscore? Did I use an underscore? That's sort of unnecessary record_PI equals 0, and then record_PI is that new PI. And what I could do is whenever I have a new record, I could print out record_PI. So let's take a look and see what I get in the console there. And in a way I kind of want to do that every time because I feel like I should give it a chance. This is not a big calculation to do. I might as well do this every single time, even though I'm only drawing every so often. So let's put all this inside of this loop, and let's run it. And we can see this is now currently the record 1.415926. Hey, I don't know. How many digits have I gotten correct? All right. So, let's go look at the actual digits of pi. So I'm going to go to PiDay.org/million and I don't need that many of them. This is going to be plenty just the first line here. Let's open up Text Edit. Let's put this in here. And let's make this a little bit bigger. Let's go back to the processing sketch. Oops, let's bring this down here. How many digits do I have? And let's take a look and compare. So, so far, we have gotten 1 is correct. 4 is correct. 1 is correct. 5 is correct. 9 is correct. 2 is correct. 6 is correct. 5 is correct. My font size is not the same. Have I gotten as close as I can get? No. No. This is wrong. 6 is correct. 5 is correct. 3 is correct. So, I'm just going to give myself a couple of minutes to take a short break. And I'll come back and see if anything got a little closer. All right thanks for watching this coding challenge. There are so many ways this could be improved. You could sort of plot the difference. You could visualize these numbers and highlight which digits are correct, which are incorrect. You could think about how you're drawing this. You could make the random numbers double that you're picking. I don't know if that would really help. You could use my favorite website, Random.org which has an API for random numbers. It's really not going to make your program run faster. But there is so much that you could try to do. So, if you make something with this coding challenge, please share it with me in the comments below. You can also go to TheCodingTrain.com website. There's a place where you can link to your shared version. I will also release a JavaScript version of this that you can run in the browser, and maybe actually that might be an easier way to also display the results. So thanks for watching. I hope you enjoyed this Pi Day coding challenge. [TRAIN WHISTLE] [MUSIC PLAYING]