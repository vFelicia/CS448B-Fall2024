hello in this video I'm G to give myself a headache I can tell already but I'm here to describe to you a problem called the minimum spanning tree it's a problem from a computational geometry kind of thing uh and I'm going to describe that problem we're going to look at a solution to that problem known as prims algorithm uh named for somebody named Prim presumably uh and then we'll implement it in p5js and as always I will also upload a processing version of this as well but I'm going to use p5js to actually write the code so first let me just show you before I describe to you what the actual problem is and the solution let's just look I have a simple example preset that's going to that's the the foundation for what we need so if I just look at the code for this example for a second first there's just an array a blank array calling it vertices because every time I click the mouse I'm going to create a vector a vector being an object that stores an X and A Y so I'm going to create a vector with mouse X Mouse Y where the mouse is and then I'm going to add that Vector to an array and then you can see in draw here I'm just drawing an ellipse for every single one of those vertices so if I run this program and I click you can see here that every time I click a vector gets added to that array and I draw a circle for every one of those spots so the question is what is what is a minimum string tree problem and this is a temporary whiteboard that I'm going to see how it works so bear with me please um what is the problem how what what is this problem once you have these points so let's say you have the points and I'm going to make some random points the minimum spanning tree problem says how can I connect every single one of these points every single one of these points must be connected to another point and if I add up all the distances I have the smallest amount of distance so there's lots of ways that I could connect them all like I could just do this and they're all connected but I could also have done this and they're still all connected and I could have also done this and they're still all connected and if I at least I made these pretty evenly spaced out so probably if I oh Bo this is scary probably if I were to draw a diagram like this um uh and then if I put another one here right they're all connected like this but that's probably if I add up those distances it's going to be a lot greater than if I connected them like this so uh and it doesn't have to be a closed shape it doesn't have to be a continued path the only thing that has to happen is that every single point has to you have to be able to get from every point to every other point somehow so this is the kind of application that you could probably create some kind of interesting visual art project out of but but it's used it's it's a relevant pract it has practical applications for example if you wanted to connect everything with some kind of like electricity or telephone telephone people use those anymore telephone signal you know and you only had a certain amount of cable like what's the way to have them all connected and you're using the you're saving the most money using the least amount of cable and I'm sure you could come up with all sorts of other scenarios for where this is relevant so how do you solve this problem okay so there's a variety of different solutions to this problem some of which are more efficient some of which are less efficient some of which do it you know um more quickly or less quickly but the solution I'm going to show you sorry is called a prim's algorithm and it works as follows what if we start with a random Point essentially let's start with this random Point okay now what if what we do and we have this I'm going to introduce this idea of an unreached vert Vertex or a reached vertex so at the start all of the vertices are unreached there's no line connected to it they're all unreached vertices I can't get the telephone signal to them and we're going to start with one single and this is now a reached vertex so what I want to do is say okay what can I connect this one to that has the least distance so this particular vertex I can check every other one and I can see and I check the distance and this one actually has the least distance so now I have two reached vertices this one is reached and this one is reached now what I need to do is the same thing I need to find not just the one that's closest to this one but the one that's the least distance between this one or this one so in other words if if this were here I but you know this is a little bit longer than this but shorter than this and this I'm going to go in I'm going to go ahead and connect this here but if this one is if this one is closer than this one I'm going to go ahead and connect this now I need to say is this shorter than this than this than this or this and this so every I have to check every single reached vertex against every unreached vertex and find whichever pairing has the least distance and then that gets and maybe maybe right now it's this one and all these are reached and then maybe right now it's this one and then maybe it's this one and then maybe it's this one and maybe it's this one now I don't know if that's exactly right but you can see that eyeballing it that's probably a vague solution so this is the problem now let's go and write the code to solve it okay I'm coming over here okay so what is the first thing that we need to do well the first thing we need to do is is implement this idea of reached and unreached so I'm going to create in the draw Loop I'm going to create two new arrays one for to store all the vertices that have been reached and one to store all the vertices that haven't been reached at the beginning what's going on here every single vertex X should go in sorry in unreached so I'm going to write a loop here so and I'm going to say unreached push vertices indexi so this is me just essentially cop I'm sure there's a somebody in JavaScript land can tell me a better way to copy an array into another array but one way to do it is just say hey let me go through everything in this one array and put it all in this other array so at the beginning all the vertices right all the vertices are unreached every single one okay come back over here now I want to pick one vertex to start being the one that's reached I need something to go in the reached array so I'm going to say um VAR uh start equals unreached index zero and then I'm going to say reached. push start so I want to put I'm sure I could you know whatever this is silly to have a separate variable I'm going to just put ah unreached index zero zero not o I'm going to put one the first vertx from unreached En reached just to get us started okay once we have that I need to do something else if I'm taking a Vertex from unreached and it's going in reached I need to remove it from unreached so I need to say unreached splice zero so the splice function set is like delete delete the zero element element only I'm not done yet the splice function wants you to say not just which element you want to remove but how many so so I want to just remove one element from that zero spot okay now now I have an algorithm I want my algorithm to go as I want to the goal of this is to get everything from unreached to reached and unfortunately this camera shut off because I forgot to start it at the beginning of this video so I want everything to go from unreached to reached so here we go I'm going to say as long as unreached do length is greater than zero I can keep going so maybe there's another way in JavaScript to test if the array is empty or not but basically what I'm saying is as long as there are still unreached vertices we haven't finished the algorithm yet so every single cycle remember every single cycle we need to say what are the reached vertices for every reached ver ver check the distance against every other unreached vertex and find the shortest distance so in order to find a shortest distance amongst a bunch of candidates we always have to start with something that's kind of the record if I was trying to find the longest distance it would be easy I say does is the distance bigger than zero than it's currently the longest distance so the first thing I need to do is just come up with I'm going to call it record some like large number 100,000 so there's not going to be any vertices that are more than 100,000 pixels from each other in a 640 by 360 window then I need to uh say for every uh oh and I probably shouldn't no it's okay to use I for every vertex in the reached array check every vertex in the unreached array okay for for every vertex in the reached array check every so for every reached vertex check every unreached vertex and what do I need to do the thing that I want to know is the distance between and let's um let's say V1 is reached index I and V2 is reached index J and I want the distance between v1x v1y to V2 dox and V2 doy so the core algorithm here is check every distance between every reached vertex and every unreached vertex now if the distance is less than the record then the record is the distance so what we're doing is we're saying I want to find what is that shortest distance at the beginning the shortest distance is 100,000 and the first distance is like 300 oh it's less than it that's the record then the next one is 250 oh that's less than it that's the record then the next one is 400 oh that's not the record then the next one is 100 oh that's the record so we're doing every single one always if we have a distance that beats the previous record we have the record so this is the core algorithm for finding that shortest one but if I find that shortest one what do I need to do I need to store also the two vertices that are involved in that shortest distance so I I need to have in addition to just um the record I need the reached I'm going to call this the r index the reach index and the unreached index so if this is the case if I found that record r index is i that's the index from this array and uh U index is J and in fact I don't I could actually instead of storing the no we'll do that we'll do it with the distance with the index so I got those so so now you can see here uh I now I'm storing I've checked checked every reached every unreached found the shortest one and once that's done once that's finished what happens I need to do exactly what I did up here right I need to say put take take the unreached one and put it in reached and then remove it and then remove it from unreached so this is my algorithm to I found that new vertex remove it from reach remove it from one array and put it in another array there's probably I probably could like do this all in one fancy line of code but it's nice to have it in two and then while I'm here I might as well draw a line uh oh I don't I don't have those AS Global variables that's fine I might as well draw a line between reached r index dox so this is going to get very long very quickly r index doy and then unreached uh uh uh unreached index dox unreached unreached index doy okay so let's see um I don't know did that work okay so line 45 uh I messed something oh because you know what I better not here's a problem right I mucked around with the arrays and then I drew the line after so that's definitely not going to work right I need to if I'm drawing the line right before I start moving them around I should do that so let's just see here okay so we we got kind of something happened and then and then something didn't happen what okay so um so let's think about this for a second what what could so so this is the core idea let's let's review for a second how long have I been at this only 13 minutes that's not terrible so we started with uh every time we every time there's something's left and unreached we start with a record we have two indices we go through everything in the reached check it against everything and unreach ah look at that that's not right V2 equals reached so the point of the second one is to pull something out of the uh second array that's clearly not going to work and yeah this looks like it's working look at that and I don't like the way the lines look here so I'm going to say stroke 255 uh stroke weight two and here and you can see there we go we have our minimum spanning tree as I add points and conceivably by the way um you know if I wanted to just demonstrate this in a different way I could say uh I could just add like 50 random points right when the program starts uh and I could say random just width uh random height and uh do this you can see every time I run it we get a new and the one thing I'll mention about this is I'm doing in this program you notice the whole algorithm is happening in draw so it's recomputing the minimum spanning tree over and over and over again it doesn't need to do that it but you know conceivably if the points were always every time you add or subtract a point you would need to recompute it and I'm so you might be if you were using this and something you might be more thoughtful about only recomputing it at a certain point the other thing I'm not doing here is this particular like drawing is just sort of drawn and I can't do anything with it so if I were if I wanted to go further with this I would probably make Edge objects so in other words I might have an array of points or vertices or like a Vertex object I'm just using the P5 Vector object with create Vector but then I might create these Edge objects so there are things that I could animate or change color and put those in an array as well you and the place that I would do that is right here right instead of just drawing a line like I just said I figured out the vertex I'm just going to draw a line there I could actually create that edge object all right so this is pretty much the end of the video I'm actually going to look though I don't know if people are posting qu I have this even though if you're watching this you might be watching this like 10 years from now um I actually am recording this live and there are some people watching this live so I'm going to you could shut this off now if you want but I'm going to just look and see if there's any questions uh somebody points out that um okay there are two um improvements that are pointed out in the chat which I'll mention let's see if they still work so first I just want to make this with just 20 so one is that I could copy the array by saying uh reached uh reached equals unreached the JavaScript function concat which I guess is like concatenate no but then that doesn't it's not an array it just joins them I would have to then split it or something um but and then uh oh reached push unreached shift is another way to put the first one in so people are so there's all these other array functions but that one's not going to work I'm sure there's another I'm going to put it in the comments read the comments I'm sure it'll be fixed in there um there are all sorts of other kind of array function so is there anything else I'm missing here I think we did it I'm going to post this code a link to this code uh please post your questions in the comments because I I I don't know how well this was explained or if this makes any sense at all but I'm glad to have made a video today on Friday it's 515 um I got to go let me just look is the code available somewhere um um yeah the code someone asked the Cod the code is going to be there'll be a link in the description it's not available yet if you're watching this live I'm going to stop the recording and then talk to the live people okay bye thanks for watching this