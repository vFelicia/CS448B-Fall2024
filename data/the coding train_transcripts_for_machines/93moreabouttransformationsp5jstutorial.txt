All right, so I'm going to make one more video here about transformations just to cover a few bases that I didn't get to. And some of this is unnecessary information. You could probably skip this one. But if you want to dive a little bit deeper into this, there's a few things about this. The first thing I want to say that's actually quite crucial about push() and pop() is that push() and pop() doesn't just save and restore transformation information. And this is actually not true if you're using Processing, the Javabased platform that I use in some of my videos. This is only true if using p5.js because it's the way that the HTML5 canvas works using all these terms that I don't want to use but I'm using them. So it actually saves and restores lots of style information as well, which can be useful to you. So, for example, if I go back to this code. And at the end here, if I just want to draw another ellipse, another ellipse is going to be at 300 is going to be at 300, 300, 60, 60. And I hit Refresh. Now look at this. This ellipse is not gray with a white stroke, with a white outline. It should be because I said, stroke(255); fill(100); drew the rectangle. But actually, push() and pop() also save and restore stroke weight, stroke, fill, all sorts of styling things. Now, if I could try to give you a list of every single function, that's every single setting that's saved and restored by push() and pop(), and I wouldn't know I wouldn't be able to begin. But in addition to the transformation stuff, you can also use this for styling information, which I generally don't, but you might find this useful in another context. So that's number one. Now the other thing that I want to mention is that you could imagine a more complex scene, where this thing is rotating around this thing. And this other thing is rotating around this thing, but this other thing is rotating on this thing but not this thing. And you start needing to say, push(), draw some stuff, push(), draw some stuff, push(), draw some stuff, pop(), draw some stuff, pop(), pop(), or something like that, right? So one thing you should realize is you can only have as many pops as you have push. You could only restore the amount of things you've saved. But the question arises, which is, when I save a bunch of times and I restore, which thing that I saved do I restore? And a way that you can determine the answer to this question is, is the way that I'm saving the sequence in something called a stack or a queue or perhaps some other algorithm? So there's something called a stack, and there's something called a queue. I don't know if I spelled that wrong, a queue. What are these things? So push() and pop() are terms that apply to saving and restoring information in a stack. It's called a stack because you can think of it like a stack of paper. So if this is like a bin, your inbox, so to speak, and I put paper A in there, then paper B, then paper C, then paper D, they're stacking up, A, B, C, D. So push() is pushing the things onto the stack, adding to the top of the stack. When I say pop(), I take the last thing out. So first one in, last one out. No, last one in, first one out. That's what it is. The stack the last thing I put at the top of the pile of paper is the first one I'm going to take off. This is different than a queue, which you could think of like some kind of ticket window, where people line up in a queue. The first person in line for the queue is the first person to get a ticket. So these are data structures that are common to a lot of programs and a lot of scenarios that, if you watch all of my videos, might come up and lots of other places. You don't really need to worry about this too much in the case of transformations, but it is important to realize that push() and pop() are terms that relate to the data structure, a stack. They refer to pushing things on to the stack, popping things off of the stack. And if you push() multiple times, save multiple times, you're restoring in reverse order. So I probably should cook up some kind of example that needs that. I can't think of one right now, so I'll come back and do that another time. But that's one thing I want to say. Now the other thing I want to say with the p5 reference here, I'm going to go to Transform, and I'm going to look at all these functions. So there's a couple of things that are there's some things that are important here. Number one is, oh, my goodness, in addition to rotate(), there's rotateX() and rotateY(), and rotateZ(). Now, those functions rotateX, Y, and Z I actually have no idea what shearX() and shearY() do. We should look at the reference to read that those functions are for the WebGL renderer. The WebGL renderer is a 3D render for p5. At the recording of this video, it's still in the very early stages. There was a lot of work that was done over this past summer through a program called Google Summer of Code. So the WebGL library is in much better shape and hopefully will continue to improve. It's a way of doing 3D in p5. I should come back and make another video about that and look at transformations in 3D. But in case you're wondering, if your rotate() is the same as rotateZ(). The zaxis is the axis that comes out of the screen, and so things rotate around the zaxis. If I come back to this, this over here [LAUGHS] let me zoom in on that. I'm desperate to do this exact demonstration that I want to do. [LAUGHS] Feeling like my hand right there. Oh, there is. That's the zaxis. This is pathetic. [LAUGHS] That's the zaxis. I'm pointing at you. So that's the something rotating around the zaxis. If it was rotating around the yaxis, it would come out of the screen like this. If it was rotating around the xaxis, it would come out of the screen like this but not actually come out of the screen because it's 2D, and I'm off in nevernever land, talking about 3D, but it's really 2D. It's just the illusion. Explore that on your own time, or I will come back to it in a future video. But the other thing I wanted to mention here is you'll see like, oh, applyMatrix(), resetMatrix()? Why is the word "matrix" there? What are we talking about? Well, it turns out that the way the orientation, the transformation state what is the transformation state? Is 0, 0 in the top left, is there any rotation, is there any scaling, is stored in a matrix of numbers. And that matrix of numbers might look something like this 1, 0, 0, 0, 1, 0. So this is a 2by3 matrix, two rows, three columns. And this is describing the default matrix with no rotation, no translation, no scaling. You can imagine if I scale by 2, This matrix might turn into 2, 2. If I translate, some of these numbers might change. If I rotate, some of these numbers might change. So I would love to do some kind of tutorial, pretend that I know all about this. I'm going to do something like tutorial series about programming your own transformation engine 3D rendering thing and how you calculate all these matrices. But this is what's more important about it is that, as you do this, it's all stored in a matrix. So some things you can do is you can just actually call the resetMatrix() function. And reset is just wipe everything. So push(), push(), push(), pop(), pop(), pop() is like save, save, save, restore, restore. But if you just want to reset back to the default state, you can just call resetMatrix(). ApplyMatrix() I've never actually used this, and I don't know how far along if this actually works in p5. But in theory, if it does, what it's supposed to do is I could cook up my own set of numbers, put that into some kind of array or something, and then apply that to the matrix. This video better go far away buried deep somewhere in the playlist because this really isn't part of the first few weeks of learning to program, but I'll figure that out later, but, boy, it is. So that's really the last piece that I want to explain what is push() and pop(), and why do we talk about a matrix when we talk about transformations. OK, thanks. [MUSIC PLAYING]