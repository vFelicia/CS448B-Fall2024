hello welcome I am very excited that this is another guest tutorial video and today's guest is I meant to ring the bell after I said her name and Alicia she is Peter in the studio and she just did a tutorial building exactly this what you see behind me which if you don't recognize is a visualization mirroring the rain effect in moving the matrixmatrix rain so this is really wonderful it's a perfect thing to use p5.js for and there's a lot of creative possibilities that I hope that after you watch the tutorial you will make and share and share so a couple things I want to mention number one if you're looking for the source code for this tutorial if you're looking for Emily's Twitter to share what you make with her everything will be in this video's description I also wanna mention for those of you viewers here we've always asked me to please use for each loop you will finally see on the coding train sub for each loop in this particular video because Emily very smartly is using them so without further ado I will leave this screen and you'll then see the tutorial starting from Emily oh I want to say a few things about Emily so Emily is a creative coder and artist she has done workshops and other projects with organizations great organizations like girl develop it and pioneer works in Brooklyn and she's also currently working for Squarespace so you could find out more about her to check out her Twitter and her website which will also be linked in this video's description ok now just enjoy the tutorial ok thanks bye ok everyone and thanks for the wonderful intro dan I'm super excited to be here especially as someone who's been following this YouTube channel for a while now so for today's tutorial we're going to be rekt creating that iconic matrix raining code using p5.js and some of you who have never seen the matrix series before don't know what it is that I'm talking about have no fear I'm going to play the clip from the movie to clarify cool so that ringing green code this right here this is what we're going to be recruiting using t5 and in terms of background level I'm going to teach with the assumption that you have some basic understanding of objectoriented programming and may be rich in a few simple p5 sketches maybe you've seen some advanced videos on this channel or maybe it just sort of explored the library yourself anyway let's jump right in so here is my sketch file where all the p5 magic will happen and right now it's empty but let's still in with our two core p5 functions set up being one of them and as some of you might know this is the function that gets in both watts immediately upon loading up your sketch and I know I'll also need the function draw which some of you might also know it's the function that gets called repeatedly at 60 frames per second as your sketch run so now that I have these down let's start first by flushing out setup so inside of this function I'm going to make my canvas so as to carve out where on the webpage I want my sketch to be we're going to use the function create canvas and I actually want the sketch to span the entire page so for the with argument I'm going to pass in window dot inner width and this returns the width of your browser's entire content area and for the height I'm going to pass in window dot inner height as what you might be able to guess returns the height of your browser's content area cool so I know I also want my background to be black so let's go ahead and set that to zero and let's run this there we go awesome so we have our initial setup which I blend entirely into so this is the scene where we'll make the matrix raining code happen so now let's take a step back and think about the sketch at a higher level and let's sort of consider what might be some of the general components or classes here so if we look at this as a matrix if you look at the screenshot here I can sort of sense that there are going to be two primary object types one of them being the symbol so it's like each one of these characters individually and the other one being the stream object so a stream being like one of these vertical lines comprised of symbols so let's go back to our code and let's stub out these prototypes and by the way I'm going to use the term prototype and claps interchangeably here so as we go to code and stuff out symbol there we go and our stream here we go so let's start off with our symbol class and make just one symbol and show chill it for now and we'll get to the screen coughs a little bit later so I'm just going to go ahead and move it down a bit so for our symbol you're going to need an X and the y to show the location on the canvas both of which will we pass in to this signature here and then let's add these properties so this dot x equals x dot y equals y and we also want a variable to hold the actual symbol itself and we'll call this value and this will be set later on using this function set to random symbols okay so one will go into this function what should each symbol get set to maybe take a look at the matrix you'll see that the symbols are in fact comprised largely of katakana which are characters that represent syllables in Japanese and I knew I knew being the an indigenous ethnic group living in Hokkaido and Russia so that's your a bit of trivia for today so how do we represent these characters our keyboards won't let us type in katakana so what do we do also we're almost simply enough we will use unicode which is an American coding in order to represent them and pictured here here is all of the katakana in the katakana unicode block and our 96 total so let's go to our code and write our function to randomly retrieve one of these beautiful symbols here we go and I'm actually just going to wipe this out and I'll explain in a bit so that's not value equals green dot from care code okay there we go the past in 0 x3 0 a0 plus round it to a random number 0 96 okay so that looks about right so the katakana unicode block starts encoding 0 x3 0 a0 which translates numerically to 1 2 4 4 8 which will then be added to a random whole number between 0 and 96 because there are 96 available characters in the katakana unicode block and then whatever number results from this addition will be passed into this function from care code and finally converted into a string containing your katakana characters and set to this stop value okay so now that we have the code to retreat and set our symbol let's write a function to actually display it on our canvas and we'll call it render it's going to scroll down a little bit for everybody to see so we'll use the text function to actually display our symbol and we know that the symbol is contained in this top value and we want to display at coordinates X and coordinates x and y and we'll fill it with colored 0 for red 255 for green because we want it green but we also don't want it sugaring so maybe we can I don't know add a little bit of blue in there so maybe like a blue value of 7b might look nice great so now respecting love so that we can create our symbol and renters so if we go back up here at the top of our code let's start a global variable to hold that symbol we'll call it a symbol and since its global we can access this variable anywhere in our global scope and now down in our setup function let's stick an instance of our symbol into that global variable so symbol equals new symbol okay and for now we'll display the symbol smackdab in the middle of the screen the canvas just for demonstration purposes so we'll set the x value to what's divided by 2 and the y value to height divided by 2 and now within the draw function oh we should probably set the symbols values symbol dot set to random symbol there we go and now within our draw function let's render it symbol dot oops of thunder okay and let's play okay so I've made a mistake somewhere let me go ahead and inspect my code so it says somewhere on line 12 but there's an unexpected token ah I have an extra comma here I'm going to fix that and now I'm going to replay this okay awesome so now we generate a random kind of Kanna character but actually it's a little bit small I'm not even sure if you can see it so let's go to our code and increase the size of the symbol and we'll do that by creating a global variable called symbol size and let's set it to something huge just so that we can see so I think maybe 60 and now within our setup let's actually assess the text size here text size I believe is the function to our symbol size and now I'm going to refresh okay fantastic so now we generate a random katakana character whenever we load up our sketch and if you refresh I'm just going to refresh here you'll see that you get a new one every single time however in the matrix the symbols don't just sit there in the middle of the page they rain down so let's go ahead and write some code to do just that so let's go back to our sketch file and if we go back to our symbol class what's that a speed value here to determine the rate at which this symbol Falls so speed will get passed in and the speed property will get passed a set as what gets passed in and what's right a function to actually make the symbol rain down and I think an appropriate name would be rain okay and inside this function all we're going to do really is increment the Y position of the symbol object according to the speeds still have to make the symbol slowly move down the page so this got y plus equals the stop speed okay and now within render let's pass in a random speed sorry now within our render function since this is what gets invoked on every frame by a draw let's make it rain so this stop rain right and now back in our setup what's passing a random speed whenever we create this new symbol object so for now let's say we'll give it a ballpark of five to ten so randomly generated but let's also switch the Y value out so it's not halfway down the page will cause it why I like how the symbols start up the top of the canvas so we'll set Y does zero okay so let's go ahead and refresh this okay voila so we now have a symbol that rains down the page but we actually want to redraw the background on every frame so that it erases this trail because this isn't what the matrix looks like let's go to our code let's go to backgrounds other let's go to draw and let's uh stick the background in there okay and now let's replay this okay great so now we have a symbol that rains down but once this character reaches the bottom of the screen we actually want it to loop back to the top and replay all over again kind of like a jiff so let's go to our code let's go to the rain function okay and let's rack the in a bit of a conditional with throughout the increment okay so if this dot Y is greater than or equal to height so if the Y value is greater than the height of the canvas this means that it's reached the bottom so let's reset Y to 0 otherwise let's just proceed as normal okay and actually we can make this look a little bit nicer using a ternary operator which is just a syntactic cuff for this commonly occurring a conditional pattern so there was me four seconds that's got y equals this cot why is it greater than or equal to hype if it is then set it equal to zero otherwise increments Y with the speed so this this here and this here are the same I'm going to get rid of that and now we have some nicer looking code so I'm just going to go ahead and replay this now okay great so now we have a symbol that rains down in a continuous loop in the R matrix but if we paid attention to that clip from the movie we'll see that a symbols randomly switched to other symbols as it leans down so let's go ahead and implement that let's go to our code and let's go to our render function since this is what gets called on every frame and if you think about it we've actually already written a function that allows us to switch from one character to another and that is set to random symbols so let's go ahead and just call that within this render function okay so now I'm going to play this again okay great so it's switching to a new random symbol but it's doing it way too fast it kind of looks like a blur you might not even be able to tell what this is so instead of making it switch on every single frame and there are 60 frames per second let's do it accordingly according to a interval okay so let's go back to our code and um hmm let's go to the symbol class and let's make this interval a property of the simple class so this stops which interval seems like a pretty good name and simply know that the switch interval should maybe differ a bit for every symbol let's randomize it so I'm going to randomize it to a whole number between I don't know 2 and 20 let's say and now let's go to our set to random symbol function and restrict the symbol being reset by the switching table and we can do that using a conditional let's wrap this all in a conditional so if frame count I'm just going to write this and I'll explain it in a second modulo this which interval is equal to 0 I'll move this line of code up here some proper indentation there great so frame count is a variable that is built into p5.js for you and keeps kind of just running tally of how many frames has passed thus far and modulo is an operator that performs division and returns the remainder so we performing modulo on frame count using switch interval and so we're looking for a remainder of 0 here we're basically saying whenever the switch interval divides evenly into our frame count then execute this line of code so it's winter such interval over 15 this means that when the frame count is 0 or 15 or 30 or 45 the modulo will return a zero and then we set a new symbol football is very short this code says to reset the symbol at every end frame and being your switch interval anyway let's play this now great okay so now we have a symbol that rains down and switches to another symbol at a randomly determined interval so now that we have our symbol class figured out let's make it rain not just one symbol but an entire stream of symbols and since stream comprises of symbols our symbol should be should live inside this Greek stream class so let's remove that single symbol that we've subbed out for demonstration purposes let it go to my setup remove yeah little bit and remove this from as a global variable and now let's go to our stream class let's all the way down here move this up a little bit and without a property that contains an array that will hold all of our symbols for the stream so this stop symbol is what we'll call it let's give it an array and now thinking through some of what are the other attributes of what constitutes a stream I think each stream should know how many symbols it has so this thoughts total symbol pretty good name and let's give it a range that it could randomly pick from so that each stream has a different number of symbols in it so I don't know maybe on streams will be as short as five symbols and some trees will be as long as three symbols and they'll be screams of all sizes in between okay and I also think that each stream should know how how fast is traveling at so let's give it a speed property let's set it to a randomly determined one let's say somewhere between I don't know five and twenty I also think it should be the responsibility of the extreme to create all of its own symbols during the initial setup so let's write a function to do that and this function will use a loop to do all of that so we'll call it generate symbols okay there we go and outside of our loop will set a Y variable that gets passed into our symbol objects and we'll start it at zero so that it starts at the top of the page and for an X variable let's also set that to let's set up to a width the width divided by two so that we see it the symbol for the screen at the top of our canvas in the middle okay all right so let's write our loop so for each of our four loops looks more like this start at zero and we want to loop through however many symbols there are that's how many times a loop through and we'll increment our loop and on every iteration we should create a new symbol so we'll pass in X Y and speed at which the stream is going and right after we create the symbol we're going to set the symbols initial values so set random symbol and then we're going to take that symbol and push it into the streams symbol array so that it can live there and then at the end of each loop we also want to decrement Y whoops looks like this what is decrement Y by the symbol size there we go so that's the third except the next symbol immediately above it so at the program start if you were to render all of the symbols in the stream what it would look like is if you're at the top of the canvas the streams of the symbol to be stacked in a straight line above the canvas and that's because Y starts at zero and gets decremented and since it's the streams responsibility to create its symbol let's also give it the responsibility to display each symbol on the canvas so let's write a function for this we'll call it render and we'll write a for each loop looping through all of our symbols and we're going to pass in an anonymous function and call each of the elements that were iterating over symbol and we can actually copy and paste the code that we wrote in the symbol class since we're transferring responsibility of rendering from from the symbol to the stream okay so let's copy and paste this and let's also get rid of the remnants of this function and then let's let's paste this so indents things correctly and since each elements that we're iterating over it's called symbol we must change all of this too bowl okay and there we go and by the way keep in mind that there is more than one way to skin a cat you can cheap it so that it is the symbol responsibility to render themselves and organize your code in such a way but I prefer it this way and I think ultimately it will make the code look just a little bit nicer and easier to read so now that we have our stream clock figured out let's go back to the top of our code and write a global variable to hold our stream so we'll call it screen and then what's in our setup creates our stream so free okay and then after we create it let's instruct it to generate all of its symbols and finally in bra let's render that stream so looks this symbol no longer exists we're gonna render the screen okay so let's load this thing up and how we did okay awesome so now we have a stream that rains down repeatedly and the stream contains characters that switch at their own randomly determined intervals but as you may have observed the matrix does not have just one stream there are streams all the way across the screen so let's go ahead and set things up so that our matrix is all the more exciting let's go to our code and let's change the global variable so that instead of holding just one screen it holds an array of extremes now let's give this an X so it's streams and now in our setup let's populate that array with a loop so I'm just going to go ahead and get rid of this one term that we've subbed out and outside of our loop we're going to have an x and a y variable which will inform the coordinates of each stream so let's start them both off at zero and now we loop so start the loop at zero and we're going to go until whips divided by symbol size and we want to divide the total width of the screen by the symbol size in order to get the total number of streams since each stream is a symbol wide so there we go and now let's loop so we're going to create a new stream on every iteration and then instruct the stream to create generates all of its symbols there we go and we originally hardcoded X&Y into the generate symbols function but since each stream will have a variable x and y that gets packed into it we should just go in and let's go to that function and let's pass those variables into it reflect that in the signature and get rid of this x and y that we hardcoded okay great so now going back to our loop where was it ah here it is so once we once we have our stream and all of its symbols we'll push it into the mega array containing all of the streams so stream dot push that one stream that we just made and then we also want to increment where X starts because we want each stream to start right next to the last one so we'll increment by symbol size because each three money know is a symbol symbol wide so now in draw instead of rendering just that one stream let's write a loop that will loop through all of our streams and render them all at watch so let's go to draw let's get rid of the rear Enders just that one screen and we'll write a 4h on our streams mega array and we're going to pass in a function each items that we iterate over and screw in this loop will be called stream and get rid of that okay and every time we loop through we're just going to OH screen there we go Thunder okay now I'm going to play this and see what happens oh okay so I've made a bit of a mistake here let me go to my console and try to figure that out so I have an unexpected token on line 12 so line 12 oh okay so I forgot to increment my loop that's no good so I think this should be alright now actually I'm going to go ahead and change each symbol just be a little bit smaller while I'm there classic changes with size of 26 okay so let's try again okay and close my console and let's see if this works great okay awesome so there we have it we have the basic effect down this kind of looks like the matrix right and now I think it's just a matter of putting some finishing touches on this so what do I want to change well you see how the sort of on initial load I'm just refreshing this fricassee every every single screen starts at the same yvalue of 0 I kind of want the streams to stagger as they come in so let's go ahead and change that let's go back to our code and on initial setup let's go to our setup here we're going to remove this Y value which is fixed at 0 and when we pass in to our generate symbols function here we're actually going to pass in a randomized by start value okay so let's call it random okay so instead of always starting at 0 maybe the string will start somewhere between a Y position of let's say this is the top of the canvas say between 0 and up to 500 negative 500 so let's code that in negative 500 there we go so I think looks like does that look right I'm just going to split this up into several lines so I can better see it there we go that looks nice okay so let's try again let's see how that looks okay great so I do think this looks a little bit better but I think even like even yet still I think it can still be staggered a little bit more so let's go into our code and let's change this random value minimum maybe to something even large even smaller so maybe like negatives 1000 so let's try that instead and see how that looks okay fantastic I think that looks great so now we have this nice aspect of the matrix more slowly trickling in and for the next finishing touch well right I think it looks a little bit too crisp for it to be the matrix and if you hook up a get a look at it so I'm going to pull up these screenshot once again the matrix have a little bit of a blur to it right so let's go ahead and let's change that let's do this so I'm going to go into where the background is set where the background is drawn on each on each frame and we're going to alter the opacity for this effect so the default opacity for this background is set to 255 that's maximum that's fully opaque and we packed in two parameters background then what will happen is g5 will interpret the second parameter as opacity levels so if 255 is fully opaque and the zero is transparent entirely let's set it somewhere in between I don't know at 150 let's say so I'm going to set that and let's play this again okay ready great awesome so now our matrix has this couple this nice subtle glow effect and has happened because each time the background redraws the background is somewhat transparent so some of the previous frame still shows through and now going back to the sequence from the movie the screen shot here we also might notice how the tips of these streams are actually brighter in color than the rest of the screen right kind of I guess like a whitish green so let's write something in our code Emily this cool effect let's go back to our code and let's go to the symbol class and where is it here it is okay and the way that we're going to do this is we're going to add a first property to this class right here and the pass the sin that's top first equal first set it and this first property will inform the symbol so the symbol will be cognizant of whether it's the first in the stream or not so and since it's a stream that creates these symbols let's go there so let's go to the stream class and we'll specifically go to the generate symbol function that's right here we'll set a variable called first outside of this loop and we're going to set it to true and I'm going to pass this in when we make our new symbol okay and right before the loop plays out fully we're going to actually set this variable to false so first equals false so that only on the first round from this loop the first variable will be set to true so that I guess any iteration afterwards any iteration after the first one this first variable will be set to false okay and now in the render function we're going to write a condition so that if it's the first symbol then we're going to set it to a color to that special white green color so let's write our conditional so if it's the first symbol it's first this will evaluate down to true oh sorry we want to go inside the loop here so if it's the first symbol let's set it to a special fill and if 255 is the maximal brightness for our RGB values let's bring the red and blue of a notch so let's say 180 for our red gleams days maximally bright and 184 for our blue value and if it's not the first symbol well let's proceed as normal let's fill it in just like everything else okay and now if we reload those things okay great so there even have our effect what I actually think it looks a little bit too excessive to have the tips of every single stream of this price and in fact if you look at the matrix that's not the case I would say like 50 percent maybe even less our colors this like special bright green color so let's actually limit let's go ahead on our codes limit what gets this color so for a first variable instead of setting it just to true I'm actually going to set it equal to this and then explain in just one second okay so we're going to get a random number either 0 or 1 and we're going to evaluate if this number is equal to 1 and if it is this whole expression here the whole thing will get evaluated down to truth otherwise it gets evaluated down to false so there's a 50% chance that this will evaluates true therefore there's a 50% chance that the first symbol in a given stream will be colored bright white green kind of like a coin toss right so let's go ahead and replay this now ok great so now 50% of these screens have a first symbol that is a different color but even still I think that 50% is too excessive so let's go ahead back into our code and maybe increase the pool of numbers but random can choose from so let's say it's four so now there's a one in fortune of five chance that first will be true so now there's would be a lot fewer brightwhite first symbols okay right I think that looks that looks great okay so I think we've now officially recreative our own version of the matrix digital reign in T 5 great so I put up my code on github at this URL you can read it in case you were sort of coding through and wanted my reference point just in mind however that the code on my github repo won't 100% reflect what is shown in this tutorial it will mostly but not 100% and that's because my final version includes some finishing touches extra finishing touches and a few more creative decisions that have made and I sort of encourage you to do the same feel free to experiment to play around or inject your own creative decisions into the sketch I mean maybe we'll make some matrix purple or maybe you'll make it rainbow or maybe it'll be 3d or maybe how to screw upside down I don't know I'm super excited though to see whatever you come up with and whatever direction you take this project in whatever the case if you do make something cool tweeted at me and also use this hashtag to share it with the rest of the g5 community because I think that's part of the fun that's sort of the beauty of t5 not just being able to make awesome art work with code but also being able to readily share it out on the Internet to share it with your friends or your family or randos on the internet like me so anyway I think that wraps it up for me thank you so much for watching I hope you had a ton of fun I know I certainly did so yeah thanks