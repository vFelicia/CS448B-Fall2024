Hello, welcome to Part two of the Polar Perlin Noise Loops. I wrote polar noise loops on purpose as like a wordplay thing. But people kept saying, "No, no, no, it's Perlin noise, Perlin noise." Yes, yes polar Perlin noise loops. The whole point of this is, I'm doing a follow up of my previous coding challenge where I made this blobby shape which is created with a Perlin noise algorithm and the end of the shape matches up to the beginning of the shape, by walking through a twodimensional Perlin noise space in a circle. If you're wondering what I'm talking about go and watch the previous video. But also I forgot in the previous video, I neglected to show this particular sketch created in P5JS by Golon Levin which demonstrates this idea. So the idea is I want to use Perlin noise values over time, but I want the last value to match up with the first value. And so if I pull those values from a circular path, and in truth, it doesn't have to be circular as long as I end up where I started, then I'm going to have this perfect, loop in Perlin noise. So why not take that perfect looping Perlin noise and apply it to my GIF loop so that I can miss, in the GIF loop coding challenge. I just had this rotating circle and it's very easy to have the end match up with the beginning. But what if what I want to create with is random, chaotic, algorithmic scenes of beauty. And an example, an artist who does this is Etienne Jacob. And you can read more about this work at necessarydisorder.wordpress.com. This is a blog post from November 15th, 2017. You can find many more of these, like, amazing GIFs on Etienne's Twitter account, all of which I will link to in this video's subscription. So this video is inspired by the beautiful work. And this just is mind blowing to me. This is not a sketch running over time it is a perfect loop. Yet it seems as if it's just continuous, random chaos. So let's go. let's go back to all this stuff. So what do I want first? So one thing you might have noticed is in the previous video, I was working in JavaScript. I have now moved over to Java using the Processing developing environment. This is mostly because what I want to do now is render files out that I can then repackage into a GIF. You could do that in JavaScript, too. But I haven't found, like, a really excellent, elegant solution for doing that yet. So when I'm working with rendering, I generally prefer it to be in Processing. And also I like to just show you different things. So I have ported that code, it's the exact same code but I'm in Processing now. So now I'm going to start with this code but I'm basically, I'm going to remove almost all of it because what I want ultimately is I just want a single noise value over time walking along the perimeter of a circle. So the idea of looping inside draw is no longer relevant. So I can take that out. The idea of drawing anything is no longer relevant, so I can take that out. I don't need this translate. What I do need is this idea of calling the noise function in twodimensional space based on an angle that's incrementing over time around the perimeter of a circle. So now that angle had to be a global variable. That angle, every time through draw gets incremented by some amount. When I want to make a GIF loop I'm going to change that to the percentage thing cause I want to go from zero all the way to two pi. And that's the end of the GIF loop, that closes the loop. But for now, just incrementing it by an arbitrary amount is fine. And if I were to say print line r, let's watch this go. So if I run this. What we're seeing is the noise values. Now, this is looping. You can't tell, but I'm getting the same noise values (mumbles). Except not really, because 0.1 isn't perfectly divisible by two Pi, but I'm not going to worry about that. David Snyder actually pointed out that if I used the radiance functions like 360 divides into one perfectly, so I could say like, or divides into 10 even. So I can say plus equal radians of one. This will actually now give me a perfect loop. Thank you for that suggestion. So now what I need to do is map those noise values to something. So I'm ... I could do color, I could do position, I could do size. Let's have it do position. I think that's kind of a very literal way of looking at it. So I'm going to now say x equals map r, which has a range between zero one to zero and width. I'm going to use the circle function because it's my favorite function. X, height divided by two, 100, and now I'm going to do this and we can see this looks like randomness, right? This looks like randomness. This looks like smooth randomness, Perlin noise, but it is a repeating pattern. Hard to see that repeating pattern, but it is there. Sorry, sorry, sorry, I know I'm interrupting. I know I'm interrupting you on a roll there. You're going to loop the noise was going to be great. It was, it wasn't great. I'm here, it's been about five days and I've been thinking about this constantly. What is a better way to demonstrate, what I'm trying to demonstrate here? Looping a chaotic scene with noise. And thank you to Etienne once again, who came in with some nice advice, with some messages to me over the weekend and so what I'd like to do is now, you can go in and watch what I did before. If you want to click over to the live stream, I'll link to that in the time code, video description magic thing, but I'm actually going to continue and do it in a different way for when I did before in this video from the future, although it's present for me now. That was the past. (mumbles). One of the ways I think that will demonstrate the idea of looping effectively, is to have multiple looping noise values, right? Currently, I just have this one noise value. I'm getting it from the path of the circular path in the noise space, and I'm assigning that value to the x location of the circle. And certainly, if I were to also, say, "Oh, well, take that value and assign it to the, "map it to from zero to height "and assign it to y, what's going to happen?" Well, this is not that interesting. If x equals y, it's just moving along the diagonal path. What I want is to have multiple different values of noise for different parameters of the system. And then I could make like lots of things moving all around. This is going to make some exciting stuff happen. So let me first of all, how would I do that? So in the case of noise in one dimension, what I've done previously is I've just taken different parts of the noise space. Like, "Oh, let me look at the noise values "between here and here." And these noise values, I'll use for the x value. And then I'll take you the values between here and here. And I'll look at these values for the y values, but these won't be loops. So there's two approaches I could take. I can't decide which one I want to do, but if I'm thinking about twodimensional noise space, right? And this is by the way, going on to sort of theoretically forever and ever. I could take the noise values along this path and the noise vies along this path. I could look anywhere within this noise, in this twodimensional space to have a new set of noise values that are looping. There's another way I could approach this, is I could always take the noise value from the beginning chunk, but have a different seed value so that could work. But let me ... I think actually I want to do it looking at different places. So come back with me and I think a nice way to do this, would actually to create a noise loop class, right? So I could make different like noise loop objects that just pick a random spot and give me those loops. So I'm going to ... what I'm going to do is I'm going to create a new tab. I'm going to write a class called Noise Loop. And the idea of this class that anytime I create a new noise loop, I'm going to get a set of noise values on the circular path and they're going to be different circular paths. So what do I need? First, I need a constructor. And what are the parameters? What are the variables inside of a noise loop? Well, one of them is this noise max parameter, which actually another way to think about it is the diameter. It's really like the size, the spread. I like to think of it as like the spread. Like is this a small circle, where I'm going to have lots and lots of really similar values? So it'll be less ran, it'll be smoother or do I have a really, really large circle? So that's kind of key. So I need, that's the thing going to want to set. So I'm going to want to say what is the ... I could call it spread. I could call it, let's call it diameter. And I could say this .diameter equals diameter. And maybe I should call it like noise diameter, and I need to declare it. I'm forgetting about Java. Need to declare that up here. So we can call that diameter. And so the idea here is that I'm going to say, I'm going to have a noise loop called X. I'll call it x noise. And x noise is a new noise loop with a diameter of five. And then somehow here, what I want to do, all of this stuff I don't want to do this here, what I want to do is I just want to say, "Float x, "equals, x noise .value "at a given angle." So I probably want to ... I'm calling, I'm thinking I'm going to have a function called value, maybe we should just call it noise, I don't know what it should be called, but let's call it value, which basically what it does with a given angle is it does exactly this. So now if I go back into the class and I write this function value that returns a float and receives an angle. The idea here is that I need to calculate the x offset and the y offset, I called it angle now, let's just call it a right here. So it's the same. This is now called Diameter. And ... why is that not picking it up? Diam meter, diameter, Like I spell it the same way in every place, and then I need to say, "Return r." So if I did that ... Now, well, I think what I would actually like this was in here, the loop, I think I'd like to define what kind of values I want. The noise loop object should keep track of that. So Perlin noise, right? I could just say "Return r." But this is always going to give me a value between zero and one. But what if I asked the users would say, "Give me a minimum and a maximum that you want, "and then I'm going to always return map r, "between zero and one "to between zero and width." That's pretty simple here, right? So I always want to just return that, not between zero and width between minimum and maximum. These are variables that are part of the object. And then what I want to do, is when I create the noise loop, I'm going to say between zero and width. So I want a noise loop with a diameter of five and I want the noisy values to be returned between zero and width. So now ... You know, I could just recreate what I did, like I'm good at now ... Actually, let's make a y noise object. So then I'm going to have two of them, x noise, y noise loop, between zero and height. I'm going to do a y noise object, well, this very exciting. Y noise object. I'm going to get both of those values and I'm going to run it and it's still moving along the diagonal. Why? Because I haven't done that offset. So even though I have to separate noise loop objects, they are both walking along the perimeter of the same exact circle in the noise space. So I need some other variable to give me a random spot, a center spot, so to speak. And so we can call that, I mean, I don't ... I could just move only a long, like one access, but why not just pick something random throughout the entire 2D space? So what I'm going to do is in the noise object, I'm going to say ... I'm just giving like an x and a y as a center. We could call that, I could call it, I don't want to call it x offset and y offset because that's what I'm calculating here. Let's call it the cx and cy to indicate center. I'm going to say cx equals random. I don't know. I don't know what the reasonable range would be, but let's give myself a range between zero and one million, cy the same. Where do I add cx and cy in? Well, clearly that needs to enter in here somewhere and you might think, "Do I adjust this? "I'm I adjusting the angle?" No, it's actually these parameters that I'm adjusting because what this really defines is, and I didn't draw this super accurately, but basically, if this is zero and this is the diameter and this is the diameter, the circle that I'm getting is this. So what I want to do in this center point, what I really want to do it's ... I guess it's not, I don't know if it's really the center point. It's actually ... It's more like offsetting the corner. So it's really, I'm looking around, I'm looking at a box between zero and diameter. And then walking along that perimeter. So all I need is an offset for this box, somewhere along the x and somewhere along the y, and the map function will take care of that for me. So I can just say, I want to look at cx, cx plus diameter and cy, cy plus diameter. Okay, so this should now, give me this. Great. So now I am getting different noise values for the x and the y and I've also like encapsulated this nicely that I could do things like let's just change these diameter value to two. I can also change, like I could also have 240 frames. I mean this is for making a GIF loop. So you have 240 frames and going to see it sort of like happening over many more frames. So this now is a perfect loop, but let's make this even more exciting somehow. So one thing that I think could really help here is what if I make yet another class, I'm going to call this a Particle, and the idea of a Particle is that it has all of this stuff. So it has two noise loops and a particle constructor, and in the particles constructor it makes, those two noise loops. It has a render function, and in the render function, I draw this circle and let's make it, you know, kind of pink with some alpha, maybe with no stroke, maybe the size is smaller and then I'm also going to need to get the angle passed into the render function. And this has to stay void render. Why am I doing this? I'm doing this because now, I could say particle, particles is a new array of let's say 100 of these. Let's make the window a little bit bigger, and then in a setup, I'm going to ... go iterate over all of the particles. (chuckles) (mumbles) it's hard. Particles index I and I'm going to make a new particle. And then I am also here, going to say for every particle, P, in particles. P.render with that angle. Now there we go. Look at this. So now I have a whole bunch of them, moving chaotically. Okay, stop. We'll just do a few more things here. I am going to say thinking (mumbles). Let's make them a little brighter. Let's add a noise loop for the ... size. That's the particles diameter (mumbles) D noise. Let's add a noise loop for like red values, red, green and blue values. So I'm going to make some more noise value, more and worn looping noise values, like D noise is a new noise loop also with two, but I want the diameters of these circles to go from zero to 10 to 60, and then this is going to be for color. So the range is from zero to 55 and B noise is for blue, zero to 255. And let's make sure it stays somewhat bright. Let's give them a larger space to work with. Actually, since I have so many of them, I don't mind if they leave the window. Somebody with negative width plus two width times two and negative height two height times two. That might be a bad idea. And then now I'm going to get some more things. Like I'm going to have a diameter, which is from the, which is the D noise. I'm going to get a r and a b, which is from these other noise loops. And let me get this fill now should be down here and I'm going to say, "r" And I'll just give that 50b and now let's run this. Whoa, it's going really crazy. Why, why, why is it going so crazy? Well, I think my diameter values are kind of large, so let's move. Let's now especially because the space is so big, so let me do that. Wow, that is weird. Right, so I was a little bit, I think overly ambitious to like pick this very large, (laughs) space by where I would place these little noise circles and I think it's given me some weird results. So I'm going to shrink this. I think our random number, somewhere between zero and a thousand is perfectly reasonable. And so with that, let me run this again and we can start to see, here we go. This is what I'm looking for. So this looks like a bunch of particles moving smoothly. I can have their colors change. Perhaps their colors should change more rapidly and maybe their size should also be, but, and I can have the move a little bit faster so we can see this. Again, I want to stop myself from trying to be artistic because as you know, it's not something that I'm capable of doing. What I want to is just show you the technique. This I think certainly has the appearance. Maybe you can see the loop. Can you see the loop? It's hard. I don't know, I'm losing my mind here staring at this in terms like, "We'll get those 3D pictures. "Do you see it or not?" But what's magical about this is how I have a lot of different values looping so I can now render a GIF, where all sorts of parameters are changing. And if you have some other design that is your own creative design, then you can now apply this technique. Let me indulge me for just a little bit longer. I'm going to make the noise loop a bit wider and I'm going to make these change, and then I'm going to give myself more frames to work with. Let's actually just double it to 480 frames and now ... this should give me a scene here. Okay, so I'm going to look at this. You might be able to see a looping pattern happening. I cannot detect it, (laughs) but that's not the point. The point is the creative possibilities that you will make from watching this. Let me close this. Now, if you were recall, this is based on the code from my GIF loop processing challenge, and all I have to do now, is change record from false to true. This will trigger this saving to the output directory. And I'm going to run it now and I have to wait. (upbeat music) All right, it finished. Let's go check to make sure it actually recorded. If I go here, there's an output directory and all of the GIFs ... All the image files that I've saved are in that directory, there's 480 of them. So now if I render those to a GIF, we'll make a loop. Now, in the previous time I did this, I used a website easygif.com, which was a nice technique for just finding a website, dragging your files and navigate, create the GIF there. There are plenty of other ways to do it and what are the ways I want to demonstrate that right now is using something called FFmpeg. FFmpeg is a complete cross platform solution to record convert and streaming audio and video. I'm happy to do a video or tutorial about how do we install FFmpeg, but I already have it installed on this computer and what I can do, this is an application that I can run via the console. So I'm going to go over here to the console. You can see I am in the processing sketch. There is an output directory and I can say, "I don't know FFmpeg, "but let's see if I can figure this out." The commander ... I definitely start by saying FFmpeg. Then maybe I do I, it's not I, it's f maybe for format. I actually don't know it. Read the read the FFmpeg documentation image two. I'm looking, frame rates. My frame rate, I think I'm going to do 20, absolutely, 30 frames per second for this GIF and then I. Now this is the names of the files. So everything is in a directory called output and then all the files are named and numbered. So what I can do is, I can say GIF % 0D3, no, %3D, because basically, I'm saying it's GIF three digits and then .png. And then I need to give it the file name that I want, which I'll just call it noiseloop.GIF. We're going to go with that, right? And now if I hit Enter, let's say my little FFmpeg player and I hit Enter. It is doing something. It finished. I can go back to the Finder and way at the bottom of this directory. What? Nope. Oh no, it's right here. Noise loop GIF. Okay, let's take a look at this. As it looped yet, I have no idea. That's the point. It's a perfect loop of random noise. Yeah, I want to add a couple of things to this video and I would like to come back and actually make a longer video about this and actually implement a noise algorithm itself. I got some comments on the previous video asking about or discussing, whether what's in processing is actually Perlin noise? So this is a very interesting question, and there's a long history of this, that goes all the way back to 1983, and I don't claim to be an expert on this. So I need to do some more research and I would be happily take suggestions in this video, but if I go to the Perlin noise Wikipedia page, you can see here Perlin noise is a type of gradient noise developed by Ken Perlin in 1983. This is maybe sometimes also called fractal noise or value noise and that, this 1983, implementation or a version of that is what is in processing. And there have been several get up issue threads discussing whether that should be updated and it's a point of decision was made to leave it historically what has been, not since 1983, cause processing started in 2001 because it would really change the way people's projects that were made in processing look, these are artistic quality that if the noise implementation was redone. But, what Etienne uses for his GIFs, is actually simplex noise. And so you can see there are ... Ken Perlin has published many different updated versions of the algorithm. I don't know if they're all open source or not open source, but this is something I would like to explore, particularly simplex noise because one thing you might notice about Perlin noise in processing or the noise function in processing in P5Js is there are some strange artifacts and you can see this, some of the problems with Perlin's, classic noise, among them, computational complexity and visually significant directional artifacts. So you could could make the case here that there are some visually, significant, directional artifacts. And I do not like directional artifacts, I like non directional smoothness. Who knows? So I want to come back and revisit this, but I do also want to make one other point, which is that what I'm doing is, I'm creating a loop by working in two dimensions. I'm looking at Perlin noise in two dimensions. But if what if I want to do actually loop in two dimensions Perlin noise why don't you just go to three dimensions or when just to go to four dimensions. So that's yet another topic. This could never end, honestly. So some day keeping me honest about this, remind me, give me your thoughts about this in the comments. I would like to come back and do two more videos. I would like to look at other noise algorithms. A great coating train community project, could actually be a processing library that allows you to pick and choose from value noise, fractal noise, simplex noise, true Perlin noise, whatever, all these different possibilities. And this will be something that ... You know what? I want to do some tutorials about making a processing library. (giggles) And I could, this could be the library. Oh, this is great. I have a plan now. Coming soon this week. So I'm going to do this and you're going to need some feedback and thoughts, but hopefully, this is giving you the seeds, the pearl, the noise seeds to do something interesting, to make your own GIF and have it loop in a magical, wonderful way. Thank you for watching. Mwaah! I will see you soon in a future coding challenge. Goodbye. (funky music)