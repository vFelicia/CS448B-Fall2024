hello and welcome to another coding challenge in this coding challenge I'm going to program a visualization that looks just like this that was for the thumbnail and uh I'm going to do it in uh p5js using JavaScript in the browser what's running over here is an example that I made previously in processing which will give you higher performance so at the end of this video perhaps I'll take a look at that very briefly so where I'm not going to start from scratch um this video is really going to be um built on top of this idea of twodimensional p noise if twodimensional pein noise is not familiar to you stop now go to the video description and go and find my series about pearing noise and then come back okay hi you're back great okay let's get started so I'm going to start from this particular piece of code which generates this particular output so this is already an example with twodimensional pearing noise and each P each each pixel gets a grayscale value according to two diens PL noise but I want to do something different what I want to do is in the kind of grid of pixels right this is my very very low resolution grid of pixels instead of having a grayscale value for each pixel so to speak what I want to have is a vector I want to have an arrow pointing in some direction and I want that direction to uh to be a direction set according to pearing noise because ultimately what I'm going to do is I'm just going to like pour a whole lot of particles into this area which known as a flow field this is known as a flow field and pour the particles in and they're going to follow the arrows and we'll see what happens okay so the first thing that I need to do is start revising the code to make vectors instead of pixels so let's take a look about how let's take a look at how that might work so I'm going to work with a very low resolution canvas just 200x 200 just to kind of get things kind of started here and one thing that I also need to think about is a core variable here is I need to think about what is the ratio of kind of cell to width so I don't want to have an arrow for every pixel it's not going to be it's going to be unreasonable for me to have 200 vectors instead of maybe I want to Vector every 10 pixels or every 20 pixels so let's make that a variable called like scale I'm going to call it uh SC short for scale and I'm going to say that's 20 and then what I I what I also need to have is columns and rows so I'm going to have have uh the columns is going to be the width divided by scale and I better floor that floor is something that gets rid of the decimal place and I'm going to say rows is height divided by scale so now what I want to do is I'm not dealing with pixels anymore so I can get rid of load pixels I can get rid of update pixels and in fact I can get rid of all this pixel array stuff but let's just see that things are working for a second so what I want to do is have y now go through all of the rows and have X go through all the columns and what I want to do is draw I'm going to draw a rectangle I'm going to draw a rectangle at x times scale I got to scale up y times scale and the size of that rectangle is scale and I'm just going to give it a random fill for right now and I want to see that I'm at least getting a grid of rectangles so if I run this okay so this is working so this is now going to be my grid now what I've done is I put a grayscale value a random grayscale value in every cell hey why don't we make that a random no a noise value just so just to get started here so let me now change this look I already have this here I already have this noise function why not let's just make that fill based on that noise function and you can see okay so you can see right now that I'm not really because I'm so low resolution that these cells aren't um these cell are kind of like very almost the color is almost identical so one thing I'll do let's just try making the scale 10 you can see let's make the increment a little bit bigger there we go so now we're starting to see something that looks a little bit more like pearlin noise um because and uh and one thing I want to do also just while I'm working on this I kind I think it would be useful to just keep an eye on the frame rate so I'm going to do something a little bit goofy I'm going to uh make a variable called f FR and I'm going to say f FR equals create P so I'm making a paragraph element on the page and then I'm going to say f FR HTML frame rate and I'm going to floor that so this is a P5 function that just gives me back the frame rate I want to just see it as a paragraph element on the page so you can see the frame rate I'm I'm right now everything's fine I'm running really fast like 60 frames per second so okay so this is my grid and I essentially have a grayscale value for every spot on the grid but that's not what I want what I want is a Vector for every spot on the grid okay so one thing I could do is instead of saying fill let's at least right here create that uh create a vector so what I'm going to do is I'm going to say VAR V equals create Vector now actually there's actually a function in P5 where you can create a vector from an angle P5 Vector from angle and I'm going to create a vector from the angle zero um I now uh I now have a vector I've created a vector from an angle and what I want to do actually is instead of drawing a rectangle I'm going to say uh uh stroke 0o I'm going to draw that Vector as a line so I'm going to say a push pop there's a bunch of different ways I could do this but I'm going to rotate by that vector's heading and then I'm going to draw a line from so I'm also I'm going to translate to x times time scale y time scale and then I'm going to draw a line at that spot um that's uh a line oh of of that is sorry from0 0 to scale zero so what am I doing here what I'm doing is I'm saying for every single one of those vectors translate to this spot then draw a line that's just a line like this and then rotate it according to rotate rotate it according to um uh the The Heading of that random Vector the angle so to speak so now if I run this you can see look I have a whole line whole bunch of lines pointing directly across now what if I were to say from angle Pi / 2 now I have a whole lot of lines pointing down what if I were to say Pi / 6 now I have a whole bunch of lines pointing that way we're getting somewhere right you see where I'm getting at because what I can do now is I could say what if I have a random angle between 0 and 2 pi oh okay first of all I should probably clear the background so you can see now this is just a random Vector for every spot in that grid every frame so one way I could stop it from like changing all the time is I could say a random seed 10 so if I reset the random seed you can see this is a whole bunch of random vectors now ultimately what I want to do is show you how to make this field of vectors this flow field with noise values but I could I could come up with other ideas I could use sine waves I could I could get a data input oh I could get like wind data from various geolocations through some kind of like weather API and there's a great project which I've shown in other videos which does that but I'm going to just use pein noise so let's go back and say the angle is the noise value time 2 pi right so when I wanted to get a grayscale value between 0 and 255 I took the noise value time 255 now I want a random angle I want the noise value times 2 pi I don't need the random seed anymore from angle that particular angle and now you can see there we go so now I have this nice flow field essentially of all of these vectors kind of pointing similarly and each time I refresh I'm going to get a slightly different one now one thing you might notice is that I don't actually need to calculate this every time through draw because ultimately um I don't need to calculate this every time through draw because ultimately it's staying the same I could calculate it once in setup and then refer back to it later however I think this might be a good time you and me okay we need to talk meet me over here at this other camera we need to talk actually never mind let's talk over here there is pearly noise I've shown you onedimensional pein noise L I've shown you two dimensional pein nois I have yet to show you threedimensional no no pein nois and in fact pein noise can exist in any n Dimensions but here is an opportunity where we might decide let's do something with threedimensional pear and noise so the one one dimension is the x axis another dimension is the Y AIS imagine a z Dimension as slices these angles change as slices that I'm just are like coming out of the screen well what if instead of actually building something visually in 3D that we thought of that third dimension as time every frame of Animation what if I were to add as a global variable Z off and set that equal to zero and then I were to say noise X off comma y off comma Z off I've now said give me noise values in threedimensional space so there's a noise value right here in threedimensional space it's similar to all the values that surround it and so I'm looking at a slice of noise values then I want to present another slice of noise values then I want to present another slice of noise values so those Z off offet change every time through draw can you hear people laughing and talking in the background I don't know if you can and now whoa it's changing like crazy so I'm moving through time a little bit too quickly so let me move um like quite a bit slower and now let me move even slower so you can see now I have a flow field that's actually changing over time and you could imagine there lots that I could do just with this much but ultimately what I want to do if you recall and we can sort of see this crazy sketch now is like really just like filled over itself a zillion times but what I'm trying to do is recreate this particular visual so what's happening in this particular visual is that particles are being dropped on top of this flow field and following those arrows so this is the first thing that we need to do now I just realized we have a bit of a problem small crisis of conscience here which is that if I want to drop a particle on there I need like a whole like physics engine and to move the particle around and all that and I kind of want to just go and grab now let's make it we can do this really fast this is a coding challenge I'm going to to to add the particle object from scratch here so what I'm going to do is I'm going to make a new file I'm going to call it o particles.js and I'm going to use a JavaScript Constructor function and my particle needs to have a position which I'm going to just make it 0 0 it needs to have a velocity which is going to be an uh 0 vector and it needs to have an acceleration um I'm going to uh write an update function where the uh position gets added the velocity and the velocity the acceleration gets added to the position if you're confused about how these physics engine works go and watch all my nature of code videos on physics engines and then I'm also going to uh reset the acceleration to Zero by multiplying the vector by zero then I'm going to write an apply Force function which is a function that receives a force and what do I want to do with that Force I just want to add it to the acceleration so this is actually all I need well this is so easy and then I just need a dis a show function whoops that's I wrote that incorrectly equals function then I want to show function which what does it Dre do it draws the particle so what should I draw it as let's just draw it as a point for right now we're going to say stroke zero um uh Point this.position dox this.position doy so this is nice I have this really simple particle object it has position velocity acceleration it has a little update method to update its velocity based on acceleration to update its position based on the velocity and then as an apply Force function to accumulate any forces into the acceleration so now I just need to make sure that my uh index.html file references that new particle. Js file and let's just very very quickly make a particle array and in the particle array I'm going to say particle index zero equals a new particle uh I've lost my train of thought here a new particle um oh yeah new particle and then I want to say uh here particle index Z do uh show sorry and Dot uh update and let's let just see uh okay what's missing uh couldn't find particle JS because I typed that in wrong I said particles.js whereas the file is called particle d as and now particle is not defined what oh particles and this is also very confusing here the array is called particles there we go so you can see there's that particle up there in the corner so I have one single particle that's good now what I want to do is add a whole bunch of particles uh so um let me make this a for Loop uh it's less than 100 let's add 100 particles and just say particles index I and then let's write another for Loop uh iterating over the entire length of the array and uh having each particle okay so now uh particle prob I typed something wrong particles okay there should be 100 particles there let's make sure all the particles are everywhere let's um let's give the particles uh random positions to start so you can see there's 100 particles around randomly and then uh just to make sure they're like doing something let's say p v uh sorry P5 vector. random so this gives them all a random velocity okay so the particles are moving around with a random velocity they're doing something okay one thing I need to do I just realized is that I need to have the particles wrap around when they get to an edge they should come back on the screen so I need let me add that really quickly so I'm just going to add a function called edges and I'm going to say uh if this.x is greater than wi this.p do do dox equals zero and I'm going to do this in a kind of Shandy way and I'm going to say uh less than zero should equal width and then uh I want this again but I want to do it with Y and I want this to be height and I want to do this then needs to be Y and this should also height so I now have a new edges function and I can quickly also say you know wrap them around the edges here so now we should see I have a whole lot of particles moving around forever and ever and ever and let's not render the uh vectors for a second okay so now I have a window with a lot of particles moving around but I want those particles now to be affected by the actual vectors in the flow field itself so how do I do that okay this is the this is the Crux of this project so first thing I want to do is I want to actually say I want to give these like quite a bit of alpha so let's see if um so you can see now you can see it's slowing down quite a bit but I'm drawing the vectors but you can see the particles are not moving anywhere according to the vectors I also just while we get started I'm going to take off Z offset to see now this oh whoa did I not hit save yeah so now I want to make sure this works with a fixed flow field and with the particles I also just so we see them a little bit better I'm going to say stroke weight four to make them a little bit thicker okay oh boy but I don't want my vectors to have that stroke weight so I'm going to say stroke weight one okay so now we can see the particles moving and the flow field kind of behind it so what what I want to do is say for every particle's location look up the vector that's nearest to it and then apply that as a force so here's the thing the the all of the vectors are calculated up here so what I want to do is actually store all of those in an array so I'm going to make a variable called flow field which is an array and that that array should have as many spots as there are columns and rows so now what I want to do is say flow field equals uh a new array H this is a weird thing to do in JavaScript but I'll do it anyway you know you can actually preet the size of an array by saying new array and maybe that was a bit unnecessary um but I'm going to do that anyway and then uh and then what I'm going to do here is I actually already have perfectly the calculation this was left over for my pixel example this should be columns and this should be not be multiplied by four anymore because I don't have RGB value so I have a single single value I can now say flow field index index equals that particular Vector so now all of these vectors that I'm calculating are now stored in that particular array so now what I need to do down here is say I'm going to say particles index I and I'm going to write a function called follow and I'm going to pass in that flow field so what I'm doing is I'm saying hey you particles here's an array of vectors each particle is responsible for finding the appropriate Vector in that array to look up so for example just to come back to this diagram I'm a particle right um let me get my actually it's fine use I'm a particle right here my position might be like 300 by 200 and maybe these are 100 by 200 I need to First divide by scale to look up the appropriate index into that array find the vector and then apply it as a force let's see how that works so if I go to the particle function I'm going to write a particle uh object the Constructor function I'm going to write right a function called follow equals a function uh I'm going to just call this vectors and now what I'm going to do is I'm going to say uh x equals floor this position. x ID scale so I need to take remember its X position is its actual place on the screen and but it's corresponding position in the grid I have to scale down by that scale variable its y value is do that with Y then the index is X is x + y * columns this is that formula for how you take a twodimensional value into a onedimensional array and I cover that in some other videos which I'll try to link to in this one and then now I should say the force is that array of vectors at that index and I should be able to say this do apply force that Force so now essentially what I'm doing is I'm saying based on my me I'm a particle based on my XY position scale myself to a grid of column and rows then look up the corresponding Vector in that onedimensional array and then take that vector and apply it as a force so let's now actually have the velocities start at zero and let's see if this works and I'm sure I missed something but let's give it a try oh okay that's kind of working but you can see excuse me that they're spiring out of control in terms of speed so one thing I should think about is okay you know I should think about uh one thing I should really think about sorry is what is what is the magnitude of these vectors so maybe these vectors I need to set their magnitude to something much smaller like 0.1 they shouldn't really be that strong like a full um a full uh uh unit full and you can see that now but you can see they're still like really speeding up over time that's because this acceleration is just building up and pushing and pushing there's no limits to how fast these particular these particular particles can go so I think something I could do here which would make sense would be to have a like a maximum speed variable and set that equal to like four and then in the update function I could just say this do velocity. limit this do maximum speed so now I'm just saying the particles actually you know no matter how much you start pushing them they do have a ultimate maximum speed and now we should see that the particles are following this flow field and you know maybe they're not following it you know you know and I could kind of control what that now I could go back and I could say well actually maybe I want the magnitude to be five and you can see when the magnitude is five they're going to be lock step exactly with the flow field so you can see what the magnitude of that force is really controls how exact they are in terms of following this path and by the way let's add the Z offset back in so those vectors change over time and you can see now what we're kind of getting we've got these particles following a flow field but that flow field is changing over time reasonably I've still got 30 frames per second I'm going to do a couple more things one is let's add some more particles let's have Z change a little bit more slowly uh something like this and let's see how we're doing so now I have a lot more particles um but it is running rather slow so one thing I can do here hopefully to get it to run quite a bit faster is I can actually just not bother to draw the vectors the data for the vectors is still calculated and exists but I could still I could skip drawing them and you can see now I'm getting a nice 60 frames per second it's really getting stuck at the top and the bottom um that ve that force is really quite strong so I'm trying to oh I set the magnitude to five let's set it to like one uh and actually I'm going to set it to uh 0.05 anyway you could play with this your I could also one thing that I could really think about is well do I want the full maybe I want the vectors actually to be to have more variety to them they're all it's generally always pointing to the left because remember I'm picking random values between zero and pi and they cluster around the middle so I'm not picking random so like I could say times 2 pi * 4 and now I'm going to get a lot more sort of like noisiness but there's a lot of different ways and it's all moving like kind of too fast and I I should create some sliders and I can kind of like really control this stuff a little bit more strongly so you can see this is kind this is more what I was trying to get so I have a sort of stronger flow field but there's a lot more variety in terms of where the particles go now I could add some separation so that they don't get on top of each other as much but you get the idea here now what's this I basically am all the way done I now have this flow field where I can drop particles in it and I could you know I could sort of push the performance here and say like well what if I try to drop uh you know 500 particles in you can see it's running a little bit slower but I've got more stuff happening but what if instead of drawing the particles as dots what if I drew them what if I allowed them to blend their Alpha to be sort of like Alpha Blended across the screen for a while so let me um to kind of create that visualization so really now one thing if if I were you I would stop this video and just go to this show function and play make rainbow colors add Alpha values but let me do a couple things to try to get that effect so one thing I'm going to return the stroke weight back to one and I'm going to give it quite a bit of Alpha and in the sketch I'm also going to draw the background now only once in setup so let's see what we get here with this so now you can start to see what I'm getting here I'm getting this kind of nice Alpha blendy pattern now if I were to zoom into this you can see there's actually like the particles move faster than one pixel per frame so they're actually skipping pixels so something that could actually be quite useful here would be to have each particle store at the very least a previous position which I'm going to say is uh a to start with is a copy of its original position so it when it starts it has its current position and its previous position and then every time it moves right after update it's actually let's do this every time after we so what I want to do is actually not draw a point but I want to draw a line from its current position and I know that camera just went off because that means a half an hour has passed uh to its previous position uh this. previous position doy now if I whoops ah I'm in the wrong place if I run this again okay there's a couple issues number one is oh my goodness what is going on there's some crazy extra lines so we have a problem right if I'm always taking a particle and drawing a line between its that its position it's previous position when it leaves its previous position is here its new position is here suddenly this line goes all the way across so I want to add an extra check in here just to correct that there might be like a better way of doing this and actually what I could do is I could just update it in this edges function uh which actually let me do that this is different than how I did in my other example but what I'm going to do in this edges function is uh I have to add right if any of these are true what I need to do is say what I want to say uh this do previous uh previous position dox equals this. positionx so I'm going to I'm going to write a function this. update previous is a function which just does this algorithm in it oops X so so anytime it hits the edge uh I'm going to just update the previous so this is like an extra time and I need to make sure sure I do this then right before I draw it so I actually want to have edges right before show so it gets updated and then uh what I so this should correct that problem so now you can see oh look at that okay so it's actually kind it's doing something interesting I never update the previous position so it's actually drawing a line from where it started to its current position so let me actually add the most crucial part here which is that I also want to every time after I draw it to say this. update previous so after I draw it the previous position comes the current position and now you can see what this is doing and I'm getting nice continuous lines I don't actually see those continuous lines what did I miss here uh hold on I time out I'm going to debug okay I'm back I I didn't actually need to debug anything it is working so you can see I've basically gotten the gist by programming from scratch of this particular example now there's a bunch a few things that are different number one is in this larger version one is I I've got kind of higher resolution going on one thing that I think you probably would notice is this is running reasonably at 30 frames per second but if I were to go back and try to add you know to make this run over like a much larger canvas and have something like 2500 particles you're going to see that right currently it's running at like four or five frames per second whereas this processing version which I will pull up right now this processing has 10,000 particles and it's for whatever reason it's 1 1200 by 8800 now let's look at I let's and actually I'm going to render this with uh in the p2d renderer which uses uh open gel Hardware acceleration I'm going to print the frame rate just to the console and take a look at that come alive come alive processing so we can see that this is actually running over 50 frames per second and once again again let me point out there are 10,000 particles and I'm at kind of high resolution whereas here I have you know only 1,500 and not as high resolution and it's running really really slow so what I would need to do to like pull the most performance out of the web browser would be to um probably render this somehow with webgl in a kind of Hardware accelerated way which maybe I'll continue and look at at some point but hopefully this video gives you the basic idea and um what I would love to see and I'm just going to let's you know oh i' love to see you do is first of all make this like rainbow colored try playing with the various parameters try rendering it a different way see what kind of quality you can get can you make you know large scale prints out of it go and look at the processing version there's a variety of things um that you could look at and try uh to expand upon this maybe you can make a bunch of Sliders to change different parameters and that sort of thing so I hope you enjoyed this particular coding challenge it was a little bit long a little bit scattered if you liked it uh like the video say it in the comments uh let me know on Twitter at shiffman and I look forward to seeing you in another coding challenge soon enough thanks for watching bye