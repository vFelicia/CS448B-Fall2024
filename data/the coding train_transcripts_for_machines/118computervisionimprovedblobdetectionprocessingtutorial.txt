welcome to a followup blob tracking video now in this video I'm going to look at a comment that came in on YouTube from quack quack which says I think you could obtain a better result which a much lower threshold and a different way to calculate the distance between a pixel and a blob you need to calculate the shortest distance between any pixel of The Blob and the given pixel this way if the red area is Big you won't get a lot of small blobs next to one another even if you don't exclude small blobs so what does this comment mean so let me run the example which I believe is actually already running over here um and what I'm going to do is I'm going to hold up this so you can see here I'm doing blob detection on this red cup now I could add a second red cup now I have two look at this as I bring them closer now strangely enough I kind of like how this works because these are two different objects I want them to be two separate blobs but they really shouldn't be separate blobs once they're together it should really recognize them as one blob but look how it picks it up as a second one as soon as I move it a little bit apart this is why is this happening this is is happening because let me there is a distance threshold so when I find a pixel this is a new pixel that is red I have found a new red pixel is it part of that blob or not so the first thing I do is I test its distance from where the center of the blob so I get that value as some distance and I check that distance is it greater than or less than some threshold so let's say the threshold is 80 and my blob is now this Big Blob that's like 160 by 8 you know 90 pixels so even if I find a pixel over here its distance from the center is going to be greater than 80 by definition it's going to be 81 so it'll actually my algorithm will actually make a new little blob right here which in a lot of cases isn't what you want you just want this blob to be a little bit bigger now I'm sure and I'm sure I will get a YouTube comment explaining what the optimal way of doing this is but I'm just kind of showing you the basic idea and in the end you know you might I'm going to show you in a future video using like open CV or a blob detection Library a lot of libraries will have sort of optimized code and maybe I'll get to that at some point but a way of doing this would actually just be to find you know this blob has kind of accumulated a whole lot of pixels let's find the shortest distance between this new pixel and any single other member of The Blob and see if it's uh within a given threshold so um let's come back over here and let's add that there here I am I'm giant don't eat me um I'm uh let's add that to the code and this is by the way exactly what quackquack suggest you need to calculate the shortest distance between any pixel of a blob and the given pixel so if I go back to where am I my code I have this blob object and this blob object keeps track of really only a few pieces of data of The Blob it keeps track of the XY over here and the XY over here it doesn't keep track of the Interior pixels you know one thing I might do I kind of have an idea of making this a little bit more optimal to just like see if it's um if it's within the Y how far away it is from the X but anyway I'm going to do it by looking at all the pixels of The Blob I thought of there's a couple different ways I could approach this but you can see the blob doesn't keep track of the pixels but there's no reason why I couldn't make an array list of P Vector objects a Vector being a a um could I could use as a position Vector an XY coordinate as a single object and I'm going to call this like points and when I make a blob I make a new array list of P Vector objects uh and then and then whenever I add a point I I want to also make a p vector and add it so what I'm doing now is not just creating the rectangle but storing every single point that's part of that blob now the question is how do I determine where in the code do I determine whether it's part of that blob well I do that here and so what I want to do now is I need so you know let's just make sure this is working by the way and uh we can see that this is working but what might be interesting here by the way is to um just when I display the blob right now just to have a sense of things I'm going to go um look at all the vectors and I'm going to uh say stroke let's make something let's make a blue RGB by the way here RG we should have an RGB song RGB RGB BG RGB G RGB a sometimes okay somebody will compose that song um uh and then I'm going to make a point so this should also in addition to Simply drawing the rectangle the sort of bounding Bo box of that blob these are all the actual pixels associated with The Blob as well as blue so now what I want to do is here when I'm I want to write a function that's going to return true or false and I'm going to call that function close enough or or maybe call it is close so what I want to do here is start and and I need to I'm going to return true just by default for a second so what I want to do here is say let me find the shortest distance between any point in the blob and this new point so the thing that I want to check is some given XY and what I want to do is say the record distance the record distance starts out as something like super big 100,000 right and then what I want to do is look at every single Vector uh in all of the points and I want to I want to give I want to get that distance so I want to say distance squared between point dox point doy and a given x. given XY and sorry v.x v.y then want to say if that distance is less than the record distance then the record distance is now that distance and let's let's actually just do this let's have this return a float get shortest D so I'm actually going to make the function return that shortest distance and I'll do the threshold checking out in the other um I'll do the threshold checking out in the main Loop and then at the end here all I need to do is return the record distance so in other words what I want to do here now is instead of just looking oh that's by the way oh I have an is near function I already have the is near function I'm confused because I have two it's very confusing because there's two different thresholds there's the color threshold like is this pixel was in the color threshold once it is what's its distance so I actually all I need to do is do this this is very silly of me this algorithm this whole algorithm that I worked on I don't need another function I just need to find this is near function right is this distance less I don't want the distance from the center anymore comment that out what I want is I want a bell by the way I want to ding whenever I like have this like Epiphany moment where I realiz I did something wrong then get a bell um a phys Bell uh and then um so now I want to check this record distance if the record distance is within that distance threshold so I'm going to look at all the points and find that shortest distance now normally I would be 100% sure that this large number for record distance is totally reasonable but um because I'm doing distance squared you know the blob could be quite far away pixels wise and P Squared so I'm going to do something like uh wi time with I probably shouldn't have it do that math let's just um let's just make it a really big number how about 10 million let's just be safe here so now I'm going to run this code and let's see how this goes I have a blob oops I don't have a blob look by the way oh kachunk kachunk kachunk slow slow horrible slowness so this was already this is just too much back after some testing and debugging and I think this particular algorithm of checking every point is just going to be way too slow so let's do it a different way so what another way we could do it is uh if this is if this is the blob and this is the given point and I don't want to test its distance to the center the other thing I could do is actually just test its distance to the closest Edge so if it's down here I'm essentially testing the distance to here if it's here I'm testing the distance to here if it's over here I'm testing to here so I'm going to test the distance to the closest edge of this rectangle now how do I find the closest closest Edge now there is a technique known as clamping not to be confused with glamping which from what I understand is like glamour camping or something i' I've never done that before I don't know what I'm talking about but this is called clamping which is mean take the point and kind of clamp it to the side of the rectangle so there's a way that we can do that actually by let's say the point is over here I can kind of look first for the minimum between this this points X this if this is PX py I can look for the minimum like uh if if we were over here right I would get I would the minimum would be here if it's these two points the minimum would be here so I can look for the minimum and the right of the rectangle which in my program was called Max X and once I get that whether it's now either here or here I can do the sort of maximum of the result of this the result of this and now this side of the rectangle Min X right because the maximum if it clamped it to over here this would still be the maximum but if this was still the minimum then suddenly I'm going to now have this side of the rectangle so this is a little bit confusing but this is a nice technique for being able to find which side of the rectangle is the point on by the way if it's in the center what am I going to get I'm going to get the um the minimum between these two points is going to be here and then the maximum is also going to here I'm going to get itself so if I get itself it's already in the rectangle the distance will ultimately be zero so that's very very useful okay so let's come back over here and I'm going to implement this so I'm going to get rid of my other idea and in fact I don't no longer need to have this array list of points that was an interesting idea I guess it will stay in this video forever as my misguided attempt probably another way of doing that I'm going to get rid of this all this stuff that I added I I had this counter thing I was experimenting with something and now over here what I just want to do now is say first I want to find the this point CX which is not the center of the rectangle anymore I want to test the maximum sorry sorry I mean the minimum of X and um the right side of the rectangle and then I want to say CX the result of that is the maximum of itself and the minimum of the rectangle and actually I could write this in one line of code the maximum of the result of this and the minimum of the rectangle it's a little bit awkward to write it that way but you know it's kind of what you'll probably see I might prefer it and and I could do the same thing with Y I think I got that right and then instead of the center I can now just calculate the distance between this new clamped point the point that's kind of clamped around the edge of the rectangle itself so now when I run this that's my singing That's My Singing for when I'm waiting for the processing sketch to start and I bring these blobs up look at this ah look at that notice how it's now one blob that's because my distance threshold is 75 so now I could change that ah I could change that distance threshold I got to change the color threshold ah I got to guess now come on give me a over here I I clicked on the no no no help get out oh no stand in front wait can I do this no okay I got to just rerun the sketch this is a problem don't click in the window it sets the color of what I'm tracking um so I what I want to do is change that distance threshold you can see I have some keystrokes which are allowing me to uh change it very slowly and ah the window lost focus and if I click in it I got a major problem here there we go uh I should have it change by five anyway you can see that distance threshold is now 39 and if I step aside and you can see now they're separate blobs until they get within 39 pixels than their one blob but this is going to be much more accurate now I can at least kind of really tune how when do I want to be separate blobs versus one blob and have a lot more control oh I like this better but this is probably way too long of a video for to just get this like simple optimization but uh I had to discover it um somebody uh I don't know I'm sorry I I'm just enjoying the fact I want to like wear a hat with these things on them so many possibilities okay so now that you've seen this uh this is one optimization I can do of this not really optimization doesn't make it run faster optimization is the wrong word but to gain a bit more control over the algorithm and Improvement in terms of how I'm checking for distance uh from the edges so this code will be published link to it in the description uh I'm glad that this is now working and I'll see you in the next uh video back for a quick addendum I had tried remember to make it work where you find the shortest distance to any pixel it's part of The Blob and that didn't work well I had made a silly error of course the internets uh saved me from my own failings and so I'm going to quickly add this back in and so what I'm going to do is I'm going to make an array list of P vectors called points boy didn't I already have this uh I'm going to say points is a new array list of P Vector objects uh okay and then and then what did I do every time there's a new point I would say Point add new P Vector X comma y oops don't don't don't and then in a show what I also want to do is say four in I equals z i is less than oh no no no no no no no no no I can use my P Vector look at all of the P vectors and just say uh uh make it blue and then type in uh Point um v.x v.y there it is and I don't know what is going on whether things are working or not working um so we can see here now that I'm seeing all the points that are part of the blob in addition to that bounding rectangle okay so one way that I could do to find multiple blobs right instead of uh in I could instead of simply finding that bounding rectangle I can now find the shortest point to any point ah but what was the mistake that I made here was the mistake that I made look in the add function every time there's a new point I add it to that list but guess what I forgot when I first make the blob I make it I make it with an XY so what I forgot was to say points. add new P Vector X comma y so now I should be able to go back and add that code so I'm going to comment this out which is an excellent method and I'm going to do another method which says that uh uh D is I'm going to start it with like a really high distance and then I'm going to look through all of the vectors and I'm going to do the temporary distance is the distance between that X distance squar between that X and Y and the ve that particular point and then if that temporary distance is less than the distance um then distance equals that temporary distance so this distance this D is like a record I want to find the shortest distance between the new point and any point that's inside the blob and if it's less than the threshold go right ahead so now I'm going to run this and this should actually work and it does so and it works and it's perfectly fast uh so the only reason it wasn't working before and you can see how this threshold that distance threshold Works beautifully as well right it combines the blobs when they're in within a certain threshold and I can change that right by making it higher so what's higher going to do I should make it lower right oh I I really should change this so that okay so I change this make this lower I should just have it changed by five or something uh okay and so now we can see here there's they're separate blobs until they get quite quite close let me just change that right now because this is driving me crazy um I want to change here I whenever I press the key to change those threshold values I want to change it by like five so that I don't have to uh so that I don't have to um be pressing it so many times so here they are right here are two blobs uh and you can see them whoops no the color threshold now distance threshold they're separate blobs right when that distance threshold is five we get lots oft extra little blobs they really don't become the same blob until they're literally touching each other but if that distance threshold is more like 60 than when they're within 60 pixels they become so this is another way of doing it that's perhaps a little bit more accurate than the other way but it works okay so I fixed that problem thank you very much I did both now this video now contains both Solutions one solution being the clamping to a rectangle right finding the distance of the new point to the edges of The Blob versus another of just finding the shortest the shortest distance of the point to the the rectangle itself the shortest distance of the point to any points within the rectangle okay that's the end of this video now for sure until I record Another addendum goodbye