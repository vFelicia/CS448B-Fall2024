hello and welcome to part three of my genetic algorithms video series I'm almost ready to like dive in and actually start looking at all the pieces of the code and how they implement the actual genetic algorithm itself but what I want to do in this example you can see that genetic algorithm just ran and it arrived at the phrase to be or not to be what I want to do is just kind of run this example a bunch of times while tweaking various parameters of the system and look at kind of what all the pieces here of the example running are so here's the algorithm I have it for reference that we could come back to and first thing I want to do is just run this example this is this is running in the browser this example is programmed in p5.js I will show you at the end of this video I'll just run the same thing in processing to show you the Java code as well and you can see in the talking there in the talk am I talking it evolved this system evolved to be or not to be that is just to be or not to be period so one thing you can see in this example is that I'm kind of drawing on the right side here all of the various current elements of the population and you can see those current elements of the population at this point where the program stops where one of them is the exact correct phrase you can see here what they look like and if i refresh the page you can see you can see the population itself started to get closer and closer to that correct phrase and eventually it's going to stop and here's just sort of a selection of those members of the population you can also see over here I'm kind of having the program always show you the current elements of the population with the highest fitness and you can see that over here and you can see this is the current element of the population with the highest fitness eventually that will be 100% fitness to be or not to be and then I'm also showing you how many generations so this happened in 514 generations what's the average fitness remember the fitness function calculates the percentage of characters correct from 0 to 100% how many characters does the phrase have correct you can see the average pop Fitness goes up over time it doesn't get to 100% because when one of the phrases has the correct the correct one of the elements of operations the correct phrase the rest of them still don't have the correct phrase and then also showing you the total population and the mutation rate so before I get into the code I even just want to change a couple variables here and show you a little bit about how the system behaves so for example what happens if i take this mutation rate and these the the maximum population and the mutation rate are simply just variables in the code there's also a target phrase right so I could actually just change this program right now to be unicorn I've never done this and run it again you can see how quickly it only tip with a short phrase when we took five generations to get unicorn come up with your I'm going to go back to to be or not to be I'm going to take the mutation rate and make it zero and now I'm going to run this again now notice what's going on it's kind of sort of settled into something look all the members of the population actually have exactly the same sequence of characters the best phrase is not changing and the total generation is just going up and up and up and up and up so this is a scenario where if there is no mutation there was not enough variation at the start to actually evolve the phrase right there was no initial member of the population with an O as the one two three four five six seventh character so this is something you really have to be careful of this mutation is route now one thing I could do is just say well the total population was only 200 so I could make the total population a thousand and look we actually got to the best phrase the target phrase in 44 generations with no mutation so with a population of 1000 elements there is actually plenty of variation you know we can see what happens by the way I don't know if I just have a population of one well I broke it let's give it a population of two that broke it all so a ten right you can see oh this me I love this this page is in Norwegian sadducees so with with only two members of the population we got a phrase that's in Norwegian okay so you can see how this the size of the initial population is quite relevant now let me let's talk about something here that's kind of important little factor also let's go back to that population of a thousand we can see I was able to involve the correct phrase in forty one generations very quickly now let me make the population max of five thousand twenty seven generations even more quickly let me give it a little bit of mutation one percent mutation rate it took longer that time but this is sort of randomly I'm getting it rather loud noise there I'm getting it rather quickly one of the I should mention here is you have to remember this is an artificial problem that I've designed to demonstrate a genetic algorithm I'm not actually trying to get to be or not to be the fastest because I could do all sorts of things like okay I know what the answer is so when a when a member of the population has the correct the correct character I could actually just use that correct character and make sure I put that in the next year there's all sorts of things I could do to actually try to get to the answer more efficiently like just say print line to be or not to be but so but what we want to do here is just sort of look at how does the genetic algorithm behave and perform changing some of these variables but you I kind of got off track there and I sort of meant to talk about that later but whatever it's fine um here's the thing I could keep ramping up the population max thinking it's going to be faster and faster and now I have the population max of fifteen thousand characters and you can see that I was able to get to be or not to be in thirty generations but look how slow the kind of frame rate so to speak of each generation the program starts to run slower and slower and slower like if I were to have a hundred thousand members of the population I think I might have just crashed I've practically crashed the browser here like I might be able to it's running so there's a tradeoff here having a large population helps because you have a larger Matt larger pool to start with in terms of very but once your population is so large the computation can become rather slow that it just takes forever to get there so even though I might have gotten there in 25 generations it took much longer than if I just said 1,000 members of the population which you can actually crunch through really really fast might take more generations but actually happens faster so that's another important thing that's another important thing for me to mention another thing that I should mention here is that the mutation rate itself but I haven't started looking at the coast yet the mutation rate itself is also a prime key factor you know more mutation you think might help but what if I say point one like 10 percent mutation if the mutation rate is so high that those mutations have been so often it's almost akin back to that brute force solution where everything's just random in the first place for example at 50 percent everything becomes almost completely unrecognizable in the sort of like list of the population and if I were to make the mutation rate 100 percent this is actually complete and total randomness okay so thanks for watching this particular video in the next video I'm actually going to peel open tert like pull open whatever this like I'm going to open a suitcase or pull a curtain something correctly look at the code itself go back to this algorithm what are the pieces of this algorithm and where are those pieces of code and how are the different techniques working to make this algorithm run