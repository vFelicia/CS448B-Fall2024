hello welcome to another coding challenge video in this coding challenge I'm going to look at something called lexicographic ordering and look at an algorithm for solving lexicographic which for some reason I can't say but you could say lexical for short so I'm just a lexical ordering just kind of like alphabetical ordering and we're gonna look at how that works make a little algorithm that solves it you might have some creative ideas about how to visualize it or make something out of it and then I'm going to apply it to the traveling salesperson problem to look at how we can look at every possible path through a set of cities ok so let's just talk for a second about what lexical thank you very much ordering is and I'm going to come and do that over here so let's just say I kind of did this before but let's just say I have the letters a B and C so these are actually sorted in alphabetical order right a comes before B B comes before C but what if I want to know the next ordering of these that's also the next order in alphabetical order like I could say like here's another order C ba or here's another order be AC but neither of these are the next order in alphabetical order now I could tell you that the next ordering in alphabetic order is a CB right because a should come first well B already came second the only other possibility is C and then the only thing left is B and we could think okay well I I tried all the a possibilities so the next in alphabetical order and by the way let's go order in alphabetical order or very similar concept is a sort of subtle distinction which has to do with how numbers or dates are kind of treated in the way they might sort things in kind of the computer way this is this is by the way my version of the computer away so but I'll let you read about that in this page that I'm to show you that has more information so so I could say B and then what would be next in alphabetic order would be a and then all I have left to see so B is next and then C and then a and then C then a then B then C then B then a so I could do this rather easily myself but you know if I have ABCD EF GHI is going to be a little bit harder although not that much harder because honestly it's just going to be a b c d e f g i than h you could sort of imagine and there's this swapping so what we need is an algorithm to do this for us and then print out every single possible ordering because what I'm ultimately going to do with this is actually use these as indices into an array that has different cities in it so you know Baltimore New York London I don't know I shouldn't be so US Europe centric everybody in the comments give me some better cities to use in my next example but so you could see could imagine is gonna be 0 1 2 0 2 1 1 0 to 1 to 0 2 I don't know if I'm getting this right to 0 1 2 1 0 something like that so hopefully I got that right but this is what I want to do and I want to try the cities in all of these orders so let's go back over here and I found this wonderful page on the subway this for critic that I read in my google search which was a Cora post it says how would you explain an algorithm generates permutations using lexicographic ordering so the wonderful thing about this answer by Michael for a sec check which I'm sure I'm not pronouncing correctly somebody will have two people to give me great cities Kuala Lumpur Rio Coventry UK so let's be an international coding ring vote here in this thing that I'm doing in YouTube but so for the impatient here's the actual algorithm so what I'm actually going to do in this video is just kind of read through this algorithm and sort of talk you through it and implement it and I would suggest to you that if you want to find more about it you can kind of read further down this page where the author provides an example scenario of an example order how the algorithm plays out with that example and then also derives this algorithm but I'm going to kind of leave that aside as kind of and I just want to kind of like I think you might have an intuitive or kind of sense of how it works just by implementing it so first let's get ourselves set up to do this what I want is to have an array I'm going to start with an array I'm going to call it Val's yeah that's fine and I'm going to have it be 0 1 2 we're just going to start with 3 number so we could see that it works and what I want to do now in draw is first I want to what happens if I do console.log Mouse so let's just look at that and run this we can say okay so that's good I'm getting I'm seeing here in the console the current order of the array so I want to see it as I do each permutation one at a time so if I go back to this explanation first find the London Zoo mint on this you can see it better find the largest X such that P index X is less than P index X plus one okay so what does that mean I often we think of eye as the index not X but we're looking for is whit which where is there something in the array the highest the element closest to the end of the array where it's number is less than the last number so and intuitively right now we could say like which one is that it's this one right and if honestly if this were the array three four five six seven it would be this one right right now the last element of the array who is that is less than the one next to it is when instant order is always the second to last one but we should write an algorithm to make sure of that so the first thing I want to say is largest I largest I I'm going to assume it's zero and then I'm going to loop through the entire array and what I want to do is say okay if Val's index I is less than Val I plus one then largest I equals I and I can't go to the very end right so I want to find what is the largest and you know what I really need to do I want to start with this as negative one because I want to start with an invalid index because if I don't find anything that's going to be important if we go back to this algorithm if there is no such X that means we finished so what I wanted to add here is say all right here after I do this loop if largest I equals negative one no loop you know console dot log finished no loop is a function in p5 that just stops this animation loop from from going okay so we can see that here I've kind of implemented let me let me I've implemented step one of the algorithm and let me just in the code here just add a link to this article that I'm using just so I don't forget to do that later okay now find the largest Y or you might think sort of in this cavity use J because I'm used to using IJ as index values find the largest Y such that the index X that I just found that's the largest one is less than Y so let's think about that right so let's say I think I might need a diagram for this oh yeah I have my uh so let's say we on let's say we have a bunch of numbers 0 1 2 5 6 8 4 3 right let's find the first let's find that largest X which I'm calling largest I such that the such that the the the value in the array the index is less than less than the one after it which would be here so 0 1 2 3 4 so this is 4 now so what's the next step whoops the next step is find the largest Y such that P of X is less than P of Y not of AP index X so I now need to find whichever one in here is high it is actually less than this number 6 and that's actually here right this one is the largest one that's less than the number 6 so so if we come back to the algorithm and I implement that what I want to do is for I need to go through and I'm going to use J I'm going to go through the array again and I'm going to say a largest J equals a negative one so what I want to do is hear the largest y such that P of X is less than P of Y P index X so if if vows index J is less than Val index largest I which was X then largest J equals J so now I have largest I and largest J I have both of those and I don't think I need length minus 1 here because I can check all of them we'll find out now I swap P index X and P index Y now you might have come to this video without watching the previous one I made on traveling salesperson but in that video I look at a quick little algorithm for swapping two elements of an array and here's the function that does that right I have a function called swap I receive an array I just receive an eye in a J I save the value that's at a index I I put the value that's a J and I and I put the value that was a tie in J so now all I need to do is say swap largest I largest J right and then reverse oh boy so this is kind of a funny thing but what I also now need to do is reverse everything that's between X plus 1 to N now how do I do that this is going to be a little bit goofy I'm back from thinking about and talking with the chat about how to do this last step reverse so but first first let me let's see we did we did steps to in steps 3 let me at least add some this is a step 2 and this is now step 3 and what I want to do for step 4 let me write this out is reverse from X Oh largest I plus 1 to the end right so what I want to do is reverse everything that's from largest I plus one to the end of the array okay so one thing that I could do I think a way that I could do this thank you to the chat again is I can say I'm just gonna call this end array and I'm going to say I'm going to say Val splice now if you remember I don't know what you remember this from but if I go back to the my array documentation page I'm going to look at splice not slice splice what splice does is it that takes a start index and then an amount of things you want to delete out of the array but I'm not only am i deleting them out of the array I'm actually getting them as a separate array so what I can actually do is say Val's dot splice from largest I and then how many things do I want I want I think that the length is the arrays length minus largest I is that right like if the array has five things in it and I want and my largest I is the 0 1 2 3 4 is at 2 5 minus index ooh minus 1 right Val's dot length largest I minus 1 I believe is right that's the length that I want to splice out let's let's let's confirm that let's let's debug this to be sure what uh you know 5 6 7 8 9 and what I want to do is I want to say a dot splice what happens by the way if I just give it the index like 2 so 2 should be 0 1 2 5 6 & 7 ah so I don't even need that last argument splice will do it for me I don't need to calculate the length brilliant then I could say end array dot reverse now does that actually change the array itself hey dot reverse whoaohoh a is that ah start over let's worth it up hey is this array now B is a dot splice so now I have that as B we may need to make this bigger so you can see this now I want to try to reverse that B dot reverse but what is the be uh it does actually reverse the array itself not just create a new array that's returned back so now all I need to do is say end array reverse and then what I can do is say valves dot append I could just put it back so what I did is I took the end of the array off I reversed it and then I put the end of the right back on which is essentially doing exactly this piece of the algorithm reverse X plus 1 and did I add the plus 1 in there I think I did uh plus 1 okay so I need to add that plus 1 in there so this is done I've done step one step two step three and step four now what we should be able to do is look at those values and whoops and I should be able to run this again and sort of see what happens whoops ah Vale's dot append is not a function hey append is not a is not an array push must be push there's no append function must be push push must you must be allowed to push in a full array right the elements to add to the end of the array and you can push you probably can push another array right I'm pretty sure you can't let's try push and see if this works and okay this is too many things for me to see let's just do it with let's run a quick little test here and oh no no no no so how do I contact at could cat because you can see what it did it's actually just pushed the full array on there which is not what I want to do so let's go back and fix that it would be nice if I knew what I was doing wouldn't it I guess you're seeing the process of how things are figured out by people who don't know what they're doing uh nope nope nope Vale's dot can cat let's look at King cat we're getting close can cat the concat method returns a new array so I've got to set it back equal to itself there's probably some sort of slightly more efficient way of doing this but this will do just fine for us right now there we go up all right so I'm getting something but I'm missing something so uh I have got to I could use push dot apply but I'm trying to so there's some fancy JavaScript ways I could do this but I'm going to I'm going to try to kind of get around those ways so something is going wrong here so what I want to do is I actually want to take this out what I want to actually just say a no loop and I want to be able to look at this running one at a time so a way that I can in p5 by the way is is run each draw loop one at a time one as I can just say redraw all right I thought I could at least oh I have to I have no loop in here let's take that out do I have console dot log maybe I took out the console dot log whoops console dot log Val's yeah okay so I'm getting the same array each time and maybe the call to swap is incorrect to someone in the chat is saying so let me look this up this I'm now in a debugging portion which maybe will edit this should get edited out but I guess it's staying in swap so let's look and see what we're getting if we're getting values that make sense so the first thing I want to look at is largest I and then I want to look at largest J which is probably I'm guessing I did something wrong there and then I want to look so let's just look at that for a second so the largest eye is one which makes sense that's the largest index where it is less than two now the largest J is if we look at the algorithm is the largest J such that ah I have my code is wrong look at this this should be largest I is less than J if we look at that algorithm again that makes total sense that I'm looking for the element of the array furthest along that's actually greater than the one that I just found so that should that should fix things here and then if I say redraw okay so that's a little bit better I made an improvement here that I'm finding let's we refresh this that the large is one and then the largest J which is 2 which is greater than that what I just found is the last element that's correct and I've got a terrible error here bad bad sad little bug I just like had a brain malfunction when I wrote this swap function it's like swap large assign largest Jake but swap it with what head with chat just pointed it out to me the way that I wrote this function is I've got to say here's the array that I want you to swap these elements in so I've got to actually put that array in there which is Val's so let's redraw and we can see there we go and now we can see the order is happening so I can take out some of the console logs I can put in no loop back here and I can take no loop out here and I can run this and we should see there we go 0 1 2 0 2 1 1 0 2 1 2 0 2 0 1 2 1 0 we got it yay now let's be a little fancier here and let's put something let's put something in on though in the window I'm going to say text size 5 but no 64 I want to create a string and I want to loop through the current values and I want to say s plus equals I and then I want to say fill 255 and I want to say text s so I just want to draw the text at like 20 and height divided by 2 so I just want to see and did I put that I want to see no because it just happened so fast oh not I I want have valves index I there we go I want to see it do all the possibilities there so I want to be able to see that happening in the window and now we can try three four five six seven eight nine to see how this goes and we can see here we go I am now looking at it's almost like I'm counting down backwards in this weird way this is now every single possible permutation of ten numbers now you'll notice this is going to take a really long time to finish it's running at 60 frames per second so it's doing 60 possibilities every second and how many possibilities are there 10 factorial which is this particular number which is like three million six hundred twenty eight thousand eight hundred so I could let this run but I'm going to stop this particular video and you could sort of calculate how long is it going to take how long is going to take if you add go to eleven this this video about lexical lexical ordering goes to 11 and except it doesn't because it actually just goes to ten but and so you know what might be some interesting creative ways you could sort of visualize this these permutations what might be another scenario where you use all these permutations and what I'm going to do in the next video is I'm going to use this to try every single possible permutation of the order of cities in the traveling salesperson a problem and once I do that I'm going to look at an evolution after that a look at an evolutionary strategy for solving a traveling salesperson problem okay thanks very much see you in the next video