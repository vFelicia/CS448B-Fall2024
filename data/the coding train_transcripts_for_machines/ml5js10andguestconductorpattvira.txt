Welcome to a very special episode of The Coding Train with our guest today, Patt Vira. Patt has an incredible number over 100, at least, already in the last year of tutorials and videos about p5.js creative coding. So if you like the coding train, you're going to like Patt's channel. I hope so. So we're here today to do a special collaboration. Patt happens to be in New York for ITP Camp. ITP is the program where I teach during the year. They run a monthlong program in June for Camp. And I just so happened that yesterday, I taught a quick workshop at ITP Camp on the ML5 library, which also just yesterday had a 1.0 release. So what we're going to do in this video is introduce to you the new release of the ML5 library, show you the new ML5 website. I'm going to give you a quick walkthrough of how to code some stuff in ML5. And then Patt's going to make it much more visually interesting and exciting. All right, so what is ml5.js? The ML5 project started in 2017 when researchers at Google were developing deeplearn.js. And we asked the question, could deeplearn.js, which was a library to run machine learning models in the browser, could we run those models with p5.js? deeplearn.js later became TensorFlow.js. And the ML5 project has had many years of development with different models and tutorials and examples. But in the last year, a group of us at NYU in New York and at NYU Shanghai have been working on updating the library to use a bunch of refreshed, new models for pose tracking, as well as some new functions for training a neural network, all of which I explore in a lot of detail in chapters 10 and 11 of my new Nature of Code Book, which think I've probably mentioned way too many times on this channel. So let's take a look at the ML5 website, and I can show you what some of the new features are. This is the new ml5.js website. I encourage you to take a look at the About page so you can learn all about all of the wonderful people who are contributing and building this library. The Getting Started page is probably where you want to begin, just to find a quick walk through of how to get started with the library and the p5.js editor. Under the Reference, you will see here, on the left, all of the machine learning models that are currently supported in ML5. There is a model for tracking body pose, for hand key points on your hand, key points on your face. That's what we're going to use for this tutorial today. There's an image classifier, a sound classifier, a sentiment analysis model, as well as a module for training your own neural network. So I think I'm going to go to the BodyPose page. Each model page includes a description, a demo let's run this demo here. I'm going to allow it to use the camera. So I'm going to just awkwardly stand up. So the BodyPose model, you can see, captures 17 key points on the body eyes, nose, hands, shoulders, hips, knees, and toes. And this is actually this particular model that it's running is called MoveNet. One of the wonderful things about on the website is you can run the demo here, but you can also click to just look at the example. And you can see the example code here in the P5 editor and start playing around with it yourself. More examples are linked below as well as a stepbystep guide. And then, all the way down on the page, there's more details about the specific properties and functions for more detailed documentation of everything you could do with the BodyPose model. I also just want to quickly highlight that the new ML5 has a body segmentation model in it that will give you a colored pixel map of every pixel and which part of your body it's associated with. In a minute, I'm going to show you how to import the new ML5 library and write code with it. But just in case you happen to be a current user of the previous versions of ML5, there's a lot of models and functions that you still would have to access by using version 12.2. So let's get started using ML5. I've got a completely blank p5.js sketch. Now, normally, if I'm working on a project that uses the ML5 library, I'm probably just going to click on one of the examples which will already have the library imported. But I'm going to show you here, stepbystep, if you're starting from a blank p5.js sketch, how to import the ML5 library. If I click on the Getting Started page and scroll down, there's some instructions of how to do it here. But this is what I'm looking for. I'm looking for this script tag to where the ML5 library is hosted. And you'll notice this @1 because we're using version 1.0 of ML5. I'm going to copy this to the clipboard. I'm going to go back to the index.html file in the p5.js sketch. You can see how the p5.js libraries are being referenced here through script tags. And I can now just add by pasting in the ML5 library. One thing I'll note is that you want to make sure that you're using the most recent version of P5. I'm going to show you in a minute how some features in the newest P5 work really well with the ML5 library. The next thing I'm going to do, which is not related to ML5 specifically, is I'm going to open up a connection to the webcam on this laptop and see that in the p5.js canvas and create a variable called video. In Setup, I'm going to call createCapture. And we can see here already there am that is the DOM element floating on the page separate from the canvas. Now could leave it there. But what I want to do eventually is draw over top of the video. So in order to do that, what I'm going to do is actually call video.hide so you don't see it anymore. I'm going to change the size of the canvas to 640 by 480, which is the size of the video, and then draw the video on the canvas with the image function. I'm going to show you something that's in the new version of P5 that is incredibly exciting to me. Now I'm holding up my hand. This is my right hand, but it's showing on the left side of the canvas because it is not mirrored. And if you've ever watched any of my other videos where I try to mirror the video, I've got to look up translate and scale and use a negative number and all sorts of stuff. But the new P5, I can actually add an option to the createCapture function with a property called flipped and set it to true. Let's see what happens. I have a syntax error. I'm missing a comma. Look at that. And now, as I hold up my left hand, it's on the left side of the canvas. The video is mirrored, which is incredibly useful for any kind of interactive application where you want people to see themselves reflected on a screen and interact with it. It's much more intuitive if that video is flipped horizontally. All right, so that's it. We have the video. Now is the time to incorporate ML5. All of the models, whether you want to look for key points on the full body, key points on a hand, or key points on the face, they all work the same way. The first step is to create a variable that will hold onto that particular machine learning model. And I'm going to call that variable faceMesh because we're going to use the FaceMesh model. I'm going to navigate over to the FaceMesh page on the documentation. Let's run the quick start just to see what the example looks like. And you can see all of the points that it's tracking on the face. Now you might be wondering, wait a second, where does this even come from? The models that are available in ML5 are not magic. There's not some magic system that knows how to find your face and put key points all over it. The FaceMesh model and, in fact, all of the pose detection models in ML5 come from the TensorFlow project. And you can find documentation around what are these models, who trained them, what data sets they were used to train on the TensorFlow website itself. And this is a really important question to ask. If you are working with a machine learning model, it's very helpful for you to think about who owns this model, who trained this model, and what data was used. That will really inform whatever decisions you want to make about how you want to use that model and in what context it's going to work well for. In particular, when you're tracking somebody's face, it's really important to be thoughtful about these kinds of questions. Back to the documentation the next thing that I want to do is load the model itself. I'm going to add the preload function and say faceMesh equals ml5.faceMesh, and let's see what happens. So every function that you call in ML5 is namespaced under the variable name ml5. And, in fact, in setup, if I say console.log(ml5.version), we'll see that version 1.0.1 is logged into the console. The next thing that I need to do is somehow connect this FaceMesh model with the video. The way that I do that is with a function called detect and, in fact, in this case, detectStart start video. I've loaded the model, and I've called the detectStart function, which will trigger the model to continuously analyze the image from the video. Now there is also a function called just detect then you can use if you want to analyze a single image one time only. But with detectStart, what I need to do and you can see this in the error message here is I need to add a callback function. So the model returns the results of what it finds in the video asynchronously, meaning that after it's analyzed the image, when the data is ready, it will execute a function and pass the results into that function. So I'm going to make up a name of a function, call it gotFaces. I'm going to define that function, and I need to give it an argument which will hold the data, the results of the machine learning model, and let's just see what's in there console.log(results). One object so I'm just one person. I have one face. So that's why we're just seeing one object. But this model, presumably, if a second person do you want to prove if this is true, Patt? Let's see if this is true. If you come here I think you need to Change the maxFaces? Right. This is important. But actually, the FaceMesh model, I can also give it options. So I'm going to allow it to have a maximum of five faces now. Yes, now we have two faces. There we go. All right, thank you for that demonstration. But it's actually going to be kind of convenient to work with it with just one face. So I'm going to take out I'm going to put maxFaces back to one right now. Here's another aspect that's very important that I want to emphasize. Even though the model is being loaded from the cloud, when you call ML5 FaceMesh, the model a giant file with a lot of numbers in it, basically is being downloaded from one of Google's TensorFlow servers. That model itself is actually executing in the browser. So the images that are being seen from the camera and being sent to the model are all happening ondevice inside your web browser. This is very important and quite different than if you were using another cloudbased service, where you're actually sending your data, sending your images to another server to be processed through a model and then sent back. Everything is happening ondevice here. So the next step that I need to do is I want to be able to draw where those points on my face are on top of the Canvas. So I have the model, I have the video, I have the results, but I don't have the results inside of the draw loop. So to do that, I'm going to create a global variable. I'm going to call it faces. I'm going to initialize it with an empty array. So when the sketch starts, it will assume it's detected no faces. And then I'm simply going to pass that array, those results, into that faces variable. So now, inside of the draw loop, I can access the global variable faces. But before I do that, let's actually go and add I'm going to add the mousePressed function. And in here, I'm going to console.log the faces so we can just take a look at what's inside the actual object that holds all the results from the model. So let me make the console a bit bigger. And I think it's detecting my face. I'm going to click the mouse, and there we go. Now I can start to look inside of this object. So, first of all, it's an array that holds one object, a face, and then all of these properties. You could look at the ML5 Reference page, which will have all the documentation in terms of these properties of the results object, as well as a diagram that shows where all the points on the face are and what order in the array they are. But, for now, one way we can just figure it out is by poking through this object in the console. You'll notice there's a keypoints object. That is an array with all 468 points. But one of the things that ML5 does is it takes that raw array of all the points and divides it into parts and gives you a bit more information. So let's focus on the lips for right now because I think Patt's project is going to have to do with opening and closing your mouth. So if I unpack the lips object, I can see there's an x, a y, a width, a height, center x, center y, as well as an array of keypoints, and only 42 key points. So let's first see if we can draw just the bounding box of your mouth. I have to remember I'm going into faces, index 0, dot lips, dot x, y width, height. And I can do that right here in draw. The first thing, though, is I should probably check to make sure that it's detected at least one face. I can use an if statement and say if faces.length is greater than 0, then let the face equal faces index 0. Let's just put it in a separate variable. And then let's draw a rectangle at face.x, face.y, face.width, face.height, stroke weight of 4, no fill, and let's give it a nice, I don't know, blueish, pinkish I don't know, pick a random color out of a hat. And let's see what we get. OK, I've made a mistake. Oh, I forgot dot lips. So there is no that's interesting. Let's go back, and let's look at the object. So I've made a mistake here. I went straight for assuming there is some there is a box which has the full bounding box of the face. But I'm looking for the lips, so I forgot dot lips. So it might actually be nice for me to say let lips equals faces index 0 dot lips since that's what I'm using here. And then I can change face to lips here. And these should be the properties. OK, let's see if it works now. There we go. Uhoh, what happened? So one of the unfortunate but beautiful things that's happening is that I mirrored the P5 video, which is only mirroring the way that it's displayed and not actually mirroring the data that's being passed to the ML5 library. But guess what remember how I was able to add a property called maxFaces to FaceMesh, and there's lots of other properties you could add, which are all on the reference page? I can also add the flipped property. And now look at that. And I don't know what I did. I thought I did no fill, but oh, I typed fill here. OK, that was meant to be stroke. I wanted it to be seethrough. There we go. So now you see that this bounding box is tracking my mouth. If I wanted to look at the specific points on the mouth, then I could actually dig into not just the x/y width and height, but the key points array itself. So I'm going to do a for of loop to look at every point well, I shouldn't use the variable name "point" because point is an actual P5 function. So let's call it lipPoint. That's a weird name, and I'll keep it. Let lipPoint of lips.keypoints I think that's what it's called and then I can just do a little let's do a stroke weight of 2. And we'll make a green color to differentiate it. And I'm going to say make a point. That's why of lipPoint.x and lipPoint.y. So I've got an error. Let's take a look lip.keypoints is not iterable. Let's go look again at that object to see maybe where I went wrong. Oh, keypoints with a lowercase p I capitalized the p, which is incorrect. If I had bothered to look at the reference, I wouldn't have had that issue. So let's lowercase this p. And I think now there we go. So you can see, in addition to the bounding box, we now have the contours of the actual lips itself that are being detected. And I could pick specific points to track. I could use those to draw other colors or shapes. I could give myself a really bright shade of lipstick or something. I'm sure you're watching this could come up with many more creative ideas. And, obviously, in addition to simply just the lips part of the face, I could also use the left eye, eyebrow, right eye, as well as the face oval for all the other points. So that's the basic howto to load the model, open a video, pass the video to the model, get the result, and then analyze the result object and draw based on it. But what kinds of creative projects might you be able to make with that? Well, I'm going to turn it over to Patt to see what she can do. What I want to do is I'm going to step away from the sketch that Dan just made and create another one to show you how to make the kinetic topography sketch, and then we'll combine it at the end. So we're going to start by declaring a few variables. The first one is center. And center is going to be a vector. And a vector is an object that can hold two to three values. And I'm going to use it to hold the x and y values of my center coordinates. So center will be equals to createVector. And this is a method within the vector class that allows us to create a vector. And I'm going to give it in the middle of the canvas. So let's do width divided by 2 and height divided by 2. And then another variable that I want to create is going to be called pos, for position, and I'm going to set it as a vector as well. And let's give it at how about 300 by 300. So it's going to be at the bottom right corner of the sketch. Now inside draw, I'm going to draw the positions of the center and the position vectors using an ellipse function. And the ellipse function takes in a total of four arguments. The first two are going to be the x and ycoordinates of the center of the circle. So let's do center.x, center.y. And this is how you can access the x and ycoordinates of the vector. And then let's give it a size of 10 by 10, and I'm going to give it a color black. So nothing's new here. We have a circle in the middle of the canvas. Let's do one more, give it a color red, and ellipse of pos.x, pos.y, 10 by 10. So now what I want to do next is that I want to move this red circle in the direction of where it is from this black circle here. So we have to do a few things. The first thing we need to do is that we need to figure out what is the direction between these two. So first, we're going to find the angle between the black dot and the red dot here. We're going to be using trigonometry, and I think that has many videos on this already. But, essentially, we're going to find that the distance between the xcoordinates of these two points and the ycoordinates of these two points. And then we're going to use the inverse tangent formula to find the angle between the two. So instead of just putting everything inside draw, I'm going to create another function. And let's call it calcAngle. And the parameters for these are going to be center and pos. So it's going to be the two vectors that we have right here. And then I'm going to now define x to be equals to center.x minus pos.x, and then y to be equals to center.y minus pos.y. And then angle will be equals to inverse tangent, which is a tan of y divided by x. Now we're going to return angle. And we're going to be doing this in the radians mode. But I'm going to change it to degrees first because it's more intuitive for me to understand. So we're going to change it by using the function angleMode, change it to degrees, and then, inside draw, I'm going to call the function calcAngle and put in the two points, center and pos, and then we're going to print out the result, which should be the angle. And, as you can see here, what we have here is the angle 45, which is what we want. So where the xaxis here is 0. If you go clockwise, you get 45 degrees. It works when we're in quadrant 1. So I'm going to call this quadrant 1, 2, 3, and 4. Let's try a different point. So what if I put in 100, comma, 300. So now it is in the second quadrant, but the return value is negative 45. But what we want is actually 180 minus 45. So we are going to be writing a few conditional statements. So let's start with the first one. So if pos.x is greater than or equals to center.x and pos.y is greater than or equals to center.y. In the case where it is in the first quadrant, then we'll just return angle. But else if pos.x is greater or equal to center.x and pos.y is less than or equal to center.y, which is the case that you are seeing right here, what we're going to return is actually it's going to be, what, 180 minus absolute value of angle. So if we do this and I click Run, what did I do wrong? Oh, so it actually is less than or equals to center.x And then this is more than or equals to center.y. Now we get 135 degrees. Now I need to do two more cases, which is when we're in the third quadrant, which is here. So let's do 100 by 100. Now it's going to be else if pos.x is less than or equal to center.x and pos.y is less than or equals to center.y. So if I just return angle, what we get would be 45. But what we want is 180 plus 45. And then, for the last case, which would be 300, comma, 100 yes. What we want is else if pos.x is greater or equal to center.x and pos.y is less than or equal to center.y, then return angle. And what we have here is negative 45. But what we want is actually 360 minus absolute value of angle. So we get 315 degrees. And actually, we also want to do this as greater than but not equals to for the first case. So that none of these conditional statements overlap. And I'm going to actually delete the angle mode here because I want to be using radians right now. So now that we get the angle, now we want to get the direction between these two points. And we can actually use a method within the vector class called from angle. So we can do that easily, and I'm going to do it inside a function. So let's do function how about calcDir for direction? Actually, let's do Vel because it's going to be a velocity. So velocity is speed and direction at which this red circle is going to be traveling. And then we're going to need two parameters, the same ones, center and post. And then how about I declare a variable called vel? And to call the P5 vector method from angle, all we need to do is put in P5.Vector.fromAngle. And we want to put in the angle that is returned from the calcAngle function. So how about I also create a variable called angle, and then let's call this function calcAngle with two arguments, center and pos. And then we just put in angle in here. And let's return actually, let's draw a line. We're going to draw a line between center.x center.y, center.x plus vel.x and center.y plus vel.y. I want to draw a line between these two points. And inside draw, I'm going to call calcVel. All right, let's delete this. We don't need this. So calcVel, and it will be center, comma, pos. There's no error, but we don't see anything right now. Why is that? Let's print what vel is. And as you can see here, it's an object with three values x, y, and z, but we only have two values, x and y. And you can see that the values are less than 1. So the magnitude is very small. So what we want to do is we want to actually set a magnitude that is greater than what it is right now. So we can do vel.setMag, and this is also a method within a vector class. How about we set it to 100? Uhoh oh, I changed it to the radians mode, but I didn't change these values, so 180 will be pi. This will be pi, and then 360 will be 2 pi. And now we have this line that almost there, but not yet not there yet. And that is because the distance between the black dot and the red dot is actually greater than 100. But how do we figure out what is that distance? We can do that easily using a function called dist, DIST, which allows us to find distance between two points. And we need to put in four arguments, the x and ycoordinates of the two points. So center.x, center.y, and pos.x and pos.y. And then we want to put in distance in here. So now that we find the direction between these two points, now how do we move the red dots? So let's come inside the draw function. And now I'm going to actually set this function here to a variable called vel. And then, instead of actually drawing the ellipse using the x and ycoordinates of pos.x and pos.y, what I'm actually going to do is that I'm going to use a translate function, and I'm going to translate the origin point from the top left corner here to the point where the dot is. So let's do pos.x and pos.y, and then now, inside the ellipse function, I can just do 0, comma, 0. Click Run. You should see the exact same thing, but the line is gone. And that is because vel was not defined earlier. So now I want to move the red dot. I want to move it in an oscillating motion. An oscillating motion is a backandforth motion between a center point. And that center point is going to be the point where it is right now, which is the position pos.x and pos.y. And I want to move it back and forth, and I can use a sine or cosine function. So the equation will be how I define this variable as oscillation or osc. And we're going to use let's use a sine function. And then, inside the sine function, I'm going to put in 2 pi times angle here. And then, what we want is that inside here, we're going to translate it by vel.x, which is a vector, times osc, and then vel.y times osc. Let's click Run. Angle is not defined. OK, let's define angle. Let angle equals to 0. 18 oh, I forgot to return. So inside here, we also need to return the vel vector. OK, perfect. But it's not moving because we have not incremented the variable angle yet. So how about we increment it by 0.005? All right, so now, as you can see, it's oscillating around this point here. The original position where pos.x and pos.y was. So let's just try to change it to something else. Let's do 150 by 150. So, as you can see here also, the closer it is to the black dot here, the smaller the magnitude at which it is oscillating or the amplitude. Perfect now, what I'm going to do is let's change from a circle to a letter. And I'm going to comment out this ellipse, and we're going to be using a function called text, which takes in three arguments. The first one is a string of text that we want to draw. I'm going to just draw a letter A, and then we're going to put in the x and ycoordinates as 0, 0. Yay. Now what I want to do is I want to align the text to be at the center for both x and y direction. All right, so now it's at the center. And we can also set the size of this string of text, and we can do it using the function text size. But actually, what I'm going to do is I'm going to use a function called scale. And I'm going to how about we scale it by, let's say, 3. So that's really big. Let's do 2. Now that we have this code ready, why don't we put it inside a class before we make a bunch of them? So I'm going to come to this arrow here, click the plus sign, and then click Create File. I'm going to call this file letter.js. And then before we start writing a class, make sure you go to index.html and integrate this file into the whole program. So all you need to do is copy and paste this line of code, change the name here to the name of your new file in my case, letter.js and now we're ready. All right, so inside the letter class, let's start with the word class. Let's call it letter. And then we're going to write a constructor function. So what do we want to put in the constructor function? Let's start by going back here. I'm going to keep center as a global variable. And so is angle. So this angle is actually different from the angle in the calcAngle here. Actually, I'm going to change the name here to theta so that we're not confused that they're different. So the angle variable that is global is the variable for moving the oscillating motion. And then, now what we need to do is we want pos here to be part of the constructor function. So this.pos will be equal to createVector, and the parameter will be x, comma, y. And then I'm going to write a method called display, and then we're going to put all of this here inside the display method. And then don't forget this dot. So this dot before I change all this dot here, let's put these two functions, calcAngle and calcVel, inside the class as well. And when you put the functions inside the class, you don't need the word function anymore. So we can delete that and here, also. And then, now, it's time to put in all the this dot. So center is a global variable, so we don't need that. We are calling the calcVel method inside the class, so we need this dot as well. We're going to put this dot OSC and go, here is the global variable, this dot post this dot Vel, this.osc a lot of this dot here. That's it for here. And then, under here, we don't need this inside. Put in this dot, this dot, and then this dot, this dot, this dot, this dot, this dot here, here, and here. We don't need this inside the calcVel. We need this.calcAngle because we're calling the method. And then we don't need the parameter here. This will be this.vel. I'm going to call this as this.distance as well, and this.pos, this.vel, this.vel. And we don't need the return function because it's already part of this.vel variable inside this class. I hope this is all good. Why don't we just start by creating this one object just to make sure that the class is working? So I'm going to call this variable l. And l is going to be a new letter object. And we need two arguments, which is the x and y coordinates. And I'm going to put it as 150 by 150, just like what we have here. Then, in here, we're going to call the display method so l.display. Uhoh, it seems like I forgot this dot for one of them. And actually, Dan has a song. OK, one more thing that I missed 9. I don't think I need to set this.vel to this. So we can just call this method here. All right, so now we have the same thing but now inside a class. Now we're ready to make a bunch of letters inside a grid. So I'm going to start by creating an array called letters. And then we're going to create a few more variables, cols, rows, and size. And I'm going to set size to 20, actually. And then, inside the setup function, first, what I'm going to do is I'm going to calculate cols and rows here, which will be determined based on width divided by size, and rows will be height divided by size. And now we're going to store the objects inside a 2D array letters. And I'm going to use a nested for loop. So let i equal to 0, i less than cols, i plus plus, and then same thing for the j. So let j equals to 0, j less than rows, and j plus plus. Now to create a 2D array inside the outer loop here, we're going to populate this letter array with a lot of empty arrays. And then, inside here, it's going to be letters of i and j is going to be new letter object. But what I'm going to put here as the x and y arguments what we need is x will be equals to i times size, because it's going to be spaced out by equidistance of size, and then let y equal to j times size. And I'm going to put x and y here. Now that we create letter objects, we just need to display them using the nested for loop. So I'm just going to copy this down here, delete this, delete this, and just call the display method. Whoa, what's going on here? I forgot something important when you use any type of transformation functions, which are the two main functions, push and pop. So whenever you use transformation functions, you need to think about whether you want to save the transformation and then return back to the default mode before you call the next transformation functions, which is the case right now. So inside the display method here, we call translate, and we call scale. To use the push and pop function, what you want is that you want to put it before the transformation functions. And so it is going to save the translate position here and then the scale. And then, afterwards, we're going to put in pop. So it's going to return back to the original default settings, which is when the origin point is at the top left corner of the canvas before you call the next transformation functions. So if you do this, it should fix the issue. Whoa it's pretty cool. All right, I'm going to delete or comment out these lines. We don't need them right now. So as you can see, all the letters are going from whatever the amplitude is down to the 0 point. But what if I want it to travel at a shorter distance? What I can do is actually I can just multiply this magnitude here by a certain scale. Let's do how about 0.3? So you can see that it moves a little bit at a shorter distance, basically. Instead of putting or hardcoding this number, I'm going to actually set a variable this.scl, for scale, and put it here. So we can just change it as we want. And then let's go back to sketch, and then I'm going to put in 0.3 in the constructor function here. Now what I want to do is I'm going to comment out this angle. And, as you can see, it's not in the center. Actually, I need to fix this a little bit. So instead of just i times size and j times size, I want to also add my size divided by 2 for both of them. Perfect. Next, we are going to actually now draw a rectangle. I just want to draw a grid so that you can see. So i times size, j times size, and then size, size wow, OK. We also want no fill. And how about we scale down the letter to just 1.2, maybe, here. So let's do 1.2 so it's smaller. I want to get that feeling of, like, a wave. And we can do that by actually add a little bit to the simple harmonic motion equation. So we can add some shifting and go here. So let's call it this.shift. And, actually, let us try it. If I shift it by because this is in radians mode, so if I shift it by 0.4, you can see that everything is shifted a little bit. So what I want to do is that I want to shift it based on its distance from the center point. So I'm going to define this as this.shift. And this.shift will be mapped based on the distance. And between the value how about I just do 0 to 1,000. And I know for this particular sketch, the canvas size is 400 by 400. So, actually, the distance is not up to 1,000, but that's OK. You can change or play around with these values to get the look that you want later. But I'm going to map it to the values 10, comma, 0. Let's see what happens. It looks a little bit wavy here. I don't know if you can tell, but why don't we first move it and to see what happens. Tada. That looks really cool. And I can actually stop here, but I'm not going to. I'm going to make it a little bit more interesting. And what we can do is how about we also change the size of the letter A here. And we can do it in a very similar way by using the oscillating motion. So we're going to actually create another variable. Let's call it this dot how about fontS. And we're going to set it to be equals to I want it to also oscillating back and forth. So this.fontS is going to be mapped to this oscillating motion, which is this.osc, which will go between negative 1 and 1 because the magnitude is just 1. And I want to map it to the values of how about 0.5? Actually, let's do 0, comma, 1.5. And you can play around with these values as well. And we need to make sure that we put this.fontS in here. Let's see. Wow, OK, so because I put in 0, you can see that there is a point at which the letters just go away. So you can actually if you don't want that, you can do, let's say, 0.3 maybe. And, actually, another interesting thing that I want to show is what if we do this.fontS and set it equals to this.osc, which oscillates between negative 1 and 1. Do you see that? The letter actually flipped, which is an interesting look. So play around and see what you like. I'm going to keep it as this. And then, now what I want to do is because we're going to be putting it back with the video part, I'm going to set the canvas size to 640 by 480. And then I'm going to set the background to black. And, also, we don't need the rectangle anymore. And then how about we set the color of the ellipse in the middle or the center as the color white, and then we're going to set the font to white. There. All right. So the next thing what we can do is also what if we move the center based on where the mouse is? So inside draw, all we need to do is actually just set center.x to be equals to mouseX and center.y to be equals to mouseY. There you go. And remember that a variable scale that controls how much each of the letters travel. I'm going to play around with that variable as well inside here. So how about I write a conditional statement that says if mouseIsPressed and mouseIsPressed is a blunt variable that returns true when the mouse is pressed and returns false when it is not we're going to change letters of i and j.scl the scale to 1 when the mouse is pressed or else, then we're going to set it to 0.3. And I have a typo here and then here. Let's try that. So the mouse is not pressed. The mouse is pressed. The mouse is not pressed. The mouse is pressed. One last thing that I want to do, just to add a little bit more complexity to this so instead of just sending it right back to 0.3, when you release the mouse, I'm going to write another conditional statement that says if letters of i and j.scl is more than 0.3, then I want to slowly reduce it by 0.01. Then else here we're going to set it to this, just to keep it a little bit of a nicer transition. I don't know if you can really notice. Anyway, this part is all good. Now we're going to put everything back together. All right, so when you were not looking, I have already put Dan's code with mine. I didn't change anything at all. We just combined the two together. And, as you can see, this is not the effect that we're looking for. So let's just edit this a little bit. So first, I'm going to hide the video. Actually, we don't need it at all. And then, what we want is that the face is already detected. I want to actually, instead of just using the lips, I'm going to get all the keypoints for the whole entire face. So let's define a few more variables. So I'm going to actually comment out Dan's code here, and I'm going to define a variable called face. And let's set it equals to faces with index 0 because we're only detecting one face. Then, I'm going to set another variable called keypoints, and it's going to be just face which is faces of 0 dot keypoints. And then we're going to loop through the entire thing. So i is equal to 0 to i less than keypoints.length, i plus plus. And I want to draw all the points out. So we're going to use an ellipse function, put in the x and ycoordinates of all the points. So keypoints of i.x and keypoints of i.y. And let's set the size to be 2. And then let's fill it with the color white. Let's try that. Can you see that? You see my face in the back there because the circle is kind of small, a little bit hard to see, but you can see that there are so many points on my face. So, next, instead of using lips, what I'm going to use is that I'm actually going to pull out a specific point on the mouth here. And I actually happen to know what are those values. So let mouthTop equals to keypoints with the index of 13. And let mouseBottom to be equals to keypoints of index 14. And then let's just draw these points out. So mouthTop.x, mouthTop.y let's do 10 by 10. Same thing for the bottom. And then let's color it white. Oops keypoints. You see the point on my lips, on my mouth? Perfect. Now what I want, actually, is the center point between these two points. And I'm going to define some variables up here. I want to define mouthX, mouthY, and mouthW for the width. And down here, what I'm going to do is I'm going to calculate mouthX to be equals to mouthTop.x plus mouthBottom.x divided by 2, and same logic for mouthY. And then let's just draw out a circle for this point. mouthX, mouthY, 10 by 10 and we can draw it. We can put this back as well. And you can see, there's the middle point there. And why am I doing this? I want to actually control this instead of with the mouse location, but with our mouth location. So now what we're going to do is I'm going to comment out these 2 again. And then, instead of sending center.x to be this, it's going to be mouthX and mouthY. So you can see that it's tracking the face. But if I open the mouth, it doesn't do anything yet. But let's make it do something. So how about we set mouthW to be equals to the calculation would be mouthBottom.y minus mouthBottom.x. And I'm going to print this out so you can see the value. So mouthW oh, it's negative because it should be top minus bottom. Well, I did this wrong. It's mouthBottom.y minus mouthTop.y. See, as I opened my mouth, the value increases. So we can just set a threshold at which we want to call this. So how about when I open my mouth, it goes up to, like, 4050 here, so we can just do what did we just do 40? And where are we going to put it we're going to put it in this conditional statement. Instead of mouseIsPressed, we're going to do if mouth of W is greater than 45, maybe. Let's run. And there you go. So we're going to bring Dan back so that he can play around with this sketch. Whoa. I love how you're drawing all the points of the face, like, very subtly there. And then that's the center point. Ah, OK, my mouth didn't open as wide. [LAUGHTER] I just decreased this. Let's do 30. That is really fun. I wanted to check how one thing I was curious about I'm just looking at your code here. So, ah, I see so you pick specific points, and then you found the top and the bottom and then average them. So it's interesting I'd be curious to see if we use the lips object, which analyzes the lips and, in theory, finds the center, if that's the same point or a different point. But it's good to see this technique. It'd be interesting to think about what other kinds of text you could put in here. It's all the letter A, but you could imagine this being like a poem or it somehow is changing as you're interacting with it. It's also maybe something to consider as adding the lerp function because, sometimes, the points that come for the model it's actually quite smooth, but it's a little bit jittery. And the lerp function is something that anybody who's watching could try to add for some smoothing. Amazing. Thanks, everybody, for watching. Thank you, Patt, so much for demonstrating this project. Hopefully, you've gotten both now a nice introduction to the new ml5.js library, and I hope you try that out, as well as seeing how you could take a creative computational design, which there are many, many to choose from, from all of Patt's videos that encourage you to go and check out and see how you might combine them with interactivity from the FaceMesh model, but you can also try HandPose or BodyPose. And this video will be included on the Coding Train website with the Passenger Showcase page. So if you make something based on this video, please share it. Don't forget to check out Patt's channel and subscribe. And I'll see you next time on The Coding Train.