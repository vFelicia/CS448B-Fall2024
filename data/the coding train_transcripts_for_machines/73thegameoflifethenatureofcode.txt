now we're ready to talk about a twodimensional cellular automaton and the one we're going to look at is arguably the most famous southern time a time of all the game of life and now it gate so in 1970 I encourage you all to read this article Martin Gardner published an article in Scientific American called mathematical games the fantastic combinations of John Conway's new solitaire solitaire game life so this was really a thought experiment in many ways get out your checkerboard get out your checkers a checker on a square on a cell means one no checker there means zero and play this game see what plays out now Conway wasn't just doing this for fun although it is fun if you've ever tried this at home but Conway was really trying to produce really trying to think about biological reproduction and could a system that exhibits the properties of biological reproduction be simulated with such simple rules in a gamelike way and so Conway started with a few core principles which are outlined nicely in this article there should be no initial pattern for which there is a simple proof that the population can grow without limit there should be there should be initial patterns however that apparently do grow out without limit so in other words there are paths this this system can kind of grow out of control but there's no way to predict or prove exactly how it's going to behave just from its initial pattern and if you think about that that's really Wolfram's clap from the previous video that's really Wolfram's classification for complexity right there is this there is this unpredictable growth pattern that you that's going to come out of these simple this simple initial state okay now the third principle here is there should be simple initial patterns that grow and change for a considerable period of time before coming to an end in three possible ways fading out completely settling into a stable configuration or entering an oscillating phase so we're going to see that there's also these patterns that ultimately come to uniformity repetition or or as well so we're going to see that while this this game of life will run in this kind of amoeba like bacteria away for quite a while it will eventually settle into a stable state so this is kind of really interesting can we achieve this again just with squares on a grid and each square which is we're calling a cell has a 0 or a 1 so let's look at how we might define this from a systems point of view and then ultimately how we would write the code to simulate this and i should note country was doing this you know not only without processing but with without a computer essentially ok so um let's come over here so one of the things you remember from the onedimensional CA and this is kind of one of the reasons why we looked at it in this order is that if we have this cell here's the cells neighborhood it's just three cells myself the friend to the right and the friend to the left now in a two dimensional CA we have something a little bit more complex going on obsessively drawing grids here on the on the board here okay so let's say we're talking about this cell what is its neighborhood but we could define a cell's neighborhood in a lot of different ways but the simplest way we could possibly think of doing it in two dimensions would be see every cell to the right or left as well as the ones to the right right left up or down as well as the ones diagonally so if we count these there's 1 2 3 4 5 6 7 8 9 cells total remember there were eight possible ways that these cells could be configured now two to the ninth possible ways 512 I hope I got that right there are 512 possible ways this cells could be configured so we're not going to account in the two dimensional CA there's not really a good reason to account for every possible outcome we could say like ah there's only eight possible outcomes the first one is a zero the second one is a 1 the third was a 0 the 4th one is a 0 v 1 is a 1 right I could actually do that if I were doing all 512 we be here for quite a long time so in the case of 2d CAS and boy you want an exercise for yourself try to make a 3dimensional one right there are so many possible neighborhood configurations that we look at them in terms of generalities and this is what the game of life approach does it says things like this if there's a whole lot of cells around you that are half of the state of one you know turn your state to zero if there's none around you that of the state of that of the state one also turn your state dessert we're going to look at generales if the number of neighbors that have a value of 1 is greater than 5 is less than 2 we're going to look at it in those terms and the game of life is is really looking at these in the terms of what we think of almost in a way of like population dynamics so we have three key principles in the game of life death birth and what we'll call stasis I guess so death means we are a cell and our state was one but in the next generation our state is going to be a zero not a six right when do we die we die do from two possible principles one is overpopulation we are crowded or I don't like lots of cells of the state of blood around me it's too much I must die so overpopulation means that four or more cells are alive I don't know what I'm writing here are alive now we also died due to loneliness we can be very sad and say that that we can't we can't stay alive if there's nobody to be our friend around us so in the case of loneliness that is one or fewer live neighbors I'm not doing this in the most organized way here on this board but we can see here this is death death if our state was one we go to zero if there's overpopulation too many cells around us are alive or not enough cells around to sort of live now let's think about birth for a second birth is when our state was zero and now we're going to be born we're going to go from dead zero to alive the only time we have birth is if we have exactly three live neighbours exactly three live neighbours so these are the conditions by which we die go from 1 to 0 this is the condition by which we go from 0 to 1 and I said the last principle here is stasis in essence what we're saying is in all other cases state remains the same right so if our state was zero and we don't have three live neighbours we stay at zero so if we have two live neighbours one live neighbor zero like neighbors six live neighbors we stay at zero right and if we if our state is one and we don't if we have two or three neighbors right it's not overpopulation or loneliness we stay alive so this is the set of rules and now you know it's interesting to think about how did Conway come up with this would you have come up with these rules how much trial and error would it have taken you with a computer obviously you can try a lot of different rules and I encourage you to try rules most of the rules that you would try with a to DCA are going to get you very boring results everything goes to one everything goes to zero nothing ever changes but this set of rules is this kind of magical sweet spot where you get this unbelievable almost bacteria like reproductive complex complex outcome so let's take a look at how that works in processing I'm not timing myself again okay so the example that we're looking at here is example 7.2 this is a very simple implementation of game of life and we're going to talk about a couple more calm things that we could add to it to make it a little bit more difficult to program but more useful perhaps as well okay so let's take a look at a couple things number one we should point out is that no longer do we have a onedimensional array right we now have a twodimensional array talking about RCA right RCA is it at a given generation is a two dimensional grid of states not a one dimensional grid so in this example we have a two dimensional array and if you don't or not a familiar with twodimensional arrays I will include a link to a tutorial in the processing website about two dimensional arrays okay now a couple other things we have the same same idea here where we have a function called generate the function called generate is where we create the next generation and we have to compute the states for every single next generation now what is the value that we need to calculate notice all of these all of these rules require us to know the toe a number of live neighbors right we need to say here am I look around me at this moment in time how many neighbors are alive are there four are there one are there three are the two are there one and depending on my state and the combination of my state and the number of live neighbors this is how we're going to get our results so let's take a look at how that happens one thing that's a little bit insane here is we have this loop going through every single cell a nested for loop for every column for every row we're going to do this to every cell in our so every cell in our twodimensional array once we get to each cell we've got to do a little mini loop this little mini loop is the loop that says hey let's look at our own little neighborhood right what does that mean like if we're looking at this particular cell we're going to loop through all of these cells right first we're going through every single one and when we get to each one this one we look at these this one we look at these and that's what this mini loop is right here and what do we do we add up we start with a total number of neighbors at 0 and we add them all together once we know the total number of neighbors that are alive we can then implement our rules and let's see if I can uh I'm not well prepared here let me I'm just going to make this much wider so you can see it oh the awkward pause sing to yourself about the game life ok so if we look at this here we can see here are those rules loneliness if I'm alive on I have less than 2 neighbors my neck new cell is 0 my new state 0 I die if I am Alive and I have more than 3 neighbors my new state is 0 I die loneliness over population birth if I am dead and I have exactly three live neighbours my new state is alive otherwise stasis everything stay the same so you can see just in a little set of a conditional statement here based on what is my state what are my neighbor what how many neighbors do I have alive what is the new state and again the next generation then becomes the current generation when we run this you've all been waiting for this your whole life the game of life here we go here is the result and we can see we can lit it's just like going to go for quite some time we can see there are these places where it reaches a static state there are these little oscillating places where it's oscillating back and forth back and forth and I encourage you if you're wondering why is it doing that get out a piece of graph paper get out a checkerboard and try to calculate the generation you know put put for put those four states on and see look at it and why are why are the ones around it staying off why are the ones inside staying on it's it's it's it's quite entertaining to do that I'm gonna go have lunch in a little bit I might you know get up some papers do that while I'm having lunch okay so what are some other things to say about this a lot to say and I'm sure I'm going to miss a bunch of things but a couple things I want to mention well one thing that's really important is that we haven't enough men in the previous video on this one I've really left this out we haven't talked about what to do with the edges right look at here's a onedimensional CA right this cell has neighbor to the left neighbor the right what do we do with this cell it has a neighbor to the right it has no neighbor to the left if you notice in my examples if we go back to the code here I am taking a sort of license to make things very simple I'm actually starting at column 1 and ending it calms my ending it at the total columns minus 1 starting at Row 1 ending at the total rows minus 1 what this allows me to do is never have to worry about that the edges the edges are in a sense staying constant we don't calculate their their values perhaps a more useful thing right think about a onedimensional CA as being a strip of paper tie the two ends together and we have a continuous strip of paper right we could say this edge is neighbor to the right is this one its neighbor to the left is this cell so we could wrap around the edges that's and I have examples in the repository that do that as well it makes the code look a little more confusing and I'm using the modulus operation to do that but that's an important thing to realize the other way you could do is you could design different rules for the edges you could say well the edge only has one neighbor so I'm going to come up with a rule set just for the edge but that to me is like unbelievably light you causing yourself so much trouble just for the edge it's very inconvenient so I'm you know that's an interesting idea but in my examples I'm either ignoring the edge or doing wrap around the other thing I should just point out here we're going to get to this again to think in the next video is really where how do we go a little further with two obvious ways that you might think of as your own exercise and I'll talk about them a bit more in the next video is number one what's the most what's the thing that you're always looking at that you're working with which is a a twodimensional grid of of cells that have a state pixels pixels live in two dimensional grids they all have a state their color sure there are millions of possible colors with black and white is just 01 Gray's are 0 to 255 right all just about all image processing algorithms are cellular automata right a blur is just saying take a pixel and average it with its neighbors that's the rule for how a color changes from generation to generation if you were to apply a blur over and over again if you look in Photoshop there's a convolution filter which allows you to set the weights of various pixels in a neighborhood that is a CA algorithm there I've seen a water ripple like effects water color effects all sorts of types of things that you could do with the CA so one you might think about applying this to image processing and the other thing you might think about which I think is really important here is the fact that these cells they could be object oriented right now we have a twodimensional grid of numbers but what if instead of a 2dimensional grid of numbers sorry exercise oh no that's an exercise is an example example 7.3 what if our game of life was a twodimensional sorry about this twodimensional grid of cell objects right what if instead of just having twodimensional integers we had twodimensional objects those objects could no where are they on the screen what has been their history of states other aspects do they move there's so much you could do that in this particular scenario is very simple but it just shows you how in this case what we're doing is when a state when a cell gets a new state its when it goes from live to dead its turn when it dies it's blue it's red for a moment when it's born it's blue for a moment so the fact that we could store more about a cell in an object is something that's going to afford you a lot of possibilities and you can see here all we're doing is storing each cells location its width and its previous its its current state in its previous state you know the other thing you should really well I'm going to get to this I think in the next video actually boy I'm really screwing these up now this is kind of a learning exercise it may might like rieta these or remake them in a different order but I want to talk through a whole lot of exercises and possibilities with CAS in the next video so you could just keep watching if you want or you can stop