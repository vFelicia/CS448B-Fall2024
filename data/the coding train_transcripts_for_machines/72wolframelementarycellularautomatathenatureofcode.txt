all right we're ready to look at our first cellular automaton now first I should mention that CA has kind of a there's a rich history of work you know that you could really look back into into the 1950s and were look at the work of John von Neumann in Stanislaw ulam there are all sorts of interesting beginning uses of this idea of modeling behavior that we see in our world or behavior that we could imagine through CA like principles and again we're going to look at the game of life which is a very wellknown CA from the 70s in in a later set of video so we're oddly going to start kind of towards the end of this and a history of cellular automata and we're going to look at the work of Stephen Wolfram now I'm going to stop this discussion right here and point you to if you're really interested in kind of diving into deep into the science behind this stuff I would encourage you to take a look at Wolfram's book a new kind of science which you can read the entire book online I should note this book I think it's about 50,000 pages long or something I don't know maybe it's like a crew it requires like four iPads or something just to fill up the entire book anyway it's a lot of material and there's a lot of controversy about this material and the sort of big question is nature discrete or is it continuous does this but but will from central point here a principal I think is that this way of thinking this type of computational way of thinking is relevant to all forms of science now I'm not here to answer that question or even pretend to know have it appeared know the answer that question but I do want to sort of say that I just wanted to kind of point this out to you and I encourage you to take a look at this material but for us we're going to go all the way down to the guts of this and we're going to start in a very very simple place we're going to say we're going to ask ourselves okay if these are the defining characteristics of a cellular automaton what is and this is but what is the simplest possible scenario we could imagine okay so we started to go down this road but let's go through each of these and say what is the simplest possible scenario well a grid of cells the simplest possible grid of cells would be a one dimensional grid a linear grid so to speak I don't of selves the simplest possible set of states would be a zero or a one I suppose the simplest possible set of states would be just zero but we couldn't possibly get anything out of just having one state so we at least need two states 0 or 1 now we have a slightly more interesting question here which is what is the simplest possible neighborhood well let's say we're talking about this particular cell we might state that you know the simplest possible neighborhood it could be just to the left or just to the right but I'm going to say the simplest possible neighborhood is the three adjacent cells this cell and its neighbor to the left and to the right so if this is the simplest possible neighborhood one cell with its left and right neighbors am i recording yes now we have to ask our question how do we write the rules for the elementary CA where we get the cell state is a function of its neighboring states at the in the previous generation okay so this is our project right now we need to walk through these rules to find them and then see how they're implemented in code and then well look at the results have the results achieved anything interesting or a value or have they achieved complexity so let's answer that question so I'm going to erase this we can we can kind of remember this and let's look at a little bit more detail here so let's say this is our CA this is our CA at generation of acting analretentive here this is generation zero generation zero this is our CA okay and we're going to give it a bunch of cells of states and what I did here is somewhat arbitrarily I made a bunch of zeros and I gave one cell a state of one the reason I did that is this is kind of the classic or standard way of demonstrating a CA is to say let's have all the cells be off and just put the center one to one I don't know if that's actually the center one but close enough so we have to ask ourselves how do we evolve generation one I probably shouldn't have used the word evolve I don't think technically any evolutionary computing going on here although that is something we're going to examine in a future video how do we compute the next generation would be more accurate okay so this is our neighborhood now let's think about this what is this here this neighborhood that's going to give us at the very least the state for that particular cell at generation 1 how many possible ways could that neighborhood be configured well that neighborhood could be 0 0 0 or 0 0 1 or 0 1 0 or 0 1 1 or 1 0 0 or 1 0 1 or 1 1 0 or 1 1 1 right 1 2 3 4 5 6 7 8 ok so you know we should admit something to ourselves there's a lot of binary number stuff going on here and you know I kind of enjoyed that I think it's sort of fun you got zeros and ones and it makes you look like you're kind of a mad crazy person with writing all these zeros or ones but really um this might you might remember this if you want have you started first working with computers or learning to program or if you've had to work with a microcontroller what we have here are three possible ways of having a number with a 0 or 1 in it or we have 2 to the 3rd power possible way configurations or 8 possible configurations 1 2 3 4 5 6 7 8 so what's interesting to note is there only eight possible ways that neighborhood could be configured so if there's only 8 possible ways why don't we just define an outcome for every possible way meaning if the neighborhood is configured like so the resulting new state should be a zero if it's configured like so it should be a zero if it's configure like so it should be a 1 then let's say a 0 then a 1 then a 1 then a 1 and then obsessive and then a 0 right so I made up an arbitrary rule here but in a wolfram elementary CA this is what is known as a rule set Oh somewhere in my magical annotation system to this video you will see the decimal equivalent of this right it's some number I can't do this binary stuff in my head I wish I could that would be cool I could secretly like pause and rerecord the video and make it look like I know this so if you look at this this is the ruleset this is called the ruleset and now we have to ask ourselves another interesting question so we looked at this and said okay there are eight possible ways a neighborhood could be configured now how many possible rule sets are there well a rule set requires 8 binary numbers 2 to the 8th power is 256 that I do happen to know by hard drive memorize or somehow calculated my head I'm not sure which one so interestingly enough there are only there are only 256 possible ways an elemental wolfram elementary CA can be defined which means we can look at very easily week you know you know if we have like you got like 15 minutes we can look at you know if you're not too busy we could look at all the possible configurations we can see all the possible outcomes and what's really and we're going to do this in a moment what's really interesting about this is that a bull from actually categorizes all the possible outcomes into four classifications one is called uniformity another is a oscillate I would say oscillation remember if that's actually what it's called I like to think of it alt alternating values oscillation and another is I like to pause this video and fix what I'm thinking but I'm just going to keep going another is a random and then we have complexity so you know you might imagine the getting the first two components the first two classifications right if we look at this and we look at okay well 0 1 0 in this system 0 1 0 means you get a 1 and let's look at like 0 0 1 here would give us this value 0 0 1 gives us a 0 and then 1 0 0 gives us a 1 hey look at that we got 0 1 1 so we look at this we could imagine like we're just kind of sometimes we're flipping numbers sometimes we're not we might get like everything just becomes 1 so everything just becomes zeros or everything goes 0 0 1 z was your one repetition that would be perhaps a better name instead of I don't know wirelessly give oscillation I could think of it as an oscillation between states but repetition right good of uniformity everything tends towards just one state everything goes to zero everything goes to one or some type of repetition zero zero one zero zero one zero zero one zero zero one we could compute we could make up all these songs like southern CA songs one zero one zero one zero okay um so that's what you would expect but what's really shocking or kind of exciting or interesting about this stuff is the fact that we get not only do we get these sort of obvious results we get completely random results attention we all we essentially get a pseudorandom number generator out of just a CA I hope that's accurate um we also get we also achieve complexity we achieve this sort of ordered pattern that is unpredictable it's it's not pure random but it's also not pure repetition either we get this we get this intelligent behavior and this is really this is really interesting that this really highly computational system produces the type of result that we find in nature so that's that's the I suppose there's a good argument for why we're looking at this stuff in the first place I'm not timing myself and I'm just going on and on so we now need to kind of think about let's take a look at how this works in code okay all right I want to mention one other thing before we look at the code example so here's the other thing in the exact a well I'm going to go over to the example for a second and I'm going to open it up and I'm going to run I'm going to run rule 222 so what do I mean when I say rule 222 a great resource that you should take a look at is it can be found by any Google search but is this a page on in Wolfers math world about elementary cellular automaton at automata it's anise habitat and more we have we're talking about many of them they're automata but look we can see here here is a given rule set if we have three black cells or three cells with the value of one then we get a zero if we have one 1 0 we get a 0 you can see how this is modeled now if we go down we can see here this by the way is every the outcome of ever single possible rule so if we look at hey rule 88 and again rule 88 is just simply the decimal representation of the binary number 88 which would be zero zero one zero one blah blah blah blah so but what are these patterns that are being drawn how does this relate to a one dimensional CA so the thing that I should mention that I think is really important is when you look at through visual representations of this stuff you will see a two dimensional image why is it a two dimensional image it's because the way we're visualizing it is we're stacking all the generations so it's really important to note that the system is a onedimensional system this grid is onedimensional there's a onedimensional array of cells each with the state but if when we want to visualize the result and see what pattern we get what pattern emerges what we're doing is we're looking at all the generations stacked and the reason why I have belabor it lately but I'm just like saying this over and over again is because we really are going to look at something in a moment or in a future video which is a two dimensional CA the two dimensional CA is really a grid of cells and each state we're going to look at as a different frame of animation but this is one generation right in the 2d CA this is a single generation right here yes involve camera and this is a onedimensional CA where each generation is a given row in this pattern so let's take a look and now if we go back to processing here we're going to see first of all I'm representing up here I'm representing the rules as an array so you can see this is rule 222 this is the binary representation of the number and the comments were showing the decimal 190 31 10 and 90 these are some rules I want to take a look at for the different Wolfram classifications so let's run this first one and we can see yes this is what you would expect and in addition to stacking the generations that I've talked about over here what I'm doing in this particular scenario is letting them scroll by so we can see this is uniformity all the cell's just ten the same state now let's look at repetition which what rule 190 is an example of and we can see this now it looks like I don't know if you maybe if i zoom in here a little bit you can see there are these kind of diagonal lines it looks like but you can cut we have some kind of a this is making me crazy we have we can see that it's black black white black black white black black white that's the pattern if you look at any given cell from generation to generation so how is this stuff being calculated so I want to look a little bit I'm going to switch here to the kind of simpler example which is just showing this is rule 90 I believe which is by the way kind of amazing that with this simple system what is this pattern this is the sierpinski triangle it's a fractal pattern which we're going to get into more in future videos or previous videos if you're watching these out of order ok so what's going on here the you know I just want to point out a few things one is that the the cells are represented as an array of integers so a given generation is an array of integers 0 1 0 1 1 0 1 whatever it is that is the array that is that generation this is not my best video ok this function here generate is the key function for how we get the next generation right if we have an array of cells right we have an array of cells which is this here what do we need to do to get the next generation we mean to make a new array we have an array of int for that one generation we need to make a new array events here we go we've got a new array of int and now what do we need to do for every single cell we need to say ok the next generations value is a function of the cell to my left i minus 1 the cell to my right I plus 1 and me I I have I over here is I minus 1 or by plus 1 and over here is I minus 1 or whichever way you're looking at this video ok once we've calculated for all the cells the next generation then the actual CA which is cells becomes that next generation so we're doing this goofy thing where we are where we are creating we have an array called cells we're creating a new array called nextgeneration right this might have some values in it we calculate the next generation values and as soon as we do that we say hey cells is now this one and then we make another new array called the next generation so every generation we make a new array calculate everything into the new array and then hey say cells is now that next generation with zeros 1 2 so we're not in this particular example we're not storing a history we only have the current generation the next generation which is something to think about depending on how you're using this ok so the last piece of the code here that I think we should look at is well what is this function this function is saying hey I need to get a value from my state that I let the but from that neighborhood my new state is a function of my neighbors States and if we go look at this function called rules if we scroll down now I've in this particular example I've kind of written this in a ridiculous way just to demonstrate what's happening if my cells are one if the states are 1 1 1 give me the first element from the array if they're 1 1 0 give me the second element if they're 1 0 1 give me the third element right so with that rule set array remember which is the encoding for all of how the cell state change over time we're getting those results from the from from these configurations now in truth there's a simpler way to write this function which is that we could just convert the 3 bit number into an index into that array and you'll see in other of my examples in the repository it does that but I think this is kind of a nice way of looking at it at first to say like what is the next generations value based on three states I think you can see that ok so now that we sort of see how this works let's go back and just look at a couple more examples so we have we saw we saw uniformly we saw repetition I also pointed out that we can get a fractal pattern which we have to ask the is this is this repetition is this complexity interesting question to ask I'll let you answer that for yourself but or discuss in the comments comments or I still really this is like a 30 minute video basically probably or here let's take a look at rules 30 whoops come on run so rule 30 is a wonderful example of a surprising result or at least a result that I when I first look at this kind of stuff found surprising which is that how this this rule these rules are so unbelievably simple and yet look at this complete and total randomness now I don't know you know how do we get random numbers out of this maybe we could look at there's all these kind of like little kind of triangular patterns forming maybe we could use the areas of those triangles or something like that but and you know if Tasker quit is this better than existing pseudorandom number generators generators that it's worse but the fact that we can see this completely like non repeating pattern from such simple rules that just you know all you can think about is that we're going to get repetition from them is is a really interesting result and at the same time we can also see just from these simple rules if we go to rule 110 we can see that we're going to get something that has the properties of a complex system it's unparliamentary with simple rules the result is ordered yet unpredictable intelligent there's lots to look at here so this I think is a pretty unbelievable result and I think is what makes working with CAS so enticing alright there's a lot more to kind of say or look at with these but I think that I'm going to I mean I'm definitely gonna stop this video and the next video we're going to look at the game of life which is a 2d CA and