now that we've looked at the dot product and we understand the concept of scalar projection we're ready to look at the path following example the path following steering Behavior so let's say for a moment we have a path and a path we're going to Define as a line between two points something like this so what is our goal here I mean first of all we should point out that if what we want is a shape a vehicle a creature a particle whatever we're calling it to follow this path you know we could actually just put it on this path and move it using a little bit of math and understanding the formula for a line have it locked to that path that's not what we're trying to do here we're trying to create a flexible improvisational lifelike steering behavior um where a vehicle is attempting to stay on this path so in order to do that I me we're we didn't I didn't come up with this we're going to look at Craig Reynolds scenario so actually I'm going to um yeah let's keep going with this so Craig Reynolds does few things there's stuff in my way over here um first he says okay a path has a radius so we're going to think of the path's radius as a distance from the line um kind of like a width of the path so we can call this distance from the L from the from the center of the path to each Edge the radius of that path so first a path has a radius then let's say we drop a vehicle into the this world with the path so we have a vehicle here now we can clearly see this vehicle is off the path so one of the things that's important in a uh in the steering behavior is to understand is the vehicle already on the path or is it off the path and actually we're going to take that one step further the very first thing in the Craig Reynold steering Behavior path following is check vehicles future location now it's been a few day been a few days since I made the last video so I don't particularly recall but I I'm pretty sure this is something we looked at before and if not this is something that appears in lots of the steering behaviors this idea of a vehicle being able to understand its future location how does it understand its future location well it knows its current velocity Vector right its current velocity Vector tells it how fast it's moving and in what direction and what a vehicle do is say if I were to continue moving at this speed in this direction five moments later which we could think of as five frames of Animation later or 10 frames or 25 frames I'm going to be in this location so this is the future location and when we look at the code well maybe we'll if we can pause for a moment and try to find where's the line of code that says here's my location here's my velocity add my velocity to my location okay now once we do this the next question we have to ask is is that future location on the path right is my future location on the path is it is it within the the the the the sort of on this diagram here at least the top and the bottom is it within the radius of the path I mean visually here we can see no it is not but let's just say for a moment let's have it add another vehicle here and say this vehicle here's its future location is that on the path yes it is so we can say here in our algorithm if yes do nothing apply no steering Behavior so Craig Reynold steering Behavior algorithm says if you if your future location if you're already on the path you don't need to steer I mean why would you bother steering I'm on the path I'm path following I'm already on the path path path is fine yeah yeah yeah I don't need to apply steering Force got it so this is good I mean if we're always on the path we do nothing but if the answer is no we're going to go to the next step which is find the normal to the fath path find the scalar projection to the path so find I'm going just call it the closest point on the path so if for some reason you skip the dot product video because you know all about the do product then um then you might want to go and and this is confusing to you then you might want to go back and watch that but here this is the moment where we're going to use that scalar projection technique we're going to take this future location and connect it to the path at a perpendicular angle so this is that point that we found in step four the normal the closest point on the path this normal point then you know you should think like we've done enough already my goodness all these steps all this math and diagrams getting a little bit complicated but we're not done yet Craig Reynolds take this one little step further where he says boy I don't have enough space here he says predict I don't know what I don't know let Le let me figure out a way to write this let's just say move along the path this is probably not how it's written a little bit so this is my my just mental um this is my way that I'm stating the step right now move along the path a little bit what we're what what Craig Reynold says is okay so that is the closest point along the path but this vehicle in order to sear back onto the path let's in the same way that we predicted the vehicle's future location let's predict the uh let's move a little bit further along the path to a future location in a way so let's say we move a certain distance along the path and now we have this is now the Target and that so this last step yields us a Target and the very last thing we do is seek that Target so we just use the seeking Behavior so in Essence the vehicle says where am I going am I moving on am I is is where I'm going going to be off the path if it is let me seek back onto the path so remember every steering Behavior boils down to a desired velocity right what is my desired velocity at this moment if I'm already on the path my desired velocity is my current velocity if I'm not on the path my desired velocity is a velocity pointing towards a future Target along that path so we have an elaborate set of steps here but we luckily we've learned all about vectors we've learned all about the dot product we understand about velocity we understand about modeling motion we can we have all the tools to implement this algorithm any questions okay uh right you you um you don't even exist at this moment okay um so let's take a look at a couple things first let's look this is Craig Reynolds site um you uh link below where you can find the the uh demonstration of the path falling algorithm and you can see in this D I call it a diagram I guess in this Java applet that's running online that red dot is that vehicle's future location and you can see as soon as that dot moves off the path the vehicle starts to steer otherwise it's moving at a constant velocity and you can also see on the diagram where there's these red and white circles which are showing the target along the path that it's steering towards so this is a great demonstration excuse me and um I don't think I've ever done that in one of these videos before we we like edit that out maybe you didn't even notice good okay so but um let's let's look at this what we need to do is look at this in processing so this actually this is quite complex the path has a lot of points it's very curvy there's lots of things being drawn in here so the first processing example that I'm going to show you simplifies a bunch of things and in essence the major thing that it simplifies is that our path right now is just a straight line it has a start point and an end point so it's not going to be that interesting to look at the result but at least we can work out the algorithm and as soon as you see I'm going to add a vehicle and you can see look it's steering it's that as soon as it's off the path right while it's future location while it's off the path it's steering and as soon as it's on the path you can see both of these vehicles are now moving at constant velocity so they're moving kind of slowly the path is a straight line they're not really going to go off the path anytime soon um so um you know but I can add a lot more and we can see the kind of behavior that we're getting when I add a lot of these vehicles that they're all kind of locked onto this path now they all have varying maximum speeds and maximum forces so we you know we almost have this like traffic like behavior and you can imagine if we could make our path more sophisticated and um if we could even add some more stuff later we're going to see if we can add a little separation force between these we've got something that really starts to simulate uh you know a crowd of vehicles on a crowd of of things of creatures on a path so let's look at a few elements in the code in terms of how this is being done um okay so element number one that I want to look at is that we have a new class the this class it's called a path class and this is very simple it just has a start point and an end point and a radius so this is where we're starting the point that I'm saying here is we need an object to describe the path But ultimately what we're going to need is not just a path that has two points a beginning at an end we're going to need a path that connects a series of points right so that the path might have a um you know can be much more sophisticated than just a single straight line but this is a beginning here a start and an end the other piece that we need to look at here is okay well what's going on in the vehicle the vehicle is the same thing we've always had location velocity acceleration a size maximum Force maximum speed all that stuff we used to have seek we had arrive we had flow field a flow field function now we've added a new function called follow and what does this vehicle do it follows a path object so now what we've said is if we look at the main program here that we said I don't know why oh they call them car here every car can follow the path so we're adding a new piece of functionality we're saying the vehicle can um follow a path right so this is this is where the guts this is where this entire algorithm that we've worked out is all going to be in that follow function so if you're looking at this on your own time later or you're pausing the video that's where you want to go look look at that follow function look at these steps find a couple lines of code that correspond to each one of these steps and I'm going to walk you through that right now um for a couple minutes okay so let's go to that function and let's take a look okay the first thing we need step we can see is like predicting the object's future location and look at how we're doing this we make a vector that's the velocity Vector copy we say hey velocity Vector let's make a copy of you let's set your length at 50 pixels and add that to the location right so what we've done is we've said hey here's an object give me the velocity Vector set its magnitude to 50 pixels and add that to the location that is the object's future location and that what we've done here right here in the first step so great we know the object's um future location we have to ask ourselves is that location um on the on is that location on the target well how do we know sorry I can't say anything right today we want to know is that future location within the radius of the path how do we know that we need to know the length of this line is the length of that line greater than the path less than the path how do we know the length of that line we need to find this point we need to find the distance between those two points all of that stuff is baked into this algorithm we're going to find the distance to the the we're going to find the distance to the path is greater than the radius then we're going to apply a steering Force how do we do that well look at this we have this function get normal point we have the we have the predicted future location and we have a and b the which which are the beginning and end of the path um we have the predicted location this is a and over here the end this is B we need to find this point so there's a function that does that called get normal Point what's in that function all of the math for scalar projection that we did in the dot product so you can go back and look at that if you want I don't I won't scroll down and look at it that's where all that is once we have that point point we can find the distance between the the predicted location and the normal point and if that distance is less than the radius seek the target along the path what's the target along the path it's a point a little bit further than that normal point which I'm calculating here by just what is the what is the vector of the path move a little bit further along the path so you can see all those steps are here step one step two step three step four and step five the very last step is seeking that Target okay so I think this pretty much covers the Bas basic path following example but we still have a bigger question to answer and so I I'm going to answer that in this um in this video even though it kind of gone I've gone on for a little bit longer than I had intended if you want a really difficult exercise for yourself pause the video now and go try to take this example which is uh oops oh I'm I'm in the wrong place I was talking for a while which is example 6.5 take example 6.5 and try to expand it for a path that has multiple line segments but I'm going to talk you through that right now okay so we know now based on example 6.5 that we could follow this path but what if I want to follow this path well first of all how do we Define a path like this you know we could do all sorts of crazy curve interpolation formulas to make this really beautiful curve but the point is if we can draw this curve remember we're just trying to get a vehicle that's kind of looks like it's following it so there's no reason why our actual path data couldn't just be a selection of points that's on this curve so whether you're finding the Contours of an image or you have a data set that's a graph if you can get the points along a path right which we think of as connect which the datawise will just be connected straight lines but you could visually draw it however you want it's going to look quite a lot like it's following this curvy path then if we can follow a single line segment can't we follow a bunch of line segments so that's step number one if we look at the next example which I'm going to show you um shoot uh minimize this which H it is right here which is 6.6 the main Innovation here is our path class now has an array list of be points are you still are you awake are you still with me right it has an array list of points it's not just a start and an end and it's .1 2 3 point4 all connecting and making a big path when I run this example you're going to see that uh here um and in fact every time I uh press the space bar I get a different path and we can see look we have a bunch of vehicles now following this path okay now that we've uh figured out how what the path class has to look like let's give ourselves a new scenario so I'm going to actually draw a path as a series of connected points which I'm arbitrarily drawing here on the board it's probably way too complicated we can see this this could be a path that we want to follow and let's say I have a vehicle and my vehicle right now is over here and here is its future location great so what's step two once we have a vehicle's future location what we need is the normal to the path we need to find the distance from its future location to the path so let's work on that oh oh okay I got it I got it right over here connect this perpendicular line there's my normal point we're done yay okay goodbye okay obviously I missed something that was my little play acting thing here okay but because what what what did I miss actually I got one right over here there's a normal to the path and whoa look at this there's a normal to the path I mean I didn't draw that perfectly there's one an even weirder like let's uh or like let's let's extend let's pretend this line was like an infinite line look there's another normal to the path really over there so like there's all these normals to the path because there's all of these line segments I could make one for this one for this one for this one for this one if I extended this out what do we follow how do we pick this oh my God we're so stressed out I think we're going to be fine right because we can come up with something I mean first of all we could just read Craig Reynold's materials to be like thank you you came up with it but there's really it's not too hard to think of it the whole point of finding the normal to the path was to find the closest point on the path to my future location well we have a whole bunch of options why don't we find the one with the least distance so if we pick the one with the least distance which clearly from this diagram we can see is this one the other thing is we can disqualify any where the normal is not actually on the actual path even though we can think of all these lines so this one can be disqualified instantly and now we have to pick between these three there's four and five which we can disqualify we can see that this one has the shortest distance so this is actually excuse me the Target that we're going to seek we're not seeking a Target over here or over there so this is a methodology we can employ and is in fact the methodology that you will see in my processing example what we have to do is say look at this line segment find the normal look at this line segment find the normal look at this one find the normal this one find the normal this one find the normal this one find the normal all of those distances which one is the shortest pick that one to seek so let's see if we go look in our algorithm let's see what's actually changed in the code okay okay so this was the example we were running let me uh turn it off for a second and go to the code and we can find sorry the um uh the uh uh excuse me the I'm looking for the follow function Talk Amongst yourself for a minute here we go right so we have the same old thing where first we need to get our future location by making a copy of veloc velocity moving forward from our location we have that future location look what's going on here now we we're doing the exactly the same than we did before but points A and B aren't just the start and the end points A and B are Zer and one one and two two and three three and four I and I + 1 so we're going to do that find the normal point and find that distance for every single one and what we're looking for is the world record distance so if you walk through this algorithm you see every time we're going to say hey is my distance less than the world record distance if it is the world record is my distance and that normal point is the one we're going to save when we're done with this algorithm then we just say hey um as long as remember that distance is greater than the radius as long as we're actually off the path let's seek that Target so um um so that's the full algorithm it's really if you look at these two examples they really are exactly the same the difference is in the first example we're just looking at one line segment in the second example we're looking at at a series of line segments and finding the one with the shortest distance and if we run this again um we can see here that uh we get our vehicles following the path and um we can add a lot of them we can keep what's kind of nice about this which didn't occur to me is that if you have a path that's changing the vehicles will adjust which is kind of a nice behavior somewhat similar there's a lot of similarities here to the flow field following right um we really have a set of vectors so you can almost think of this as a flow field but it's just defined by um a path instead so uh what could you do with this boy probably a lot of things you probably have a lot of ideas let me give you a couple um suggestions number one is try making this path actually like move with pearing noise or something so think of the points on these path as uh as as entities with location velocity acceleration like what if you took like a springy something from toxic lives which is like a springy wavy thing and had Things fall in that's probably pretty complic it's interesting idea another thing you could do is find trace the Contours use Edge detection blob detection find the Contours of an image um in a magical place I would like point you to a video All About blob detection which may exist someday and I'll like dub my voice over here and now go through this video but um because I don't know why you put your hands over your mouth when you dub anyway um so um but mostly I would suggest um another thing that you really might want to play with is try um try lots of variations making the radius bigger the radius smaller smaller CH do things with the vehicle in terms of affecting its maximum force and maximum speed see what type of um see how good and how bad you can get something to follow a path another thing you could do is can you make a closed loop path right you can make a racing simulation essentially by having a path that closes its loop at the end so right now this path has a beginning and an end and the vehicles wrap around but what if you instead had a a circular path so try that I'm just rambling okay good night and good luck or just I don't know it's like 1130 in the morning I would like to take a nap but it's not time to say good night okay uh next video is coming soon