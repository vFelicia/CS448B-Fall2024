hello welcome to part four of this video series thing that I'm doing about genetic algorithms okay what's going to happen now in this particular video what I want to do is actually finally and know Tak of me for videos look at the code itself so I have a premade code example as you know I'm not going to write it from scratch it's coming from the nature of code chapter 9 you can find the link to the chapter and the code in this video's description but what I'm going to do is look at the algorithm itself that I covered in detail a couple videos ago and look at where all those pieces are so so what does it mean to initialize a population randomly what does it mean to do step two selection to calculate the fitness of every member of that population how do you write a function in code to actually do that how do you write a function to to pick randomly but have each thing that you're picking randomly have some sort of higher or lower probability of being picked that's a kind of a tricky problem we'll look at how is that solved and then how do you do this thing heredity how do you do crossover how do you write the algorithm for crossover how do you write the algorithm for mutation and then have this new population that you then make the current population repeat over and over again so I want to look at every single one of these steps and find in the code where those steps happen so let's just start doing that okay actually before I do that though let me at least um open up this directory here and show you that how I have the code organized so I have the code organized you know there's the libraries folder for the P5 Jess uh JavaScript library I'm using there's the HTML file which references the JavaScript files and there's some like kind of worthless styling in style.css but the files that actually matter up to you are sketch. ja that's where kind of the main program is set up this initialization state is draw this looping state is that U um population. JS that's an object that manages the array of all the elements of the population so there's functions for calculating the fitness values there there's functions for doing the selection there and then there's the dna. JS file this is a really important file because this file is actually this object this DNA object as I look at more sophisticated examples in future videos the code in dna. JS will actually be present in almost all of them so a lot of what's great even though this example is kind of completely trivial example because again I could just type to be or not to be that is the question the code in this example can actually be almost lifted essentially verbatim to other scenarios to write your own genetic algorithm and that's kind of the next video after this one that I'll get to how do you take this code and implement it in a different scenario yourself but so the dna. JS has that DNA object it has it a function for mutation it stores the characters for each phrase that sort of thing it's each individual element of the population okay so let's go back to the algorithm step one create a population of n elements so let's go to the code and where this happens is actually in population. JS and we can actually see this happen right here uh I say create population equals a new population so the population is made with three arguments a Target which is the target phrase to be or not to be which I could change a mutation rate and a population Max so those values are sort of stored also in that population object and in the population object itself this is the kind of key variable this. population oh no this dot dot dot don't forget don't forget this dot so uh uh a variables that are part of that object itself are attached to it by saying this. population so this is a Constructor function that's creating a JavaScript object and a population is made as an empty array And Then There are a certain number of elements of the population made as DNA objects so the so what the um I think if I uh come over here for a second the population object itself is just a big array of n elements and each one of those elements is a random phrase you know popcorn you know uh unor whatever these sort of weird nonsense you know a a a a a whatever the each one of the members of the population is a random phrase and but it's not just a string so rather than use just a kind of literal string uh what I'm actually doing is creating a DNA object and this is kind of crucial and this is now where the dna. JS file comes in dna. JS has an object it's itself which is an array called this do genes so if I come back over here whoops step on a light on a fan I think I broke no I didn't break this anyway that light went off this might be a little bit darker for a second back hello everything's okay the fan is blowing up my legs so this is the population array each element of the array is a phrase which is actually a DNA object which itself is an array array and each element of that array being a single character okay so that's how each element of the population is an array of elements each element is an array of characters so this is ultimately how the uh whoops let me come over here this is ultimately how that population is made make a certain number of DNA objects each DNA object uh each element is a new car now one thing that's a little bit goofy here is I wrote an entire function to uh make a random character there might be an easier way to do this in JavaScript but I really just want random characters I'm using the sort of asky table here so I'm picking a random number between 63 and 122 and then converting those from that number to a string using its character code so like using the asky table and if you're not sure what the asky table is I'll try to include a reference Link in this video's description to that so that is step one initialize okay okay step two being selection now we need to evaluate the fitness of every element of the population so where does that happen so one thing by the way that I think is worth looking at by is this uh is this main program right so draw by the way look at this the draw function essentially and it's funny how I'm doing this in a slightly weird order I maybe I should flip this around but what the population does what the the population object itself has all of these steps of the algorithm written in a specific functions so I could just say population calculate the fitness of every element population perform natural selection population generate the next population and then population. evaluate why I um that what that function does actually is just sort of checks to see if we're done so these are the three I kind of I don't know why I did this I'm going to just right now put this first because it's Loop over and over again it doesn't necessarily matter but I'm going to calculate the fitness um first because this is sort of essentially the order of the of the genetic algorith itself so this is this is Step uh two right here uh selection which calls that function calculate Fitness which is right here uh oh I froze hopefully I didn't actually object um somebody in the chat will tell me if this sto working uh there's this function calculate Fitness and notice what that function does it Loops through every single member of the population and calls another function calc Fitness so when I say Cal Fitness on the population really what I'm just doing is saying Loop through the entire population and call a function on every element called calc Fitness and check the fitness against that Target phrase so now if I go into the DNA object we can see Cal Fitness right here this is now a key key function in a gen any genetic algorithm is the fitness function itself so you can see what's going on here I start with a schol four of zero I iterate over every single character in the phrase if the particular character in the genes array matches the character in the Target phrase increase that score by one and the fitness is the score divided by the total length so the number of characters correct divided by the total length gives you a percentage I got nine out of 10 characters correct a fitness score of 90% so you can see that's what's happening and so that's step two selection calculate Fitness initialize generate 200 random DNA objects step two calculate the fitness for those random DNA objects okay now the next thing we need to do is reproduction now here's the thing let's come back over here and talk about how this is going to work so let me erase this for a second so if you recall I had this idea of this spinning wheel wheel Wheel of Fortune so here's the wheel maybe there are you know a whole bunch of members of the population uh each with a certain Fitness and depending on their Fitness they get a bigger slice of that pie and then the idea is you spin this wheel and you pick a parent and pick another parent well you know I could actually build in the code like the sort of physics simulation of a spinning wheel but that would be a little bit Overkill there are a lot of different techniques of um of of picking uh picking random elements from an array based on probabilities there's a snack technique where I can pick two random numbers a kind of qualifying random number it's a I forget what I call I actually just recently made a video or an example about this uh accept reject um kind of algorithm but the algorithm that I'm going to use is actually a very uh simple technique that works well in this case so let's say I have a b c and d and I want a to have a 40% a has a 40% uh chance of being picked B has a 20% C uh has a 15% oh why did I make the math so hard on myself 6075 no no no I don't I don't this is not going to turn out well for anybody with 15% so we'll just make um we'll make C uh 10% 40 60 70 and D 30% okay now look at this let's say I have an array this is the array and the array looks like this a b c and d let's say I want to pick a random element from that array A B C or D each element has an index 0 1 2 or three so I could pick a random number between zero and you know four but not including four each one of these has a 25% chance being Pi of picked I have a one out of four chance I can't write 25% of picking any of those what if however I were to write the array a different way so I'm going to write the array like this a a a a b b c d d d notice I put a in that array four times I put B in that array two times C in that array one time and D in that array three times now there are 10 elements of the array four of which are a so if I pick a random value between 0o and 10 not including 10 0 and nine right four out of 10 times I'm going to pick 0 1 two or three an a two out of 10 times I'm going to pick a four or a five a b so what I can actually do if I have a this is the population array that's the actual population array in the code I build another array which I think I'm calling a mating pool or I might call it like Darwin or something where I take these elements and put them in this array a certain number of times according to their Fitness so the more times something is in an array the more likely it is to be fit picked and I think if I come back over here for a second um I think I have so this is kind of a just some other diagrams demonstrating this idea right what if I have all of these elements with a different probability this is the spinning the wheel approach but what if instead I just create this big bucket and I put like a in there so many times B in there so many times c in there and I pick out of it the more something is in the bucket the likelihood the likelihood the higher the likelihood is that it will get picked so how do you do this in code code if I go back to the code again we're looking now for this function natural selection which says generate a mating pool so let's go look in population and here it is notice what I do this mating pool is now a new empty array and and then ultimately later on right down here there is this code where I'm adding every member of the population into the mating n times so how do I figure out what that number n should be well you know this I could this could probably use some refinement and there's different ways you could do it but ultimately up here what I'm doing is finding out okay what's the number with what's the what's the member of the population with the most Fitness the highest Fitness value then what I do is I take that object's that particular element's Fitness and give it a number between Zer and one mapped from zero to maximum Fitness so in other words what I'm saying is I'm doing sort of Step where I'm normalizing all these Fitness values now ultimately I kind of made up an example here with sort of prenormalized ex uh value like 04 2.1.3 but your Fitness scores might just be like a whole lot of numbers like this one got a fitness of 2,000 this one got a fitness of three this one got a fitness of 4,228 so what I do is I have a way of saying whatever the fitness numbers might be take them all and just have them have a range between 0o and one and actually the next thing I do is multiply it by 100 so actually the range is between zero and 100 and you can see that's what's happening right here I do that mapping then oops ah I lost my oh I sorry I lost control of my computer and then I multiply that value by 100 and that's n that's how many times those elements are in the mating pool itself so if I were to just do something which I'm a little bit afraid to do but I'm going to say console log this. mating pool and I'm going to go back to the sketch and run it and what you can see is these are the mating pools right and it finished and you can see that there are uh this array this this array is actually quite huge I wanted to say uh this do I think it might make more sense to say this. meting pool. length so you can see this is how many things are in The Mating pool in the in the 15 to 20,000 range whereas the population itself is just 200 but based on their Fitness that maing pool is built much larger okay so that's we're getting there that is let me go back to this particular Alum so that is selection so once I have the mating pool then I'm ready for step three reproduction all I need to do is I have the mating pool all the probabilities are already sort of built into that big array right now I just need to pick two random ones from the array and we can go into the code itself and we can see where that happens look at this this four I want to do this end times I want to make a new population here are all the steps that's the generate function pick two parents give me a random index into the mating pool a give me a r another random index into the Ming pool now technically speaking you might want to say to yourself ah you know what if B equals a I want to invalidate B and pick another one but you know me I'm sort of being Loosey Goosey about it doesn't really matter if I by accident on the rare occasion pick the same parent twice big deal so I have two parents parent or I play partner a and partner B both of those are DNA objects that come from The Mating pool and then I simply call crossover I take partner a crossover with partner B and that is a new child element and then child I call mutate for the mutation rate and then I have that new member of the population so this happens end times I just say I have the mating pool give me two parents uh cross them over apply mutation here's the new child it goes into the population this happens over and over again so we've really looked at every single element of this algorithm here the last thing though is we could look at what has actually happened in crossover mutation so again just to remind ourselves this is the crossover step the technique that I happen to be applying is take half of one and half of the other and put them together but certainly you could take one from each one I think I don't think I have a DI for that or you could do it a different way and then mutation I'm using this probability to say at any given random uh any there's a certain chance that I might just change that character randomly so let's look at how those functions work now notice where is that function happening I'm saying partner a that's a DNA object cross over with partner B that's another DNA object so that code for the crossover function itself is in this DNA object which is right here so look at this this is now the crossover over function first of all I'm creating a new DNA object with the same length the same amount of genes as this current DNA object I'm picking a random midpoint right I could just say oh the Rand the midpoint is always five or the midpoint is always this. genes. length divided by two but I'm picking a random midpoint and look at this this child's genes are either coming from right if I'm on one side of the midpoint they come from this particular DNA objects genes otherwise um otherwise they come from the partner genes so this is how I'm applying crossover it's literally just a new array take elements from one array or from the other array and then mutation you can see here mutation these are incredible incredibly simple fun then I have a new child DNA object and mutation these are incredibly simple functions all it is is hey let's look at every single Gene and just say pick a random number between zero and one if the m ation rate is 01 or 1% if I happen to pick a random number less than 01 then just give me a new character forget about whatever I got through crossover give me a new character okay so this is it these are all of those pieces this is the main program right in setup I have what's the target phrase what's the maximum population what's the mutation rate then I create a new population object and then I just walk through the algorithm itself calculate the fitness build the mating pool generate the next population evaluate is just checking to see how everything did at the end that's and um and then you know there's some other code for sort of displaying all the information using Dom elements and that sort of thing but this is the key algorithm it's all in separate functions and each one of these functions calculate the fitness natural selection and generation simply iterates over that entire population right the population object has a population array I'm always iterating over that population array calculating the fitness for every element of that array uh assigning a probability for every element of that array picking a random parent from that picking a random element picking a new child for every element of that array and all of those functions are in turn in this DNA object the DNA object stores the actual genetic information it has a function for calculating the fitness it has a function for performing crossover and it has a function for performing mutation so these are all the elements so I've kind of finished this here I'm going to do a followup video where I talk about a couple things that I think could optimize or change the way this works but ultimately what the the project for you in your head that you want to think about for right now is well what is the thing that you want to make that you might want to try to evolve are you trying to evolve a particular design to make it more beautiful or more intuitive are you trying to evolve a particular animation behavior of an element on the screen um and what might be you know how could this algorithm apply to your scenario what might be the genetic information how are you how is how is how is I just made this like weird like closing my one eye thing expression at you I don't know why but um how how can how can you apply this sort of algorithm and idea to your particular uh creative project and that's what I'm going to start to get to as I look at a few more advanced or more advanced is the wrong word but really more sophisticated examples of applying this so I'll see you in the next few videos where I look at some other scenarios and other things with genetic algor okay byebye quick addendum here since I said I would do this uh for those of you that are interested the code for this example is also available in the processing program environment which is a a a creative coding environment built on top of the Java programming language so if you're looking for Java classes to do a genetic algorithm you can find those as well and really ultimately it's all kind of the same there's some you know little differences the you know we've got the sort of more classical objectoriented programming where I have a DNA class and and a population class uh the population itself is an array but one thing you'll notice that's kind of key is the mating pool I'm using as an array list in JavaScript arrays can easily just kind of be resized and things can be added and deleted just with a regular array but in in Java itself uh a an array is a fixed size which works for the population which always has a fixed size but the mating pool itself has to have a flexibly sized array list but otherwise everything is essentially the same and you can see here I have setup where I'm creating a population object and draw where these functions are being called natural selection generate calculate Fitness um and various things like displaying the info by drawing text of what's going on on the screen itself so uh look for the links in this video's description for also the Java code and if you have questions about that please let me know thanks