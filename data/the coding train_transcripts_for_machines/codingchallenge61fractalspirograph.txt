hello welcome to a coding challenge fractal spirograph day today here on the coding Train choo Cho all that sort of stuff so what you're about to watch is really awkward and a little bit odd it's going to have some awkward edits in it I had several long stretches where I got sort of stuck on a debugging problem if you're interested in that longer debugging process you can go and click on there's a there'll be a link in this video's description to the long almost like 2 hour at this point live stream where I uh did this challenge but what you'll see here is that I do have an end result that closely matches this particular image on this blog so the blog is Benise equation blogspot.com um is uh thank you to CJ Chen um the Creator I believe of this blog proposing and describing some of these images so this coding challenge is going to start twice because I'm doing this intro and then it's going to actually happen where I'm going to introduce it again because I think that I don't need this intro and then at the end it's actually going to end twice cuz I I'm going to finish and then realize and come back and add a few bits to make this more closely match the images on this particular blog so I hope you make something creative with this I I really hope this this uh has some put something out into the world that's useful because boy did I spent a long time trying to make this video with a lot of problems and please share it with me um shiffman on Twitter uh hash coding train wreck hello welcome to a coding challenge in this coding challenge I am going to attempt to make something that is called a fractal spirograph perhaps or fractal roulette or sort of like an orbital thing or a pattern thing so this was requested it's uh in my rainbow topics repository and it I I I'm still trying to figure out um why it's sometimes called the Benise equation and also how to pronounce that so perhaps uh it's called that because somebody who keeps a Blog uh maybe their name is benice and I really should just research this but I'm going to rely on the YouTube audience here to correct me and fill me in in the in the uh comments so you can see here that there's this idea of nested circles uh orbiting each other and um then you the smallest one sort of like the last nesting of the circle tracing out a pattern and you get this kind of nice beautiful uh fractally thing um and so you can see here's a bunch of varieties of it oh I really like this one maybe we can try to do this one so I'm gonna try to make one of these and see if we can get it to work and you will hopefully then adjust the code think of your own ways of making the pattern of of using Color your own design and creativity I'm going to do this in processing now uh processing if you're not familiar with it you know I'll try not to say this in every video I make but it is a Java based platform uh with a uh robust drawing library and a a development environment so I'm going to be able to just write code with Java syntax call a lot of draw drawing functions and see the results of my program in a quick sketching prototyping way now another thing I want to mention is this is quite similar and let me come over to the Whiteboard here this is quite similar to a coding challenge I did a while back called solar system you guys yes thank you thank you very much thank you did you hear that or am I just doing weird stuff people started cheering in the hallway I'm not sure why uh okay so uh in the solar system coding challenge I created a system that had a circle and each circle had some number of other circles orbiting around it and those had other circles orb orbiting around it and I used to do this functions like translate and rotate and these function calls were nested so I would from the center of one Circle translate out and then rotate by some angle and then I would translate out again and rotate by some angle so that I could have nested circles orbiting each other which is very similar to and so the idea of this is like the sun and this is a planet and this is the moon that sort of thing this is quite similar to what you're seeing in this orbital fractal thinggy um but I think what I want to attempt to do in this challenge for no other reason just to see a different way of doing it is to uh actually use some trigonometry math so if I know the radius of this circle and I want to have another Circle right outside of it and I know its radius then I can figure out where this circle should be positioned based on based on Polar coordinates and this is something that I've used again and again and again in various coding challenges where I say okay I have it I have a a twodimensional space with an XY coordinate and then I can also think of that XY coordinate as a distance from the center R and an angle so uh x equals radius time cosine of that angle y = radius * s of that angle and this is a formula for converting from a polar coordinate to a cartisian coordinate that I've used again and again and I will once again Link in this video's description to a uh video that covers the this formula in more detail so let's start uh trying to program this let's start in a very basic way what do I need I need a circle in the center so I'm I'm going to make a global variable which might not be necessary called R but let's just make it Global just to just to see later how we're going to use it and let's make that radius uh 100 let's start with a radius of 100 so I'm going to set a background color of 51 because that's my favorite background color and um I am going to then say uh no stroke no no no I'm going to say stroke of 255 no fill so I want to have an outline of circle with no interior and then I'm going to use the ellipse function which draws a circle at uh 300 300 with r * 2 as the width uh and R * 2 as the height and if I do this I have have my for first Circle so some things that I might do just to make it easier for you to see on the live stream or however you're watching this uh is just increase the stroke weight a little bit so I have a little bit of a thicker circle now I want to position a circle right outside of it and maybe I want its radius to be half the size so let's work out the math for this so what I need to do is I also need an X and A Y so that's going to be the center of the first Circle and I think I'm going to need to do this in an object oriented way soon enough why I really didn't plan this out at all so this is going to be at X and Y so now I want another Circle I'm going to say uh and and let me not make these Global variables actually I'm just going to sort of figure out a static version of this just to get started uh then I'm going to say uh Ral R * 0.5 so R divides by two so so I'm going to have a a uh I'm going to say uh R2 for the second Circle uh I'm definitely going to need to do some object oriented way of nesting these but I'm just doing it this way for right now just to get the basic idea so now what I need to do is say uh X2 = X + r + R2 and then I can say ellipse X2 y R2 * 2 R2 * 2 and now we can see I have two circles I just wanted to see the basic idea there of putting two next to each other why does this work here's a circle at XY and here is a circle at X2 comma y this is R1 and this is R2 so you can see X2 is offset by X by R1 + R2 now of course things are going to change quite a bit once I start this to rotate let's see if we can just make just this rotate around how do I do that so really the the answer here is what I really need is an X2 and a Y2 and really what our what I what I the distance is oh boy these are terrible variable names I'm going to clean this up in such a nice way so soon we've really got to get to it so let's say r r oh my god let's make this R1 X1 y1 just for the let's just at least make this make some amount of sense for a second uh X2 Y2 and what I want to do is I want to say uh R sum equals R1 + R2 and then X2 equal R sumtimes cosine of some angle and y 2 = R Su * s of some angle right what I want is is to rotate this around so I want to do this formula but this R is actually the sum of R1 and R2 so now what I'm going to do is uh uh do this and I'm going to say the angle is zero so I'm going to start with an angle of zero and now whoa that is way off way off what mistake did I make okay let's look at this R2 is half of R1 R sum is R1 + x two is R so it's right but it needs to be offset by the where it originally was so this is just the offset from the center of R1 so X2 really equals X1 plus this X y1 plus this there we go so now the circle's in the right place now let's make this angle a global variable and let's say angle plus equals 0.1 and we can see there we go so we now have the circle rotating around so this is the core mechanic I used I could have done this in a much simpler I don't know if it's simpler is the right word but with less code and less math I could have just used translate and rotate and achieve the same effect see my other video about how to do that but one of the reasons why I wanted to do it this way is I have full control like I can now uh draw a path so I'm going to just add something to this I'm going to say array list P Vector uh path so what am I doing here I'm using a data structure that's a Java data structure called an array list it's like a flexibly sized array and I'm going to fill it with P Vector objects P Vector objects are twodimensional or threedimensional vectors an X and a y and x y and a z so what I want to do in setup then is I'm going to say path equals new array list filled with P vectors and then what I want to do is every time I rotate this I want to say uh path. add a new P Vector at X2 Y2 so as this thing is going I'm going to store all the points to keep track of a path and then at the end here I can say uh for every single position in the path so this is a nice Java enhanced for each Loop for every P Vector pause in path I want to say a set a Vertex at pause dox and pause doy and I'm going to say begin shape and end shape to make this one continuous path and now we can see this so whoops we can see that it's tracing its path so we've got the core idea down from the Benise equation the orbital fractal which is that we need to have some way of positioning a circle outside of another Circle rotating and then then uh keep track of the points of its path and uh draw something okay so we're good now we've got a serious problem here this is not sustainable right I could maybe do some kind of like weird for Loop here and kind of just keep building on the previous one but I I don't I don't that's a problem so what I want to do is um is this really going work well we're going to give it a try what I'm I might have some angle issues but what I'm going to do is I what I need is to make this into an object so let's take a look at what I mean by that so I need an object to keep track of what I need an object to keep track of a a circle that has so each circle let's call it an I get yeah a cir let's call it an orbit I don't know I don't know what it should be called I'll call it a circle cuz I'm confused uh it needs to have an x a y and an r and then it would have like a child so we can think of these as parent child relationships this is the parent of this circle and if this one has one going around it this is the child of this one and if this one has a little one so as this one so that's what we can think of now it also probably needs um it needs to know it probably needs to know have a reference to its parent so that it can pull its parents radius and then it also needs to have some type of uh orbit speed so I think I could call each of these an orbit an orbit has its current XY it has its own radius and it might have a child it might have a parent right the first one has no parent the last one has no child so I think this is a structure of each object that we can build I think this is going to work I'm sure you guys can think of better ways to do this okay so I'm going to make make a new tab here in processing and I'm going to name that tab orbit and I'm going to write a class to create an orbit and I'm going to say each orbit has what and I could use a p Vector to describe its position but I'm going to be a little bit I'm just going to use an X and A Y here so it needs an X and A Y it needs a radius that's its own radius and it needs what it needs a parent its parent is another instance of an orbit and it maybe has a child um you know I could call it's like parent the it's sun and it's ch the child it's moon but let's just use I think parent and child will be easier for me to remember and then what else did I say uh orbit speed okay so uh it needs I'm just going to call it um speed oh and guess what it also needs an angle right needs to keep track of that angle um so angle and angular velocity is really what we've got here okay so all of these things are all the properties this object needs so when I make an orbit I can maybe get now this is like a a kind of annoying convention that I follow but the arguments to a Constructor in Java are uh variables that are kind of like tempor they I mean these are arguments to the Constructor but I'm going to use them just as temporary variables to fill the um to fill the the actual instance variables of the object itself so I kind of just name them with an underscore to mark them as different but I realize this often looks kind of uh cryptic or confusing but let's do this and then uh if I'm making one I could assign I would assign myself as a parent so parent equals P so let's think about how so something like this might work like I'm going to make an orbit is going to have an X and A Y it's going to have an R radius and it's going to have apparent orbit thing so I'm going to comment all this out because we might need it again later but what's interesting about this is I don't actually need an array of all the orbit objects I could make one but each orbit object is simply going to keep track of the next one so to iterate through them I can just go to one which points to the next with point to the next and this is actually somewhat by accident a data structure called a linked list so we're we're kind of programming a bit of a linked list here um because each orbit is linked in like a list format so I'm going to say orbit and I could call it root like it's the core but I'm going to call it sun I'm going to call it sun and I'm going to say sun is a new orbit and it is it has a X and A Y which is the middle it has a radius which is 100 and what else did I say it needs it needs a parent and this one has no parent so I'm going to say null now I could do something here's an interesting technique in Java I could actually overload The Constructor um and actually let's do this just so you see this you can actually write for an object multiple Constructors in JavaScript you would just have one and you would you would query the amount of arguments but I'm going to uh do it this way I'm going to write another Constructor that does not have the fourth option and I'm going to say this which means call the call a different Constructor with x y r and null so meaning if you ever create an orbit without the fourth argument it just does the other Constructor and sends it null there's not really a major point of me doing this but I don't want to have a parent for the original one so now one thing I definitely want is I want some sort of display function which these days I'm uh calling show and what I want to do in the show function is say stroke 255 stroke weight 2 and then ellipse at The X and Y with r * 2 R * 2 so now if I here if in draw I just say sun. show if I run this again we should see there it is now how come I guess I forgot no fill so sun. show there it is okay I don't know how long have you been watching this video and all I've got is a circle on the screen I'm very very sorry but it I'm hoping this will get more interesting soon okay so now what we need to do is we probably want to say how do we add a child maybe what we should do is say a sun let's just write a function to it sun. add child I'm just gonna write a function called sun. ADD child I mean I'm gonna write a function called ad child so I need to write ADD child what does ADD child do okay so first of all uh it has a child so I'm gonna I'm gonna set child explicitly to null here I'm going to set angle to zero and uh angle speed to 0.1 just to give those some values so adding a child means I don't want it to be null anymore I want to say child equals new uh orbit now I need to give it an X and a y a radius and a parent okay so the X and the Y so first of all I should say uh new radius equals R * .5 so I'm just divide it by half I there's probably some appropriate ratios I'm supposed to use but I'll just try uh dividing it by half by two uh um so I want the new orbit now I need to get those X and Y points so a new X X should equal x plus r plus new new radius right because I just want to offset it by its own X Plus its own radius plus the new radius and New Y will just be the same so I want to create a new orbit at X new X New Y and I want a new X New Y with new R I'm just going to call it new r just to for a little bit more shorthand and then its parent is this so I'm having the function itself I'm having the object itself create its own child and it's going to pass a reference to itself to the child so that the child then keeps track of the parent good okay so now let's see what's happening here so now what if I say uh what if I say orbit current equals Sun why I'm going to have to sort of type this out so what I want to do is I want to write a loop I want to say show all the orbits so start with the sun draw it look at the sun's child draw it look at the son's child child draw it and when eventually one of the CH children has no child then stop so as long as current is not equal to no say current. show and then I'm going to say current equals sun. child so this is now an algorithm I have look at this for saying look at the Cur start with one this is iterating through all of them it's kind of like I probably should do something like um you know write a function that returns it called Next or something but just for Simplicity I'm just going to say the current equals its child so start with current equal to son it's not null so show it then get the child is it null it's not then show it then get the child and this should say not sun. child current. child right because I'm really in a way I I maybe I'll call this next while next is not null go to the next child something like that doesn't matter if they call it current or next or whatever the point is it's a variable that's iterating through all of the things so let's see what we get now awesome we've got the son and his child now what if I had this actually also return the child so in addition to creating it and assigning it it returns a reference to it because then what I could do is I could say uh uh orbit child equals sun. ADD child now this is terrible but I could then say orbit Child 2 equals child 1. ADD child something like that right so this is this idea of like I could have the son create a child and then the child of the sun create a child etc etc so I probably want to write a loop there but you can see now I've got a bunch of them this is pretty good this is looking pretty good okay so why don't we do this why don't we write a why don't we do this a certain number of times three times and I think we can employ the same sort of idea where we can say and and this needs to be an integer where we can say uh orbit next equals Sun so uh next equals next. ADD child right so this is a little Loop to start with one and then add a child get its reference back do it again do it again do it again so this should give me oh right cuz I started with the sun then I added three children so you can say I was like why do I have four I have four because I did it three times but I started with one and we could even see here you know this should probably be a parameter but if I made them much smaller like 0. 2 uh well that's a bad idea let's just leave it at 0 five so this is good so you can obviously play with this okay now interestingly enough I just want to show you something really quickly what if I just change this to a minus look what I got there so that's interesting to see a little quick variation right instead of offsetting it out by the sum of the radi what if I offset It Out by one radius minus the other that's going to give me a circle inside so that's something that you might a little variation that you might play with okay now what happens if we want these things to rotate is this just going to work uh what if I write in the orbit uh okay so I need to write a update function update uh function so first what what did I do back here I kind of figured out this algorithm here let's grab this algorithm so our sum in this case is now the sum of my own radius plus my parents radius then my the X should update to be the parents X plus the sum time cosine of the angle right and y so this is updating should be the parents y plus the sum Time s of the angle so this is me updating its position every frame right I want to look at the I want to offset my location based on the parents XY um um plus a uh whatever my rotation is and the sum of the two radi so that should update everything and then in addition to that I want to say angle plus equals angle speed or what did I call that uh just speed so I always want to increment the angle I have a feeling there's a mistake here so that should update so let me just run this no syntax errors I think I'm missing some pieces but let's let's throw caution to the wind and as we iterate through them all let's also update them okay what's wrong here ah okay I've got a null pointer exception why because I don't want to update it if it has no parent so I'm trying to well yeah the the parent never moves never spins so it's really only for the Sun so I'm trying to you know where I put the um you know one thing I could do there's a bunch of ways I could solve this but probably a good way to do this is just to say if parent does not equal null I just do this right now just to make sure it's not a null parent then I'm going to actually do this okay interesting now why why is it doing that I have a feeling it's doing that because they're all spinning at the same exact speed let's see if I uh let's see if I can create another I'm going to create another argument here float s for Speed and I'm going to say speed equals s and actually before I even do that let's just give them a random speed let's just try a random speed between uh between 0.01 and .1 and forget about this for a second so let's give them a random speed H whoops speed is a signed twice uh so I need to get rid of this and like leave these random speeds let's run this again and see so you can see now we're seeing some like slightly different offsets from each other now there's probably an exact science to this and they all also there's a bit of an issue where they're all have the same uh they all have the same angle rotation I am looking at the YouTube chat right now speed reset to 0.1 um so I think I want to look at the original uh the original version of this again let's pull that up and let's see if we can kind of uncover what the relationship is between so first of all are they this one is moving so they're moving in opposite that one's moving this this one is moving counterclockwise and the other one is moving clockwise so this would be something to do so let's actually think about that so I have a kind of idea let's just actually leave them with the same so first of all let me add another uh let's let's minimize this let me add another argument here uh and um what I'm going to do is just give the first one 0.1 so I'm going to uh well I I'll there's so many different ways I could do this but let's let's try to be a little somewhat consistent about it let's add a fourth argument for Speed right here okay so let's make sure that works and then speed equals s now they should all have exactly whoops and here I should pass in oh speed so now they all have the same exact speed and that's a little bit fast I want I think it'll be easier to sort of figure this out if we watch it a little bit more slowly so let's uh let's start with just kind of like 0.4 oops 0.04 or something okay that's a little bit easier to look at okay now let's just try a simple idea of when I make the child the child should have the negative speed of the parent same speed but opposite direction now this looks more like something the question is is this exactly the path that is is and you can see this is this exactly the path yeah speed is actually angular velocity someone in the YouTube chat writes which is a good point it seem and I'm also getting it seems that speed is I minus 2 times the parent speed so maybe it actually is faster but um but in the opposite direction so let's try that yeah this looks so but I've started with it too fast um so let's try it as much slower yeah this looks good so I feel like this looks much more like what the original uh program had so now did the original one also have a total of four circles let's see let's look back at that original example and I can't see zero one it also looks like they' they're shrinking more by like a third I can't exactly tell you know exactly but it looks like there's four and it looks like maybe they're shrinking by a third so let's um let's div divide it by three and see so this looks much more like what happened there and I think we can also start the original one at 200 uh I guess that's a little bit off this window so let's try 150 there we go so now I think we've gotten kind of exactly what's in that thing let's try tracing the path okay um so all we need to do is we need to to uh we need to to have a reference to the last one so what's the best way for us to reference the last one when this is done next is null unfortunately so I think um I think what I'll do is just for Simplicity is I'll just keep track of a global variable called end and at the end end equals next so the very last child is the end and then I can actually just go back and add this back this path stuff exactly back in and uh I can say um n.x and N doy so this should now be that path and let's make the path I don't know pink or something or purple let's make it um just so we can see it and let's um let's also make the uh orbits let's make them maybe a little bit lighter give them a little Alpha and let's see what we get well that's certainly something let me make the stroke weight a little bit more visible here and we can now see how it's tracing that path it's kind of nice doesn't look like that fractal pattern at all I'm seeing in the chat um that I'm being suggested to multiply it by 3 so maybe I just had that off3 let's try that there we go so this looks more like that pattern uh and second Circle has five times the speed and last has 20 times four so I think the how those speeds are changing is actually it you know we can see what kind of patterns that's times four I think they're actually uh almost exponentially increasing okay there was an awkward edit there but there was a bunch of debugging that that happened that I was trying to get this right by just eyeballing it and actually uh the chat nicely pointed out to me that the formula is just in the comments lower down in the page so I'm going to go back down here and look at the formula which is right here and it says uh okay so speed of speed is equal to k a constant to the N minus one power and N being um the level so the first circle is zero the next one is one so n must be the level and then also something that is important here is I also need to use 10 or 11 circles where I am in my code I actually only have uh three or four because the first one is zero so um what I want to do is go and look how am I getting the speed so I'm multiplying the speed by 2 I think I tried a bunch of different things so maybe where I last left off it might have been four we can see multip like increasing the speed gives me kind of more interesting patterns but really what I want is is not what I want to do is rather than have the speed be this thing that changes I want each orbit to keep track of its level so ultimately what I want to do is just send in the number zero the sun is zero so I'm going to add a variable called n to keep track of its level and instead of s I'm going to pass in n and and I'm going to set n equal to that level then speed is going to be something that I calculate based on the formula so if I go back and look at the formula it is K now I don't fully understand this but K I believe is usually uh a constant so I think maybe I can just sort of like pick one of these so I am going to uh arbitrarily pick uh K of two and then I'm going to say speed equals power K to the N minus one is that is that correct K to the N minus one yes and then when I create the next orbit I just send in n + one so the next one is the next level the next one is the next level let's just take a look at this really briefly and why is this giving me oh this should be an integer I'm using integers for the level and same thing here not this really matters that much so now oh something is way off ah okay here's an issue these values are very large and that's my so one thing I could do is just maybe think of them as angles and convert them to radians and now we've got something that more now there's a couple problems with this first of all I'm getting a pretty interesting shape even just from this one thing that I need to do is I need them to alternate their Direction so the nice thing about setting something to the power of an integer is that if it's to if it's a negative number to the power of two squared it'll be positive to the power of three negative to the power of four positive so I can actually just say k equals 2 and now they're going to go in opposite directions and you can see this kind of looks remarkably like what I started with but let's try having this K be something larger and we can start to see now that this resembles much more closely to the pattern that we saw in this original um this original image now I'm not getting so much detail here and I think the way that I'm going to get more detail is by actually having many many more levels there's only three let's add 10 and now we can see now I'm still my incrementation steps are kind of large from that conversion to radians so there's probably a way for me to have the time steps be smaller so I can get more detail out of here cuz you know this would be interesting to try adding a hundred of these and it can't even I don't know maybe it's let's just try adding 20 but my incrementation steps are so large that I'm not getting that level of detail so we've we've we've got something that kind of um that kind of resembles it um I I suppose if I wanted to really trace it out um I could uh have the incrementation steps be much smaller maybe I could just divide by a thousand but add like a 100 it's going so so slow so I'm going to have to speed this up and timelapse it I'm going to leave that to you as a challenge so the challenge that you should do and um uh maybe I'll come back and revisit this in a future challenge let me get this back to a state where we get something is to take this basic idea and more closely match the level of detail in these images and also think about how can you adjust where how the circles are positioned relative to each other to change to get these different kinds of patterns and I would read through this entire page and uh and see look at some of these kind of amazing crazy patterns and see what you can get see how you can color it see what you can do and these are uh I'm loving this I just want to let's try one more thing let's at least try the thing where we Nest the circles inside of themselves rather than outside whoops that didn't work uh sum where's my sum that's what I'm looking for here uh uh yes so let me say minus here with the sum and now we can see this particular pattern that's very similar but now sort of more inside of this particular uh Circle okay so um thank you for watching this coding challenge I have no idea if this was interesting or useful at all I feel like there were some nuggets at the beginning if you've made it to the end of this hasht trre coding train wreck I think is the new appropriate hashtag for this channel uh you can tweet Me @ shiffman # coding trre with your nonrain W beautiful visualizations that you've made from this uh benice benice biche I don't know how to pronounce it uh somebody will tell me I'm sure in the comments uh equation uh orbital fractals thank you for watching okay I'm back for like the 10,000th time for a quick addendum this train wreck is not finished of some nice I got some wonderful nice comments in the chat and I would like to improve uh I think it's worth taking an extra minute of your time to improve my particular drawing uh to match more closely what's going on here so first of all the first thing and I'm sure everybody who want this is bothering a lot of you I know which is that I didn't actually line everything up with the top and you'll notice that if we look at mine it lines up perfectly to the right at the zero angle so I just want to go rotate piun / 2 a 90° so first thing I can do is just very quickly fix the angle to be Pi / 2 and in this case now we at least have the pattern pointing up now one of the reasons why we don't have the same level of detail that's here is that I my incrementation amount is quite large so as it moves the rotation is is happening fast and I want to see this play out in real time but if you'll notice this is this has a kind of like stuttery I mean it's a it's a gif so there's probably some some issues with how that s but this has a kind this is actually probably each time it moves it's kind of drawn a whole lot of points so I can emulate that so I'm going to make a global variable which I'm going to call um I'm going to call resolution and I'm going to set that resolution right now to uh one to one so what I want to do is here what I want to do is look at the speed and I want to divide the speed by resolution meaning I how many how how many incremental steps do I want to take in between each each angular change of that angular velocity so maybe I just want each time step is like a full unit of one so I want to divide by resolution there and then what I need to do here is each frame each cycle through draw I want to do this same updating the path n amount of times that resolution amount of times so I'm going to write a for Loop here to do this n amount of times so there's a little bit of an issue here where I'm drawing the I'm going to be drawing the circle multiple times but I want to get all those incremental path points n amount of times now resolution amount of times I shouldn't use n because that's being used somewhere else now if I run this this is exactly what I had before now I could if I wanted take this out I I kind of did this all at once CU I practic this a minute ago when I was debugging um so uh but even if I just change that resolution now to something like 10 what you're going to get is you're going to see this giving us a finer level of detail but it's going to be running more slowly because the whole animation is doing kind of 10 steps so one way I can kind of clean that up is I can do 10 steps each cycle through draw to keep that same speed the one thing you'll notice is those circles look much brighter because they've been layered on top of each other a bunch of times I mean one thing I could actually do is just not bother to draw the circles and we could just see the path and there it is and I probably should also you know stop it from redrawing when it gets around a full rotation so you can see it's it's kind of drawing over itself but you can see this has much more like the quality of what's in the original image and you know just to sort of see you know if I make the resolution 100 does this really give us anything better I'm not sure but you can kind of see now I've got even more levels of detail so the number of levels of C nested circles and that resolution you know it would be I think a great thing to try making this very high you know blowing this up and making this a large pixel area and trying to really see how detailed can you make that and and make it kind of like a high resolution image version of this okay so um thank you for watching this uh coding challenge um I think there's a lot of exciting creative possibilities that you could build off of it if you able to follow this I will post in the GitHub repository I will post both a processing version of this and a P5 GS version of this that you can run in the browser and I look forward to seeing what you make thanks for watching