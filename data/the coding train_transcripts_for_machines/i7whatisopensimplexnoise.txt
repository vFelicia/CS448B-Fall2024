Hello! Now, this video has been a long time coming, because let me tell you something I've been living in the past. I've been living in 1983 my whole life, I mean, I didn't live in 1983 for ten years of my life, then I actually lived in 1983, and then the years went on, but since then, or at least for the recent times in those making those coding training videos about Perlin Noise, I was living in 1983, '83 all on, and I sort of knew that but I never really bothered to look into it, I didn't want to know, I didn't want to know about what's happening since 1983. (laughs) I, am going to update my life, right now, and your life too, 'til the year 2001, and actually more like the year 2014 and all they way to the present, because today, I'm going to unpack what it means, to the best of my ability, what is what is the difference between the original Perlin Noise implementation of 1983, something that came out in 2001, which is an updated version of Perlin Noise called Simplex Noise by Ken Perlin himself, and some opensource implementations that have been made more recently, notably by Kurt Spencer called Open Simplex Noise. So, (chuckles) a lot of stuff to cover here, this video will be approximately 71 hours and 32 minutes long, I hope you enjoy it. 1983, the original Perlin noise, a type of what's known as gradient noise, was developed by Ken Perlin in 1983, um, Ken Perlin won an Academy award for this work. It is the the algorithm that Ken Perlin invented in 1983 forms the basis for the source code, the implementation that's in processing itself and all these videos I've made about Perlin noise. Where I first learned about, uh, how the Perlin noise algorithm actually worked was from an article written by Hugo Alias. This page is no longer on the internet, but you can find it through web.archive.org. This is a wonderful introduction, noise functions, talks about, uh, random sampling, interpolation, amplitude and frequency, octaves, and looks at this kind of gradientsmoothing process that happens to create Perlin noise and explains why you get these sortof patterns. How all this stuff works there's actually even imputation. So. But I am not going to go through this today. Um, I will point you to the idea of gradient noise. This is a key idea, because the idea of Perlin noise is to smooth gradients, in perhaps what well let's say we'll consider here twodimensional space, to smooth gradients within a twodimensional space. Squares on a grid, this is how we usually think of a 2D space. The reason why I'm highlighting this is because this idea of how this space is oriented, the geometry of this space is the key distinction between classic, (chuckles) what I like to call, classic Perlin noise and Simplex noise. Alright, so we'll come back to that. Next stop on my, uh, Wikipedia Tour, (laughs) is the page for Simplex noise. So Simplex noise is an algorithm for constructing ndimensional noise. It's comparable to Perlin noise created by Ken Perlin himself. But the key element here is fewer directional artifacts. So what do I mean by directional artifacts? Maybe you've noticed this in some of the videos that I've done before. Let me pull up this processing sketch. Look at this. Does it feel like it has this this is um, two I'm visualizing twodimensional noise using a thirddimension of noise as slices of animation. Do you feel this, like, kind of bouncing, like it's kind of like, herkyjerky? Classic Perlin noise is kind of herkyjerky, it kind of gets to a point where it stops, it bounces. That, the sort of visual quality of a directional artifact. It doesn't feel smoothly continuous over long periods of time. And so this is really the innovation of Simplex noise. Now the innovation has to do with, um, Symplectic geometry, which is really, and this is actually in an article that I'll refer to, but a Simplex grid looks like this. So the core innovation is the idea that instead of smoothing the noise, calculating these gradients over a square grid, a rectangular grid, a tiled system of equilateral triangles, and there's lots of variations of this. And this also generalizes to multiple dimensions, and Symplectic Symb (laughs) I can't say that word, but Symplectic geometry, which maybe even will be at topic for another day. I do want to highlight the work of Stefan Gustavson, um, who is, uh, a computer graphics researcher. In particular, uh, the page of documents on Simplex noise, and this PDF, which I'll scroll all the way back to the top called Simplex Noise Demystified. So, I've read this (stifled laugh) on the subway home last night, and on the subway to work this morning, (chuckles) um, and, so I have some picture in my mind of how this works, I probably need to read it about 73 times more, but um, this will give you much more background into the difference between classic noise, which there's a nice, uh, and you can see here, this idea of these gradients, and Simp Simplex noise, and how the tiling system works in multiple dimensions. So I encourage you to check that out. Now one of the oddities about Simplex noise is that there's a patent for it. This, if I'm correct, is the patent. Patent US6867776B2. Inventor Kenneth Perlin. You can download the PDF. Uh, this was filed in 2001, at the time of the invention of Simplex noise. Um, and there's, uh (stutters) This is an apparatus for generation an image. The apparatus includes a computer. The apparatus includes a display connected to the computer, upon which images from the computer appear I will stop doing a dramatic reading of this patent. And so, to me, I'm not a lawyer, I'm not an expert in this, but it's unclear to me what it would mean to use these sort of like, literal version of the Simplex noise algorithm, which is described in great detail here, in the patent, in, say, a processing library or processing sketch in an opensource environment. So there is, fortunately, a post that was on Reddit that I found from four years ago, from 'KdotJPG', which is a post about this new version of what's called Open Simplex noise. So this algorithm is very similar, it's highly correlated and relates to the Ken Perlin Simplex noise, but there are some key differences. And this the code for this algorithm is published here, on 'KdotJPG's GitHubGist "OpenSimplexNoise.java" (bell rings) Java! And which means I can use this in process 'cause it's Java, and if you scroll down (laughs) first you can look and be like, "Whoa!" You got to love anything that has a variable named 'SQUISH_CONSTANT_3D' muah! That is a beautiful variable name. Um, but what I want to do is highlight down here. I looked, I looked, I looked, uh, (chuckles) keep going, there's a lot of code, Whoa! There's a lot of code! Oh my God! Scroll, scroll, scroll! Ah! Test, and then here. "This is free, unencumbered software released into the public domain." So, I believe this is something that I can use, and I'm going to use it in the context of this video. Boy, that was a lot of explanation. So, what does this mean? I want to do another video after this one, which is I just find every single piece of code I ever wrote using the classic Perlin noise function, and try do it again with Open Simplex noise. But I'll just do that for one thing right now. Alright, let me go here 'Raw'. Let me do a nice, big 'copy/paste'. I'm going to go to processing because processing this is the sketch, I want to whoops! I want to change this particular sketch from Perlin classic Perlin 1983 noise, the noise function in the processing library; uh, AKA, gradient noise. There is also something called value noise. There's all these fine distinctions between them. But anyway, it's easy to get confused. And somebody will write a nice, succinct comment that I will pin to this page that has this all explained perfectly, I'm sure. Um... Uh, I want to change this to use Open Simplex noise and I want to examine and look at the difference in quality. And by the way, what does it mean? What do I mean when I say 'quality'? So first of all, I'm going to re I'm not going to redo this whole description, but I'm going to go down here and I'm going to say I'm going to read this part "There have been debates over the accuracy "of the implementation of noise in Processing. For clairification, it's an implementation "of 'classic Perlin noise' from 1983, "and not the newer 'simplex noise' method from 2001." So why not I mean, processing, by the way, was invented it started by Casey Reas and Ben Fry as a project in 2001 at the same time why not update the version of Perlin noise that's in the library? So I think you could make a good case for you could make an argument for both cases. But there is a different quality to the values. And there is now, historically, years and years of people making artworks, visual artworks and projects based on the quality of the Perlin noise, the noise function in processing. Just say noise, I'm just going to say noise from now on. (laughs) And if it were to be updated, those projects would suddenly maybe not look the way they were intended, not look as beautiful, not look as compelling, not not be as visually distinctive, because it's not that one is better than the other. I mean, there are reasons why you can say Simplex noise is an improvement, those artifacts, and the smoothness, and the computational complexity, those types those are things that had changed and are updated that are better, in in according to different kinds of metrics, but it would make much more sense to have a separate library that you could use with processing to get Open Simplex noise. I mean, you could make the case and there is GitHub issue/discussion about this. You could make the case that it might make sense to add to processing something called noiseMode, in which case, you could put in here I don't know what the terminology would be (laughs) I would put in '1983'. Put the year No, but you could put in maybe 'gradient', 'Perlin', 'Simplex', 'value'. You could have Worley Noise! In my research, there's look up something called "Worley", WORLEY. I want to really implement that noise. It looks really cool! So that could be something that you could do. I would say, uh, a good test case to see if this makes sense to add the processing API would just be to make it as a library first, where you could pick your different noiseMode; and then if everybody in the world is suddenly using it and it creates so much opportunity and possibilities, maybe then it would make sense to fold to decor. That would, at least, be my point of view. I'm not speaking as an official representative of processing. I'm just telling you my take on this. (chuckles) Alright, now (clears throat) So... Let's see the difference, let's see the difference. This this this this moment, being living in the year 2001, in 2019 has really changed my life. So ah! One other thing because processing is built on top of Java, I can actually I'm going to create a tab, I'm going to call it 'OpenSimplexNoise'. I am going to paste in all that code, and this code, because it is written as a standalone Java class, will work just out of the box, right like this, with no changes in processing. It's really amazing. I could even, if I wanted to, have named the tab, um, 'OpenSimplexNoise.java', and sometimes this is necessary if there's certain features of Java that the processing IED won't understand, but in this case it's not necessary. And I should say again 'thank you' to Etienne Jacob, for showing me this and giving me lots of advice and help. I mention Etienne's work in several videos so far, but, um, okay. So. Now, we're going to change this over. The first thing that I'm going to do is I am going to create an object called 'OpenSimplexNoise', just call it noise. I'm going to say 'noise = new OpenSimplexNoise object', and I'm just going to run this to make sure I'm not getting any errors. I am getting errors. Oh! Weird! (scoffs) Amazingly.. (laughs) I did this yesterday! I swear I did this yesterday just to test, and I didn't have to make any changes; but this is one of those things you can't have static functions in a class inside processing. It has to do with things being internal classes, yada yada yada. So, what I'm going to do let's try renaming this to 'OpenSimplexNoise.java'. I think that will, uh, fix that issue. Great! So, no errors, and maybe that's what I did before and I just didn't notice. It's running now, it's running the current noise algorithm the noise function in processing. Now, we're getting we're getting close. What I'm going to do now is just change this, comment this out; I'm going to put this in and instead, what I'm going to do is I'm now going to say 'noise.eval', so that noise object has an 'eval' function. The 'eval' function takes one val I don't know if that if it's supporting one dimensional noise but we can talk about how you can get that. You just fix the second dimension. But then I give it the arguments for 3D noise xoffset, yoffset, and zoffset; and now using the library's noise function instead of the builtin noise function. Let's run this. I'm going to get errors. Cannot convert from a double to a float, so this is a little bit of funny business that we're stuck with here and this is what I if turning into a processing library, I would clean this up. Processing in its, uh, simplification of Java has basically ignored the existence of the datatype double. Double is a floating point (it's not a floating point I would say) decimal number that has more memory, more accuracy, more digits, than just floating point; and so here what I need to do is do something like, well I need to convertwhich is called casting what comes out of the eval function as a float. And then look at this! Now interestingly, this looks so different! Now there's a couple reasons why this looks different. One, is look at those, look at those! I don't see a single directional artifact in there. Do you see any directional artifacts? There are no discernible directional look at this just, like, flowing, smooth, noisey transition. Okay. Now but it looks kind of weird, and one of the reasons that it looks weird is that the noise functions are generally designed to give you a number between 1 and 1, the mean being 0. Processing simplementations gives you a value between 0 and 1 as a sort of convenience, so this multiplying by 255 this is why we see these vast areas of the color black, because any noise value that's less than 0 gets reduced to black, which is kind of interesting to know. Now, what I can do here and I should really take out the third dimension to demonstrate this but so if I change this to float 'n', and then I say, uh, float bright = map 'n', which goes between 1, 1, to 0, 255, now Whoa! That's not what I meant to happen, but that is cool! Okay, uh, this is actually a really nice but accidental effect. I kind of love that I got this, but I forgot that I had previously multiplied it by 255 here, so that I need to take out. I'm sure the chat is yelling at me about that. There we go. This looks more like what you what we originally started with. It's a different noise algorithm. I'm visualizing it in very literal fashion, in a twodimensional space, um, and there you go. Now, there's lots of ways we could alter the quality of what we're getting. I mean, one thing would be this increment value, is really playing a big role in, um and the zincrement value is playing a big role in the quality of what we're seeing. Like, for example, let me make increment .1 like, suddenly look that's what the noise looks like. Look at that! Ooh, this is really nice! Oh I love this! And then, uh, I could the zincrement, you know, if I made that really fast, then you're just seeing it sort of like, changing really fast, and that that now has a lot more sort of chaotic randomness to it, but ultimately this is a nice addendum. Now, the quality of this has such a sort of like, smoothing, graceful visual quality, even that moving beyond, uh, uh, just this very plain visual representation they're enormous possibilites. And I would refer you to the work let me just refer you to the work of Etienne Jacob, who, uh, makes all these amazing, um, gifloops, uh, using Open Simplex Noise and a variety of techniques all described in his blog post. So now, this thus this ends this video, which I don't think was a coding challenge at all, just explaining a little bit about the background and difference between the different noise algorithms; and I will now do a video where I attempt to loop I will do a coding challenge where I I'm going to do two more things I'm going to do one coding challenge where I attempt to do a twodimensional noise loop using four dimensions (I'll explain what that means in a second), and then I think I also want to do like, a speed video where I just take every single thing I ever made with noise it's not going to be everything, codingchallenges wise, and like change it over to Open Simplex Noise. Alright? See you in those videos! Muah! (bell rings) (upbeat pop music)