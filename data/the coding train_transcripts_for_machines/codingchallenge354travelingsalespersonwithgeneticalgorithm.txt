hello I am here in a coding challenge and this coding challenge is a followup on a previous one where I looked at something called the traveling salesperson problem now I would suggest if you didn't watch those videos they're linked in this video's description go watch those find out what the traveling salesperson problem is but guess quickly just in case you don't what the traveling salesperson problem is is you create a set of points cities in a twodimensional space it could be threedimensional could be fourdimensional but in this case twodimensional and you try to find what is a path that connects every possible city starting from any city ending with any cities that is the shortest path what is the easiest way to visit every single city and get to every single one what's the shortest path or all the cities okay so this particular program which I did the previous coding challenge is looking at every single possibility it even just with one two three four five six seven cities it's taking quite a while to check every possible City it will get there eventually every time at every Buzzle city every possible order but if I just go and change this to like ten you know this is based this is really just never ever I mean it will finish at some point but changes eleven twelve there are 10 factorial possibilities with ten cities 11 cities 1250 15 cities so is there a way we could do better so the strategy I'm going to look at here is using a genetic algorithm so these are the traveling salesperson previous videos that I would recommend you take a look at and if you haven't seen or looked at any of don't know what a genetic algorithm is then I would recommend this particular playlist so this video that I'm making is not on this list right now because but it will be in the future when you are watching it it will be there it's not there now but like it is now but if you're watching it anyone forget it right so uh only thing yes so this is going to go with its playlist so if you don't know what genetic algorithm is I recommend maybe you check out some of these videos first and then come back but I'm just going to start programming this straightaway so this idea of the genetic algorithm is what I want to have is a population so right now I'm checking but I have this idea of an order which is an order through all the cities so I'm just going to use the code I have some previous coding challenge and just start from hopefully this is I'm gonna this is going to work there's a bunch of stuff I'll be able to get rid of but one thing I need is a population so in the population I need a population of many orders so what I'm going to do now is I'm going to create that population so let's let's I'm going to so a couple things I don't need let's get rid of some stuff I don't need this total permutations or count let's just get rid of this stuff I do want to keep track of the best ever I don't think this individual order anymore there's not just one so I have the city's I have the total number of cities let's reduce that to five so we can see if it works or easily and I have a population okay so I need to create the cities first so first I create the cities now what I need to do is I need to create the number of the population so let's just start with ten so population index I equals what so how to do this so one way that I could do this is I could create I'm going to create I'm going to create actually a variable called order right here which is just order index I equals I okay what am i doing okay so the idea is that I have an array that keeps track of all of these vectors that's called cities now what I'm going to do is I'm going to create an array called order and what I want is just to have an order of how we're going to go through all those cities and so I can start with just this right so with their five cities 0 1 2 3 4 now my population the idea of the population is I want to make a whole lot of these and I want them to be random no they can't have zeros right I can only have one number I think it's so how to type so how do I create a whole bunch of random configurations of this well I could start with this regular order and then I could just shuffle around elements a bunch of times to randomize kind of like shuffling a deck of cards so let's do that so this is just the standard order this array is just 0 1 2 3 4 and now population is going to be order slice that slice I'm pretty sure the slice function in JavaScript is a function you can use it if you give it arguments to slice out a part of an array into a new array but what I'm doing here is I just want the whole thing so it essentially makes a copy of that array so if I just did this right if I just said population I equals order dot slice and I said console dot log population let's go to the browser oops and let's run this okay what's not defined there's lots of other stuff that but I can see here that look at this 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 that's what I've got so what I actually want to do a stop go away what I want to do now is I want to shuffle it so how do I shuffle it well let's should I make a separate function shuffle population index I why not so I'm going to create a function and there's probably like be surprised that there's a function that does shuffling maybe not or we could add it using prototype but anyway I'm just going to write my own function so I'm going to go down here to the very bottom I don't need this is something from the previous example that I don't need anymore I'm looking for the swap function where is the swap here it is so what I'm going to make use of this swap function so my shuffle function is going to receive an array why don't we give it like a number shuffle 10 times so like shuffle the deck 10 times so I'm going to say 4 of so this isn't know for VAR i equals 0 I is less than num I plus plus bar so let's use n because what I want to do is I want to pick two elements I want to say pick a random index and you know actually we can use I and then I'll just say this is like index one or index a is a random index into the array and index B is another random index into the array and then all I need to do is say swap array index index a index B so the idea is that I shuffle by saying ten times swap ten spots in the array or a hundred times or a thousand times so now if I were to come back up to the beginning of this program there's all this extra stuff that I don't know what I'm going to do with here so I'm just going to comment it all out what I'm going to do here and I'm going to comment this out too is what now if I look at this when I look at the populations I should see them all shuffled orders okay Oh p5 had problems creating the global function shuffle there's a p5 function called shuffle whoo interesting well first let's see if my shuffle function worked and that's the first one oh it doesn't look like it worked mmm okay so what did I do wrong let's let's just make our own array did I not give it a number oh I forgot to give it a number I have to say shuffle a certain number of times so shuffle a hundred times let's try this again and let's look at it now there we go so you can see these shuffles into random orders so now I have a whole bunch of random orders perfect okay now what do I want to do here first I want to go look up click this shuffle function shuffle p5.js reference because maybe this does what we wanted to do oh yeah array function to shuffle look at that shuffle and array randomizes the order of elements and right implements fist sure engaged shuffle algorithm so this is a much fancier oh and look at this we're on this wonderful this is a beautiful Fischer Yates shuffle this is a great tutorial by Mike Bostock creator of d3 it's a different algorithm for shuffling an array which is maybe it's just different than mine but anyway let's just use it so let's let's get rid of my let's comment out my shuffle function learn and let's just leave the p5 shuffle function and see what happens run this again let's look at what we've got now they're not shuffled why are they not shuffle well I have a feeling that what it does is it makes a new copy of the array so actually what I want to do here is just say shuffle order so I'm using the p5 shuffle function I want to just take that array order shuffle it into a new array and put that in the population perfect and now if we look at this we can see there we go so both are good ways of doing it now I'm at the point where I have an array and I have a population of orders and I've shuffled up next step I want to find the best one in the population okay actually what I want to do is give each one a fitness score okay so I could do some kind of like objectoriented programming here where I create a wrapper object that stores the order and its fitness but for simplicity right now I'm just going to create another array called fitness and so for every element of the population I'm going to put a fitness score in the corresponding spot in that other array so what I'm going to do is now I'm going to loop through the entire population and I'm going to say what is first thing to say what is that distance the distance is and don't I have a calc from my previous example I have this calc distance function which is right here so this calculate distance function already calculates the distance of an array of points in a given order so that's perfect I don't have to add that code again I already have that from the previous coding challenge that's really nice so I'm going to say D equals calc distance cities in the particular order of the population and then I'm going to say Fitness index I equals that distance now that's not exactly right because I would have to do some mapping to the fitness because a smaller distance is a higher fitness but let's just leave that for right now and let's also write we have this idea of the bestever record distance so I'm going to start with the record distance as infinity and while I'm doing that I'm going to say if distance is less than record distance record distance equals at distance and bestever equals population index I that particular order okay great so now I'm going to take out this let's put this all this draw stuff back in to sort of see the best ever oh I'm going to leave the shuffle function with swap function calculus tense and now let's see what happens we run this okay order is not defined sketch that line 46 okay so this is this I don't need I just want to look at the bestever so oh so I could say this should say bestever dot length sorry and this should say bestever dot length look I don't need two of these sorry I'm just going to there's all this extraneous stuff that I don't need I'm going to take all this out so I just want to draw the best one so you can see it's you know it's making however many and drawing the best one now interestingly enough if I were to increase the population size to 100 it's probably just out of 100 possibilities you know what's 5 factorial 5 times 4 is 20 times 3 is 60 times 2 is 120 so there's only actually 120 possibilities in here but if I were to make the number of cities something like 10 and I just have a hundred possibilities you can see got something better than just a random order but this is clearly not the best order okay so one thing I want to do right now just because a good time seeing things starting to get as I already have all this code I'm adding new code I'm going to create a new JavaScript file I'm just going to call it GA for genetic algorithms AF and then I'm going to add a reference to it in my index.html file and what I want to do is I want to take some of the stuff I don't need this next order any more function this should go away that was from the lexical order version calc distance swap these can all stay but I want to I want to have this other JavaScript file where I can start putting functions that are particularly relevant to the genetic algorithm itself there so all I view okay so all I have so far I know I just said it's like I recap this for myself is I create a whole bunch of random orders I try all of them out and I pick the best one so for the genetic algorithm to work what I want to do is after I've done that I want to generate a whole new set of algorithms Beit chart a whole new set of orders based on the orders that did better so one thing that I need to do here is where I am calculating those those distance values and I'm actually going to take all of this here and I'm going to make this in a function I'm going to say a calc fitness calculate fitness so this particular algorithm that goes through and assign the Fitness what I'm actually going to do is I'm going to map the distance you know that is a value between the Fitness is a distance that's a value between what should I do here what would be so this is kind of an interesting thing to think about you know what I'm going to do I'm not going to do that I'm going to invert it so if I have a number if I want to take if I want to make a number that's a high number and make the higher it is the higher it is a lower value the lower it is a higher value I can actually just say 1 divided by D now I could worry that D might be 0 and if I could say 1 divided by D plus 1 that way if D is ever 0 like the 0 being the you know absolute best distance ever you know which is unrealistic obviously because you're never honest all the points ranging or right on top of each other but then everything's going to be 0 but anyway then the fitness would be 1 and everything else would be lower so I'm going to add that in there just as kind of a nice little extra thing and that's the fitness value okay then what I want to do is I actually want to write a function called normalized fitness because for the way that I'm going to pick them what I want to do is I'm going to mention another video that I made recently as I want all those Fitness values not to be just some arbitrary value that's higher or lower but I want them to map to a probability between 0% and 100% and I want all of them to add up to 100% so the way that I do that is I first need to calculate a sum then I need to loop through the entire population again and I need to say sum plus equals fitness index I so I want to get the total fitness and then all I have to do again and by only I can say fitness dot length because that's really the array that I'm working with although Fitness and population are gonna have the same length I'm going to then go through it again and say Fitness index I equals Fitness index I divided by sum so this is the process of normalizing all those Fitness values ok so if I go back to the sketch this is something I'm going to do every frame so now I really have my genetic algorithm the first thing I need to do is calculate fitness then I need to normalize Fitness ok so once we've done that I calculate a fitness I've normalized fitness now it's time to make the next generation and you know I suppose I could draw the best before I make the next generation but I'm not gonna worry about order too much right now right now okay calculate fitness normalized Fitness make the next generation so how do I make the next generation okay let's go back to here and I'm going to write that function next generation so I'm going to make another array I'm going to call it new population and what I want to do is I want to create something like this I want to say for every I want to say for every member of the existing population make a new member of the new population so I want if I have a hundred to start a one of them next generation has 100 the next generation at 100 so just as a little experiment here just to make sure things are working I'm just a new population index I equals population population index i dot splice so what if I just this is like not a genetic algorithm at all this is me just making an exact copy of the previous generation it is the new population and then at the end I can just say hey guess what population equals new population so make a new population that's a copy of the previous population and then have that be the new population so I should be able do this over and over again so I just want to see if this doesn't give me any errors it doesn't give me any errors but this is now this is now running in a loop the thing is I'm never going to have an improvement because my new population is just the same as the previous population so now here's what I want to do here we want to have a genetic algorithm so what I actually want to do is I want to say the new population is pick from the old population and I'm going to say and I'm actually going to say I'm just going to call this bar order equal because I'm going to need to add something called mutation pick one from the new population how do I pick one member of the old population according to its fitness value so things with a higher fitness I want to pick more often the things with a lower fitness I want to pick less often I want to just copy the ones that were good and not copy the ones that weren't so good okay so how do I do that so I've already Norma Matt I've already calculated fitness and normalized it oh I know how so guess what I just made another video about this a particular algorithm for doing that so I'm going to link to that video in this video I'm going to link to that video in this video's description and right now I'm just going to go and grab the code from that so that code is here in this particular sketch that I programmed earlier today called pool selection and I'm going to go and grab this function called pick one okay so I'm going to grab this function and I'm going to bring it over to my gif so what this function does it's a particular algorithm that I go through I'm going to describe it to you briefly if you imagine this as the population and this has a fitness of 70% this has a fitness problem a probability of 20% and this has a fitness map the probability of 10% well I could draw that almost like as a twodimensional space with 70% being a 20% being B and you know I didn't draw that very well to scale 10 percent being C so how can I pick a random number between 0 and 1 and when I ever I picked from 0 to 0.7 I'm going to kind of land within here whenever I pick from 0 to 0.9 I'm gonna land within here and whenever I pick two point nine two point one I'm going to land in here so you can see that 70% of the time I'm gonna land in here and that's what this algorithm is doing and I go through it more detail in the other video but I do have to make some adjustments here because I'm picking one from this population and okay and I think I need two arrays here so lift and probabilities so I need to pick one from the population according to the fitness values so I need to just change this R equals R minus probability index and then return the index value that defines with that list so let's see if this what this does okay and I think I also want to I just want to make a copy of them might be of because I'm going to start messing with them so it's good for me to create a copy of it so get that order and copy so return a slice okay not seeing any errors but again no improvement why is there no improvement well even if I pick better ones more often if they never change whatever the best one is only the best one matter will ever be so this is where I'm going to add a function and I'm going to call it mutate so in next generation I'm now also going to say mutate order so now I need to write up sorry yeah you take oh and also I didn't I also have to actually put it in the population in the new population which I forgot to do so let's make sure things are still working when I do that whoops new population equals order and let's refresh okay ah uncaught error F is not defined G is line 45 hope there's like an extra straight character there okay okay great so it's working same problem now so I need to add mutation what I want to do is add some subtle changes to the ones that I want to take the ones that did really well and just change them a little bit how am I going to do that so I'm going to write a function called mutate and it's going to take an order and what I'm going to do is so now we have to take an ax mutation rate so let's think about this mutation so how do i mutate an order well one way to do it would actually just to be to take two or two random elements and swap them so this order was pretty good 0 1 2 3 4 but maybe 0 4 2 3 1 would be even better so let's try that so what I'm going to do is I'm going to say and I did this already in my shuffle probe I'll do it again index a equals floor random border dot length I'm going to pick index a and index B and then I'm going to say swap order and remember swap is a function that I've our written index a index P so in my mutate function I'm just always going to swap just one let's see how that does okay so I'm not seeing any improvement one thing I realized I probably forgot to do so let's take a look at the sketch is I'm not actually this thing where I check where do I check I need to actually check to see if I've got a new best one where is that did I lose that by accident where I went to find the best one somehow I lost not oh no it's right here oh no it's not okay so what I need to do is we have this record distance so I don't know where that went I have that coated already but what I want to do is I want to look at the distance did I put that in gaj s somewhere oh it's happening and calculates fitness actually so oh sorry hold on hold on a sec hold on a sec I don't like the way that I wrote this I've confused myself so even though I'm doing it in calculate Fitness I feel like this is a problem and so I am going to say a separate function called find best really makes sense to do it there because I don't this is an expensive operation to calculate the distance so I'm going to leave it never mind so in calculate distance it should be finding the best ever and I should get and this should be drawing the best ever so I would think that with mutation let's just make sure it I don't let's make sure this is running yep so this is doing this over and over again and let's uh let's look at let's let's try to debug this I don't know what I've done wrong here let's look at the record distance so it's finding the same record distance over and over and over again you would think that through some swapping so let's take a look it do I even have like a population a new population yes the population has stuff in it let's make sure that what's in it makes sense hold on so it wasn't working because I had put in the mutate function but i i i didn't uncomment it because I wrote the function and uncomment it so let's add that and now let's see and I got some console.log here that I probably want to get rid of or maybe I don't let's try refreshing it and see what happens oh yes so it's getting better over time this is working look at that how wonderful okay yay all right so um now what have I done have I really solved the traveling salesperson problem I don't think so so first of all is this the optimal order looks pretty good it's kind of hard to say like wouldn't it be better maybe to go like from here and then here and then there wouldn't that be less but I know it's hard for me to eyeball it but only way for us to check for sure would be also have the brute force solution going and have a check every possibility which I would love for somebody to contribute to this to add that functionality back in but let's just go to total cities equals 5 and we can see that bear and let's make the population size let's make that a variable let's make that let's just make that 10 right now and so we're I'm going to put that here and so you can see it kind of like finding it over a short period of time let's make this 6 so we can see that this is working for small numbers and even with 10 like oh that's not whoa that's the population size sorry and what I have it at total even with now with ten cities you're going to see like it's doing really really terribly but I only gave it a population of 10 so let's give it a population of 300 and you can see midtech I don't know maybe that's is that a good or no you could clearly see that you could get a much shorter order by going up those three and then across you can't my handles oh there it figured it out so look at this ah maybe there's some optimization here that could be done I don't know so you can see that this is working and I don't even do crossover all I'm doing is you tame swapping some points in ones that did well I didn't even make the disc the fitness function and exponential function so there's a lot of improvements we can make on this what I'm going to do in the next video and then you play through mutation is a little bit awkward what I'm going to do in the next video is see I can improve this so there's a part one it kind of got something going I'm going to try to and I'm going to try and I should really what I would like to do is also draw just the current populations best one down here and should add that in so what I'm going to do in the next video is I'm going to try to add some things to improve this and namely do crossover between two orders which will not be so obvious how to do that I don't think a lot so think about that in between when I hit stop recording and recording okay see you in the next video you