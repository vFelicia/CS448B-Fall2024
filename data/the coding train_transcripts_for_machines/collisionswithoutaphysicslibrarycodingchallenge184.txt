[MUSIC PLAYING] They're not colliding very often. Come on, collide! [THEME MUSIC] Welcome to a Coding Challenge. Today, I am going to look at something that I refer to in my new version of The Nature of Code book, which is coming out on September 3, 2024. The first half of the book is largely dedicated to a stepbystep process of building your own physics engine. There is a part of the book where I stop and look at, what does it mean to use a thirdparty library? There are a variety of reasons why you might want to use a physics library or not use a physics library. But in the book, I make the argument that a key reason to go over and use another physics library is if what you need in your p5.js sketch is rigid body collisions. All right, let me see if I can give you a quick summary of everything in chapters 1 through 5, just to get us up to this point. And of course, you can watch all my other Nature of Code videos, which go through all this stuff in much more detail. All right, I have a p5 canvas. I have a particle in that canvas. That particle presumably has a position. And the particle also has a velocity. The velocity is a vector, an arrow that's providing instructions as to where the next position of the particle should be. So after some amount of time, typically referred to as dt, or delta time, the new position, often written as position prime, equals the current position plus the velocity times delta time. But I make the argument in The Nature of Code book that life is short. We don't need to over complicate things. We have a draw loop in p5. One frame is one cycle through draw. We can also consider that the change in time. So delta time, as a simplification, can just be the value 1, in which case, we're saying the new position equals the current position plus the velocity. Now, there's also this concept of an acceleration, which is additionally a vector that changes velocity. And this forms the basis of the physics engine that I walk slowly through and build and use for a variety of scenarios, including the flocking system in The Nature of Code. There's additional concepts, like the particle might have a mass. It's important to note that these are all vector quantities with an x and y component. But the mass is a scalar. And there's also the concept of forces, forces being some external or internal factor that causes an object with mass to accelerate. Or the force equals mass times acceleration, being Newton's second law of motion. So why are we here? I would like to expand the material in The Nature of Code book to consider the following scenario. Let's say I have particle A, and I have particle B. Particle B is moving this way. Particle A is moving this way. At some point, the two of them will meet. How do I know when these two particles collide? This is called collision detection. This is something I cover in the book and have countless examples in videos over the years, where I determine if two objects are intersecting. That's the easy part. The difficult part is what's known as collision resolution. When these two particles collide, when they're intersecting, how do I solve for their new velocities? So this is a very important moment in your life, where you're going to have to make a decision. Do you want to stick with me and continue watching this video where I am going to look at the math for solving for these new velocities? You could just stop right now. If you read chapter 6, I look at a wonderful library called Matter.js, which does all of the collision math for you resolving, detecting, everything. And in fact, what I'm going to do in this video will not get nearly as far as what Matter.js does, because, for example, what if these two particles aren't circles? What if they're squares or some other arbitrary irregular polygon? This is why these physics libraries exist. There's no reason for me to reinvent the proverbial rigid body collision wheel. I don't know. But I do think it's really interesting to learn about the vector math and see how far we can get just baking it into our own p5 sketch. And I imagine that I've got this Passenger Showcase thing that if you continue watching, follow the code, you might be able to create something wonderful that I can't even imagine right now. And so that's why I'm going to keep going. Here's the sketch I'm going to start with. It's one of my Nature of Code examples. It's got two particles in it. The particle class has all those things I talked about position, velocity, acceleration. The velocity is set randomly. The acceleration is zero. I won't actually be using acceleration in this particular demonstration, but it could come into play into the things that you might build on top of what I'm doing here, in combination with other examples. Each particle has a mass, which is a random value between 1 and 6. And then I am setting the particles' radius to the square root of that mass, because the area of a circle is pi r squared. And then just scaling it up so that I have smaller values, draw bigger circles. The update method has velocity change by acceleration, position change by velocity. And then I quickly cooked up this edges function. So this is actually already a perfectly elastic collision between a circle and a wall. So this is a very similar scenario to what I need to do. I've got collision detection. Does the position along the xaxis reach either edge? And if so, perform collision resolution by inverting the polarity of the x component of the velocity for the horizontal edges and the y well, those are the vertical edges, I guess and the y component of the velocity for the horizontal edges, the top and the bottom. We're finally there. All of that exposition to get to the part that I'm here to talk about in this video. Let's do a little warmup and first just look at collision detection between two circular bodies. The first thing I need to do to determine if those two circles are colliding is look at the distance between the two of them. Once I have that distance, I can compare it to the sum of those two radii. So I've written a Boolean expression here. Distance is less than the sum of radius 1 and radius 2. Let's think about, what does it mean for that distance to be less than the sum of those two radii? Look at this case. If the two circles are overlapping, that distance is going to be less than radius 1 plus radius 2. If the two circles are not overlapping and not intersecting, that distance is going to be much greater than or not much greater than, just simply greater than the sum of radius 2 plus radius 1. Let's add collision detection now to this sketch. Let's I don't know write a function. I mean, not write a function. I will write a function called collide, where I say particleA.collide particleB. And the way I'm thinking about this right now is it would be the same either way. I could say particleB collide particleA or vice versa. That means I need a new function. And the argument in that function I'll call other, referring to the other particle that this particle is checking whether it's colliding with. So what do I need first? Distance. Ah! There's a vector function in p5. I can say this.position.distance other.position. I'm pretty sure that will give me the distance between two vectors. If that distance is less than what? this.r plus other.r. Then, what should we do? Just to know that it's working, let's just console.log something. All right, moment of truth. [CHOOCHOO] I think that works. Yeah, it's working. You can see, whenever those two circles are colliding, the choochoo number goes up and up and up. We've got collision detection. That was the easy part. It's time for the really hard part collision resolution. To talk about collision resolution, I need to introduce some new concepts, concepts that I don't actually get into in The Nature of Code book. Are you glad that you stuck with me so far in this video? I hope so. So I probably said at some point earlier the word "elastic." And I certainly wrote it on the board here. What do I mean by an elastic collision versus an inelastic collision? First, let me talk about the concept of momentum. Momentum is a vector quantity. And it is the product of the mass times the velocity. A massive object with a small velocity has just as much momentum as a small object with a lot of velocity. There is also the concept of kinetic energy. The kinetic energy of an object is 1/2 of the mass times the speed, the scalar magnitude of the velocity squared. The reason why I'm talking about these two concepts is because in an elastic, a perfectly elastic, idealized elastic collision both the total momentum and the total kinetic energy are conserved, meaning let's say I have particles, again, A and B. They have a mass the mass of A, the mass of B as well as the velocity, which I'll just use V for velocity A and velocity B. And remember, the reason I'm doing this is because if I have object A and object B that are colliding and maybe they have these velocities I need to solve for the new velocities velocity A prime, velocity B prime. If this collision is elastic and it conserves the momentum and the kinetic energy of the system, that means that the momentum before collision and after collision are equal. Additionally, in an elastic collision, there is no loss of kinetic energy, meaning the total sum of the kinetic energy before and after the collision must be equal. Conservation of momentum. Conservation of kinetic energy. Now, in an inelastic collision, some kinetic energy would be lost. And that usually manifests itself in the form of heat or sound. This would be quite interesting to model. And if you're interested, if this video goes at all well and anybody actually watches it and enjoys it or makes something with it, or if it works out in any way whatsoever, I would be glad to come back and try to add the concept of inelastic collisions into another example. But right now, I want to solve for these new velocities based on these two equations. I'm not actually going to do that in this video. I'm just going to tell you what the solution is and show you some resources into how it could be derived. So my first stop before recording this video was to review this Wikipedia page for elastic collisions. You can see this nice animated demonstration of atoms in the thermal agitation system that are undergoing essentially perfectly elastic collisions. These same equations that I've covered for you on the whiteboard are here on the page, as well as some animated demonstrations of how this plays out in one dimension. So onedimensional collisions, which I looked at briefly in my Pi Day video, where I calculated the digits of pi with elastic onedimensional collisions based off of the work of 3Blue1Brown. Now what I'm hoping to do is model those same elastic collisions but in two dimensions. And here is a nice visual demonstration that shows you the primary components and aspects of the vectors that you need to solve for that collision resolution. The key element here being the line of impact. The line of impact is a vector or a line that connects the centers of both particles. In this case, it becomes an axis. You can think of it as the horizontal axis of a new coordinate system. So why is this line of impact important? Well, remember, the objects have velocities velocity A and velocity B. Typically speaking, when you take a velocity vector and divide it into its components, you get the x component along the horizontal axis and the y component along the vertical axis. What if you were to unpack and get the components of these vectors according to the line of impact? And that is, in fact, what's necessary for calculating the new velocities. This is very much related to the section in chapter 5 of The Nature of Code book, where I talk about the dot product and the concept of scalar projection. Scrolling down on the Wikipedia page, you'll actually find the result of all of that math, the new velocity for particle 1 or, in my case, I'm calling it A and velocity 2 prime. Now, interestingly enough, the Wikipedia page doesn't have a full derivation of the formula. If you want to learn more, I'm going to point you to two additional resources. This is an article called "2Dimensional Elastic Collisions without Trigonometry." It is from a piece of software from 2009 called Bouncescope from vobarian.com and includes additional explanation on finding the new velocities of two objects after a collision. Coding Train viewer and contributor Dipam, who was very helpful to me in preparing for this video, created a PDF called Elastic Collisions, which goes through onedimensional elastic collisions and the derivation of the new velocities, as well as twodimensional elastic collisions and how to resolve the velocities along the line of impact, as well as covering another key component here, which is the vector that is tangent to that line of impact at the point of impact, the place where those two circles meet. And here, again, are the final formulas, which I don't know how long it took me to get here, but I'm now actually going to implement in the code. OK. I have printed out the formulas here. And I'm going to put them into the code now. I can think about this formula in different components. For example, I want the sum of the masses. Why did I call it mSub? mSum. I also need the line of impact, which is my particle B will be position 2, or x2, in the formula. And I'm considering particle B to be the other. Again, these are somewhat arbitrary decisions. Then I need the velocity difference velocity B minus velocity A. Now, the change in this velocity so I'm going to call this deltaV equals 2 times the other mass divided by the mass sum plus the dot product between vDiff and the line of impact divided by I'm doing this in a kind of a clunky way. Let me change this a little bit. Where did the plus come in? There's no plus. I'm going to do the top, the top of the formula, the numerator, then divided by the denominator. Let's call it the numerator numerator A. I'm just going to call it numerator A, is 2 times the other's mass times the vector velocity difference dot the line of impact. And the denominator A equals mSum times the magnitude I'm going to call that that's the distance. That's the distance. The magnitude of that line of impact is d times d times d. So the change in that velocity I should make a copy of the line of impact and then multiply it by the numerator A divided by the denominator A. And then this.velocity changes by that deltaV. I don't know what's going to happen when they collide. One of them it's kind of working, but only off of one of them. OK, this is good. I think I did my math right there. I'm sure I could write this in a clearer way. Maybe I'll come back to that. Let me just do the other one. So Particle A this. And now for particle B, which is other, it is 2 times this mass. Denominator is the same. So I don't need a separate denominator A or denominator B. This should be deltaVA, deltaVB. deltaVB multiplied by the wait a second. So the polarity changes because for B, I need to take the difference between x1 minus x2 instead of x2 minus x1, which means just multiply this by negative 1. So that should work. And then other.velocity.add deltaVB. OK, are you ready for this? We're about to see my implementation of the formulas works. They're not colliding very often. Come on, collide! Here we go. It's going to happen! There, that looks pretty good. OK, I actually have a mistake here. vDiff needs to be reversed for the other one because it's V1 minus V2. Also, the line of impact should look let me just reverse them here. And then instead of doing that here, that should be fine. Now, somehow it worked before, because it's really just a matter of I somehow got the negative in the right place by accident. But really, if I look at these formulas, I've got V1 minus V2 dot x1 minus x2 for the second particle. So both of those need to be reversed before I compute that dot product. Let's run it again just to make sure. Will they ever collide? I really hope so. Collide again, please. Yes! OK. Looking good. All right. So it worked by accident before. It still works now. Now I'm realizing I could actually simplify this further because ultimately, it's just about the numerator being positive in the top formula for particle 1 and negative in the bottom. So actually, we just have a numerator. Forget about this. And then there is only a numerator. And then the numerator is negative here. And I don't need this second one. So that's simplifying it. Wait. What's going on? Oh, I know what's going on. I'm going to have to fix something. It freaked out! I thought it was working. But what did I get wrong here? I think to make this more clear, let's calculate the line of impact here. And we'll call this I'll just call it impactVector. And then the distance is the magnitude of that impactVector. And that should also save one small calculation and simplify a few things. Oh, what did I get wrong? This is called impactVector. Why is it speeding up like crazy? I've been writing this a lot. I'm encountering two issues. One is, for some reason, sometimes I seem to be manufacturing kinetic energy out of thin air. The balls keep going faster and faster as they collide. They also are getting stuck on each other. This is because and it goes back to that question of the time step there's a certain inaccuracy here of having a large time step of 1. As two particles are approaching each other, when I detect that they collide, they might actually end up looking something like this. They could easily have moved quite a bit into the same space. This is something I can correct for right here. What I need to look at is, what is the difference between that distance and the actual sum of the radii? In a perfect world of perfect elastic collisions, those two values would be equal. I'll call it overlap. Along that line of impact, I need to move each particle half of that difference. So let me make a copy of that vector, set its magnitude to half of the overlap. And then particle A, which is this, should be offset by that direction. And then particle B should also be offset but in the other direction. So I should subtract that vector. And then when I use the distance in the calculation, I should correct it as well to be the sum of the radii. Now that I've added this overlapping correction, let's take a look at the total momentum and total kinetic energy of the system and see if it's being conserved. Let's start with just the kinetic energy. That's a scalar quantity. That will be a little easier to track. Kinetic energy of A is equal to 0.5 times particle A's mass. Let's get speedA to be particle A's speed, the magnitude of its velocity. And speedB. And let's console.log the total kinetic energy kinetic energy A plus kinetic energy B. Now, I don't expect this to be perfect. The large time steps of Euler integration, JavaScript rounding, there's all sorts of reasons why this could go wrong. But let's at least see how close it is to being accurate. So far, the total kinetic energy is not changed, but they haven't collided yet. Oh, boy, it doubled. It halved. It doubled. OK, that's way off. Something must be wrong. Let's go back and look at my formulas. 2. Oh. Oh! When I did this simplification of only one numerator, ah, I forgot that I have to change this can change. This part of the numerator can change to positive to negative. But I need to use mass 1, not mass 2. That was the error. I tried to simplify this code, and I made it worse. We're going to fix this. The numerator is just going to be this. And what I'm going to do is I'm going to say, 2 times other.mass times the numerator. And this one is negative 2 times this.mass times the numerator. Moment of truth. We lost a little kinetic energy, but just a tiny bit. That's a rounding error, maybe. I'm curious about not correcting this distance. I'm just curious to see what that does. Yeah, let's not correct that distance. So correcting that distance felt like it should be something I should do. But apparently, I should not. Look at how beautifully this kinetic energy is being maintained now. Now it's just rounding errors. Why did I think I wanted to do that? I moved them apart. Ah, but I didn't actually I see. I moved them apart, but I didn't actually change the length of the impact vector. And I'm using that here. So if I wanted to correct that distance, I think I might also need to just adjust the impact vector to be that correct length. Let's see if this yeah. So I just needed to be consistent. If I'm going to correct that distance, maybe I should, maybe I shouldn't. Doesn't really matter so much. But I just need to be consistent. So I'm going to do that correction. I'm going to move them apart. And I'm going to consider that impact vector to be slightly elongated if need be. OK, let's have some fun now. Let's put a lot of these particles onto the screen. Comment it out, this kinetic energy calculation. Now I'm going to have an array of particles. Let's try just adding five of them just to start, at random locations. Now they're all on screen and all updating, bouncing off the edges, and drawing themselves. Let me make them a little bit smaller. And let's try making 10 of them. Great. Now let's see if we can get them to collide with each other. So I'm going to do that in a separate loop. So particleA is every single particle in the array. But now when I want to look at the other particles, I'm going to start from particle i plus 1, the idea being that I want every particle to check every other particle. But I don't want particles to check against themselves. And I don't want a particle to recheck against another one later. So if I have 10 particles, zero checks 1, all the way to the end. 1 checks 2, all the way to the end. 2 checks 3, all the way to the end, and so on and so forth. particleB is particles index j. And then I can say particleA.collide particleB. Here we go. I love it already. Let's make a lot more. And there you have it. Coding challenge complete. So I'm curious to see what you might do with this. I don't have any ideas. I'm exhausted from recording this whole video. I'm sure you'll have some. Share them with me in the Passenger Showcase. I do want to say one more thing, though. I'm going to make these particles briefly much, much smaller. And then I am going to add 400 of them into the canvas. Wow. That's amazingly still working. Let's do a thousand of them. This is actually running much faster than I would expect, because I'm able to start j at i plus 1. But technically, it is still an n squared algorithm. And it's going to get quite slow if I were to get up to, let's say, 3,000 particles. So I believe this can run quite fast with 3,000 particles with a particular kind of optimization. This is something that I cover in, guess what, chapter 5 of The Nature of Code, under optimization, and is something that I've explored quite extensively in my Coding Challenge Quadtree video series. So I have I mean, I haven't made it right now, but after I finished recording this, I'm going to make a version of what you're seeing right here that uses a quad tree to optimize those collision checks. I will release that as part of this video. Take a look. If you're interested, I could come back and unpack that further in a live stream or make another video about it. I don't know. What should I do next? Was this helpful? Was this interesting? Are you at least mildly interested in The Nature of Code book now? I hope so. Thanks for watching. And I'll see you next time on The Coding Train. [CHOOCHOO] [MUSIC PLAYING] [BEEPING]