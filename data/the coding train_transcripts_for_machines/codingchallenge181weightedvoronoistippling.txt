This is actually a true story. I slept with this paper Weighted Voronoi Stippling under my pillow with the hope that it would absorb into my mind somehow. [MUSIC PLAYING] It's time for another coding challenge. I am very excited about this one. It is a high degree of difficulty, but if I've made it succeed, you know already. I don't know, but you know because you're watching this, and you're seeing me as a Weighted Voronoi Stipple. There's a lot to unpack here with this topic, and the first thing that I want to tackle is just the concept of a Voronoi diagram. I'll get more to stippling and image processing and all the other kinds of things of the way that we're going to weight the diagram according to the pixels of an image later. The Voronoi diagram, also known as a Voronoi tessellation, was named after the mathematician Georgy Voronoi. It is also linked and related to something called a Delaunay triangulation. So let's look at both of those concepts briefly. Both Delaunay triangles and a Voronoi diagram require a set of seed points. The Delaunay triangulation algorithm will build a mesh of triangles out of that set of seed points. Now, I've made a guess here as to what the proper Delaunay triangulation would be. Yes, this is a collection of triangles made from these seed points, but there are other ways to make these points into triangles. What makes it a Delaunay triangle? What every single triangle has something called a circumcircle associated with it. A circumcircle is a circle that passes through all three vertices of the triangle. The Delaunay triangulation is such that no other points, none of those original seed points, live inside of any of the circumcircles of any of the triangles. So here are two circumcircles that I attempted to draw for this triangle and this triangle, and they aren't containing points from any of the other triangles. But it's reasonable to ask the question as to whether this triangulation would be the proper Delaunay one. I will include a p5.js example along with this video that shows you how to calculate the circumcircle for a triangle, which would lead you to implementing the Delaunay algorithm yourself. But what I'm going to do here is I'm instead going to use a package inside of the d3 library. Yes, I'm using a different JavaScript library than p5.js alone to compute the Delaunay triangulation for me. Let's take a look at how to do that. Then I'll circle back and move towards the Voronoi diagram. Let's make an array of random points and draw them into the canvas. [MUSIC PLAYING] Wonderful. Now, there are several JavaScript libraries for computing the Delaunay triangulation, most notably the Delaunator from Mapbox. That library is what the d3delaunay triangulation package is built on top of. To bring it into my p5.js sketch, I need to just make sure to additionally include the CDN link to the library itself. You might be asking why not just do the whole thing in d3? And that's a very reasonable question to ask. The reason is I don't really know d3. I'm invested in using p5. I'm going to keep with it. But I certainly would love to see ports of this experiment with this same algorithm and idea in other languages and libraries, and I hope that you'll explore that. I'll start with a global variable for the triangles. And in an ideal world, I might be able to say something like this. However and you can see the error pointing me in the direction that I've got to go in d3 has different ways of dealing with vectors and points and arrays of numbers. The easiest way, I think, for me here, would be to write my own function that converts the p5 vector array into something compatible for d3. And I could have worked with something compatible for d3 from the start, but again, I'm just exploring how to mix these libraries together. I'm not necessarily invested right now in writing the most efficient or fast code. [MUSIC PLAYING] What I've done is taken all of the vector objects and converted them into a single array with x, y; x, y; x, y pairs. That is what d3 is expecting. And looking at the documentation, I can see that I can now get a collection of triangles from the Delaunay object. They aren't triangle objects or vectors, so I've got to do my own counting to go through and find each point and pull out the x and y from nested arrays. [MUSIC PLAYING] It's very important that I spell Delaunay consistently and correctly throughout this sketch. [MUSIC PLAYING] Something is wrong. I'm going through the entire array every three spots because a triangle is made up of three points. Let's look at the Delaunay triangles. What? Oof I really need to read the documentation better. The triangle vertex indexes are stored as an array i0, j0, k0. Those indexes are the indexes to the x, y positions inside of a separate points array. This is going to be a really long video. [MUSIC PLAYING] Oh, whoops, my global variable is called points. [MUSIC PLAYING] Aha. After all that, I finally have the Delaunay triangulation, but this is just an appetizer. I'm actually just going to wipe that out of the code. I wanted to just show you how you could get that triangulation, but I'm actually not going to use it because I am instead going to use the associated Voronoi diagram that goes along with this triangulation. Let's create that same collection of seed points again. But instead of the Delaunay triangulation, let's look at the Voronoi diagram. The result of the triangulation is a collection of triangles. The result of a Voronoi diagram is a collection of polygons. And the polygons are defined by looking at every single point inside of this two dimensional space. So I'm going to pick any given point, and I'm going to get a different color marker. Let's take this purple point and ask the question. Which point of all of these seed points is it closest to? And I can eyeball that and see that it's closest to this one. What if I were to draw in purple every single point in this 2D area that's closer to this one than any of the other ones? It's probably going to be and I'm going to get this a little bit wrong. I'm totally making this up. So obviously, I didn't get that exactly right, but this whole area, by my eye, are all of the points that are closest to this one. Maybe this green area are all of the points closest to this one. [MUSIC PLAYING] I will calculate the correct Voronoi diagram and overlay it. We'll see how close I got just to my drawing here. This might remind you of the Worley noise coding challenge where I actually did a noise algorithm where I calculated from every pixel its relationship to a set of random dots. The Voronoi diagram could be computed that way. I could look at every single pixel and iterate the distance over all of the seed points and calculate it that way. That would be a very, very slow, computationally expensive algorithm. Fortunately, there are many faster algorithms for computing the Delaunay triangulation and associated Voronoi diagram. The d3 library built on top of the Delaunator is using a sweep algorithm, and I'll provide some references for you to read about further if you're interested. Now, you might again be wondering, wait, what is the relationship between these two things? Well, if I were to go and put the Delaunay triangulation in and I think this is the correct one. [DING] Where do all of these points come from that are making the Voronoi tessellation? Those points are actually the centers of the circumcircles that are associated with each of those Delaunay triangles. Coming back to the code to calculate the Voronoi diagram, first thing is maybe I'll fix my spelling mistake. I can now call the Voronoi function on that Delaunay object to calculate the diagram. And in order for this to work, the function requires a bounding box to fit all the polygons the cell's in. Now, I can ask the Voronoi object for an array of all of the polygons. And then I can iterate over them and draw them. [MUSIC PLAYING] In looking at the documentation and console logging each polygon array, I can see that the x, y pairs are in separate small arrays. So it's an array of many arrays with just two values in it x, y; x, y; x, y So I need to look at every polygon i and get the x as index zero and the y as index one. And there is both the Delaunay triangles and the Voronoi tessellation. I don't actually want to draw the triangles. So I'm just going to remove that from my code, but don't worry. All of the steps will be included in examples that are linked in the description below. There's quite a bit that you could experiment with just from where I've gotten to so far. You could start moving the dots around. You could think about how are you placing the dots? You could add color and a fill to each one of those cells. I encourage you to experiment with just the Voronoi diagram itself as a material, but I am going in a particular direction the Weighted Voronoi Stippling direction. And the next thing I need to do in order to get there is to look at something called Lloyd's algorithm. This algorithm was first proposed by Stuart Lloyd at Bell Labs in 1957, and it's also known as a relaxation algorithm. And I really love a good relaxation algorithm. Boy, do I need one. Let's imagine I have any particular polygon from my Voronoi diagram. Maybe the seed point was over here. You could imagine there was maybe another cell right next to it. Maybe it looked something like this. The idea of Lloyd's algorithm, the idea of relaxing these cells, is to look for what's called the centroid of each one of these polygons, the center of mass of that polygon. In purple, imagine that that center is over here, and maybe the center of this one is over here. Then, what if you were to interpolate, move, the points towards that center of mass? What would happen then to the Voronoi diagram as those seed points move and you recalculate it? What I need to do then is calculate the centroid for each one of these polygons. Now, this isn't the precise centroid, but a quick and dirty way I can get a new point would be to just take the average of all of the vertices of the polygon. [MUSIC PLAYING] Can I not go through the polygons again? Returns an iterable over the nonempty polygons for each cell with the cell index as the property. Oh, look at this yield. It's a generator. I don't know generators. I'm going to have to learn that, come back, and make a video about generators. Let's try making an array from it. So if I get the generator thingy that's iterable, then make it into a more normal array that I'm used to, then I can probably do this twice. Yes. That was a little bit of a digression, but now you can see the separate red points, which I am calling the centroid. It's not technically the correct centroid, but I just wanted to get something working. Let's now move the points towards the centroid and recompute the Voronoi diagram. So rather than draw the points again oh, let's put them into an array then iterate over all of them, and lerp the original points towards the centroid. Did I call that something different? Seed points. I could go back to calling it points now because I got rid of the Delaunay triangles that I was using a points variable with. I can call points index i lerp. So I can use the vector lerp function which will interpolate between those two points 10% of the way. And then I want then the Voronoi object to be a global variable because I'm going to recompute it every time through draw. So this moves to set up, and then this exact thing that I did at the beginning, I can now do it at the end here after I've moved those points. Look at it. It's relaxing. Let's try 1,000 points, bigger canvas. This is lovely, but it's collapsing onto itself as a black hole. This is because I'm not actually properly calculating the centroid. My centroid, I calculated it as the average of all of these vertices. But to find the proper center, the center of mass, if you will, I need the average position of every single point that's inside of that polygon. Luckily for me, I will turn to a resource that I have used probably thousands of times in however many years I've been doing this, Paul Bourke's website. There is a section written originally in 1988 called calculating the area and centroid of a polygon. And I've got the formula for it right here I do, however, need first to calculate the area before I can calculate the centroid. So let's go ahead and do that. You can see here that I need to iterate through all of the vertices and then calculate, this looks like, the cross product between the vector that describes one vertex, x, y and the next vertex, x, y. So I'm going to need to look at poly index i and poly index i plus one. I'm also going to use the modulo operator so that when I get to the last vertex, I calculate the cross product with the first vertex, index zero. So v zero's x times v one's y minus v one's x times v zero's y. And the last piece is just to divide the area by two. So the area calculation is now here in my loop through every polygon. This could be something you could try in terms of filling each polygon with a color associated with its area, but I'm not going to do that right now. I'm going to move forward and finish off the centroid calculation. So I can see now that to calculate the x component of the centroid, I need to again iterate over all of the vertices. And this cross product appears again here. So let's make a variable called cross and save that cross product. Let's put that centroid vector back in, and what am I adding to it? I'm adding x of i plus x of i plus one. So that's v zero's x plus v one's x times the cross product. And same for the y, just using the y components. And then all I need to do is divide that centroid by six times the area. I put all that math in, and if I did it correctly, the Voronoi diagram will relax to this beautiful state. Let's see. I'm not very relaxed right now. Nope. I've got an error. Oh, well, that's not really an error. It's just telling me not to use that variable name because there's a p5 function. Let's call it cross value. Oh I just forgot to put the centroids in the array. Oh, my goodness. I've never been so relaxed. Let's not draw the Voronoi diagram anymore just to see what happens here. Look at those points relaxing to this beautiful distribution. This is also very reminiscent of my poissondisc coding challenge. This is a nice method for having a random distribution of points where all of the points are evenly spaced. We are ready for the next part of this. So how does this algorithm of Lloyd's relaxation of a Voronoi diagram lead to image stippling? What is stippling? Stippling is a technique applied in printmaking, drawing, painting, and it's the idea of creating an image out of dots. It can be done beautifully by hand with an artist carefully curating and selecting the placement and layout of those dots. A naive algorithm to create a stippling effect with digital dots in a p5 canvas might be to iterate over the pixels of an image and place dots where the pixel of that image meets some threshold. Is it particularly bright or dark? Let's add that algorithm to this sketch. I'm going to add no loop to turn off the relaxation of the dots. So right now, this is just a random collection of dots. I can even make 10,000 of them. I've uploaded this image of Gloria Pickle to the p5 web editor, and my goal is to draw dots where the pixels of this image are darker. [MUSIC PLAYING] I'm getting somewhere. I'm attempting to draw 10,000 random dots, but I'm only including that dot if the underlying pixel of the image has a brightness value less than 100. I can be a bit smarter about the distribution by using probability based on the brightness. So I could pick a random number between zero and 100 and only draw the dot if it's greater than that value. Now you can see that the darker the pixel, the more likely that dot is to appear there. This is a little bit dangerous, but if that point didn't qualify, I could decrement i so that I make sure I do this at least 10,000 times. And on some level, you might be asking, why did you even bother all of that stuff about Delaunay and Voronoi? Look, there's your image stipple, but look at the way the dots are placed. They're all kind of mushed together. There's a lot of randomness we could do a lot better by relaxing those points. Let's put that back in. Interesting thing is happening, that the image, it appears that it's getting blurred. Let's move these points more quickly to their centroids without interpolating at all. Change this value to one. It's going to take some time, but this will actually converge to the points being completely evenly spaced. By reducing it to 1,000 points, you can see this happen rather immediately. So the key is I still want to relax the points to spread them out. However, I want their relaxation to be related to the underlying image itself, and that's the idea of a weighted centroid. In other words, what if the underlying image had a lot of dark pixels over here but light pixels over here? Instead of just calculating the center of mass where every pixel is treated equally, what if the pixels that have darker underlying colors are weighted more strongly? Their mass, essentially, is greater. Maybe that centroid would end up over here, and the relaxation would converge more in this direction towards the darker pixels. Let's see if we can make that happen. This is the algorithm that I have for calculating the centroid, and it's a really nice and fast algorithm. Unfortunately, I'm going to need to do it a different way. There might be some way to add the weights in here, but the way that I'm thinking to do it is actually to iterate through all of the pixels inside each cell, weight them, and calculate the average of all of the x. y positions. That might seem very computationally expensive, so I'll be curious to see how well it performs. And maybe we can think about other ways to optimize that later. To do this, instead of looking at each polygon one at a time, I'm going to look at every pixel of the entire canvas and find out which polygon it belongs to. And guess what? The d3 library will do this for me, and then I can calculate the centroids of each polygon collectively by iterating over all the pixels. I don't know if I explained that right, but let's get started. Let's at least look at all the pixels one at a time. So I need to have an array of centroids that has the same number of polygons. And they should each start with an empty vector. Now I need to look at every pixel. I should mention that I'm sizing my canvas to be the same dimensions as that image of Gloria Pickle. I could get it to work with different dimensions, but it's going to be much easier. I don't to worry about things matching up, and so I can just use the width and height of the canvas in my loop over all the pixels. The index to each pixel in the image is the column plus the row times the width, and then there are four values R, G, B, A for every pixel. So I then need to multiply that by four. [MUSIC PLAYING] Then I can get the red, green, and blue values, get the average of them. That's not really the proper way to get the brightness of a pixel, but it'll do for now. I want the weight to be a value between zero and one. So I want to get 100% weight if the pixel is zero and 0% weight if the pixel brightness is full at 255. Now I need to look up which polygon this pixel belongs to. And this is where I'm going to go back to the Delaunay triangulation because the Delaunay triangles have a find function which will give me that index based on an x, y position. So now I can grab that centroid, and add i times the weight and j times the weight. So I can get the pixel, get the weight, and then look up which centroid it should be paired with and add those values to the x and y. So what would happen if I run this just like this? I used a reserved function value. Let's call this bright. I should see something happen. Oh, I think I forgot to load the pixels. This didn't even run. I'm missing such a critical step. Any time you take the average of a collection of things, you need to divide by the total. So what is the total here? Well, if the weight of every element were one, I would divide by how many elements there are. Here, to get that weighted centroid, that weighted average, I need to divide by the sum of all of the weights. So in addition to a centroids array, I need a weights array. And let's fill that array with zeros. And in addition to the centroids, I need to add that weight to the sum of the weights for that Delaunay index. And then I can look at all of the centroids and divide by the sum of the weights. Wait a second. I think maybe we did it. Wow. Let's add more points. Oh, divide by zero. What if the weight is zero? So we've got to address that. And if the weights were zero, let's just leave the point in its original state. It's so disappointing how slow it is. If only there were a way. Look at this. The Delaunay find function takes the x and y that you're searching for as well as an index. That index is the starting point of the search. Well, guess what? If I had just found where one of the pixels is, and I'm about to check the next pixel, it's pretty likely it would be in the same spot as that pixel I just checked. They're next to each other. So I don't want to start from zero every single time to check all of the cells. And looking in the code, if I were to make the Delaunay index a variable outside of the loop, and then when I look for it, I pass in the previous index that it found. Additionally, let's have that lerp be a little bit higher, and look at that. Gloria Pickle weighted Voronoi stippling. [FANFARE] What is possible now? Let's go back and add the Voronoi tiles in. Let's not draw the points. So that's just yet another visualization of this image. What happens if you start to add color? What happens if you start to think about sizing the dots different sizes? What if you were to apply this to a moving image like a video? What if you use a more abstract underlying pattern, not just an image of a dog or yourself? I don't know. I'm sure you can come up with something creative. This code is a bit of a mess. I'm going to clean it up, comment it, document it. I will take a look at whatever you submit to the passenger showcase in a future live stream. And let's just relax all of our pixels, relax ourselves, and fill the world with beautiful, weighted Voronoi stippling. See you next time. [MUSIC PLAYING]