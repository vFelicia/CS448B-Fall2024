Welcome to another nature of code video. This one is all about mutual attraction and the NBody problem. Now, I don't know how you arrived here. This is a followup to the previous video about gravitational attraction, but I'm actually making it all those two years later. I just watched the end of that video. So I think I know if you're watching this in sequence, what you expect. This is the example from the end of the last video, where every one of these orbiting circles is attracted to. Pink circle in the center. Let's review very quickly that formula for gravitational attraction. So in the case here, we have two bodies. I'm going to call them body one and body two. They each have a mass. That is what is represented by M one M two. In this formula, we can look at the vector that points from one body to the other. We can call that vector are the magnitude of that vector squared is the distance between the two objects squared. And then this here is the unit factor to describe the direction of that gravitational force. So in my code example, this is the pink.in the center. And this is the other circle that is orbiting around that that's being attracted to that pink dot. But if you go back to, hopefully when I talked about Newton's laws and. How forces occur in pairs, the gravitational force that two exerts on one, pulling it towards it. One exerts on two pulling. Towards this. If we have two bodies, like one and two here and there are no other forces in the environment, there's no air resistance. There's no other things. Other bodies, the pure essence of just the gravitational forces that these two bodies exert on each other. And what motion would occur is known as the two bodies. One thing I'd like to mention. If you were about to go and do some research about the two body problem, you would discover that it is a solved problem, that the paths of the motion of these bodies can be computed precisely with mathematical equations, starting with the formula for gravitational attraction and the equations of. To execute. Those solutions requires calculus. And here we are in the nature of code creative coding, fun time landscape, where instead of evaluating this scenario through solving differential equations, I'm using this technique that I've described previously as oiler integration, where we just use large time steps, the frames of our animation, and we add acceleration into the velocity and the velocity into the. If we wanted to investigate some more sophisticated methods for doing performing this kind of integration, we could look at something called leapfrog integration. We could look at Verlin integration. We could look at Runge cutout integration, and I would love to hear from you, if you try to execute a version of whatever I make in this. With one of these styles of integration, does that improve or change the results that you get from whatever examples I make here, please let me know in the comments, but for creating a sort of first pass at the two body problem, then maybe moving to a three body problem and then to an N body problem, I'm going to just stick with my simplistic method known as Euler. The other nice thing about what we're doing here is I'm foreshadowing. Some things that are come later in the nature of code in particular, in the autonomous agents chapter. Because one of the things I want to look at are scenarios like flocking simulations, where every agent moving around a system interacts with every other agent. That's what we are beginning to do here. But with gravitational. But I think I've shown off my outdoor. It's not really outdoor. I'm like slightly inside this garage whiteboard enough. And I could go over and start writing some code to step into at least the two body problem. So in looking at this example, while if I wanted to do a two body simulator, I could reduce it to just two separate variables, mover one mover two. Um, I would like to stick with the array because that's going to help me later. So what I'm going to do is just change the array to having just two elements in it. And I'm also going to get rid of this idea of. Right. There is no distinction. Now in this example that I want to make between mover and attractor. I mean, that's not a real world distinction. That's an artificial thing that I created for this idea of attraction, simulations, and visualizations. So now I'm just going to completely get rid of this idea of an attractor. I'm also going to take out the reference to the attractor JavaScript file. Now, let me go back and get rid of this attractor. And now we have two bodies. Now they are not exerting any force on each other whatsoever. They're just two bodies with an initial random velocity. I'm going to take the exact attract function. I put in the attractor and move it over into the mover. So now the mover has a function by which it can attract. Another mover now because I have only two mover objects. I can write the explicit functions for mover, one to attract to and mover two to attract one of course they're actually zero in one and one in zero because I'm using an array and a raise the index values start. So this is now movers zero attracting mover one. And you kind of saw that. So I think what I'd like to do is just give them very little starting velocity and we can see every time I run this mover, one is attracted to mover zero. Now I have mover one attracting mover. And you can see this little dance that they do with each other. So just to try to understand and see what's going on a bit more, let's add back some trails and let's see if we can give these circles more precise locations. Uh, and with specific initial velocities to see if there's any kind of more expected patterns that we might. So now I have the movers start on opposite, horizontal ends of the canvas. Let's see what happens if I start one mover, maybe moving directly up and the other ones start moving directly down. So I'm going to add two additional arguments to the constructor, which gives me the X and Y components of the velocity. Well, I love this. They're moving quite slowly. So a couple of things I could do is let's give them a higher initial velocity and let's increase the strength of the gravitational force and we get this nice, beautiful, like, sort of like repeating circular. Now again, I'm not solving for the precise equations of motion. I am not using the proper units of measurement that mapped to actual celestial bodies in terms of their distance and mass, the universal gravitational constant. But I do see this a makes a lot of sense in terms of what we are seeing here. I almost don't want to keep going because I want to stop here. And just like play with the parameters and variables as a system ad infinitum, but let's add a third body. Now. I mentioned that the two body problem is a solved problem. The three body problem is not a solved one. We could approximate the motion of three bodies using sophisticated methods of integration. Let's see how close we get. Just with my examples right here. I'm going to add a third body just in the sentence. And I'm going to give it no velocity just for the moment. It's not participating in this at all. Now, what I need to do is I need to say, okay, zero attracts one zero attracts to one, attract zero and two and two attracts 1 0 1. Amazingly the body in the center is not moving because it's attraction forces are perfectly balanced between those two particles on the outside. That's kind of unbelievable. That's really cool. Let's just push it slightly to the left. So, this is not super sustainable. If I want to have four movers, five movers, I can't keep individually assigning which ones attract the other ones, but I can write a loop that handles this. Now I have a loop down here to update and show all the different movers. I want to keep the force calculations in a separate loop, but I need a nested one. This look now it's not behaving the same way and I'll get to why in a second. But this nested loop is doing exactly what this says. Start with movers zero, and have it attract one and two, then go to mover one, have it retract zero two, then. Zero and one, but there is a bit of a problem because every mover attracting every other mover means that the mover will also attract itself because it is another mover in the array. So one way that I could approach this is by just saying, as long as mover is not equal to other, and this is checking if two objects, you can check if they're equal, meaning they're the same data in memory of the computer. That's the same. Then this should now be exactly what it had before only. It's not because I have it twice, so I could delete this now. And we should now be seeing exactly the pattern of motion of these. There's probably a lot of things you could try doing, um, in terms of how you visualize this one idea would be to connect them with lines. So I'm no longer drawing the dots. Only the lines. This doesn't look like much yet, but I have a feeling once the three start to move a bit more chaotically in relation to each other. We'll see what we get here. Curious, just what happens if I do four movers and kind of put them in a, like a bit of a diamond pattern. I don't know what I expected to get, but I'm quite pleased with these interesting results. And I think there's a lot for you to sort of try and continue playing with just out of curiosity. Let me go back to, uh, making the random. So we can see with them random, I'm getting quite an unstable chaotic system, but I think what I'm trying to emphasize here is that by thinking about the initial starting conditions of the system, the results that you get might have some symmetry or sort of character to them that you could take advantage of for a particular kind of. And there it's often running. Hi, sorry. I'm a few days in the future. Finishing up this video. I didn't get a chance to finish it before the other outfit I was wearing. So excuse the awkward transition, but I'm going to look at now what kind of initial positions and velocities could I give an array of mover objects, um, in, uh, an end body simulation. So let's dive right in. And since I'm going to create an array of many, many mover objects, I've switched it back to just drawing them as circles. Here's my P five canvas. I'd like to set up all the mover objects inside of what I might consider a donut. I want to place the mover objects anywhere inside of this shaded area. Now, ultimately. If you happen to skip ahead and watch a bunch of videos in chapter three, you're going to learn all about polar coordinates and various trigger and metric functions that could make doing this in a spiral pattern and all sorts of fun. Possibilities happen for you. But right now I'm going to make use of the vector function, random 2d. What this is going to allow me to do is create a vector that points at any random. Like these five here, then maybe the inner circle here. If I said that was a hundred pixels from the center and the outer circle here was 150 pixels from the center, then I can set those random vectors magnitude. A random length between a hundred and 150 offsetting from the center of the window. Then I have mover objects that are placed randomly around here. Let's try just that first. So instead of setting the X, Y as random numbers individually, let's create a random vector set the magnitude to between 100 and 150. And then I'm going to give the mover that pause X and pause Y position to start. I want to comment out the update function just so I can see. Uh, oh, they all are there. Huh? That doesn't seem right. Oh, I forgot to offset it from the center so I could adjust the X, Y properties of the pause vector itself. But another way I could deal with this is just by adding translate into draw. So now I have five mover objects anywhere inside this donut. If I were to say 500, we could see clearly they're all starting, just like I mapped out on the way. Let's see what happens if I let it just run explosive, total chaos. Let's consider one example mover. It just happens to be placed here with this vector, mark, noting its location. What if I gave it an initial velocity that is perpendicular to this vector? So no matter where it starts, its initial velocity is always sending it in the direction, which would, what would be essentially tangent to this circle. Now I'm starting to use a lot of term. Perpendicular his angle is 90 degrees. It's tangent again, follow into chapter three and all will be revealed. But I think right now, as a quick way of doing this, I can use the rotate function that's embedded in the P five vector class itself. If I take this particular vector and call rotate and give it 90 degrees or PI divided by two races. Then I will have taken a vector that looks like this and turned it into a vector that looks like this. And again, not to be a broken record, if you're wondering about radians and PI, don't worry. The next video is going right into that. But stick with me here. This is going to get us something I think. So here V is the velocity vector. Let me name it V L to be a little bit more. I'm also going to start it as a copy of the position. So now that position vector is copied into velocity before I've resized it. And then after I've resized position, I can take velocity and rotate it by PI divided by two that 90 degrees. And let's see what happens. Ooh. Oh, I named it V E L and I didn't rename it here. Well, we've still got quite a jumbled mess of stuff going on. Let's take out the trails. I think the relative scale of the forces is too high just to get a handle on things. Let me set all of the mass values to a constant. Let me lower the value of G quite a bit. And then let me also give them a higher starting speed. That was kind of cool. Let's make more of them going to lower that force of gravity even more. And this is what I was hoping to see this almost undulating spiraling galaxy like formation. Let's give myself more space, spread those movers a little further out from the center. Give him an even higher initial velocity. Let's try 250. I'm quite enjoying this and let's create a little bit more variation now in the mass and the initial velocity. I wonder how many of these I can draw before it just runs too slow already. A 350. You can see the frame rate is choppy. Now, why is the frame rate choppy? It is not because I am drawing 350 circle. You could see the animation is quite smooth. If I comment out mover dot attract other, it is the fact that I have to check every mover against every other mover. This is an N squared problem. 350 times 350 is 122,500 computational cycles. Let's go back down to 200. And you can see that probably about the limit that I can get just with the way that I've written the code. Now, there are many efficiencies that you could add to a system like this, to be able to increase the number of mover objects that you can draw and the amount of forces that you could call. Probably the most wellknown technique for optimizing an inbody simulation. Like this is the Barnes Haute simulation. I've covered something quite close to this in a previous coding challenge, where I looked at something called a quad tree. So you could go back and look at the quad tree coding challenge and bring the quadri code into this example. In fact, I will make sure to do that and include a quad tree Barnes hut version of this end body simulation linked from the video subscription. So right now, I don't know what I'm going to show you here, but here you're seeing the results. One thing I'm curious to try is what happens if I bring back somewhat artificially this idea of an attractor, a stationary object that's maybe with a larger mass positioned right in the center of the candidate. So I'll make a variable called sun. Sun will be a new mover at zero zero with a velocity of zero, zero, and a massive 100. Let me say sun.show. There, there it is right there, but now I want the sun to attract every mover. It's hard for me to tell if something really different is going on here, but I do feel that the system itself is not kind of wandering off, but also you can see that the power of that object in the center is somewhat overwhelming. What if I gave it a really huge man? And I don't even need to draw it just out of curiosity. If I lower the gravitational forces quite a bit, this is kind of interesting to see what I get. Let me go back and add some more trailers. And here it is my end. Body's sort of galaxy like simulation thing. It's very hard to stop tweaking all the parameters, but I'm going to settle on this as kind of the example that I'm going to release. I reduced it down to 10 and I can strain the ranges of masses and velocities to just create this a stable system. A wonderful reference that it would encourage you to take a look at is the paper classification of symmetry groups for planar and body choreographies by James and Katrina speckles in the paper, they demonstrate a set of initial conditions for end body systems that create these symmetrical and stable choreographies. There's also a beautiful interactive demonstration of these choreographies that was created by Dan grease that you can play around. Figure eight, super eight. I can change the speed. I can hide the trajectories. I could really do this all day. So my proposal to you, my exercise for the viewer, if you're interested is take a look at that paper. Take a look at this. What kinds of initial conditions can you create in the system that I've set up and how might you visualize those simulations with color, with trails, with shapes? So many possibilities. I should mention that this particular interactive simulation, these paths are drawn with precise mathematical equations, not with a physics simulation like I'm doing here. And ultimately my physics simulation, as I talked about earlier in the video is a very crude one with these large time steps. So this wraps up chapter two of nature of code. Maybe I'll come back and explore some of these ideas further. Let me know in the comments, if there's particular things that I propose or talked about here, that you. I see in a video, but now it's really up to you. Do you want to go on to chapter three? I hope so. There's lots of fun stuff in there. All sorts of things about angular, motion rotation, polar coordinates, pendulums Springs have fun with that and I will see you next time on the Coding Train.