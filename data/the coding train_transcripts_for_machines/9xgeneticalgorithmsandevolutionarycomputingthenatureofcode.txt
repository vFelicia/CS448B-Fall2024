okay so I'm going to talk about genetic algorithms and I first encountered genetic algorithms with um by watching this video this is from 94 um I'm going to uh play a little bit of it for you um this is a project called I'm going to just turn the sound off although um this is a project called evolved virtual creatures actually the nice thing if you I encourage you to Google this and watch it it's Carl Sims evolved virtual creatures and um the the the audio soundtrack is kind of nice because it's like a National Geographic style uh video but it's all computer generated uh creatures so what Carl Sims did with this project is create essentially this physics framework for making these creatures they're all these node based creatures so all these creatures are essentially if I were to diagram them they're kind of you can think of them as particles with spring Connections in a way so they're boxes um and these spring connections are muscles and they can expand and contract and so car Sims was able to encode the design for these creatures into a virtual DNA and then say hey let me stick them all into this physics world and see how they do the ones that run really fast jump really high swim really well there's a water simulation in a little bit those are the ones that I will pick as parents quote unquote to make a strange virtual creature baby um for the next generation and they'll get the better that they do the more likely they are to reproduce and he evolved these creatures to to perform different tasks and so looking at this I was looking at this at a time where I was super fascinated with just even just trying to model kind of basic physics um and so I wanted to see if I could make something like this yeah this is this is the running sequence um this is the jumping sequence skip ahead a little bit this is following a red dot while swimming um and what's really amazing about this is it's very unexpected like you would never design a creature to look like that or do like that but this one is very very good at kind of swimming around in this water environment and um and at the end here there's this like hockey like competition where all these different creatures try to compete for this green Cube so I and so he would he would build these algorithms and then like kind of set them up in this like physics 3D environment and then have to like churn out frame by frame what would happen right so you know I don't know that's a good question I don't know the exact process that he used because in theory you don't need to watch the simulation in order to find out the result he might have just like but we're watching the res we're watching certain creatures that were evolved and then seeing them play out but it's all just data it's all just numbers and that's kind of what I wanted to get to into a description for how this worked and it's like funny they have all these weird gestures but there's a great um all of this is linked um on the nature of code website there's a further reading section and there's a paper by Sims which outlines how all this works and the design of these creatures um this one's a cruel one that likes to beat up on it um so that I'm I'm really not doing Justice to the soundtrack is really quite nice but you can watch that on your own time um okay so what I wanted to start with is kind of talking through okay so the thing about genetic algorithms is I for the book I kind of divided my thinking into three um different categories let me just erase this um which um uh you know there is this genetic algorithms were developed for solving certain kinds of computer science problems search problems where a brute force method is no good so if you need to check every possibility it would take too long maybe we could evolve towards the right answer and then there there's this category called interactive selection which is really used in art and design and I'm going to show you some examples of that and then this idea of thinking of um ecosystem simulation so what I wanted to talk about first is the um now it looks like I have a prepared presentation but these are just images from the book but um so I wanted to talk about the infinite monkey theorem which is kind kind of a classic classic test case uh classic example of an application of genetic algorithm so the infinite monkey theorem if you're not familiar with it is this idea that oh if we had an infinite number of monkeys and an infinite number of time and they're all just randomly typing at these keyboards typ typewriters typewriters maybe keyboards iPads I don't know um that eventually they would type the complete works of shakespare and so this is theoretically true I suppose I believe to be true yes it is theoretic true but the the problem is it's not something we could ever understand or or experience in our lifetime and just to like make this argument for a second so let's say we have just the phrase to be or not to be that is the question that phrase is 39 characters long so let's say we have a simplified keyboard it only has 26 characters and one spacebar so just to type a t there's a one in 27 chance of typing a t right now if you know anything about probability event probability if we have if we want the probability of two events happening in sequence we multiply the probabilities together so the chance of typing to is one 1 out of 27 * 1 out of 27 so the whole phrase 1 over 27 to the 39th power is a one in that big number a chance of that occurring randomly so that's a very large number which is kind of hard to even fathom but that's not even for the complete works of Shakespeare that's just for to be or not to be the question so and I I I worked it out a little bit with that if um there's a similar discussion by the way on Wikipedia if you go to infinite monkey theorem which kind of goes through um uh the same sort of stuff but if you if you were able to have a computer simulation that could do 1 million random phrases per second it would take that many years for there to be I don't think I put this up here for there would be a 99% probability that you would have at least gotten to be or not to be that is the question somewhere in there so if that's much longer than the entire much much much longer than the uh age of the entire universe I think like on Wikipedia when I was reading it the the other day it said something like if you had a monkey for every atom in the entire universe it would still take you know anyway just way too long that we can't possibly understand so the point this is a stupid problem right because we could just type to be or not to be the question that is the question if we needed it but it it illustrates the point that there are some problems for which you don't know the answer like we know the answer here some problems that you don't know the answer for which uh it still it would take that long by brute force method so a genetic algorithm is a way of saying okay what if we had a population of phrases so let's just say to simplify for a second we're trying to evolve the phrase cat and we had a population of phrases like bad car I don't know hog it's very hard to think of I was going to say p as a threeletter word I don't know um I can only think of like weird uncomfortable word anyway the bunch of uh hat hat is good what what paa you're good P what paa paa thank you there you go um okay so a bunch of of of of phrases what we could do is evaluate these so the way the genetic algorithm works and I think I have you know I like to sort of write this out but I'll just use these um there's this this very specific algorithm and I'm using by the way the word setup and draw are some are things that are very specific to processing this algorithm Works where there is kind of this moment of begin like the big bang happens and there's this initial population that's seated and then there's something that happens over and over again a new generation is born evaluated a new generation is born so the very first thing that okay so one of the things I should mention is that um if you look at darwinian Natural Selection by the way I don't really know anything about biology and evolution so I you know and that's the nice thing about doing this stuff in like Pro you know computer programming you and just like make it up and be I'm like Inspire it's like it's like the TV shows where they say inspired by actual events that's what this is um it's not fired by actual science yeah fired by actual science so there's heredity uh selection and I would like to write first uh variation so if you think about darwinian um Evolution these are three key principles that need to be present for evolution to happen one thing is that we need to have variation so we would never be able to get to be or not to be if we just had you know one phrase to start with and all we could ever do is combine and recombine that one phrase we'd only ever have that one phrase if we only ever had bad we could never get to cat but if we have a random um if we seed our initial population that's the first thing we do with a random um set of elements then uh we have variation and we have the chance to evolve towards some optimal solution so to speak so um the one of the other principles that we need is this idea of selection so selection often referred to as survival of the fittest we have this idea nature that you know the most fit the strongest the thing that can run the fastest will you know make the most children but really what it is if you think about it is just survival of the survivors anything that lives longer for any reason whatsoever is more likely to reproduce so for but but you know that's nature and here what we actually unfortunately need to do in this particular computer simulation is we need to uh calculate uh Fitness so this is a mathematical formula that we're going to apply to these members of this population we're going to say we're going to evaluate their Fitness and this is how we perform perform selection once we've evaluated the fitness of all these elements we can pick the ones that should be selected to be parents so for example um what you know a really simple Fitness function for these would be count the number of letter characters they got correct b a d one c a r 2 got two h o g zero hat is also two p is zero so you can see oh wow this worked out really well by the way by accident so it's not just a character choice but it's position yes so you know this is an open interesting question in other scenarios the actual data could matter and and could be but this the this the this having an a the way the algorithm is going to work having an A in the first character would do us no good we're not shifting them around that that that that is a sort of discreet Chunk in that particular order so now we have this question of um what we're going to do what we need to do is make the the whole goal of this is to make the Next Generation so what is the next generation of I don't know what to call these creatures it's kind of silly to call these phrases phrases so the members of our population are phrases what is the next Generation we have to figure out a way to pick them now there's a lot of different strategies for performing selection in this type of simulation we could just say I don't care pick the best ones car and hat you make all the babies so car and hat just reproduce and make all the all the the the the the all the members of the Next Generation we could do something where we take the top half there are different strategies a a common sort of what a common strategy which I think in many ways is the best is a probabilistic approach so what we could do is assign the fitness values to be probabilities and we could say unfortunately P has a 0% chance uh hat has a 40% chance 0% chance uh 40% chance oh no sorry TW yes oh uh 40% 20% chance and if we add all those up we get 100% yes good job okay so you can see how I'm mapping these scores to probability and um typically speaking you're not really going to have Fitness values that are this simple which you're having just Z one and two so you're going to have a much more of a range of probabilities and this is really key because in a longer phrase we don't want we want to keep it's possible that this this one let's say Okay bad here even though it only got one right it could have a gem in there that isn't anywhere else in the population and we want even though it should be less likely than car or hat to be picked it still should be possible that it should get picked and I think kind of jumping around here but uh here so this is kind of an illustration of that you can think of it as all of the parents being this roulette wheel or this Wheel of Fortune with a where you spin it and what we're going to do is now over and over again in our genetic algorithm to make the Next Generation we're going to spin it twice pick two parents and we're going to make a child element from those and if we go back to the uh this algorithm it says the the so the next thing is reproduction so this so variation we got from initializing the population selection we get from this sort of awkward thing that I described of evaluating all the members of the population giving them a score then assigning those scores to probabilities and that's how we pick the next members now we need to reproduce and this is where the third principle of evolution comes in which is heredity we need a mechanism for passing the genetic information down to the Next Generation this may seem obvious to you and this the point of this example is that it's simple enough that hopefully this can seem somewhat intuitive and obvious but if you had to combine um hat and car you know we could look at this and say aha take the C from here take the a from here put those together and we have cat we're done but again we're not taking a top down approach here what we're doing is two things one is called crossover and one is called mutation and I think one of these diagrams uh yeah one of these diagrams just demonstrates this idea of crossover so crossover one um so if you if you've done any programming um you know something called an array an array is a list of information and usually most in my examples at least the DNA is encoded into an array of information an array of characters array of floating points an array I mean a true genetic algorithm be all just zeros and ones and that's all it ever is because it's you know much cooler that way or whatever but um but here we could say um what we're doing is we're picking half half of one and half of the other we could alternate we could sort of flip a coin for each gene so to speak for each element of the array heads pick from the left Tails pick from the right we could pick a random midpoint there's a lot of other options but that's the first step so the idea is to intermingle the genes of the parents into a new generation correct exactly and now we get this next we get a new we get we get this and and in theory we're picking parents that have performed well and by recombining their genetic information we're going to get a child that will perform equally well or hopefully by by by luck a little bit better um and so um but we want to add one more step here and this is kind of important because even though we got variation in the first step by making this random population we might not have enough variation right if we only have a population of 50 elements and we need to evolve to be or not to be there might NE there might not have been one with t as the first character and with crossover if there's no t as the first character we'll never ever get to be or not to be but but what mutation allows us to do is say at any point there is a small probability that after crossover one of the genes so to speak one of the elements of the array of the data would just randomly change so here we could say you can see here in this diagram we we got f r y and uh we change it to Foxy I guess um we you know um so we we we sort of flip a coin again and and mo typically a mutation rate would be something like a small probability 1% 2% somewhere around there so we say there's a 1% chance of of just changing one of those elements randomly and that introduces just additional variation into the system um does anybody want to ask any questions uh okay let's see here so okay so let's I'm going to come back to this but let's just look at I'm going to run this example now um so if I go into uh my chapter 9 examples there is one example called G Shakespeare and I'm just going to run it and this is currently running basically this simulation that we talked about in processing so you can see on the right on the right left right on the right I'm going to do it this way um all uh stage right stage right yes all all of the current phrases in the population there's 150 they don't all fit into the window um it it after 764 we started with 150 random phrases there's a mutation rate of 1% and um after 764 Generations one of them happened to be the exactly right to be or not to be um so um some things that I would just want to kind of quickly demonstrate here is that again the point of this example is not that this this doesn't have any value right I could I could solve this problem in one line of code print to be or not to be that is the question right the point of this is if we want to sort of learn about genetic algorithm understand how they work we need a kind of example where the answer is unbelievably obvious so that's what we're kind of demonstrating here the other thing I just show you is that there's various variables that we can kind of play with um here for example if I were to suddenly just make the population 1,500 instead of 150 we got to to be or not to be in 38 Generations because we just have so much variety to work with so the other thing that we that I could um that I wanted to demonstrate here is if I make the mutation rate zero and the population only 150 this isn't enough variation for example we can see here there clearly was no second character ever that was an O there was no fourth character that was a b so we're just sort of stuck in to key a b or whatever but um so this idea of mutation is really important but of course um if we had 1500 elements again that's probably enough variety and boom we got it right there so it's kind of it's it's sort of you can play with some of these variables total population Nation that's a typo somebody do a pull pull request to fix that um there was something else I wanted to show here yeah okay so one of the other things I think is use important to see like even if I make the mutation rate 10% Like That is introducing so much Randomness into the system it's too much Randomness um you could think about it's likely that we're going to be randomly changing a character almost in every new member of the population so and to illustrate the point of that we need a lot of lifetimes of the universe if I made the utation rate 100% right this is this is the brute force method we're sitting here doing you know essentially 150 time 30 per per second uh random phrases and we're I mean there could be some kind of like amazing moment here where we actually got it but and then we realize then we should I'm going to go buy some lottery tickets if that happens okay um in this case what it's doing is it's just thrashing it with the whole phrase and if it doesn't get the whole phrase then it just moves off well right now it's actually running through the genetic algorithm but we've essentially negated the gentic algorithm because at the very last step we said I don't care what evolution you did I'm randomly mutating everything so it's as if we're just newly picking random elements every time so I you know I think there's I mean I'm sure there are lots of applications to this to solving different kinds of you know standard computer science problems data related problems the direction that I went in with um with the examples in the book is really in the animation and simulation Direction so I want to talk through a few um elements oh there's an eraser here I was using um I want to talk through a few elements um talk through a few other examples and then I think we can you can answer some questions and wrap up or whatever um so one thing that I kind of glossed over here is again uh I I don't know anything about actual science um there is something if you read about this kind of stuff called a genotype and and a phenotype and one thing this is a really important distinction that's actually sort of secretly happening behind the scenes here genotype we can think of as the data itself right the actual raw encoding the the bits the DNA itself phenotype is the expression of that data and um in this particular example this distinction is blurred there is no distinction here because the data is the phrase cat the expression of that is oh the phrase cat but when you actually go to use a genetic algorithm in a more of a real world scenario if you think of that Carl Sims um video that I showed the data might have been this kind of network diagram U data structure the expression was this kind of visual physics simulation we need to be able to have a mapping towards how are we what is our system is it something visual is it something is it behavioral and how do we encode that into data and this is you know in many ways if you look at these examples and you want to do a project with them you can just copy paste the code verbatim the the two things there probably three I'll think of more the things that you really have to think about are the fitness function you know what is that you know a a good Fitness function makes a genetic algorithm work well and then what is how are you encoding the data and how are you expressing that data so um there's a project from many years ago by J Thorp called uh smart Rockets I think I have that somewhere here uh okay I'll hit okay and um this is done in Flash I believe it's on the web I'm sure you can just Google smart Rockets jar Thorp and find it it's also referenced in the book but excuse me what's happening here and again this is just a search Problem by the way what's Happening Here is there are these rockets that launch from the bottom and the rockets launch from the bottom and uh they have um each rocket I might botch this slightly has like five thrusters attached to it that thrust in random directions so they're vectors they're forces that can Thrust out in random directions and the DNA the Gen genotype is the sequence of how those thrusters fire the expression is the actual physics stimulation of them moving so if you think about it here those these Rockets their goal is to reach the Target and um their Fitness function in this case is you know how close did they make it to the Target so inversely proportional to the distance the closer they get to the Target the higher the fitness so the ones that do better pass their genetic information to make new rockets for the next generation and if you run this over time you'll see these these Rockets start to evolve this really nice swooping path around that obstacle in the middle and there's some nice Design Elements here you can sort of see this path over time so um this is this is a nice example of kind of taking Genting Al we could say like there's a known solution here which is like I could go you know I don't want to mess up the the the screen I could go and draw a path like we could figure out possibly what's the but here we could imagine this being part of a some type of simulation a game a museum exhibit some interactive experience where the elements are evolving a certain Behavior if you were to move the obstacle around they would they would have to reevolve A New Path I'm going to show you some examples like this in processing so um the second example I have in the book is essentially a simplified so Jar's has a lot of bells and whistles for looking nice and doing um extra features um there I in the in the book I have a very simple I think it's this one that I want to look at um very simple implementation of it it's it's much uglier less interesting to look at um I put that eraser somewhere I he it this um so the thing that I just wanted to mention here is that we're we kind of you have we have this question we have to answer which is that DNA as we saw we think of as this list of information it could be zeros and ones it could be as we saw characters you know I don't know what I'm writing here um in this case one of the things that's interesting about a couple of my examples or I like to think it's interesting at least is that the DNA is vectors so it's uh directions and magnitudes velocity vectors Force vectors so each each one of these Rockets has a kind of sequence of vectors that control its path and they're evolving if you know these take a little while to run but um if we ran it for a while it would evolve sort of this path around around that Target I'm GNA quickly so just to be so like when they they die and then everyone's evaluated yeah okay so I'm kind of meant to get to this but I'll just mention this for now so you may be wondering boy this doesn't seem very natural this is like this absurd way of thinking about Evolution right if we were to map what we've just done here or in the um to be not to be them into the real world it's it's as if we'd be saying okay let's evolve some monkeys let's get 20 monkeys in this room let's have them run around for a while we'll give them hats we'll put a score on them and then we'll tell which monkeys to mate and then they'll have babies and we'll kill all those monkeys and let the next monkeys run around so it the real world is much more fluid there's no scoring it's just so that is the the the that that is I think a sort of important distinction here and um the next uh was going to say the last the last example that I have to show you kind of ask that question of could we do a more fluid simulation where just things that live longer somehow through whatever arbitrary parameters have are more likely to then reproduce so yeah it's a little weird but you're right that's what's happening I'm letting the simulation run it gets to the times out I evaluate them make the Next Generation Um just to just show you one more example um which is basically the same thing but a little more uh interesting just in terms of the technical implementation so this is exactly the same thing just a lot more rockets and I'm visually just showing you the one that's kind of doing the best that generation and there's no obstacles here one thing I want to show you about this in the previous example each object's DNA was a linear list of vectors in this one their DNA what's in their brain is actually a flow field so a flow field is a twodimensional grid of vectors you know those you can't tell whether which is pointing forward or back and what I'm showing you here but so the each one of those triangles is essentially looking at an arrow that sits underneath itself which tells it which way to move and in theory if we ran this for long enough what we would evolve hopefully I think you got it is just a lot of lines that point straight across um and one of the things that I think is kind of interesting to play with with this example is um I can kind of draw obstacles so if I draw a little obstacle here that blocks them and you'll you'll see it engage kind of in the Next Generation and they'll start to evolve a path around it um maybe what I'll do is draw a few obstacles here and then I'll let them I'll let oh it's going to be way too hard I didn't they didn't get very far in the first place but um anyway so you'll see once one gets kind of far it'll start to a few more of them will the next generation will kind of get there there's a lot of Randomness that play here I actually have the mutation rate very high in this particular scenario because I find that this is a difficult enough problem that there needs to be a lot of random fluctuation to get um around these kind of Corners so I'll try to let this run as I continue um to show you some more other things the fitness thing is kind of picking out the best guy until he dies yeah um so like right now he dies and then it picks another one no you know what I'm just uh draw highlighting whichever one is currently the best okay so it it changes over time um you know there were it was that that one for a little while now it's that one um so uh so I'm glad you mention that so so this idea of genotype and phenotype is important the fitness function is also really important um one thing I didn't mention is that our fitness function for to be or not to be that is the question was actually not a very good one just counting how many characters are right isn't very good and I I'll try to explain to you why let's say the target phrase was 8,000 characters long and we had one one member of the population that got 7,000 correct and one that got 7,000 And1 correct if we evaluate these if we turn these two numbers into probabilities the probability of picking one or the other is going to be very very very similar but 7,000 And1 is really a lot better than 7,000 so you'll see in a lot of these examples and I I think I have a like very very basic illustration of this right that in a lot of the examples if you go look at the code in the actual Fitness Formula that um we were mapping the number of characters correct exponentially so whether we Square or the power of this or whatever so that we ex the more characters we get correct the higher the score is exponentially so a linear mapping of number of characters correct to score and the same thing with distance so um that's something that you'll see in a lot of the how you tune that Fitness function can really affect how the system behaves and let's check on these guys because I'm afraid it's going to quit and we'll be very sad oh you know what it's it's running really slow because I'm drawing all those lines in the background which we don't need to do um see how well they're doing good pretty good so uh you'll see they'll make it there eventually I also not giving them very long amount of time to get there it cuts off before so I probably should have um tweaked those variables as well but okay so um yeah and in this case I'm also the other thing I should mention yes you feel like really attached to these little creatures maybe it just matches me um so uh the another thing I wanted to mention here is that one thing I'm also doing is they haven't reached reach the end yet but when they reach the end I keep track of the order of them so who was first who was second who was third and if you were first boy your Fitness is much higher that way they in theory you know they would optimize towards the fastest path as well um okay so so close don't change yeah no I'll let it run we'll come back you guys really want to watch this okay just I'll let it I'll let okay so the last thing I wanted to mention is and for those of you who are doing stuff on the web or web developers um this is this is probably where it might get even more relevant if or possibly I don't know um all of these examples I've shown you so far have taken an algorithmic approach to Fitness it's a mathematical function we're scoring the elements but we could take a different approach which is often known as interactive selection where we say Fitness is userdriven so in other words by that I say hey and so here's I apparently all I can use is Carl Sims as my examples but um Carl Sims has a project an art piece an art installation for many years ago uh uh called galap you can see how old this is by um you know this the state of the art the state of the art okay so this is called Galapagos and there're these monitors in a kind of gallery space there's sensors on the floor and they're showing these images and as anybody stands on one of those sensors it registers a value and what it's doing is it's assigning Fitness based on how long somebody is looking at something so it makes a kind there's a kind of open question here which is that you know what is that really evolving the most beautiful image the thing people are most likely to stand in front of who who knows but it is an interesting um technique for saying Fitness is user generated it's evaluated and the one thing about this is you know in to be or not to be we could do thousands of of generations per second right frames of Animation computer calculations this type of thing is very very slow people have to stand in front of it over long periods of time you know in a in a public space over years maybe you could get some data the place that I think something like this could really work is on the web where you have a distributed way of saying hey world everybody quick assign some fitnesses and we could evolve something maybe anyway um you know it's the SE at home kind of approach of of you know the mass audience kind of helping out a single problem so um and also like these are what the images look like I think they were all like these lisp sequences um anyway so um I wanted to show you just briefly a kind of simple so here is the so inter interactive selection is really interesting I've seen people do it with music with images um I saw a project which was like evolving cell phone rings um ringtones but here I have what might possibly be the lamest example of interactive selection ever but just to demonstrate the point um these are a bunch of designs for faces they have there's a there's data here the data is color size position U width of the mouth and what what this example does is it allows you to say okay um I really like green so I really like this one I'm giving that a much higher score when I evolve the Next Generation you can see you know I did that in a very um I only rated one of them but I could say I like this one a lot and this one a little bit and you can see I'm starting to mix and match there's some mutation in there so again there's nothing particularly exciting visually about this or even that creative in its thinking but it demonstrates the process of creating a visual Based on data and one of the things about this example is that every the DNA this is a kind of a nice technique every element in the in the DNA is just a floating Point number between 0o and one one thing that's nice about that is you can always map a number between 0 one to any range so I could say this is the red value and I map it to 0255 this is the green value 05 this is like the I size I map it from 10 to 20 so you can have this kind of generic DNA where everything's a floating point value and then map that those values to the design of something you know for I would say if you're looking to create a design you know thinking of a node based approach or there you know parameter based approach there's lots of other possibilities there um okay so I think I'm kind of nearing the end of the end of time maybe we have the to be or not to be that's the question by now let's check on uh oh that's is that the same one yeah oh yeah see see kind is not highlighting the guy that right so you know what the problem with that is we don't I don't know which one's going to get there so I could run it secret twice like I could zoom through it figure out which one it is it's funny I actually just added most did made this example most of it this afternoon so I what's what's so cool about this is that the guy that ends up winning is not the winner for a lot for like the first third of it right yeah there's a lot of mess going on here and what's interesting what I don't like what I what's interesting about this is that you know there's really only a small number of vectors that are really at play here all that stuff in the corner like it's not being used it's just it's only just random because anyone going up there is kind of lost and off is not going to be picked so there's it would be nice if what I was hoping visualizing the flow field is that eventually you could really see the flow field the path of the flow field it's kind of happening more mysteriously um but I think there's probably other ways of visualizing this that could be kind of interesting to demonstrate the process and so so each node or each guy has the entire flow field as its DNA that's correct so it's a twodimensional array of vectors in the example so it's crunching a lot of numbers to do this yeah yes yes I think you said earlier that it's um one that gets their first gets higher priority but it's not in direct correlation with how fast it get them no you're right yes so I didn't actually time them and use their time to Fitness which I could have I just quick quickly ordered them and said number one Higher number two yeah so you're right if it's sort of the fitness function is really here just mapped to as if they like all finished in like perfect lock step timing yeah but you could use their time but you absolutely could use their time yes for for c for sure um you know the other thing about this is I'm you know most of these are kind of pure but I'm trying to with these examples not put any top down thinking onto this but you could do certain things like I could have maybe seated the system with all the vectors pointing to the right start and that might have given us at least you know more we might be able sort see that path more clearly without it all being random to start So eventually all of these guys are going to figure out a better path no there's so much mutation that I think at this point it's probably going to look like this forever but I think we'll get we'll get some marginal improvements like there will be some some they'll start to get a little bit faster you're right if I use time that would would really help that's a great idea um yeah because right now it's just getting there first if everybody's really slow you know so yeah um so let me just show you this last example and then we can kind of be finished so um I think I have a a diagram that I'll just kind of use oh here it is um so um I there's the last example I want to show you just demonstrates the idea of a kind of more I'm calling an ecosystem simulation so more like the real world would work so we have these creatures called bloops and they're either big or small or they have a size they have one their DNA is one number a single number it maps to their size and how fast they move so the big ones move very slowly the small ones move very fast and they need to eat food to survive and there's food in the system so if I run this simulation now uh I'll leave all these running I guess sorry ah I can't it's very hard to use your my computer in this strange configuration okay oh here we go um Evolution ecosystem okay so let me run this one hopefully this will work and what's happening here all of these creatures so this is I guess a simulation of asexual reproduction um each creature just clones itself when it has a baby so at any moment in time there is a small probability that it will clone itself so the ones that live long longer just have a longer amount of time to have that happen and one thing you'll notice here if um is that the system tends to evolve towards mediumsized objects so it's not that interesting of a result the big ones are really good at intersecting the food but they move too slowly so they don't really find the food the little ones are move super fast but they're so tiny they don't seem to run into the food that often so medium tends to be about the right um the right the the kind of the perfect size to intersect the food and move about the space and so so the food is getting randomly distributed yeah it starts with a random amount of food and then um I think when they die they leave food so what the only thing that I find the only unexpected result that I've noticed here is sometimes there's a cluster of big ones that just like a lot of them die and there's a lot of food in one area and then there's another big one that just keeps eating it and making new big ones so a little cluster of big ones can kind of survive for a while in one part of the screen um so this is to me what kind of thinking the most basic way I mean there's so many things you could do to a simulation like this to make it more sophisticated for example you could give these creatures some intelligence I have a whole section about steering behaviors so you could allow them to kind of see where the food is choose to seek the food avoid a predator you could also uh add things like they only make a child when they come together for a certain amount of time so um so there's a lot more that you could do with a simulation like this but this just kind of at least demonstrates the idea there's no Fitness function and there's no Generations it's just a system that lives the the circles are moving around they live or die and they reproduce and eventually um I guess I added so many it's kind of still has a lot of variety there but if we run this for a while you you'll tend to see that um it mostly ends up with medium siiz um elements what determines their movement um it's so it's it's I'm using something called pein noise in this example pearlin noise is like a smooth Randomness so there there's no it it's kind of um a quick way to get things look like they're wandering around the screen but um just to now I'm kind of uh jumping around here a little bit but uh if you're interested in this type of ecosystem simulation I would recommend taking a look at um Craig Reynold steering behaviors and I have I'll just show you like here's an example of one this is all um from the chapter six in the book and so this is an example of crowd path following so here are entities that are following a path as well as trying not to run into each other so one thing that I always say as a exercise for uh students in the class is build a system where autonomous agents have a wide variety of steering behaviors and make the weights of those behaviors their DNA so how much they try to follow a path versus avoid a neighbor versus seek food versus run away from a predator see if you can evolve some type of optimal Behavior this the weights for these steering forces are just hardcoded in so they follow the path and um but so combining this kind of intelligence of an autonomous agent with a genetic algorithm is perhaps you know something that could yield some results other questions I think that's I finished with all of the examples with genetic algorithms like where are people taking it right now um you know that's a good question I don't know that I really know the answer to that I mean I think there is kind of a stateoftheart in computer science research um for me I see this kind of work um in in in in um game design a lot with really interesting results so you could think about if you're trying to create autonomous characters in a game that can adapt to the way a player you could certainly use this in like Museum exhibits as well that's sort of more that the space that I see at ITP at least um kind of picking and choosing from the kind of computer science research what's kind of easy to understand and use and apply um vers rather than kind of dig deep into the the depths of the stuff thank you so much great thank you