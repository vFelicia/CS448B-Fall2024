hello and welcome to another coding challenge uh in this coding challenge I am going to look at the reaction diffusion algorithm so I have a version of it running right over there that is a processing sketch that is implemented the reaction diffusion algorithm I'm going to implement it in JavaScript uh do it from scratch in this video and you can see that this allows you to create this interesting kind of Labyrinthian uh uh visual in your canvas now there's a lot of different ways that you can apply colors and get different qualities to the image but I'm going to look at the sort of core classic reaction diffusion algorithm using the gray Scott model I will include some links below to reference Pages the one that I will build the code based on is right here in the browser the Carl Sims a Carl Sims tutorial page um and so the idea here is that I'm going to just sort of look at the drop dead simple classic algorithm black and white pixels only and then hopefully you after watching this and using the code might come up some other creative uses and applications of it so let's try to understand first what this algorithm actually is and so I'm going to close this window out and look at this diagram so the idea of reaction diffusion is kind of like you have your screen and you're about to pour some chemicals into it and those chemicals are going to react and there's going to be a lot of chemical a and then less of chemical B and they're going to react and diffuse and that sort of thing and then based on the how those chemicals are arranged in the screen in this sort of like dish petri dish of your canvas I'm going to we're going to set a color so if there's a lot of chemical a we're going to make the pixel black if there's no chemical a we're going to make the pixel white and kind of everywhere in between so that's the idea here now there are a lot of different um kind of key pieces here and let's just look at this quick diagram here thank you again Carl Sims for providing the diagrams for this video um chemical a so um the way it's going to work is the canvas is going to be filled with chemical B and then we're going to start to pour chemical a into the canvas the reaction aspect is chemical A and B reacting and maybe a is turning into B and the sort of diffusion in this way is that chemical is also going to get kind of like removed uh from it so there are some there are some key constants in the system that are numbers that you're going to see in the code one is the feed rate which is how fast are we pouring in chemical a and then another is called the kill rate I wish there was a nicer name for that but that's what it's called which is how what is the rate that chemical B is being removed so this is the idea now um so and you can see here what we're going to do is each each cell is going to have a certain amount of chemical a and of chemical B and those values are going to have a range between zero and one uh one being a lot of chemical a zero being none and then that amount is going to be used to set the color for a pixel and so you can see here uh how this how this kind of works we're going to do all this in code now how look at this now we have this like terrifyingly scary looking formula but we can tackle this formula I'm going to right here I'm here with you to tackle this complicated looking formula so let's put putting that aside let's kind of make a quick diagram so the way that I'm going to build this in code is I'm going to have a twodimensional array meaning I'm going to have a data structure that's going to keep track of uh each spot in that data structure is going to keep track of an individual cell call that a cell each cell is going to have an amount of chemical a and an amount of chemical B so what I need to do is understand uh if if there moments in time there are Generations This Moment In Time next moment in time so Moment In Time a0 moment in time b0 what I need to understand is how do I get the amount of a for Moment In Time One based on some function of the amount of a and the amount of B at time zero so this is what we're looking at and in fact over here that's what this formula is showing you the new value of a equals all this stuff based on the previous value of a and b and some other constants so this is what we need to do there's a bit more to it than this so you know I could say like oh A1 equals the average of a0 plus b 0 you know divided by two this could be our formula this would be a lot easier to implement so that formula is just like this but a lot more comp complicated so now but there the reason why there's more to it than this is because we have this scenario here of an individual cell we have to apply something called a convolution you're going to see I'm going to show you in a moment it says a convolution of a 3X3 Matrix all this scary sounding stuff so here is a 3X3 Matrix and this is a given cell and what I want to know is what is this cell's new values of A and B based on its previous value of a and b but not just it I need to know also based on its neighbors so these chemicals are reacting and combining in a given also with what are the chemicals next to it so the a convolution means take every single one of these cells and multiply it by some weight so if I were blurring an image for example I could use a blur as a blur meaning the average of a convolu of of a of a 3X3 Matrix of pixels so the new pixel color is going to be an average one nth of this color plus 1 nth of this color plus 1 nth of this color plus 1 nth of this color so I take all of the colors and multiply them by 1 nth add them all together I have the new color but we have a different um convolution here and it's described in in the diffusion uh in the reaction diffusion algorithm so this is the basic idea I need a twodimensional array each spot is going to have a certain amount of a and a certain amount of B I need to have a formula that for each cycle each frame through draw I get a new value of a and a new value of B and then a new value of a and a new value of B and the math formula is going to be something like this but more complicated because it's also going to involve all the neighbors so let's start setting this up now now hopefully this is the basic idea let's start setting it up to program it okay so now I'm back over here uh I am back over here ah oh was I not over there the whole time I think I was over there the whole time hopefully this was right uh somebody in the chat tell me was I in the on the Whiteboard while I was showing that um okay so if I go back to I have this blank uh code here um and uh I'm going to go to my uh canvas here and this is my canvas so the first thing I need to do is create okay I was good the first thing I need to do is create my uh twodimensional array to store all the amount the the amount of chemicals in each spot in the in the grid okay so twodimensional arrays in JavaScript are kind of a funny thing uh not funny haha funny a little bit weird because um arrays in JavaScript there's just so many different ways you can make them but ultimately what a twodimensional array is and let me kind of describe this to you briefly I'm going to make an array called grid and you could imagine like what if I did this um I'm going to write something like this I'm just going to kind of type something out for a second just to explain this this my friends you are my friends indeed is a twodimensional array I I kind of space it out like a grid but really what it is is just an array of arrays to see how it's an array open Square bracket n square bracket and then it's three arrays inside of it but I could but so really a twodimensional array in programming is just an array of arrays so what I need is one array to keep an array for here for here for here for here right so I need the first array to be the first row the second array to be the second row the third array to be the third row that sort of thing but I I'm not going to type it out manually for 3x3 I could type it out manually what I need to do is kind of um is actually make it um uh make it in code okay everything's going to be fine so I'm going to create that variable and I'm going to do it I'm going to use a particular style I'm going to do it different I'm going to do it different so what I'm going to do is I'm first just going to say grid is an array it's an empty array and what I need to do is I need to Loop x equals 0 x is less than the width of this canvas and let me Zoom back out x++ so for every X and for every y right for every X ah stop oh I can't ah I'm waiting for my auto format that's not here um for every x what I need to do is say grid index X is an array so I start with this array and then I say hey let's make an array and then what am I going to put here grid XY equals now what do I what do I need in each spot in the grid now if I were just if I only had a single chemical if I only had a single chemical I was just putting a single number in each one of these but I have two chemicals I have an A and A B so let's actually I think this is a place where I could just make a literal JavaScript object and say a is you know there's zero of a and there is a zero of B so uh and you know I don't think I need to be so longwinded about it this is such a simple object I'm going to do this so I make each spot in the grid each spot in the grid for every in every y there's an A and A B with zero of each chemical and I'm going to need to change that eventually but we're going to start there so this is good I now have my grid yay now here's the thing in order to make this work right the whole this whole this whole all built on this idea of I need to get the Next Generation amount of a so I can't be me if if this grid is the snapshot of all the chemicals in a current generation I need a complete completely separate grid to start filling in the new values because if I were to use the same grid if I start overwriting the values in that grid while I'm checking other values neighbors everything's going to get all messed up so what I should do is I'm also going to create a variable here called Next and I'm going to be kind of silly about it and I'm just going to make two of these and I'm going to say next so I now have two twodimensional arrays and I think I just want to briefly mention that um I could have done this so grid is going to be the current and then next is going to be the next one so I could have done this by also using new array in JavaScript to create a sort of fixed size but I know my array should have a width and height as kind of the number of uh columns and rows okay so now we're in good shape so what I could do what I want to do is just sort of see that the basic idea of this is working so what I need to do is draw a color a pixel color in the window based on each value in that grid so by the way we're going to need this double nested Loop like a zillion times so I'm going to just copy paste that down here and one one thing I'm going to do at the very end is I'm going to say load pixels and then I'm going to uh say update pixels and what I'm going to do is I'm going to uh create a color let's just make sure I'm going to just make a nice you know pinkish purplish color just to make sure this is working and I'm going to say pixels index oh boy so guess what everybody I have a whole video that goes through the pixel array I should link to that from here the pixel array in Java in P5 JS in the JavaScript canvas is a pixel array that has four spots for every pixel so I need to figure out and it's onedimensional so I go through the derivation of this formula but I'm going to say pix equals x + y time width Time 4 and then I'm going to say pixels pix plus 0 equals uh 255 and I'm going to this I don't need and I'm going to say zero and I'm going to say 100 and then and this is uh one one two and three so what I've done here is I'm using a formula to find the right spot in that array for every single Pixel every width every column in every row and then I'm saying make its red 255 make its green zero make its blue 100 make its Alpha 255 so I just want to see that this runs okay great so I filled it with a color so I do have a way of setting every pixel color now what I want is for these colors to be based on the grid so I'm going to say grid X comma y. a and I'm going to say grid X y.b so um so I'm going to do the red and the blue as coming from the twodimensional array itself and we should see all black but if I give everything a uh random amount we should see uh okay so what am I missing here so I gave the grid a random amount of a and a random amount of of B and uh what's missing oh I I did random between zero and one so I what I want to do is multiply these by 255 there's there's lots of ways I could use color mode or get around this but I'm just going to multiply that by 255 oh and I'm gonna have to say floor because it has to be an integer I bet uh okay so I probably could have done a better job at this but there we go so you can see that this is working I have a mechanism by which based on the amount of chemicals I get pixel color this is the core thing that we need so now all we need to do is say like okay let's put this formula in great so let's unpack this formula right because right now and and actually before we even do that let's let's actually just get the structure going so before I put the formula in let's do something let's put this nested Loop in again and what I want to say is now I need to use this next right next index XY equals and let me just do something like I'm going to make up a formula this isn't the actual reaction diffusion formula but what I'm going to do is where's the camera where's the screen I'm losing my mind I'm going to say grid X comma so next. a equals grid xy. a you know times 0.2 and next next the the next B is the grids B * 1.2 so I'm going to do that so this is this again this isn't the correct formula we're going to have to actually put in the reaction diffusion formula but I'm showing this is the structure by which I say the next generation will be that so now if I run this again me come back to here well it doesn't seem to be animating or changing why so it's not animating or changing because I'm still drawing it based on grid so maybe what I actually want to do is draw the next one and I did get something strange happening here so it looks different and let's actually um not let it go over the values go over me so you can see that it is actually doing something like the values are different but importantly here I don't see anything animating so one of the major things that we need here is and let's think about is something called a swap are you with me are you still paying attention I would understand if you weren't okay so I need a swap so this is a very common technique in seller automata systems and other types of Generation by generation systems what I have here is I have oops wrong side of this marker what I have here is I have a two dimensional array called grid and then I have one called next so grid is all my starting values then next is calculated and then next is drawn to the window well what should next should then become grid again so I can get a new next and draw that to the window so what I need to do is swap them what I need to do is say let me put next back into grid and then I have a new blank one to write on and I could just pull grid over there CU it's the old one I don't need it anymore so if I if I want to have this continuous generation I have the old and the new so new gets calculated then new becomes old and I could just use that old one that I had to be the next new one and then new becomes old then then new gets calculated new becomes old again so I need to have a swap so I'm actually going to write this as a separate function so at the end of every oops after I draw I'm going to call a function called Swap and I'm going to write that down can you see this I'm going to write this down oh somewhere down here so I'm going to write a function and called Swap and so what's going on here next I want grid to be next and I want next to be grid I want grid to be next and I want next to be grid I want to swap them oh but this is no good if grid is next and then next equals grid well then next is next because grid is next we've got a problem here so in a swap what I need to do is I need to have a temporary variable that keeps track of the old grid so now grid can become next and next can become that old grid temp so this is a very simple swapping algorithm to swap the values of two variables um and that'll do the trick for me so now if I swap them this will get applied over and over again so let's let's do 0. n and 08 just so we see something happening here and you can see it it went down to zero very quickly um and I could um you know I could say 0.95 and I could try doing 1.01 so you can see it's going towards it's going to go towards blue eventually so we can see we have the system going on again this isn't this is the like shiffman rainbow reaction diffusion algorithm which isn't very interesting at all so we have the guts here we have the foundation we have the twodimensional array each spot holds the amount of each chemical the screen is colored based on those chemicals and I have some formula to calculate the new chemical value based on the old chemical value so I don't know how long I've been doing this for but we're so close now all I need to do is actually go and get that scary formula uh from that web page and stick it in the code and we're done so let's go take a look at that this is going to be a bit more difficult than I might have imagined but let's see how it let's see how it goes so now we're back to here so let's look at all of these things okay a the difference of the new a equals what a so let's start putting this in uh so this we can do difference of a equals new a so I'm going to go back and um I'm going to probably need a lot more space here so um and I'm just going to do a for a second the new a right equals what the old a now I'm going to go back to this formula plus plus now what da what is da oh I can't operate the computer sometimes I went back by accident da is a diffusion rate so where are those here we go these are some typical values so this is by the way is something that you're going to after you watch this video and use example you're going to want to like play around with these values yourself or go look up other values the different values will produce different kind of results so diffusion rate of a is one so I'm going to in my code I'm going to make these uh Global variables da equals 1 let's see what else we got uh DB equals .5 diffusion rate for B the feed feed is how fast are you feeding in chemical a is 055 I'm going to call that feed just to because F can mean other stuff in programming 0.055 was that it yep and K is 0.062 uh VAR k equal 0.062 that's that's sort of the the the kill rate how how fast is a b being removed um so these are the values that I'm going to need in that particular formula so now I can go back here and say uh plus the diffusion rate of a times upside down triangle PL 2D function okay so let's let's make that something temporarily that we're going to deal with in a little bit so I'm just going to say right now I'm going to say la I'm GNA make that a function La a we're going to deal with that later and uh times a times and you know what I should do to make this shorter I think something that can make things a little easier is I can say a equals grid X Y A so that way I don't have to every time I need that a value I can just put a time a times uh uh oh no minus minus what a * b^ 2ar uh so a * B * B and I'm going to I need a variable for a boy this is a lot of typing here guess you could fast forward now or put this on two times speed if you're watching this still uh I kind of want to like put this on multip lines also just so you can see it so uh whoops no this should be here I'm going to do each piece of this formula on a different line uh I don't know if this is making it uh um minus a * B * so we have a * the diffusion of a plus this lla thing I have to get to time a minus a * B * B and then now we have plus the feed multiply by 1 A so plus the feed multiplied 1 A did I get that right plus the feed multipli by 1 minus a and I'm going to put parentheses around these things I think I'm sure it's right anyway but this I think will help us a plus d a that doesn't seem right A Plus da times llas so I I so I'm going to um just to be consistent here I'm going to move this down here and uh I think I now have all the components of that formula a plus da * LL time a minus a * B * B plus feed * 1us a does that look right somebody watching this in the live stream will correct me I think I've gotten this right um and we will uh yeah da llas times a okay so hopefully I got this right I have to do the same thing for B why not just do it right now that we're here so B is B plus uh the the diffusion rate for B and I'm going to make a llas b function which is a little bit silly what I'm doing here but I'm going to do it anyway um uh times B and then it is plus ab^ 2 plus ab^ 2 minus uh minus k + f time B K plus feed times B okay we're in good shape here I'll put parentheses around this just to be consistent so I think I now have um so I think I now have these formulas now I I did miss a crucial point if you come back to this you'll see delta T delta T is the change in time for each iteration what does that mean well the way the world works is that Time Marches forward on and on and on the way that computer programs and animation programs work is Time Marches forward in time steps lock step and how and we're doing this calculation in this sort of like stop calculate wait stop calculate wait stop calculate so we can sort of scale the amount of time that's passing scale the calculation according to I'm going to leave that as one and basically my time scale is going to be the 60 frame per second that I hope that the um that the uh algorithm uh that I hope that the animation plays out at but you can really sort of change the quality of what you're getting and the degree of accuracy that you're getting by having a smaller time step so you might try 0.1 01 0.5 and see what you get but I'm going to kind of just leave that out for right now for the for the case of Simplicity Okay so we've done everything now except for this Lan thing and so I'm realizing by the way that this is lassi and a this is not multiply by a this this is the lloan a thing so one thing I can do is get rid of this times a and this times B um so what is that this is the convolution so this is this particular thing what I need to do in the llas function is look at the every single amount of a in all of the neighbors I need to multiply a weight and then add them all together to get the new value that's the lassan function the convolution so if we go back here let's go back to this page and here it says um the leian is performed with a three now there's different ways you could do this but this says with a 3X3 convolution with a center weight of Nega one adjacent neighbors 02 and diagonals 05 this means the following so I need to in this function look at every single cell and apply a weight 0.5.2 5 2 point uh this is the center one Nega 1 and then 2 05 2 05 the diagonals get a weight of 05 the adjacents get a weight of 0. 2 and the center gets a weight of negative 1 we're trying to determine the difference between that Center cell and its neighbors and you notice it's in a way these have higher weights because it's like the adjacent ones are closer to it than the diagonals so those chemicals are going to play a larger role in the reaction you could try messing around with different values now there are all sorts of fancy ways I could write another nested Loop and kind of use some sort of other twodimensional array to keep track of the weights I probably should do that but I'm going to be a little bit lazy right now and just do this in a very hardcoded manual way so let's look at how I might do that um so if I come back here first of all let's just write um so down here I'm going to need a function called llas a and I'm also going to need a function called llas B and I'm just going to do something right now I'm going to just say they return the value one which is obviously like wildly incor oh boy I'm not here uh so I need to add these two functions sorry I lost I didn't get back here I need to add these two functions and I'm just for right now for Simplicity to make sure my code runs just say that they return the number one so that this should do something and I should get something um and I should get something so let's run this and you can see okay so something's working and you can almost even like see it oops see it like Flicker and do something weird interesting for a second so that's good the other thing I want to change by the way and I'll deal with this later though let's leave that now okay so but now I need to actually do the correct llas function so what I think I'll do is pass into llas the function the current X and Y and then I'm going to do the entire calculation in that function and I need to do it with the grid right so what I need to do is say something like the sum for a is zero and then what I need to do is say sum a plus equal okay what's the center the center is grid X Y times that weight1 so I need to do this like nine times for all nine neighbers 2 3 4 5 6 7even 8 nine so the adjacent ones are all multiplied by 0 2 so adjacent to the left is x minus one adjacent to the right is+ one so these get multiplied by 02 then uh above and below is y + 1 and Yus one those get multiplied by 0.2 0.2 now I need to do all the diagonals again this is like a kind of terrible manual way of doing it but it's and I could do this in a loop in a much nicer way but I think this is good for figuring it out uh minus one minus one 0.05 that's up into the left + one minus one and I just need this same same value for each one of these uh uh okay then I need uh I need plus one + one and then minus one minus one does that seem right to you did I get oh no no no no I already did minus one minus one plus one so I have oh boy I've been doing this for a half an hour that's that's not good um okay look this is turning out to be a very long video I should have done it in multiple Parts but it's too late now okay so uh minus oneus minus minus plusus plus plus minus plus that's all four so I think I've gotten this right and then I just need to return and I need to get those X Y values as arguments and then I need to return that sum a uh and then oh and I'm not returning that whole object I'm not adding that I'm adding the a amount for each one of these and you know so I could do this in a more clever way by also having a B1 function to add these objects together so now it's going to do the and I could even like do a function that knows whether it's doing lla or a or b but again I'm just going to do this completely the totally manual way and we can do another video I'm gonna I can make this just a few lines of code and I'm just going to be sitting here come on Sublime it's try it's trying to be way too smart for me I just want to I don't want you to give me suggestions sometimes I want suggestions sometimes I don't want suggestions and this is silly now that I called it this but I did so I'm going to go I'm going to go all the way through with it okay so now we should we've got these lass functions I'm doing the convolution for every X and Y adding up all the neighbors and the weights so that should go right into this formula and honestly I think we might be done I'm going be shocked if this actually works we're gonna have to debug what we missed but let's run it I I I know this's kind of okay so sketch ah great I love what just happened here so what just happened here cannot read property zero of UND Define so I have I I could kind of try to figure out what's going on let's look at sketch. JS line 65 um so down here there's an issue here's the issue xus one when is xus one going to be a completely invalid spot in the Grid it's a completely invalid spot if x is zero because there's no negative one so I could do some sort of wraparound thing or whatever but I think what would be easiest here would just be to say hey you know what for this calculation I'm not going to do the edge pixels I'm going to start at one and I'm going to go to width minus one and height minus one so I'm actually going to ignore the edge pixel so I don't have that issue so that should fix that now I'm going to run it and look at this something kind of crazy happened so I think I've got the algorithm going here I'm a little worried I have a mistake but the most mostly the problem right now is that I haven't really seated this this in a way that makes sense so I think the traditional way these are done let's look here is right I'm giving the grid all random values is what I think would make sense would be to fill it with B right I want to fill the grid with B let's run this it's blue and it uh or it kind of turned red that's interesting that's not what I expected to happen but I'm going to just leave that that and then what I want to do is I want to give one spot like I'm going to say I'm going to override that I'm going to say like uh 100 100 a actually has a b out of a in it so I fill the grid with b and no a and then I give one spot I I pour in a little a in that one spot why am I getting this that's so interesting that I'm getting this weird Square thing so I must have messed something up hello I'm back I don't know where I would that's G to get edited somehow um so here's the issue I just I I wanted to add like a little bit of B like I filled the whole thing with a actually switched that from when I was maybe last in this video so I filled the whole thing with a and then I want to add a little bit of B but that's not going to work just like a one little droplet of be on one pixel not going to get enough reaction diffusion to make anything happen I actually need to give it a block a block of like I need to pour a lot more in so I need like a little area of so what I think I'm going to do is I'm going to say uh for I'm going to use I here just to use a different like IAL 100 I is less than 10 I ++ no I is less than 110 I Plus Plus+ now how you seed the system is like super interesting and I'm doing this not in a very interesting way but I'm going to use J uh j++ and what I'm going to do is I'm going to take a whole area and give it some B like a little 10 by10 pixel area so every pixel from between 100 to 110 is going to get some B right every pixel is going to start with a lot of a and no B and then this little 10x1 areas can to start with the and what I'm actually going to do is just for a second comment this out so let's just see what this looks like now why am I I'm getting this crazy flickering you can't see that actually interestingly enough I don't think the flickering is showing up because I've done something wrong with my rendering but you can see though that oh whoa oh now you're seeing interest I don't know what you're actually seeing on the stream um oh boy this is a really this was a much harder one than I imagined but I'm going to put this back in I got to figure out what the flickering is there why the flickering is happening okay so you can see this is now finally working um I'm getting a weird flickering around the edges oh oh I know what the problem is I know what the problem is because I'm not updating the edges the edges need to make sure they're seated with the original amount of stuff there we go finally we're good so it took me a little while there but but the issue was that I needed to place an area of of pixels um in order to to to seat it with some chemical B so uh this was this was much this would have been good this would have benefited from this will benefit from a second run like I could just do this whole thing again and probably get through it a lot faster with less hiccups but hopefully this helped you you can see now I now have the reaction diffusion simulation you can see this is one little area of pixels um and you know what happens if you give it like like a circular area of pixels or start stuff with like random values what kind of patterns might you get and you can see the reaction diffusion algorithm is kind of blossoming into this nice little flower we can let it run for a little bit I'm curious about the frame rate I it's JavaScript is handling this pretty well is is only 200x200 pixels um so it isn't um it isn't a tremendous amount of pixels for it to work with but so you might run into some serious performance issues if you do this in the browser it's going to run a lot faster in processing of course I'm sure there's like fancy Shader web gel ways of doing this super super fast but um I think this kind of wraps up this tutorial so to recap just now that we've kind of like just want to use this last few minutes to kind of recap what I've got is uh here we started out with uh in the code I'm just going to walk through all the pieces of the code now there is the grid which stores the amount of A and B chemicals across every pixel there are all these constants which are associated with gray Scott inter implementation so there's a an amount of diffusion for a an amount of diffusion for B there's a feed rate and a kill rate so you can look up different values for those like known values that produce different patterns you can also just play with those yourself then I have to create these twodimensional arrays I need a current and a next because I got to calculate the Next Generation and then use the current as the Next Generation then use it as the next I've got this cycling going on and I'm starting and filling it each spot with all chemical a and no B then I start a little area of pixels the 10 x10 area of pixels to put some chemical B in and this is another place where you wanting to play with this code you should try something different like what if you fill in around the Contours of a silhouette and you start getting this like silhouetted person reaction diffusion pattern then in draw I do a bunch of things number one is I just actually Implement that reaction diffusion formula I need to calculate the next amount of A and B based on the current amount of a the diffusion rate the feed the kill all of that stuff as well as this sum of all of the neighbors so the sum of all the neighbors happens in these lass functions and that is lower down in the code again I would suggest and I'd be happy to do this and post this at some point if someone else to remind me modified version I could condense this into one function and I could also make this happen in a loop but I think this really shows exactly what's happening and these weights again are defined by The Sims uh page you could use you could wait things you could have a 5x5 Matrix you could do different things there so that's calculating all those next values and then here the only thing that's happening here is I'm Now setting every single Pixel in the window a color based on the amount of a and the amount of B and I'm just using black and white so it's up to you I think I could go back you could say well the amount of a could be the amount of blue the amount of B could be amount of the green you could create Rainbow cycling colors somebody make a rainbow reaction diffusion thing um there's a lot of possibilities there for how you can play with this but this is all of the code I think this is probably a 40 to 45 minute video I'm assuming at this point um and so uh please play with this uh send me your feedback send me your comments and um let me know how it goes thanks for watching