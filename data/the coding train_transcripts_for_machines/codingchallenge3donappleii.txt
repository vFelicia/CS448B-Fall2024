hi there on today's episode of coding together the future of computer graphics I am going to attempt to render a threedimensional rotating cube right here on the screen of this apple two plus computer I'm gonna see if I can program it all in basic but before I get started I would love to highlight some of the wonderful messages I've been receiving from viewers just like you Kelly Murphy writes the variable name link used by Apple basic is two characters what does this mean exactly let me write a little program here with a variable called start X and then maybe a variable called start y if I print the both out I should see what 10 and then 50. but I only see 50. this is because what the computer is storing is the actual variable name is just those first two characters St David frischneck writes I remember typing in a mandelbrot plotting program listing from a copy of Insider magazine and letting it run all day while I was at school I too have been working on a mandelbrot plotting program on the Apple II plus and I'm going to show you a time lapse of it running right now it's so beautiful many of you also mentioned beagle Brothers basic which was an enhancement utility for an apple 2E or a 2 or 2 plus with an additional RAM card one of my favorite enhancements that beagle basic has is a swap command which will swap two variables and it even includes elf many of you commented on how there is a way to edit a line of code you've already written other than retyping the whole thing Mark Miller explains it as what I remember is you had to hit escape and then basic would allow you to use the IJ AK and M keys on the keyboard to move the cursor around to the line you wanted to edit okay so I think what I need to do is I need to hit Escape move up with I I've got to now press J to move over the one and then I can't use JK to move across the characters I have to now switch to the arrow key well first I press escape to get out of moving the cursor then I press the arrow key all the way over here now I could change this number to 25 now I could hit enter home list here we go I've edited a line of Code by Piper Mark Miller this is going to improve my life as a programmer tremendously I should also mention that I have since acquired something very exciting you'll notice here that I have these beautiful disk drives and countless of my old floppies super text Daniel schiffman December 4th 1982. beagle basic there it is this is my fifth grade science project she tried to load this and see if I could get it to run unfortunately I haven't been able to get these disk drives to work so I would really like to restore them to access what's on these discs but in the meantime I have acquired from Big Mess oh wires something called the floppy emu the floppy emu here is a device that takes an SD card that I can load any Apple II disk image onto and I can also write to it so I can load programs and write to it and on this SD card I basically can store the equivalent of thousands of floppy disks and it has a little menu here so if I go to Apple 2 stuff I'm going to go to five and a quarter inch discs let's go to games let's try Frogger and now you can see Frogger is loaded in to the floppy emu in the same equivalent way that it would be for a disc I'm going to restart the computer I can see here that it is reading Frogger we've got the start screen here space to play and here we go I am the king of Frogger maybe I'll start streaming these games over on my twitch Channel I am going to go over here and go to Apple II stuff five and a quarter inch disc and I've made a little folder myself called shift men and I've got a Dos sample disk that loads a bunch of sample programs and will allow me to save whatever code I write today onto this SD card and release it to all of you the first thing I want to talk about is double buffered animation now I've talked about this a bit in previous videos and we did something like this in my bouncing ball in basic example right every time I move the ball the rectangle to the next location I had to erase the previous one so we wouldn't see the trail of it we just see this rectangle moving from spot A to B to C to D Etc most P5 or processing sketches have a draw Loop happens over and over again at the beginning of draw the background function is called to erase the background the stuff is drawn when it Loops back background is erased again stuff is drawn background draw background draw background draw but we don't see that flickering of background then put the shapes this is because double buffered animation happens behind the scenes the screen is not actually updated until the end of the draw Loop so all of that stuff is happening in an offscreen buffer that then all at once gets put to the screen for you to see if I want that same functionality in an applesoft basic program I've got to implement that double buffering myself so let me find where in my manual here or maybe in this tutorial where I can find some information about it aha I have found the part of the manual that I need commands affecting Graphics so I know that the Apple 2 plus in memory has two pages for high resolution Graphics so one of those pages can be off screen and I can draw to it and then when I put that one onto the screen I can start using the other page then I can swap them and that's how I'm going to implement this I can poke the memory address to show one page versus the other so the first thing that I want to do is start a new program that both initializes high resolution Graphics page one and high resolution Graphics page two great there's the line now what if what I want to do is animate the line moving across there's one more step that I need and it's here on this beagle Brothers poster for selecting which plotting page I'm going to draw to I need to poke address 230 32 page 1 64 page two I've also printed out for myself a little reference with all the correct poke addresses that I need let's think about how we're going to adapt this program to have a line animating across with double buffered animation let's actually start over for a second foreign how high is the screen again 192 pixels I think so here's a program that should start by plotting a line moving X and doing that over and over again whoops oh H plot 192 is correct because it's 192 pixels high but it's zero to 191 what am I thinking there we go so now this line is animating across the screen if I wanted to erase the previous line I could go ahead and do that ultimately my future goal is to draw this elaborate Cube and I know this is not going to be very efficient and it will probably slow down the program enormously but when I draw the cube I'd rather not individually erase each line I'd rather just wipe the whole page and I can do that with a call call negative 3086 clear highres screen to Black so that's what I want to do and the positive integer value of that is 62450 so I'm going to in line 25 say call 62450 and then let's go to 25. now this is not double buffered animation this is exactly the problem we're seeing it clear draw clear draw now we need to figure out how to do this process on two separate pages I'm going to have a variable keep track of which page we're on or which screen so let's call it SC and we're going to think of it as screen zero and Screen one so what if I were to write a subroutine where the very first thing in a subroutine I do is show the page that I'm on actually the thing is I've done this before so I know what I need to do in this subroutine is actually show the other page because I want this subroutine to be the subroutine that swaps so I'm thinking about it I've already drawn it off screen now I want to show that other page and start working with the other other page this will make sense so I'm gonna say poke so it's either 49236 or 49237 those are two integers that are separated by one my screen is either zero or one and by the way I can turn zero into one or one into Zero by saying not screened because on the Apple 2 plus false to zero true is one so not one is zero not zero is one so poke four nine two three six plus not SC comma zero so this will display the screen that is not the value of the variable SC and then I need to poke memory address two three zero and then going back to setting the page that I'm plotting on so it's either 32 or 64 which is the same as 32 plus 32 times SC right because if SC is zero that will be 32 if SC is 1 that'll be 32 plus 32 which is 64. then the what I'll do in this subroutine is clear that one call six two four five zero okay let's look at our program so get rid of 25 and I need a return so this subroutine starting a line 1000 is just switching which screen we're drawing to so presumably I will do that at line 50. and then on line 60 I can go to 30 and draw again let's just see what happens if I run this hello so what's happening here I'm just seeing one line that's because the value of SC never changes so I start with screen zero I draw the line and then I switch to drawing on the other screen but I never switched back so somewhere in there I need to swap screens after I draw yeah right before I go to 1000 ah look at that look at it beautifully moving across with no flicker it's just very very very slow this does not bode well for my Cube now I sort of feel like the way that I've done this it's silly to have this s sequel not SC be not part of the subroutine but I'm sad that I made this first line of the subroutine line 1000 would it be silly for me to do this I don't like this at all so my draw Loop in processing terms is essentially lines 30 and 40. so you know if I want to like really have this be more like ah be more like processing bear with me let me retype some of this look at me editing that's right to edit that line yes then line 25 would be call what's the address to erase again six two four five zero this now is my draw Loop erase the background draw a line move X then I need to go and oh 999 is no longer go sub 1000 then this is the line of code that's invisible in processing a P5 the thing that goes in swaps the buffers which I do there come back and then repeat the draw Loop that's got to be you got to erase the background so 60 should be go to 25. all right here we go it's still running really slow but I'm so excited that we have double buffered animations this is amazing I think we're gonna need this book programming the 6502 so basic is a language that's fun to use and really easy for me to demonstrate and explain but to squeeze out the efficiency of this computer I'm probably going to need to start looking at Assembly Language I have a feeling also and I'll show you a version of this that if I were to just erase that single line instead of clearing the whole Graphics buffer it would also run a lot faster but that seems like way too much work for me we are however ready now to see if we can start applying some 3D transformations to this line and probably see it run really slow and then can we make a cube out of a whole bunch of lines why not right so I'm going to remove right now uh everything from line 20 to line 60. and let's start by rotating a single line now I know that eventually I'm going to want to have a bunch of lines so even though I could just have X1 y1 and X2 Y2 for a single line I'm going to have an array that is multidimensional that has two spots each with two values and then when I have two lines I'd have four spots each with two values so on line 20 I'm going to create an array we'll call it points that has two points in it each with two oh you know what three values because the whole idea of this is we're doing this in three dimensions now the other thing I want to do here is I want to think of the space of the window as zero zero being in the center so if I want to draw a horizontal line from a chord of the way to three quarters of the way my points would be points 0 comma zero which is X would be let's just consider this line to go from 0 zeros in the center and this line is going to go from negative one to one we'll scale it later zero comma one which would be the Y would equal zero because it's going to be in the center I wonder if this is eventually going to be a cube though let's have it be a line along the top of it so let's have that be negative one and then points 0 comma two which would be the Z we're just going to have the Z be zero so that's the first point the second point is going to be the same but the x value will be positive one foreign we'll start it at line 500 which draws whatever's in the points array no no no no no no let's have a subroutine that draws a line between any arbitrary two values in the points array in other words H plot and forget about the Z for a second points a comma zero points a comma one two and the a doesn't exist yet I'm going to add that in so this is X and Y of point a to the X and Y of point B then watch this on line 50 I can say a equals zero b equals one go sub 500. so this is essentially a way of having arguments to a subroutine I'm going to set two variables A and B right before I go to the subroutine that's drawing a line between a and b and then line 60 I'm I'm just gonna go to 50. just do it again we're not doing the swapping yet just want to see if this works oh no no no no no no no no no but I need to do the scaling oh okay so I need to do this a different way it's nice that I typed all that but essentially what I want to do in line 500 is say X1 is a zero and then I'm going to multiply it by some scaling value let's use SZ plus half of the width which is what was the width again 280 so plus 140 I probably should put that in a variable Center X we're going to have that be a variable so times the size so negative 1 becomes whatever size it's like negative 1 is 50. so negative 50 plus whatever that Center offset is so that would be over here okay that's X1 the center y then I can just say h plot X1 y1 to oh no X2 Y2 all right everybody ready for some editing then 550 is a return I think this is good oh but I need these variables now let's just at the very beginning uh line 12 let's just use 50 pixels for the size Center X is 140 and Center Y is half of 192. oh I've got a line there I must have messed something up oh no boy this has been a mistake for a very long time all right ready everybody this is to be index one I initialized the zero element of this array twice I'm gonna retype it okay that looks good let's run this there we go congratulations you've watched 45 minutes of somebody on YouTube drawing a line so we're in really good shape here the bulk of the work is just going to be typing out a lot more coordinates and then writing a loop to go through and draw all the lines connecting all the coordinates but before we do that there is one step here which is what if I want to see this Cube that I'm going to draw or whatever the shape is or rotate and there is no unlike in processor P5 translate and rotate and push and pop so I'm going to need to do that with the math behind rotation itself this is something that I've covered extensively in another video where I did 3D rendering in a 2d renderer by writing all of the Matrix math I'm not going to rehash all that in this video but I do want to show you the basic math behind rotation foreign let's say we have a Cartesian plane and we have some point X comma Y in that Cartesian space we can think of that point relative to the origin and rotate about the origin by some angle called Theta and it would end up over here this would be the new X and Y position I've demonstrated how to do this in previous videos looking at the concept of polar coordinates ultimately the way to apply this kind of 2D rotation transformation is with Matrix math foreign this rotation Matrix rotates the point x y counterclockwise according to the angle Theta the X Y point is written as a column vector and the new point is the result of that Vector multiplied by the rotation Matrix we're going to get a new single column vector and the first element the new X is x times cosine of theta plus y times minus sine Theta then the new y position is x times sine of theta plus x times cosine of theta notice how if X and Y was the point 0 0 the new point would be zero zero because rotating 0 0 around 0 0 the point stays the same this is not applying any kind of translation only a rotation counterclockwise by the angle Theta in the context of computer Graphics we might be going clockwise because the yaxis is flipped in three dimensions we don't just have a single plane and a single angle if we apply a rotation we need to know around what axis X Y or Z interestingly enough this is actually the rotation Matrix for the zaxis only we need to extend it out to account for Z so to get the new X we would say x times cosine of theta plus y times negative sine of theta plus Z times zero the new y x times sine plus y times cosine plus Z times zero and then the new Z is x times 0 plus y times zero plus Z times one so Z does not rotate around the Z axis we can look at the rotation Matrix for the yaxis as well as the rotation Matrix for the xaxis now that we've covered what the math is the things that I need to add to this program are a variable for the angle that I'm going to rotate we'll start with just rotating along the zaxis as well as a whole second set of points because I need another variable to apply that transformation into so right at line 25 let's go rotation Z points RZT and we're gonna have two of them and there they have an x y and z Oh my goodness I did forget an important step which is once I've rotated the point in three dimensions I need to project it into two Dimensions to draw the correct X and Y but guess what I'm just going to use the simple way of doing that by taking off the Z so it won't be perspective it'll be orthographic but it'll be good enough for us right now now I have a whole separate array for the rotated points line 50 is where I'm drawing so in line 55 let's do another subroutine two thousand and that's where I'll apply the rotation math we just went through so 4 n equals 0 2 and I just have two points right now there's two points in the array oh I forgot about an angle running out of lines of code here at the beginning but let's do a line 18 an angle do I dare no I can't use a because I use that here I could use angle the word angle angle equals zero then line 2000 to 2010 the rotation point for Z of I the x value equals so I need to use cosine of theta but as soon as I go to do I comma 1 the Y value I'm going to want to use cosine of theta again and I don't want to calculate that twice so actually what I should do even before I do the loop in line 2000 is say CS for cosine of theta is cosine of and it's not Theta I called it angle sorry and SN for sine is sine of that angle now I could do that Loop for n equals 0 to 1 and then r z p right the rotation Z point x o n for the end point x equals negative cosine you might notice that my original Matrix had positive cosine Theta and yet I just typed negative cosine Theta I'm also going to type positive sine instead of negative sign this is because in the graphics world of the Apple II plus y points down the pixels are positive in the downward Direction and I want it to match y pointing up so I've just swapped the sign there and the rotation happens in the correct direction who's to say what's correct anyway though as long as I'm consistent but I just want to let you know that's why that changed times x which is point zero plus sine times Y which is one plus Z times zero now since I'm multiplying by zero you don't need to have that operation in there probably should just leave it out but I feel like just to have the math be consistent I should say zero times points n comma two then let's do the Y y equals sine of theta times X plus cosine times y plus zero times points times Z and then you know to be consistent I should do the Z which is just zero times x again this is a lot of extra stuff zero times y plus one times Z next n to go on to the next point now the question is where in the code do I want to apply this rotation so right here starting at line 50 that's essentially my draw Loop draw the line rotate the point then go back and do it again draw the line rotate draw the line rotate but I'm missing the swap the buffers and there's another issue that I'm thinking about so let's clean up our code a little bit refactor if you will and start putting a proper draw loop at line 100. I'm even going to use some comments here draw Loop the first thing in the draw Loop should be rotate the line then draw the line I should probably put remarks on all of these but I don't got a lot of time right now then swap the buffers which is the subroutine at one thousand that's what a comment would look like let's put it in for the ghost Subs oh oops ah rotate the points draw the line swap the buffer and start over all right let's see what happens if we run this great we've got the line it's not rotating why because I didn't increase the angle so on line 140 angle equals angle plus 0.1 and then line 150 go to 100. Aha it's still not working I know why do you know why think about it let's go to that subroutine at line 500. this is where I take point a and point B and connect them by plotting a line but I'm looking up the location of index A and B in the points array and the rotated values are in the rzp array rotated by Z points rzp if only there were some generic way for me to pass an argument I don't think this is going to work I know it's not going to work because I just tried to do it for like a half an hour so I'm just going to hard code in the rotated Z array and we'll see later if I have to do multiple rotation time I'm going to handle that and guess what Now's the Time for a beautiful fancy editing Escape all the way over and then r z p and then of course I have to Arrow over to the episode line go do something else for a little while it'll be it'll be a bit looks good okay so there's a nice little Point all of a sudden that happened here this is not working oh my goodness I made a ridiculous mistake look at this I left my old draw Loop in there the one that is not applying the rotation or doing anything so I've got to get rid of that 50 55 60. now I just pray here oh oh wow oh I believe the first swapping is not working but I don't I don't care because that is totally awesome thank you I'm done I'm out of here it's the end of this video you figure it out yourself why did the buffer swap not work look at some of my reference research here oh my goodness and it was running so fast you know why I forgot to have the clear the background step should the clear the background be part of the swapping of the buffer I don't think so because ultimately it's really part of the draw Loop yeah I like swapping the buffer at the end so 150 swap the buffer 160 go to 100 and then what I'm missing there at 105 is not swapping the buffer it is call the erase the background which is call 62450 and this is gonna I think fix it but also make it run unbelievably slow that's not that bad actually to be perfectly honest there's my rotating in 3D line a whole Square that's rotating so now my points and my rotated Z points need to have four points in them four comma three four xyz's it's funny I'm not doing anything 3D but I will I will then let's do let's just change it now let's change it to a rotation by X so let's just do those all in one line do we want to see it rotate by let's do y let's do y so now when we're initializing the points which should probably be a subroutine because I'm going to run out of space but that's fine yeah I should that should be a dumb subroutine let's make that at um five thousand and I'm gonna do do all the points negative one negative one zero I should really use a z value since I have to fix that one anyway because if I'm eventually going to make a cube there's got to be Four Points in front and four points in back with like the center of the Cube It's the center of our 3D World so let's have let's draw a cube in front to start let's draw one in the back to start okay and then so I'm missing I call in there and then this should be negative one because it's important to have this D do something now I'm doing the third point the bottom right one one one one negative one foreign negative one one negative one whoops I hope this works so instead of initializing the points here and line 30 we're just gonna say go sub 5000 and then I forgot I need a return there so even if I run this ooh I was gonna say it should work with just the first two points syntax errand line 25. oh I forgot the dim I got so excited I forgot to type Den dim ryp 4 comma three so exactly what we had before but now where is that where's my draw Loop oh so first rotating them all 2020 needs to be zero to three because there's four points and then 120. so now I'm gonna need a lot more things there so that should also be a sub 14. I mean that's a little bit nuts but that's fine do I have anything at six thousand no okay so six thousand draw lines oh REM draw lines so first connect zero and one foreign then connect two and three then connect three and zero so I could do this in a loop but I just want to hard code it to know that it's right I'm also anticipating having a lot more points with a more elaborate shape and uh at this point right now I'd rather just type it all out and then 6050 return so that's my subroutine here to connect all those lines and let's go back to my draw Loop and instead of Line 120 being this we're going to say go sub 6000 REM lines okay I'd run this hey hey hey guess what we've got to make this make the 3D so I need to add rotate X you remember the Matrix math we did now we just need to add that in where does that happen where was that subroutine 2000 so right after line 2050 that's where I've applied The Matrix rotations for a z rotation I just need to do the matrix multiplication for an X rotation a y rotation I mean a y rotation so let's wipe out 2060 and 2070 right now and 2060 would be ryp n comma 0 equals cosine 0 sine zero one zero negative sine zero cosine I think that's right then 20 90 would be next and true we should apply the Y rotation first I guess it's six of one half dozen to the other because now I'm gonna have to adjust the uh when I'm drawing the line oh whoops 2090 is next and 2100 is returned let's just run this it should we shouldn't see the Y rotation yet because I'm still just drawing the rzp points and you can see it's actually running I thought it would I'm quite impressed with the speed of this uh um but where is that that's here the subroutine of line 500 I now need to change this again Talk Amongst yourselves foreign moment of truth I can't imagine that I didn't make a mistake but that's happening before let's just run it and see who where's it going goodbye where are you going I mean I see some kind of 3D rotation there I think it's because it is out from the center what it's doing is imagine it's this piece of paper what I'm doing is rotating it like this as well as doing this so it's really doing this which I think is what I'm seeing let me show it to you sped up very slow but working all that's left for me to do now is really a lot of typing I need to add four more points so to have all the points of a cube I need to draw eight more lines so we see the full cube and then maybe if I feel a little Saucy I might like to add the xaxis rotation we'll see step one increase the size of my arrays I realize I did something a little wonky here it's correct in that I have four points and three dimensions but the index values are zero one two three and zero one two and applesoft basic expects me to put not the length of the array but the maximum index which is weird but that's how it wants it to be let's correct it as I expand it oh that looks wrong but seven comma two is a twodimensional array eight by three let's add an X rotation my arrays are bigger now where do I initialize them I think in the subroutine at five thousand Yep this is where I initialize 0 1 2 3. let's keep going I have what might be a clever idea instead of typing four more lines of code I can edit these lines of code changing the line number the array index and the Z location right these are the four points at the back of the cube negative one to the Four Points at the front of the cube positive one foreign index four who knows if this is actually any better but it is going to work I think oh there's a bracket there I have to get rid of let's see if that works I think I got it I have now all the points of the cube in my array where do I process those points the subroutine at 2000 is where I rotate them for once I've actually done something in a way that makes this really easy to edit the only thing I need to change here is the loop now goes instead of from zero to three to from zero to seven now that I'm storing all the points processing all the points I need to draw all of the lines to connect the full cube that happens in subroutine line 6000. so I need to connect the back of the cube and then I need to connect the corners of the back to the corners of the front there we go great exercise for any of you watching is what's an algorithm you could design to do this in some kind of nice Loop and I've forgotten the return which is very important uh oh I I made a mistake with certain lines that I've connected let's check that out wow this is kind of cool though I made a weird shape I must have messed up my point definitions ah I have found the culprit I have a index off here in this line 50 60. it is index six and I left the two there foreign rotate now look at that beautiful threedimensional orthogonal Cube I feel like the xaxis is feeling left out let's add rotation around that axis I'm not going to add all that multiply by zero this time let's just do it the simplified way then I need next n and return all right all three axes there are some ways I could get this to run faster sure I could look into programming with Assembly Language but are there even some things that I could do in the code to optimize it would not using the call to wipe the graphics background and instead erase the individual lines be faster what about precomputing all the values of sine and cosine that I might need and storing them in a big array a lookup table essentially this would also have the advantage of allowing me to maybe use different angles for each of the axes to get a more complex rotation I would love to hear from you how would you optimize this code I will include a link to an emulator and this code that you could run there and try out different ideas and if you've got something let me know in the comments I will definitely address it in a future video or live stream another challenge I'd love to offer you is to add perspective projection this is kind of flat because it's orthographic projection and the math for doing that it's all described in my 3D rendering processing video and I will include information about how to do that in the video description see if you can get that to work I'll show you what it looks like also over here hope you enjoyed another episode of coding together what should I do in the next one I'm thinking what about music could I play a delightful tune here with my Apple 2 plus computer stay tuned and I'll see you next time on coding together oh and let's not forget to save our code disc full oh no no I've got 32 gigabytes on this SD card what are you talking about don't worry I'll have this figured out by the next time you're watching this video and the code will be linked in the description see you next time foreign