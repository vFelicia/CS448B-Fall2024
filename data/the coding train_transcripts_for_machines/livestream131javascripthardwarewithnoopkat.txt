Yes. (chuckles) Hello, welcome. (blows train whistle) Welcome to a special afternoon Coding Train with our special guest Noopkat. I was saying it wrong this morning. I was saying Noopkat, which I guess everybody says that. Everyone loves Noopkat, so it's totally okay. So if you don't know Noopkat, Suz Hinton, Noopkat streams on Twitch on Sundays. Yes. I will include links in all of that in this video's description when it gets published. You can probably find it through the magical world of Google right now. But you shouldn't go find it because you should stay and watch. Yeah, we're gonna have some fun today. Noopkat knows all sorts of stuff I don't know about, especially like how to use iTerm. (laughter) You'll notice that iTerm is here, so that's exciting for one. I don't even know if any of this is working because usually I put the chat there to monitor it. But I'm gonna go look. I'm gonna assume this is all working fine. In a minute I'm gonna go sit over there with a laptop tuned to the live chat. And so if questions come in, if you have questions you can ask them. I'll try to keep track of them. This is very informal. Probably everything is gonna go wrong as it always does. We'll try our best. One thing that's also very exciting is we're gonna make use of this overhead camera. Oh yeah. Is it this one? Because there's gonna be some hardware stuff happening. So that's new and very exciting for the Coding Train. I didn't really do a good job, I feel, of introducing you. But I'll let you introduce yourself. No, this is really fun. So let me quickly go over and check, make sure everything seems okay in the chat. Otherwise we're just gonna be doing this again. Just interrupt me if it's not good. I can do an intro. Does it seem all right? [Dan] Everything looks good and sounds good. Great, so I think we're going. So you can introduce yourself. I'm gonna mute my microphone, but then if questions come in or I must say something I'll unmute. Just jump in whenever. If anyone has any questions about what I'm doing because I may actually skip over stuff that you're just like, "Wait, she said a word that I don't know." Just let me know. Thank you Dan for having me. I'm so excited. I'm such a fangirl of the Coding Train so I'm like really excited to be here. I do a lot of hardware stuff so I wanted to briefly intro myself on that. I work on a lot of open source JavaScript hardware, which I know for some of you you might not typically associate JavaScript with hardware but I promise that it's actually super fun to get started with it. And it's really, really quick to prototype with JavaScript hardware. So that's kind of its main attraction. But you can also just create your own kind of fully implemented, real contraptions and still run JavaScript to control it. I'm gonna show you one way of controlling hardware with JavaScript today. We are gonna be working with an Arduino, an Arduino Uno which is kind of the most common one that a lot of people get started with. And we're gonna be driving this thing called an OLED screen. And I'm gonna explain all this just to make sure that Dan's not super scared. Because Dan told me he's really afraid of hardware. And I'm really afraid of generative art because I feel like I'm not good at it, so I'm trying to combine the two together because Dan is really good at generative art. So somewhere in the middle we're gonna find a nice happy place where we're both learning something. Hopefully it's gonna go well. Yeah, thanks so much for joining us. I'm so excited. I'm normally streaming on a Sunday, and yeah, I'm streaming on a Friday, which is blowing my mind. [Dan] Awesome. I'm muted, but you probably hear me through No, that's great. I would say that I'm not very If anything I might know how to implement the generative algorithms, but I'm not good at making something beautiful out of them. That's what the viewers are good at. We're gonna do a super simple one today, and then maybe the viewers can help us with stuff. I am going to just take you through a couple of the tools that we're gonna be using today. Just forgive me, this is not my computer so we had some sort of last minute shenanigans, but I think it's going to be okay. I'm gonna be using JohnnyFive, which is kind of the beloved hardware JavaScript framework. It has been designed to be like the jQuery of hardware. So if you've ever used jQuery before then you know that it's a really nice API, it's super accessible to get started with it. So JohnnyFive was designed by one of the contributors to jQuery, Rick Waldron. He's done a fantastic job. And there's been a lot of contributors ever since. I think there's at least 70something contributors now. That was when I checked a couple years ago, so it's probably even bigger now. So I'm gonna be using this with our Arduino. So if you wanted to follow along with some of the beginning code examples we'll be using today you can go to johnnyfive.io. It's kind of like the Short Circuit robot character, so I really like that it's named after that. And we're also gonna be making use of a module that I wrote a little while ago, about three or fours years ago, and it's called oledjs. OLED is the type of screen that this is. It's an OLED screen just meaning that the little pixels that are showing up on the screen are actually driven by OLEDs, which is like a type of LED. And so I wrote this module to be compatible with JohnnyFive so that you can just start really easily drawing to the screen without having to know a lot of the stuff that's going on underneath. So I'll cover a little bit more on that when we actually get started. But we're also gonna be using that as well. I wanted to give a shoutout to my friend Tim Holman because he's actually the one that finally got me playing with generative art super recently. We hung out at JSConf AU in Australia and he gave this awesome talk about generative art and how you just need a few simple things in a toolkit to get started with, and it's the first time I felt not afraid to do it. So you should check out Tim Holman's website. It's tholman.com. Yeah, he does really, really, really hilariously funny stuff on the Internet so you should absolutely check him out. So I wanted to thank him for finally getting me started with it. The generative art that we're gonna create today is, at least on this website it's called a pseudo maze. Is that what it's actually called, Dan? [Dan] I dunno, maybe. It looks like the 10 PRINT design. Is that what it's called? [Dan] Is it that you just pick randomly a left or right line? Yeah. So it's not actually a maze. I have a coding challenge that's exactly that pattern. It's from the Commodore 64. There's a oneline code 10 PRINT, GOTO 10, where you can randomly pick a forwards or backwards. Perfect. This is good synergy. So I noticed also that you did a coding challenge on FloydSteinberg. [Dan] Yes. Displaying photos, or just high resolution images on these screens, it's very effective to use the FloydSteinberg algorithm too. This is me trying to get you less afraid of hardware because you're still using the exact same stuff on this. So if we have time I don't think we will but if we have time I can also show displaying pictures on this thing. But for today we're actually just gonna work with lines, which are super simple to do. And just to kind of explore the concepts of generative art. If you've already seen Dan's coding challenge this is gonna be pretty similar. But it's gonna allow you to see how you then apply it to something like hardware I guess. I think it will still be super interesting, so thanks for tuning in. That's the super quick crash course to stuff. I do actually have a folder right now that I've created. I did preinstall some stuff ahead of time just so that we don't have to sit around waiting for NPM to install. But I will be doing this with Node.js today, which is a way of running JavaScript outside of the browser, which is really cool. So if you go to Node.js.org, just like that, you should be able to read up about it. It's really, really cool. That's kind of what JohnnyFive runs on top of. But recently I did get it working in the browser, but that's for another episode probably. So I have this folder here. I've installed JohnnyFive. I've installed oledjs. Just those two packages that I showed you before and that's it. And then we have a code editor here. I didn't quite get Vim setup. I was on a mission to get Vim going because if you've seen my stream before you all know that I use Vim. So we're using Visual Studio Code instead and we're gonna just keep crossing back and forth between iTerm and Visual Studio Code. So let me know if you can't read anything, and Dan will yell at me, and then we'll figure it out. I do actually have the Arduino plugged in right now as you should be able to see. So we're not actually gonna plug anything into it yet. We just want to kind of establish a connection to it first just to make sure we can do our little hello world, and then we'll start plugging in the screen. So I sort of wanted to do a lot of this stuff from scratch just so you can see it from the beginning. I've created a blank file called art.js because that's what we're creating today. And I'm going to start just by requiring the dependencies that I actually need. In Node.js with JavaScript, instead of maybe doing import, which you could do, I just gonna be using require, which basically says, "I've installed these libraries "and I actually want to start using them "so I can then assign them to variables." So I think the first thing I want is JohnnyFive. I'm gonna call that five for short, just because it's quicker to type. And then I'm just going to require that, and it should be smart enough to figure that out because Visual Studio Code is kind of amazing. So that's me actually requiring JohnnyFive and saying that that library from now on, when I want to access it, it's called five. The next thing I want is the actual OLED library. And because that's a class I'm gonna capitalize it. And let's see if it's smart enough to figure this one out. It didn't. Oh, there we go. [Dan] Just asking a quick question. Do you have like a package.json file? Is the JohnnyFive Node module already installed? Did you talk about that while I was looking at the chat? I did. (laughter) [Dan] I'm not gonna ask any more questions. I can show you the package.json real quick so you can actually see what that looks like if you've never seen it before. So if you have a look down towards the bottom of that file you've got dependencies, and you've got johnnyfive and oledjs. Really, really glad that we just went back over that because I know that I was talking a million miles an hour anyways. Now that we have them we can actually start working with them. Before we do anything with this OLED screen we want to just test that JohnnyFive is working and is able to talk to the device. We can do like a hello world with it, but I kind of wanted to first describe on the whiteboard kind of how JohnnyFive actually talks to the Arduino before we actually start on that. So let's go do that. We've got our computer right here. And this is kind of the confusing thing for some people to understand exactly how JohnnyFive works. I'm gonna draw a really bad keyboard here, but you get the idea. And then this computer is like, okay, well I want to talk to this Arduino. We can have back and forward communication with it. So let's just say that this is the Arduino. Everything has a smiley face too. So this is the Arduino. So what's actually happening when we run JohnnyFive is that every time we start that Node.js process it actually uses this really cool library called serialport to establish a twoway connection between the Arduino and the device, the laptop itself. And what it actually speaks is called the Firmata protocol, which I don't know if you've heard of before, Dan. [Dan] I have, yes. Have you used this before? [Dan] I think I went to a workshop once where somebody was teaching with Firmata. I know that students sometimes here use it, but mostly the students at ITP use the Arduino directly. Okay, that makes sense. So if you wanted to use the Arduino directly, this particular Arduino we're using today only understands C++. So that's why we wanted to sort of start with something a bit higher level and it's a little bit easier to stay on your machine. [Dan] So if you're using Firmata you can write the Arduino code basically in JavaScript? Yeah, you can basically become the remote control for the Arduino through the Firmata protocol. So we have our JavaScript, which understands the Firmata protocol, and then we have a C++ script running on this board here which understands the Firmata protocol too. [Dan] And that's like an out of the box thing you download and run on there. Exactly. So I'm gonna actually run that Well, I'm gonna run a very quick script to install that on my Arduino. I'm gonna show you how to do that so that you don't even have to download the Arduino IDE or anything. So we can do that. And the way that these talk to each other is because they know the same language, which is Firmata, they just kind of send opcodes between each other. That's not even a zero. So maybe 0xFF, that's like a byte that has value like 255. Maybe that means something very substantial in the Firmata protocol. Maybe it means, "Hey, start sending power to this pin "so that you can turn an LED on," or something like that. I don't actually have the Firmata protocol memorized but I do know that it is based on the MIDI protocol. So it uses I guess like the notes and everything, which is, I think, a really, really cool part of Firmata's history, that it uses MIDI to do it. So that's like a super highlevel view of how it actually does it just because the stuff that we're working with today is so heavily abstracted. So we want to just make sure that you still understand that there's this walkie talkie thing happening and that the JavaScript never actually goes and lives on this device. It's really just a remote control. We're gonna have a whole different protocol talking to the actual screen which I'll draw here later on as well. Cool? All right, let's do it. Now that we've got our dependencies we actually want to make sure that it's talking to the device. I mentioned before that the Arduino needs to actually know what the Firmata protocol is. So we actually have a premade sketch that Arduino itself publishes with the IDE and it's called StandardFirmata. And so we want to use that. Having to open the Arduino IDE, and then flash a script to the Arduino, and then close it again is sort of just annoying because that's the only thing you use it for. So I ended up making a package and it's called firmataparty. And I think I installed this on Dan's machine. I did. So what firmataparty does is it allows you to have a party with Firmata by just being able to transfer the Firmata script onto the Arduino device that you actually have. So that's literally all it does, but it does actually get you started and up and running really quickly. So it's just a command line that I wrote in Node.js. So we can run firmataparty, and then we're gonna write the name of the Arduino board that it's actually supposed to be flashing so that it knows what to look for that's plugged in. [Dan] Someone in the chat is asking is the JavaScript transpiled or interpreted? Or is the Firmata Does Firmata interpret the language or transpile? Maybe this question doesn't I don't know if that question makes sense. I think I'm really confused, but... So the Firmata protocol itself [Dan] Is just a protocol. Yeah, it's a protocol, but the scripts that are running Because that's a really good question. The scripts that are running are just basically looping and listening for any messages that come into the device or that the device sends to the laptop itself. So they're actually listening for Firmata packets, or just like MIDI notes, and then there are interpreters on either side that are interpreting those opcodes and doing the right thing with them I guess. So hopefully that answered the question. [Dan] In this setup that you're using I don't know if I'm jumping too far ahead obviously you need your computer there to write the Node code you're gonna write. But once that's finished could this work just with the Arduino and the display, or no, because the JavaScript has to run on Node on your computer. Yes. [Dan] So the C code, the C++ code, is compiled and the JavaScript is just running through Node the same way it always does. Yeah. So the only code that ever runs on this device, at least in this setup You can use JohnnyFive wirelessly, which is kind of cool. And you can run JohnnyFive on devices that run Linux. For example a Tessel 2 is able to run JohnnyFive, which is awesome. What happens is that the script on the Arduino never, ever changes. So it's literally just a listener that's listening for those Firmata commands to come from the computer, and the JavaScript always stays on the laptop and I guess the USB connection between the two is kind of the telephone game that it's playing, if that makes sense. If you've got any followup questions for that, let me know, because it's a really, really good question and I don't feel I explained it properly. And Scanline in the chat writes, "Firmata is like remote control GPIO over serial." That's a really good way of saying it. Also I'm so excited that Scanline is in here. Oh my God. I think Scanline is awesome. I just wanted to say hi. And I watch your livestreams as well. Now I'm super nervous. So we're gonna run firmataparty uno. Literally all that does is it takes the Firmata C++ script that the Arduino needs to run, and it just uploads it. And then we don't actually upload any scripts to the Arduino after this. We're just running JavaScript on the laptop, as we said, to just send stuff to that Firmata script that's running. And it's really just sending commands. It's not actually sending any code or anything like that. So hopefully that actually works. It seems to have worked. I think that I need to do v just to see if it did. Oh wait, no. Maybe it's debug. I can't see that it's actually working. So maybe it is debug. Let's see. Ah, there we go. Just so you can actually see what it's doing. So it says found uno on port blah. It connected. The reset was complete. It's flashing the code. And then we have a nice green status saying that it successfully completed. So now that we have Firmata running on the device it's actually ready to start listening for any commands that come in via that USB connection. Now that we have a five instance we want to create a board, right? We want to create this board instance so then we can start sending stuff to the board and receiving stuff from the board. So I think we just need to do a new... Five.Board I think. Wow, this autocomplete is blowing my mind. I don't use Visual Studio Code very often but it is like super nice. Okay, so we have a new board. What that actually does is it just goes and looks at all the serial ports, or the USB, I guess, ports on your computer and it goes, "Are you an Arduino? "Are you an Arduino? Are you an Arduino?" So it's actually really awesome because it takes a lot of that stuff out of your responsibility to do. Then the board comes back as an object that you can listen to events on. Again, this is very similar to jQuery. So normally where you would have document.ready, or document.onready, you can actually do like board.onready, which is actually pretty chill. So I feel like, Dan, you can totally do this. [Dan] I'm following everything so far. The problem is if I touch the hardware it might spontaneously burst into flames. (chuckles) I love it. Sometimes I have turned something on and I've smelt burning or the breadboard is melting, but that's usually if I'm doing something super dumb and it's not with the Arduino. So the Arduino is pretty safe. Ooh, I don't like tab four spaces so I'm just gonna do my space bar. Now that we have sort of attached a listener to the ready event, which basically says that we've been able to guarantee that there's a good connection happening with the Arduino, we just want to console.log out that it's actually ready. So we can just write yay, I guess. Let's try and run this just before we get ahead of ourselves and start writing extra stuff. So I'm gonna do node art.js, and let's see what happens. All right, it seems to have found it. And then we got yay. So that's pretty cool. What JohnnyFive does too is it actually gives you a REPL, which is, I think, a read, evaluate, print loop, which is really cool because you can actually start looking at anything that you create globally to be accessible in the REPL. So we're not really gonna use that today, but I just wanted to say that it's a really nice feature. So by me writing this, that's actually the instance of the board. So you can see a whole bunch of stuff comes out if you wanted to inspect that further. So to exit I'm just going to do I'm just going to send the ctrlc, the sigint twice, or the interrupt. I forget which one it is. So yeah, we're gonna do that. Are there any questions so far? [Dan] There might be questions but actually everybody is saying it's really easy in Visual Studio Code to change to two spaces. (laughter) Just in the bottom right. You should be aware that if you ever mention anything about spaces versus tabs, the only thing anybody discusses in the chat. I should've actually remembered that because my stream is really similar. So what is the command? People are saying it's in the bottom right. Oh, that's really easy. Indent using spaces, and then we want two. Wow. All you folks are the best. I figured that you might be saying something like that. Okay, so we didn't do it for the default. Let's do indent using spaces and let's do two. Yeah? Okay, so what happens if I go to a new line? Yeah! Thanks everybody. This is very, very helpful. I'm not going to start an editor war or anything like that. I'll have to be really careful about what I'm gonna say. Cool. We want to actually start using the screen now because that's really only thing that we're gonna do with using JohnnyFive, is to be able to use it to speak with the screen directly. So we kind of have to go over a little bit of theory of what we're doing today, but we also want to plug in the screen as well. So I think we're actually gonna start with the theory first. So let's do that. [Dan] My face was just (mumbling). I'm like right over here. Hello! So we have this here, but I sort of wanted to just start like a new section over here just for now. We wanted to create this generative tile effect, so we want to sort of explain that first. Let's imagine that our screen is here, our little tiny OLED screen. And the maze before looked really complicated if you're sort of not able to break it up with your eyes. But what it really is is it's just a grid. So this is what we're gonna be programming today. And this is not actually to scale of what the screen actually is, but it's just giving you an example of like a really small cutaway of the screen that we're going to be doing. In order to create this generative art pattern we actually are just gonna draw one of two things. So we're gonna generate a random number, and then depending on whether the number is more than .5 or not we're gonna draw a line that's facing it's either pointing one way or it's pointing the other. So we have one of two lines. So it's going to be either this line or it's going to be this line. That's it. So it's either gonna be leaning forward or it's gonna be leaning back. So for example if I was to use my brain to do this, which is actually harder than it looks, we can just start sort of generating these lines. But if we let the computer do it instead it's gonna be a lot quicker, and we might actually get some really nice effects out of it. So that's sort of how that algorithm actually works. We just split the screen up into tiles and then we just figure out how to actually draw those lines by cutting up the screen into pieces. So hopefully that made sense. So the actual screen itself that we're using, the dimensions are 128x64. So I want you to remember those dimensions because they're like super, super important. And I was going to explain how the screen actually works but I might just leave that until the end if anyone's got questions about it. But because I did write the actual screen library I can actually explain to how it actually is able to take pixel data and stuff like that. But for today maybe we'll just keep going with that. Cool. The screen actually speaks a protocol called I2C. It's actually, I think, technically I squared C, but I always call it I2C because that's just how I read it. But it stands for, I think, interintegrated communication? I think Scanline is gonna know the answer to this. So it's a way of communicating, and it's actually a really, really cool protocol because it's very efficient. It doesn't take a lot of wires, and you get a lot of control over things like the clock speed and things like that. So I'll try not to get too deep in the weeds but it's really cool to kind of know how these devices actually work. So generally you have two different devices. I'm just trying to make sure that you can actually all see this and I'm not going off the edge of the screen. We have our Arduino here. Our Arduino is known as the master. And then we have our screen. [Dan] It's interintegrated circuit bus. Thank you. I always think it's connection instead of circuit bus. So yeah, okay, interintegrated circuit bus, which is really cool. So we have our Arduino, and we have our screen. The Arduino is known, in this I2C or I squared C relationship as the master and then the screen is known in this relationship as the slave. I don't really like the whole master/slave kind of metaphor so I like to call this Arduino the captain and the screen is the sailor. So we're gonna go with them today because I think it's a really cute metaphor. So the captain is responsible for like, you know, sending out commands to the crew on the ship, and the sailor always takes that direction. So generally the captain is controlling the whole scenario and the sailor is just carrying out those commands. So that's like the best way to think of it. And so in I2C we have our regular power and ground but we also have two other connections. This is getting a little bit small, but one is the clock, and the other one is just like the data line. So we have only one line that we need to use in order to send the beeps and boops back. By the beeps and boops I guess I mean the zeros and the ones. And then the clock is an external wire as well because then we can actually, without getting too much into how this stuff works, we can use the clock externally to actually specify the speed at which we want everything to run. I2C is actually a really cool protocol. If you want to read more about it you can definitely look on sites like SparkFun and other sites because it's super, super cool. So that's what we're gonna be using today in order for our Arduino to actually talk to that screen. You don't see a lot of that when I'm actually coding because I've heavily abstracted that, but that's the gist of what's going on today. I guess that's what we're going to do, so let's get going. [Dan] I think we have a camera We hit 30 minutes. Oh no! [Dan] No that's good. Good timing. I think I heard a click. Maybe it was this one. Oh. It was probably the overhead one. So that worked out well. [Dan] So that should be back. And that one now... Because we turned them all on at the same time. I can't believe that was half an hour already. That went so fast. So how are we doing on time? [Dan] Oh, we're fine on time. I think there was a question that I noted at one point. This might have been from a little while ago. Apologies for this mess up in momentum. How much space Well actually I think I might know the answer to this question, I'm realizing. But how much space does Firmata and all these JS libraries take up on the Arduino? Is that a concern to keep in mind? Yeah, that's a really good question. I know that the StandardFirmata C++ script for the Arduino is a pretty big one. Whenever new features want to be added to Firmata sometimes you have to take other features away. So that's why we have StandardFirmata, and then sometimes we have other versions that have extra things put in there. This is an Arduino Uno so it has 328 bytes, or kilobytes of memory, so there's not a lot on there. And so it does kind of mean that Sorry, 32 kilobytes I believe. Yes. So it's got 32 kilobytes. That means that you don't have a lot of room. The good news is that the JavaScript that we're running never actually ends up on the device, so if the Firmata script that we flashed before successfully flashed to the device then we know it's gonna fit. Obviously that matters when it comes to things like if you have variables, or it's trying to buffer a lot of the messages coming through on the device. You might actually see those difficulties as well. So when you're running your program you also want to leave enough room or have enough good data structures in order to deal with the fact that there are a lot of messages coming through that the device has to hold onto for a little bit. So as usual with everything it's always a balance. But that's a really good question. And just to remind you, the JavaScript never actually goes to the device. The JavaScript is simply just controlling the device instead. The JavaScript is just sending opcodes to the device so that we don't have to worry about that huge overhead of how big JavaScript would be to send to it. So the next thing we want to do actually is to plug the OLED screen in and start interacting with it. If I have the overhead camera, sorry. We have a bunch of different wires. Actually let's go back and look at the documentation for oledjs. I tried to document this as good as possible but I'm always looking for pull requests or issues if you find anything confusing. The SDL that's mentioned just over here, that's actually the data line, and then you've got SCL, which is the clock line. I've been pretty clear about if you're using an Arduino Uno then these are the pins to use for each. The reset has to go to four. And then you've got your standard power and ground, which I usually don't document just because it's pretty easy to do a one for one with those. I will actually show that being plugged in before we actually get started. I have my Arduino here. And I have power, ground, reset, clock, and data line. So that ends up being a total of five different cables. But it is actually still pretty efficient. It is still, I think, less cables than SPI. And that's just because the reset line [Dan] I hate to pause you, but... [Suz] Yeah, yeah. Go for it. [Dan] I'm getting a message that maybe we could focus this camera a little better. [Suz] Yeah, let's do that. [Dan] I don't know what I'm doing at all. [Suz] It looks a little... [Dan] That's zoom. That's changing the zoom. Maybe it's on the rim? Oh yeah, probably. Oh, that's focus. Look at that. [Suz] No, wait, is that still... Yeah, no, I'm focusing, definitely. It's just because I'm shaking it. I'm looking at the Arduino, the word Arduino. [Suz] Yeah, that looks way better. [Dan] I think that's pretty good. [Suz] That is definitely better. [Dan] I'm probably not gonna be able to get it perfect but hopefully that's fine. [Suz] Feel free to tell Dan to tweak it as well if you need to. This is kind of The reset wire is not joined to the others so it's usually the easiest one for me to connect first. It says in the documentation that reset has to go to pin four on the Arduino. So you might not be able to actually see this but there is a little tiny four numeral next to that little pin input. And so I'm literally just trying to connect each one to the correct one as listed in my documentation. I like to use red for power and black for ground. So I'm going to go ahead and plug them in because they're always like super easy, especially if you've done this a couple of times before. I just plugged them into ground and power. That just leaves our clock and our data line. Our data line is actually the brown cable. Our clock is the white. Again, you can make up whatever convention you want, but I like to use white for clock because it's just my own little personal thing that I'll always remember. So the clock I believe needs to be pin A5, which is an analog pin. And then A4 is the data line. The reason why we use A4 and A5 is because most Arduino boards come with I2C capabilities built in but they use very specific pins to do that. So for an Arduino Uno, the A4 and A5 pins are your clock and data lines for this particular board. It's not arbitrary. This is how the Arduino board has been setup. The reset pin was just an arbitrary choice by me. We have a lot of this code here already. We just need to write these middle bits here. And so we have to pass some options in to tell it what size screen we have. We have to give it the address of the device itself, which can vary per screen. And then we also have to create a new instance of our OLED screen. We're just gonna go ahead and do that in the code now in order to start connecting to it. [Dan] You're still in the overhead camera. No! Thank you. (laughter) So I'm gonna show you that again. It's just these lines here. We're just gonna be doing something very similar to this but I'm just gonna walk you through it instead of copying and pasting. Let's create some options. And by the way, this is old documentation that's not using the most modern JavaScript, so we're still sort of using var and things like that. It's up to you if you want to pull request that. I have just left it old so that people don't necessarily have to use transpilers to be able to use those new features. But it depends on what version of Node they're using. I think most people are on version four at least now, so that's good. I need to pass in options so that my screen library knows how to control this device. Before I actually put that in I'm gonna establish some constant variables that are not gonna change. I'm gonna call that width. The width is going to be 128 pixels. And the height is going whoops is going to be 64. Yes, that's right. So we've gotta be divisible by eight. That's gonna be the size of the screen. I also want to establish something ahead of time called the tileSize, and that's just because we want to be able to change this and have the algorithm automatically adjust itself based on how big or small we want those tiles. We're gonna start with a tile size of four and we're gonna see how we go. And then I can change that to let you know how that works later on. I keep trying to do my Vim shortcuts. It's like a, what's it called, like a muscle memory. Now we can actually set the width to be width. And a shorthand of doing that in more modern JavaScript is just to list these. Then we need the address. So I know for a fact that the address of this particular board is 3D. You can think of an address as an I2C device's phone number. So you can have multiple I2C devices connected to those analog pins, and if they all have different phone numbers It's not always the case. Sometimes it's annoyingly not that case. But you can have let's say five different screens connected and if they all have a different address, or phone number, you can actually kind of control them all without having to pull wires out and swap them around and stuff like that. Just think of the address as us being very specific about which device we want to speak to that's connected to that I2C bus. Now that we have the address And I don't know why, but I'm a semicolon person, so I'm gonna put some semicolons in. Once we have the options and we've said This is the minimum set of properties you need to give to get this going. We're going to create a new variable, and let's call it screen, because that's actually easier to reason about than OLED. We're gonna create a new OLED screen. I think that's what I called my dependency. And let's pass in the options. Cool. I kinda want to run that just to make sure I haven't completely screwed something up. Okay, cool. It couldn't get the height, and I actually know why that is. I'm not actually using my library properly. So we do actually need to pass in a couple of other arguments. We need to pass in our board and our five instances. Because this is a separate thing to JohnnyFive we actually need to be able to give it those things so that it can actually use JohnnyFive to communicate. So we're gonna go back to the code and we will pass that in. I think it was board and then five. I hope that's right, but we'll just guess. There's nothing like reading your own documentation. I'm glad I tested that because it definitely blew up. It looks like this is okay. I'm just gonna stop this process, and then we'll keep going. We definitely want to make sure, first, that the screen is working but then we want to clear the screen because sometimes when you start this screen up it can have sort of some snow on it, kind of like an old school analog TV. I guess you still get snow, it's just digital snow now, on digital TVs. One of the first commands that I want to show you for this is screen.clearDisplay(). And then we can call screen.update() just to make sure that actually gets sent to the device. Now if we run this, let's see if we can cross to the camera. All I'm really doing is running the same file but if you look at the camera you might be able to see there's a little bit of snow on there right now. You can sort of see that it at least did a thing, and then it's very, very subtle. We might actually have to turn one of the lights out. [Dan] Let's take a minute here to see if we can make this a little better. We didn't really get a chance to test this bit. What I think might actually work better somebody gave this suggestion is I don't know. I'll just call this scene two. Sorry everybody, you're seeing nothing now. What I'm gonna do is add Oh, how do I do this? Video capture device, I think. And then add existing nope. Add black magic device. I'm gonna just put all these in. The laptop is there. I'm just gonna rebuild a new... [Suz] Oh, I'm sorry. No no no no. Don't be sorry, this is exciting. I've never used this before. This is worth trying to figure out. We can always make an edited version of this tutorial, which I often do. [Dan] So green Canon. Look how huge we are. Hello! Now if I make this Ah! I feel like I'm getting vertigo. People actually can see all these changes in real time. Yeah, that's what I love. I've had to fix my stream midstream before too and it's always very interesting. So let's do this, and what I thought I would try to do When it changes what I'm gonna do is I'm gonna add now black magic device overhead. [Suz] Oh, we're gonna combine them. [Dan] I think what might make more sense is just to put this over here. Well you could crop that. And then crop it. So how do I crop it? You hold down alt. I can hold it down for you. (chuckles) And then you just drag the handle. So let's go over to here. Hot tip right there. Is this good? Yeah, that's good. And then crop this. Oops, ah! We can crop this. Yeah, this is how I setup my stream. So take off the alt, right? Now I can zoom this out. I don't know if it looks better if it's kind of like... I have a problem. I can sit here and do this for hours. I'm not going to. If it's just kinda here then maybe that looks good. Now the question is, it's swaying. So is that because this? It might be. I hope we're not making anyone sick. Do I have any sandbags? We might. [Dan] At one point I had sandbags up here. But if we bring up the code they can't see that... [Dan] Oh no, you're gonna have to still switch back and forth. So what you would do is still switch here, would turn that off. And then I would have to map I don't have that mapped to a key. I could do it though. Why not? We're good. We have time. This is probably people's favorite part of the stream. It's the wizard behind the curtain kind of thing. I love it. I'm gonna name this to Noopkat. And then what I have to do unfortunately is go into settings, hot keys, and I'm looking for switch to scene. Put a number in there. Five, great. Now try hitting one. Let me lock all these things. I think I messed it up. Try hitting one. Now try hitting five. I love that I shrink! I think that's a feature, not a bug. Okay, we'll keep that. Now the question is, maybe if I put something heavy... How about a book of random numbers? Oh, I love that book. Will this stop it from It's still kind of swaying. I might not be able to do anything too much. Hopefully though you can see it a little bit better now. And now the question is are we turning out lights, or zooming in more? But focus. Can I make this focus? People are telling me to focus this. It's still a little... Let me put something on the screen, because that was gonna be next thing anyway. Oh yeah, put something on the screen. Screen.drawLine, I'm gonna do zero, zero this is spoiler alert 60. Yeah. And then I don't know, 12. So let's see if the line draws just so that we can actually focus on it I guess. This wire is kind of in the foreground. Oh, is it in the way? I'm learning how to... The line didn't draw. Oh, ha ha ha. I forgot a variable because I don't know my own library. Oh, I see blinking lights. That's exciting. It's in front of us. Oh, there's a line. So you can totally see that. That's viewable. So you might see that the frame rate, the refresh rate of the camera and everything might do a ripply thing. There's literally nothing we can do about that. I'm sorry. I have tried to solve that on my own stream before and I wasn't able to. You get the gist. I haven't looked at the chat. Probably people are commenting how I've done this all incorrectly and it's still swaying. I feel somehow the swaying isn't as bad if it's not the full screen, for some reason, because at least you're grounded. I just love that I shrink. Five, right? Yeah. I love that I shrink. We can also make it fade in between the two but I don't want (mumbling). I'm gonna come back over here. Make the webcam for the hardware small. Okay, no. We just have to remember when you want people to see the code... To hit that? Okay. That makes sense. That was kind of the next bit that I was gonna do. I was gonna draw a line. It's not gonna matter when we do the generative art what orientation the screen is. But what I did was think of this screen as being upside down. If we go back to the code really quick I'll show you that. What we essentially did was we took the method drawLine. The first argument is the starting x position. The next argument is the starting y position. And then we've got the end x and the end y position. So it's basically starting at the top corner of the screen and then it's drawing across almost halfway horizontally and it's going down just a little tiny bit as well. So hopefully that makes sense. I'll just pop that up for you to see one more time. Again that screen is upside down, but that's sort of the general gist of how it is. You know what I'm gonna do actually? I'm gonna flip this, because you can. [Dan] Oh, I have it locked. But I think I can do transform, rotate. [Dan] Oh, it did anyway. Yeah, I was a cheater. Cool, so that actually makes more sense. Let me know if that angle is better. I know some people get a little bit sick depending on whether it's upside down or not. But that is what you would expect there. It's starting at 0,0 and it's going across a little bit and down a little bit. The one here is just what color I actually wanna do. And by color I mean the pixel is either on, and it's shining in a white sort of color, or it's just off. So you can actually draw with negative color and you can just clear out parts of the pixels, which is kind of cool. Just remember that one always means the pixel is on. I do actually want to change this library quite a bit because I did write it a few years ago. I would love to have an enum so it would be something like Colors.White or something, or Color.On, Pixel.On, Pixel.Off or something like that. I think that would be a lot more effective. But I'm interested to hear people's thoughts. Again, raise an issue if you think that you have an idea on that. Another thing that I can do is I can basically tell it not to update the screen immediately. So we can do a lot of manipulations first and then update the screen all at once. We're probably gonna do that today because there's no point in drawing each line individually and kind of bottlenecking the USB connection. So another one we can do is we can say false for don't draw immediately, I guess. [Dan] We can't see the code right now, just so you know. Ugh. I keep doing that. [Dan] You have to click back in. Like the mouse has to be clicked back in the... Yeah. Thank you. No, wait. What did I do? Did I break it? I don't think so. You can always manually mouse to the other view. As long as you click... It should be that you just have to click into this one right here. Now the hotkey should work. Oh, okay. Nice. I have a slightly different setup with OBS, so I think that's why I'm being thrown. Cool. I can show you that method as well, I think, drawLine. Yep, draws a one pixel wide line. And yeah, you can say whether or not the screen immediately updates with the result. So cool. So this is literally all we need in our repertoire today in order to start doing this generative art. So everything else is kind of more like the algorithm, but this is definitely the fastest way to get started with drawing on an OLED screen. I'll show you that one more time. There's the line there. We're just gonna be drawing lines in different patterns across invisible tiles on this screen. So we have our tileSize, and we have our width and height so we're gonna be making heavy use of these. We're gonna be creating just a couple of helper functions as well in order to start drawing this. The first function I want is to create a vector, because we want a lot of things where we're dealing with XY coordinates and you don't really get that in JavaScript. I know that in Processing and things like that you get these really nice classes, like vectors, but we don't get that in JavaScript. I'm not even gonna pass in any arguments to set the x and y. I'm literally just going to return an object that has the x and the y set as zero. I'm just gonna go super simple today. I know this is not necessarily how you would always do it, but this is definitely gonna suffice just so that we don't lose time on creating this very fancy, very correct vector. Now we can actually just get these objects that we can get the x and y values out of. A vector is really just trying to denote a point on the screen itself. The next thing we want is to create a tile. So we need to be able to actually draw either a forward line or a leaning back line, so that's the next thing that we're gonna do as well. I think we might write this first, I guess. We're gonna have another function that does a bunch of loops as well to draw the tiles. So maybe we can just do createArt because that's actually what we're gonna create. These are just my placeholder functions, and then we can actually get started writing them. As you saw on the whiteboard, all we really want to do is kind of split up each screen into tiles and then generate a random number and based on that we're either gonna do the leaning line or the falling back line. Maybe we can just write the function to create the tile. What do we need to do with this? We need to have a random number, right? I'm just gonna call it num. And then in JavaScript I think we can just do Math.random(). And we're just gonna take the Math.random() number because we can use this pretty, pretty easily. We need to now create one of two conditions. We can just create our empty conditions at this point. I'm just really saying if num is greater than 0.5 we want to do a thing. Otherwise we want to do another thing. Let's just set up this rule. It's gonna be super arbitrary because it doesn't really matter which one you start with. Maybe this one is leaning... Let's do leaning forward, because that's a little easier to do for the first time. And then this else statement is going to be falling back. I guess that's the easiest way to do it. Like how do you describe this, Dan, normally? Like leaning forward, falling back. [Dan] I think forward slash and backslash. Forward slash and backslash. Wow. (laughter) That's actually really simple. Thank you. [Dan] Because that's what it was originally was. Oh, like on the Commodore 64. [Dan] Just printing those characters, forward slash and backslash. Of course. That's so smart. My first computer was a Commodore 64 so this is making me feel super nostalgic. I never actually did this on the Commodore 64 though. It might have been because I didn't have the Internet so I didn't really find any of these treasures online. [Dan] There's a whole book just about basically this one line of code called 10 PRINT, which is written by a bunch of different authors. I've talked about it. I don't think I have it here. I want to buy it. [Dan] I have a copy of it downstairs. This sounds so awesome. This sounds so cool. What we want to do is we want to establish two vectors. We want to have the start of the line, an x and y, and then the end of the line, an x and y. I'm gonna create some new variables. We're gonna have start No wait, lineStart. Let's call it lineStart. I don't know what I'm doing. lineStart equals, and then we're gonna create a new vector. We're gonna just manipulate the x and y afterwards. Now I just need an end line. Wait, lineStart. I'm getting so confused. lineEnd. We should have just copypasted this line, but it's cool. It's good to type stuff so you remember it. Now we just need to basically say, like we can set these new values depending on what the random number was, and then we're gonna actually draw the line. I just realized that I'll actually need an argument in here. We're going to need to pass in the screen instance so that we can actually call a method on it. You'll see why we need that later on but I'm just going to do it so I don't forget. If the number is more than 0.5 we want to lean forward. That means that our tileSize is going to need to come into play with this. I think we actually need some more variables to pass in because the tile needs to know exactly what tile it's actually on. I'm gonna pass in a tile vector. We're actually gonna make use of vectors later on as well. Now we can do something like just pretend that that vector exists. We can have tile.x and tile.y. And I want you to think of the tile x and tile y as the top left corner of that tile, where it starts. So that kind of gives us our anchorage, and from there we can start generating lines. This is probably not the correct way to do it as in the book, but this is sort of how I'm gonna figure it out. I'm interested to hear how you do it, but this is how I'm gonna do it. I feel like it's still gonna work out okay. [Dan] There's no such thing as the correct way to do anything. I feel like that too. Sorry if I knocked the mic for everyone back home. I feel like that too but I feel like I'm one of the only people and I feel like I'm from outer space when I'm like, "It doesn't really matter." But let me know if you think it doesn't matter too, because I think it's really fun when you stop worrying about that stuff. If we have our lineStart and our lineEnd vectors, we have our tile start. This is where we sort of want to start doing it. We want to maybe setup our lineStart first. Our lineStart x coordinate, if it's leaning forward, then it's gonna be right in the corner. I don't know how else to explain that, but it's gonna be right at the start because the forward slash is sort of like, yeah. The horizontal starts that way. So if you have a look at it this way you can kind of see that it's starting right in the corner. We can just set that to be the tile.x because that's the starting point of the tile. Then we want lineStart.y. Okay, so this one is different this time because it's not the y right at the top. It's actually the y right at the bottom. We're gonna do tile.y, but then we're gonna add the size of the tile. So if the tile is a square then we're gonna add the tile size. We're gonna do tileSize. And then because the x and the y of the tile, because it actually denotes the start of the tile, it's actually inclusive, so I think we also need to take one away just to balance that. But we'll see if that's correct, because I did this like weeks ago in Australia after I saw Tim Holman's talk. So we're just gonna make this up. Now we need to do the lineEnd coordinates. The lineEnd is gonna be like right towards the end of the actual tile itself because it's leaning forward. So we can just do tile.x, and then we're gonna plus the tileSize I guess, and then we're gonna do negative one as well because it's inclusive. Stop me if this is wrong, because I trust you, Dan. You're much better at this stuff than I am. And then the lineEnd is just gonna be the tile.y because it's sort of ending at the top of the y, I guess. What am I doing? lineEnd equals tile.y, that should be it. [Dan] Yes. I'm hearing encouraging things from Dan right now. (laughter) That's the leaning forward. Let's do the leaning back. The lineStart.x, because it's Let's actually just draw a little line here so that we can kind of reference it. The lineStart x, it's still starting right at the start of the tile again, so I feel like we can just do this. I feel like the lineStart x is always like there. So we can draw the line from bottom up, but we're just gonna do the line from the top down, I guess. So there are different ways to do this because you can draw the line in backwards orders, I guess. The lineStart.y is going to be just the tile.y, right, because it's right at the top. It's the start of the tile. Oop, we lost the camera. That's the overhead camera. I think, right? Yeah, it is, but I feel like all the others are gonna go now. [Dan] It's how I tell time. That's how I know a half an hour as passed. When did we start? We started at like 245. Yes. Yeah, it's been an hour. So it's gonna be a miracle if we get this done. So lineEnd.x. If the line ends right at the far part because it's leaning back it's gonna be tile.x plus the tileSize. I feel like I'm just writing exactly the same code as the other one. [Dan] It should be tile.x plus tileSize minus 1, right, because you're starting at the front? Yeah, that's how I feel. It just feels so repetitive but there are super subtle differences with it. [Dan] I'm behind. What I'm seeing... Is this falling back? Yeah, it's falling back. That's good. That's what I thought. Okay. This stuff melts my brain. This is why I can't do it. It's so funny because hardware is safe and comforting to me and this stuff is really scary because it's so much It's so much math and I'm really bad, actually, at spatial math. I just don't have a lot of good spatial awareness in my brain in general. It's just not how my brain thinks, so I really have to put in a lot of effort for this. It's gonna be at the bottom so we need to plus the tileSize again, minus one, inclusive. And then this is minus one. [Dan] Yes. Yep, yep, yep. That's right. Okay. Now that we have... (sighs) Now that we have that it's the biggest anticlimax ever. It's just gonna be lineStart I never do autocomplete because I'm not used to having it in Vim. lineStart.y. And then it's gonna be line... This is gonna go on another line. lineEnd.x and then lineEnd.y, and then the color is one, and then we don't want it to automatically update. Because we're gonna be drawing so many lines. We don't want to hit this device. And sometimes it can actually overwhelm the devices. It doesn't break the device but it does kind of just bottleneck it and then sometimes the messages just don't get through. That's a limitation of using this way of doing things. If you did this directly on the device in C++ you wouldn't actually see that issue. So that's a tile. Can we draw the tiles real quick so that this stream doesn't go forever? We want to create the art. Again, this is a function outside of our screen so we're gonna just pass in screen. Not screem. This is where we do our classic generative art algorithm, which is a nested for loop. We're going to do let i equals zero, and then i is less than the width of the screen, and then i is going to be plus equals to the tileSize. So it's gonna jump in tile widths. Hopefully that makes sense. And again Dan will stop me if I'm going completely off the rails. [Dan] I'm 20 seconds behind. I'm listening to your audio. I'm seeing the screen here. So this is gonna look super similar. It's just like j is less than the height because now we're gonna go tile downwards. So then we're going to do j plus equals the tileSize again. So we're really just staggering this thing so it just can do all the tiles, stop when it gets to the end of the width, and then do the next row, I guess. So it's doing it row by row, I guess. Sort of. No, wait. Yes, it is. Now I think we can just call... Oh, we need new vectors. So we need to generate what the tile start and end is. I'm gonna do tile equals new vector. I feel like this has now become a speed code. Tile.x is equal to i. You can see that if I actually had a proper vector function I could just pass in the x y. So I realize that that was something that wasn't so great when I created it, but this is still pretty easy to actually fix. So tile.x equals i, tile.y equals j. Now we just need to create a tile. And then we pass in What did we need? We needed tile and screen. Oh, that's it. That's easy. So we create the tile. We pass in our tile object, and then we pass in the screen instance so we can actually call things on it. Is that it? That's it. After we've created that art... (laughter) After we've created the art we need to update the screen now. We've sort of manipulated the screen's buffer, that's sort of what's happening under the surface, it's like frame of pixels. So now we do screen.update() then we're just manually updating it, because when we were drawing our lines we were saying don't immediately update. So I think that's it. I have no idea what I'm doing, but I think this is coming out all right. We need to call these functions, clearly. So I think we can just call them in here. I'm gonna just Whoops. This is a new keyboard so I'm still actually figuring out this keyboard too. It's just createArt, right? Can I just create the art? I think I can just create the art. Is that it? Yeah. So we wrote a lot of code before we actually ran this. Let's see if that actually runs. I am just doing this. I might actually just clear the screen. There we go. I'm just running the same file, and then let's see if it actually works. Oh my God. It actually worked the first go. I'm gonna make this bigger because our tileSize is really, really tiny. [Dan] Cool. I'm sorry, I just want to come in. Yeah, come in and look. Oh wow. Oh, you can see it there. It's just doing the scan thing. But I think people can see it. Let's just change the tileSize really quick. See, Dan? It's not scary at all. No. I have so many questions. It's exactly the same code. So the tileSize Whoops. What happened there? [Dan] I've never seen that. I'm trying to get out of the way. Now I'm over here. Let's do a new tileSize. I'm just gonna run that again. I'm so excited that it worked! Yeah! Yeah! Do you wanna make it even bigger? No, I think that's good. The one thing you can do that's kind of interesting This is just It's just rendering it once? So we've just kind of computed the whole screen and then it was like, "Here you go. Here's all the pixels. "Can you just display the entire screen for me?" If you wanted to animate something... Are you continuously sending the same image? Not right now. You could do that though. You could put this in a game loop. And you might have a pretty limited frame rate just because of this USB bottleneck. But if you wrote the native C++ with the same kind of thing, yeah, you could do an animated thing. Something that's interesting that you can do with the 10 PRINT design is you can just change the probability. So right now it's 50% this way versus that way. We can do it right now. You can actually, since this is all JavaScript and connected you can actually make an interface so you're altering the probability in real time. Even right now if you just go to... I'm standing in the way, unfortunately. But if you go to where num is greater than .5. If you just change that to... Like .2 or something. Oh, I'm so excited. Okay. See, this is where I have no idea what I'm doing. So does that mean it will have more forward ones? Yeah, see? It has a particular quality in that it's much rarer for it to go the other day. Today I learned. That's really cool. This seems so simple but to me I've just never explored this stuff before. I'm looking at... Breathing on your mic. Breathing on your mic. (laughter) That was me breathing. It's me probably. It might be me, I don't know, because I was really excited that it was working. That is so... I don't know how well that I can see it here on the monitor so it's clearly working, but there's something that's so beautiful about it here. It's really nice, isn't it? But this is only So one of the questions actually that's in the chat that came up earlier. You did allude to this before. But it seems to me that this is really wonderful for learning, and figuring out, and making something happen, but it feels... I guess you could have it wireless, you were saying. What if you wanted to embed this in a physical installation? It seems unwieldy to have the whole laptop. Yeah, that makes sense. So I guess your choices would be wireless, or something like a Raspberry Pi? Exactly. A Raspberry Pi is perfect for that if you wanted to still keep the same JavaScript. You can also use a really cool device called the Tessel 2 because it runs JavaScript natively on it. So you still have the same really nice abstractions but you can still use JohnnyFive with it. This isn't always the last step of when you're making a cool art thing. But as you saw, it was so quick to prototype with. And maybe some people are more comfortable with C++. That's probably you. I'm not. (chuckles) In other words, if you're trying to prototype your idea and figure it out and you can do it all the way through in JavaScript. Then when you're done you could be like, well now I don't have to debug it, and figure it out, and choose, make all my design choices. Now I just have the job of porting it. Yeah. It feels like you're writing it twice but what's actually happening is you're just testing the idea out. Because if it didn't really come out that good then you didn't sit there waiting for it to flash every time. You can use whatever IDE you want without having to get PlatformIO working. It's a lowfriction way of doing it. I do that all the time with Even though now I do a lot of my tutorials in p5 and in JavaScript, I'm still sort of like, natively my brain thinks Java and Processing. If it's me by myself trying to try out an idea, even if I know it needs to be deployed to the web, I'll just do it in Processing first because I know I can test and iterate in a fluid way and then figure out the conversion later. Which is so funny, because I feel like we're opposite. I think you're an absolute wizard because you're really good at Processing, and you probably are like, "What is this JavaScript?" Although I've seen you, you're very good at JavaScript too because you're writing neural networks in it and stuff like that. But I do watch people use Cinder and Processing and it's just my natural grab bag. My natural grab bag is like Canvas and JavaScript, or Node.js and JohnnyFive or something like that. There's another question here which is, I don't know if you know the answer to this, but if I'm using an Arduino Nano does the StandardFirmata still work? Yeah, that's a really good question. It does still work. So you might have actually noticed that that screen updates really slowly. The reason for that is on an Arduino Uno I could get away with sending So I'm just sending really, really small packets at a time so that the device doesn't get overwhelmed. A lot of people have said to me you should make oledjs faster, but what's different about an Arduino Nano is that it emulates its USB connection. So its using some of its programming, memory, and like time and cycles to keep that open. So if I send too much it literally just kind of craps out and is like, "I'm not doing anything." So I have to send this in a very careful way. I have done some experiments and I've been able to speed it up by like 10 times but it does make it on the cusp of ruining a Nano or something like that. But yes, the answer is yes you can, and that's because I made my library so small that it does actually work. One question that I have. To me it was interesting to watch this because I'm so used to doing the programming to generate a design like this. But I'm not used to doing the programming to put the design like this in something that isn't HTML5 Canvas, or Processing, or higher level API. In theory though it would be possible. I don't know whether it would be worth doing this or not, but with a display like this there's no reason why you couldn't do drawing to a canvas object with a higher level API and then read the pixels of that canvas one at a time and transfer them here. Yes? Did you already do this? (chuckles) Maybe. You would need some kind of phantom browser canvasing thing. Even with like WebSockets you can have it running in the browser, and then just send the data from the canvas to Node and send it here. You can draw on it and then have the drawing appear here. We have time to do that, right? I wish we had time to do this. I did have a working demo on my laptop of this working, so I'm like, "No!" I have no idea if that link is gonna go anywhere. Okay, one sec. So I do have a couple examples I want to show you really quick, if that's okay. It's gonna take like one sec. I have this thing that uses Canvas where you can make your own fonts for this screen. And it's actually using Canvas. So this is giving you the preview. I'm gonna come stand over here just to be out of the way a bit for right now. What this does is you can put in the font that you want to use. You can do the size. And as you change that it's changing And this is literally a canvas. And then you change the threshold for what you want the kind of the smooth stuff to be. And when you're happy with it, it goes through every pixel in the canvas file and it gives you a font file to download. And then that converts it into a frame buffer JSON file that's compatible with my library. The next thing I want to show you is actually really cool. It's way cooler so I saved it until the end. But my friend hxlnt. Do you know hxlnt? I don't know if I do. She's amazing. Oh, she doesn't have it at quick. It's called oledjsdesigner. So she took my library. Oh, wow. This is exactly what I was just talking about. Yes. And you're gonna lose it when you see this. It's a thing where you can draw, and you can download the image buffer. That's like really, really small. You can download the image buffer. But what I did recently that I had on my laptop that I can't show you is I had JohnnyFive running in the browser and it sent it. [Dan] Like with WebSockets? No no no. In the browser, with WebUSB. Oh. I didn't know you can do that. Well it's really hacky. It's not actually officially supported, because you can't send a sigint in the browser so you have to put it in a WebWorker and then... But you can also do it as a WebSocket. So I can send that to my Node process and update it. That's what she wanted to eventually do with it. I've basically been forking this project to my own GitHub and messing around with it. I've gotten it working with WebUSB, with WiFi, via MQTT, and then also with WebSockets. That is wonderful. I wish I could show you, but hxlint is awesome because she made this. Well, the two things. One is you just have to come back and do another tutorial. That would be great. Or if you're doing follow up with any of this, like coding with it or trying more stuff on your Twitch channel I can point people towards that. Yeah, totally. For me it's like I would love the idea of using the p5 drawing API to say like, ellipse, line, rectangle, create it. Obviously you're limited. It's black and white. It's very small. It's 128x64. It's so much smaller than even that. But it'd be interesting to think about how you... You had to jump through so many hoops just to like draw the line. And so to be able to have something that gives you some of that. Just to allow you to explore and experiment more. Exactly. And I wanted to really quickly show you the FloydSteinberg. I had to make all of these other modules just to get this to work. So I have this thing called pngtolcd, and you give it a PNG. It uses FloydSteinberg, which I had to implement. Coding challenge number, insert number into my voice. Does that look like FloydSteinberg to you? Did I implement the algorithm correctly? It looks like it. So you can basically give it the exact size image you want and then it will actually give you the oledjs native buffer that oledjs uses. And then you can actually do nondithered as well. And then I have a thing saying, "It's not always gonna be perfect." A couple other things. One is people are really This is slightly off topic now. People really want to know about the keyboard. Okay, let's do that. You're gonna have to unplug it probably because we can use the overhead camera. Or you can hold it up. I can hold it for you if you want to explain it. Maybe we can... This is the GK64. I tweeted photos of it yesterday, so if you go on my Twitter account, Noopkat. It is the kit that came with the wooden case so it's really hard to find this. Oh, you had to build this? It came assembled, but it came from Massdrop and they have limited runs, and I've been waiting like six months for this thing. But it is awesome. It's really, really beautiful. Go to my Twitter account, twitter.com/noopkat. And I put a custom set of key caps on it too. So I did actually get these custom. They're just a limited batch bespoke artisanal hipster key caps. But I love this so much because Check out my tweets because I just couldn't stop going on about it and it has like 700 likes or something. But it's a really, really nice keyboard and I've been typing on it this whole time and it is just an absolute pleasure to type on. I love the sound of it. First of all, my keyboard I've been saying, this laptop, the E key barely works. And also I really... I want to show you this actually. So it has these lighting effects. It's not stepped like that. That's just the camera making it look flickery. But it's really nice. I'm checking here to see if there are any more questions. Any hardware list to be able to follow up with your livestream? I'm not sure I understand that question. If I were to rephrase that question, what's the kind of stuff that you typically do on your livestream on Sundays? Is it like this? Are you working on your own projects? Well sometimes I'm literally working on oledjs. Like I've worked on this before. I get pull requests on it. I get issues. I've been meaning to refactor this and modernize it because I wrote it like three or fours years ago. I've learned a lot about JavaScript since then, and just like hardware APIs. I just generally work on my own open source stuff. Something that I work on a lot, and I've been working on this a ton recently, is avrgirlarduino, which is what firmataparty is using to flash the code. And Arduino actually uses this in their Chrome OS editor. So Arduino is using it, which is terrifying to me, so I try and keep it up to date. So that's the kind of stuff that I work on. Most of the time it's open source. Sometimes I'll just play with stuff. There's a question about the keyboard. Can you control the lights of the keyboard in software? Yes. Is there an API to it that you can actually like programmatically control it? I think there probably would be. I really want to write a driver for it in JavaScript now, but that's besides the point. See how I'm hitting that there and there's different programs? So I can cycle through them but you have a lot more control when you use the Windows app. I feel like I have to turn the lights out in here. Just to have a disco. (chuckles) We have like a good 15 minutes, 10 minutes, before we should shut down, so I'm just curious to turn out these lights. And I promise it's really smooth. It's just that refresh rate is... The green screen is gonna go away. It's still nice. So wait. [Dan] This is ridiculous that I'm doing this. [Suz] There's these effects you can do such as when I hit a light it ripples. But let me actually turn this back on. So there's all these different color settings, and then there's the cycling rainbows. Which is so nice! You can fully control this with the actual programming software, but it does come with these prebuilt ones. So you can actually do that if you really want to. But I like the prebuilt ones so far. I got this yesterday so I haven't really programmed it yet. I'm so glad everyone's excited about it. It was so nice to type on because I'm just used to mechanical keyboards now so I brought my own. I think this is an interesting I saw this kind of This is a question from Mitch in the chat. I saw this discussion, and this kind of discussion comes up all the time, I notice, when I'm livestreaming. I turn on the chat and people are discussing the differences between different languages. But the question is how does JavaScript improve Arduino? I guess I think it's an interesting question. That's not necessarily the goal of what you're doing, to improve the Arduino. It's to just have different pathways into doing that, into doing the same thing. Yeah. I actually wrote a magazine article about this but it's not out yet so I can't tell you about it. But it's coming out soon. Just keep an eye on my Twitter. Essentially the only thing that I think JavaScript adds to this, because there's obviously drawbacks to it, is the accessibility of hardware. Did you feel less intimidated as a result of just seeing what happened today? Yes. I mean, yes and no. To me, one thing that helped me, it's just the fact that you were kind of using it to then draw to a screen. So I'm like oh, safe happy place. Draw the graphics somewhere else. So that I, I liked that, whereas I might, if this were more about controlling a servo motor or something. But still, I can see the value of being able to One of the things I love about this is the fact that you're doing all this stuff with Node. For me what I see, what I use Node for, often I see students at ITP using Node for is this glue that binds everything together. So once I'm in Node it's like, oh, I could thereta.js natural language processing Node package. As opposed to if you're just on Arduino, maybe I'm comfortable enough in C++ to write a for loop to do forward and backslashes, like to then reach and talk to anything and use any other packages is pretty, I think, exciting. If I wanted to generate poetry on this suddenly I have Node packages to work with that. That is an excellent point. What you're saying is that instead of having to just rely on the raw processing power that the Arduino has, or the fact that it doesn't have WiFi, if you want to have a really cheap, really low power device, you can just be controlling it with a slightly smarter computer instead and then you have access to all this stuff. That's a really good point, because I can't remember the last time somebody ran a neural network on an Arduino. You're right. But yes, that's the thing. Ultimately there's a lot of limitations here and there's a lot of I hate to use this word, but wasted energy in the fact that there's this whole computer here. Whereas you could just write the algorithm to generate this pattern just on the Arduino itself. But in terms of learning about how this stuff works, in terms of reaching out and talking to all sorts of other things, to be able to have an interface. Now it's possible that we can have a browser instance with an interface that controls everything that's happening. So many exciting possibilities. I'm really glad you brought that up because for me it was usually just about accessibility, but I never thought about using it as a more powerful processor. I don't know how annoying this is gonna be to you but this was requested, to read some random numbers. I can do that. You don't have to read very many, and you can pick whatever you want. (laughter) I love this. I can't do as good of a job Jabrils did. He nailed it. I'll try. I will try. Table of random digits. Just in case there's any really exciting last questions. Table of random digits, page 247. 63056 10872 34173 34711 13630 31285 03621 93974. [Dan] That was perfect. I think that's pretty good for today. I'm just checking to make sure there's Okay, blah blah, lots of interesting discussions. Let me come back over here for a second. What I will hope to probably do, I will confer with Mathblank here in the Slack channel who does video editing. A couple things. One is I know that Suz takes a lot of care to do captioning for all of your livestreams. And this is something that I haven't I mean, I've thought about, and I aspire to do more of, and I have had a lot of really wonderful, generous contributions from the community. YouTube has the tool where you can just log right in and contribute captions, or also the autogenerated captions. But especially, I think you mentioned this on Twitter, especially with technical stuff. What you use here is the service called Rev. So as an experiment for me to learn about this service and see if it's feasible for me to use it going forward I'm going to caption this livestream with Rev. Thank you. Then also I will confer with Mathblank, but sometimes what I often do is take this longer livestream, which has been maybe about two hours? Sorry. No no no no. When did we start? 245. Yeah, no, and hour and a half. That's good. Livestreams are long. Yeah, they are. They're super long. And we might edit this down to like a 30 to 45 minute little just sort of the nuts and bolts of this particular project. So that might be coming. But if you are watching this right now because you're watching this live, or if you're somehow still watching this full livestream as an archive, please check this video's description to find out about Noopkat's Twitch channel, Twitter, her website, all that sort of stuff. You can see it here. I'm standing in front of it. We were talking about maybe I will come and do a little fun thing on the Twitch livestream as like an exchange. That would be awesome! That's what people do in this world of YouTube, Twitch things, I guess. I'm trying to think if there's anything else that I'm forgetting that's important. Thank you so much for coming and doing this. Thanks for having me. I did kind of have My goal for when I started to do this channel, started to get some subscribers, was to have more and more guests to try to show the range of things that people are doing, and range of voices and ideas besides my own little weird thing that I do. So I've had a whole bunch in the last few weeks, which has been really exciting, and I hope to continue doing more of this. So if anybody has suggestions for guests and other people to invite to the Coding Train you can reach me @shiffman on Twitter. If you have other questions about this project... Yeah, hit me up. @noopkat, which is spelled NOOPKAT. You can call me Noopkat if you really want to. That's that. I'm gonna do the awkward thing, which is just Do you have a good system for ending a livestream? Yeah, I usually just wave. But I also want to say this was like a big dream come true for me to be like in your computer, on your stream. I was so excited last night that I dreamed that we went upstate and then we did this on a hill with a big projector and it was like live in person but it was also streamed somehow in the middle of the wilderness. So I just want to say thanks. This was really awesome. You're welcome. Thank you so I do have this sort of dream/fear of doing some Coding Train episodes in front of a live audience. Like live live? Live live. Someday. People are saying all sorts of nice things in the chat. Lots of clap emojis. Okay, so we'll wave. Jabrils would say, "Always remember to feed your curiosity," but I'm not gonna I don't want to steal his tagline. That's just a shoutout to Jabrils. I need a tagline I feel like. I don't have one either. I just wave. Yeah, wave. We're gonna do that. So we're gonna wave, and I'm gonna hit stop streaming in three, two, one.