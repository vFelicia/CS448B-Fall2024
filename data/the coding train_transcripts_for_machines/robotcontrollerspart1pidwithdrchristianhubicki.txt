[MUSIC PLAYING] Hello, everyone. We are starting apparently at about 38 seconds according to the timer. You might have to give me an extra 10 or 20 seconds here. But just let me know in the chat if you're hearing my audio OK. I will be bringing in our very special guest's audio in a moment. So just let me know if you hear me. [MUSIC CONTINUES] Hello. I'm live. Look. I'm going to blow the train whistle, which means we're really starting today's live stream. [BLOWS WHISTLE TWICE] Hello. I'm Dan. Welcome to the Coding Train on a very special Saturday morning. Interesting time to live stream. I hope you're having a nice weekend wherever you are in the world. And thank you so much for tuning in. Just in case it's a beautiful day outside wherever you are and you feel like playing some Frisbee or going for a walk, this will all be archived. You can watch it all back later. I'll be reviewing any of the comments on YouTube after this gets archived and answering your questions. But please, stay with us. Very excited that you're all here. So I'm just kind of vamping here for a minute to make sure everything is going well. I'm seeing a little flickering on my monitor, which is a little disconcerting, but I'm not going to worry about that too much. So first, just a couple of housekeeping items here. I have a kind of entirely new tech setup for this stream, because I have a guest, which I will introduce in a moment who is going to do a presentation, and write some code, and really take over for quite a bit of time during this stream. So please bear with me if anything should go awry. I know that's not a strange thing to happen on a Coding Train live stream. If you happen to have come here for I don't know why I'm burying the lead here. But if you came here because you heard about this stream from Dr. Christian Hubicki who is the guest today, let me just first briefly introduce myself. My name is Dan. I teach programming. And I have so for almost 20 years in various capacities at schools, and workshops, and online now quite often on YouTube. I use a particular piece of software called p5.js, which I will come back to later in the stream. And so if today is one of the first days watching the Coding Train and you've never coded before, I do have a whole intro set of tutorials that you might want to check out. You can just go to the Coding Train homepage and find the Start Learning Here playlist. So anyway, I'm not here to promote myself. That's not what I meant to do. I just wanted to sort of set the table for anybody who might be totally new. Let us know, by the way I see people already in the chat saying, I'm in Poland. It's evening. It's 100 AM Sunday morning here. So I always love to hear where people are watching from, so feel free to drop your location and time zone into the chat. And Christian, you're still there. I can hear you in my ear. Yeah, OK. Great. Let me just jump right in. I have a bad habit on my live streams of going on and on for incredibly long periods of time without actually getting to the code. And I do not want to do this today, because this is a really unique and super special opportunity to bring in a real life robot scientist, if that's an appropriate term to use. If you've watched the Coding Train before, you might know that I have somewhat of a pathological fear of hardware. And I'm not so great with soldering, and programming microcontrollers, and sensors, and motors. And I always want to do more with that. And I hope maybe 2022 into 2023 will be the year for that. This, I hope, is a little bit of a stepping stone for me to be able to bring a guest who has real expertise in working with real life, moving around, physical robots. I first discovered Christian by watching the television show Survivor American reality game show where he actually I couldn't believe that a title of an episode of an American reality show was called "BreadthFirst Search." And that is all because of the amazing Dr. Christian Hubicki. He's got a bit of a presentation and introduce himself a bit more. We've been in touch a little bit. We had some back and forth on Twitter about the Monty Hall coding challenge that I released where we discussed that a little bit. He did a live stream on Twitch coding the Monty Hall problem in Python. And I thought, ah! We've got to have Christian here on the Coding Train today. Everybody's always asking for Python. So we could do a little Python. I have all these videos about nature of code, simulation simulating the movement of natural systems often very much sort of just trying to create the feeling of those systems, not necessarily always reproducing the exact or biological mechanics of those systems through code. And so what I think and hopefully this will lead to many more videos, and coding challenges, and things that I do in my own work. To look at what does it mean to write algorithms, to control the motion of robots, how does that relate to controlling the motion of animated things in generative art systems? And where can we go from there? So there's too much to say about all of that. So that's my quick introduction. I'm going to press some buttons. Hopefully everything is going to work. If we have to take a fiveminute break for me to fix audio things, I apologize in advance. But I'm going to turn it over. I'm going to attempt this first button, which will now put both me and here he is, the famous in my world Dr. Christian Hubicki. Thanks so much for being on the Coding Train. It's a real thrill to have you here. Oh, thank you so much, Daniel. It's great to be here. Once there was an opportunity to do some robot coding in a big public setting, I couldn't resist. This is too much fun. So I'm glad to be here. And I look forward to this adventure together. This is going to be a fun ride, I would say. Awesome. So I just want to make sure that I want to just see in the chat everybody heard Christian OK, the audio, the video is going through. Please let me know. I'm kind of assuming it's fine, because I can see all of the dials and buttons going. So now I'm going to switch over and give Christian the full screen. And let you take it away. And I will be keeping an eye on the chat. And I'll interrupt with any questions or things that come up. Yeah. No, this is going to be a good time. So everyone, thank you so much for letting me be here today with you. I'm Christian Hubicki. I'm a robotics professor. I have a PhD in robotics and mechanical engineering. And I specialize in robot control. So I have just a little presentation for you all today. So this is kind of me during my graduate school and undergrad days. I like putting robots together. But especially I love coding robot algorithms. And in my world, when I talk about robots, I normally break it down into three categories of things that you care about with robots. One is that you have sensors that can sense what's going on in the world. You have actuators that can somehow affect the world. And in the middle is this cool thing called control or a controller. And so my specific subspecialty of controllers that I work with are for robots that walk on two legs bipedal robots. So this is just a little bit of a sample of the work that I've done with my colleagues during my graduate school, and postdoc days, and currently in my laboratory down at the FAMUFSU College of Engineering in Tallahassee, Florida. This particular robot is called ATRIAS. It walks around and balances itself completely autonomously. We just tell it which way to walk. And it walks in that direction. And here's another example of a robot called DURUS that was designed to be a very efficient walking robot. And here it is striding from heel to toe. And we were responsible with coming up with the algorithms for this thing to both stay up and also walk while using as little energy cost as possible. So we would say it's maximally efficient in how it walks. And under the hood, there are some pretty fancylooking algorithms that you might expect to make it go. In fact, we would run these big optimization algorithms that would figure out all the ways to move all the little electromechanical joints on the robot to give it that striding motion. But I'm sure I know what a lot of you are thinking. Where does one buy robot shoes? The answer is the shoe store like anyone else. In fact, we unbolted the robot's foot and took it to Journeys. And this fine gentleman knew exactly what to do, and put it on the shoe sizer, and said, eh, size 14 men's. And he was exactly right. So thank you to that professional. But like I alluded to, many of you are probably wondering how this is put together on a controller side. You think of a controller. You think of control algorithms. You probably think of code. And this is in fact the Coding Train. And you would not be incorrect in assuming that there's code involved in coding these robots. There absolutely is. But fundamentally, control algorithms do not need to even be code. They are much more general than that. They are typically written as mathematical equations. In fact, when you think of control algorithms, you might want to think a little bit less about lines of code operating in sequence and more something like this an equation. So in fact, control theory is often considered a subset of mathematics more than it is computer science, even though there are often very much computers involved in the code execution. So today, we're going to break down control or specifically, this control over here. And where you can see there's a little p, you can see a little i. You can see a little d. This is called a PID controller. And we're going to break this down for you today and as to why we use it and why it's so powerful. And in spite of how complicated these robots can seem, at their core, they're using this. Almost certainly, the fanciest robot video you've ever seen on YouTube, somewhere down deep in the code is something like this equation. And it's very accessible in that we're going to try to code it up today and both in Python and also in these lovely online scripts. I'm looking forward to learning that from you, Daniel. That's going to be a fun time. But to get you started, one thing I want to point out. How to follow along one is that you can make a free account I'm covering up this. I'm doing my own technical issues today. Let me make sure you can read this here. You can make a free account on Deepnote.com. And if you go to Deepnote.com, that is an online notebook that you can start up, that you could run your own Python code from scratch, and you can code up from scratch. But you can make a free account. And that allows you to run your own code and also other people's code. I will be coding in Python today. And I have some base code set up here. And I just made a quick TinyURL link for you to go to. If you go to tinyurl.com/cartpolepython. Python will be controlling this cart pole today. And I'll get to that in a minute. And you can actually run this code by hitting the little Run button. And it should execute. It might take a minute or so. And it will create a little video that you can download and watch. And I'll be coding at this link here cartpolecontrol where you can watch the code change live. And you can make your own duplicate copy of it once you make your own Deepnote account. And that's how I'll be coding today. So with that, I'll go over to my whiteboard and we'll get started covering the basics of the PID controller. There you go. This is a very exciting moment, because I'm constantly using a whiteboard. And I think this might be the first remote whiteboard appearance on the Coding Train. Great. And as you can see, graphic design is my passion as you can tell from how I've set this up pretty well. Yeah, so a PID controller let's back up first about what we mean when we want a controller. The first thing we need to ask ourselves is what do we want to do with a robot. And the example we're going to do today is something called the cart pole. Classic example where you have a sliding I don't know what your whiteboard marker luck is like here, Daniel. But whenever I go to a marker, I'm like, it's never working exactly as I'd planned it to go, even if it's almost like a tech check of its own. Let me do my blue here. So this cart pole is the sliding block. And you can push it around with a force. You can push it with your finger. And you want to balance this pole on top. It's kind of a classic control that we all learn when we're teaching control theory classes when we're trying to learn the fancy ways to use controllers. And what we often want to ask ourselves is what do we want to do. And in this case, we want to balance this pole. So we might say, hey, if our pole is at this angle theta, we want theta to be up. And if you work in radian land, that's pi radians. If you work in degree land, 180 degrees. So you would say, hey, I want my theta desired. I desire theta to be pi radians. And that is what I consider my output, the thing I want to happen. And you can also have an input to your system. And there are lots of different kinds of inputs to your system. And the most obvious input to this system is this force, the force that we're applying. And that is true in that that is the physical input to the system. But in a controller, we will often say as our input our theta desired. And our output is our theta actual. So we have a desired theta. Let's say it's pi. And on our output I'll try to block the glare here. I don't know if I can do that or not. But hopefully. So doing my best here. So say it's theta actual. This is where we're actually at. And we want to get to our desired angle. So when we've achieved our task in a controller, theta actual we'll use red. We're on a whiteboard streak here. We're going to try new markers here. By the way, I'm quite familiar with this problem. That red is beautiful, though, so you're coming through crystal clear. Let's go with that red. All right. So thanks, everyone, as we work through these highly technical difficulties here. We want our theta desired we will put in our theta desired that we choose and that we want this system to go to, in actuality, where we want to go. So from one point to the other. And when we've succeeded, the difference between these things is what? It's 0. We want them to be the same. So we call the difference between these theta desired minus theta actual has a special name. It's called an error. I can't imagine we're familiar with errors here on Coding Train, are we? I'm sure you never get those. We refer to them as happy little accidents. Happy little accidents. The technical term is error. So we say error is equal to your desired minus your actual. And we want to drive that error to 0. We want that to be 0. But how do we do that? What we do is we decide we need to come up with some way of changing our force. So that way, it maneuvers our system to where the error is 0. And to make this problem even simpler for explaining what we're going to do, I'm going to get rid of the pole and just do the cart, which has some mass. I'm just going to care about the position of the cart, which I'll call x. So now I'll have some x desired and some x actual. So at any given time, we can measure where we're actually at. We know it's there. Or we know it's there. We know it's there. And we know what we want. We get to choose it. So at any given time, we can determine what our error is. We can take our desired minus our actual. And we'll call that e to save me this precious deeplooking marker. Let's call it e instead of error. So we need some kind of equation where we assign our force to be equal to something. And one way that we could do this is we can say, I'm currently here. This is my actual position. I want to get over here, which is my desired position. I can subtract them and get my error. And I can say, my force that I apply should be proportional to how far away I am. If I'm far away, I'm going to apply a lot of force to book it there. Once I get closer, and closer, and closer, I release the force. I do less force. So as I get closer, I'm trying less hard. And this naturally should drive this block to my desired position. So I could write that as some constant times your error. So that constant times that error, if I make this my controller, this equation if I start over here, my desired is some large number. My actual is a much smaller number. So desired minus actual is going to be a large positive number. Therefore, I would apply a large positive force and start moving it. And it starts moving. And then all the time, I update what my error is. I'm a little closer. Now ask yourself. Now that I'm a little closer, has my big error gone up or down? It's gone down a little bit. You got a little closer. You're a little closer to your goal. Your error gets smaller. The force you apply gets smaller. You'll rinse and repeat. And you keep running the controller. Just keep running it. And how is this going to behave? This is going to behave like another device which pushes it pulls on you the further you get away from where you want to go. So let's say you're here. You want to get here. This is going to change the amount of force you get [GRUNTS] the more you pull it back. What's that like? It's a spring. So if I start letting that spring act, it's going to go, [IMITATES SPRING]. It's going to go, boyyoiyoiyoiyoing, right? So it's true it gets us there. Not very good about stopping. So how do we get it to stop? So we need more than just something where you have a constant times your error, which I'm now going to label. Instead of a constant, I'm going to call it some constant K sub p times e, which is your error. This is our proportional term. So I'm just going to pause you for a second, Christian, because a bunch of people in the chat are discussing and this is the light bulb that went off in my head. I guess I can quickly go to this screen here, which is that I have a whole bunch of tutorials about these things called vehicles which are simulated autonomous agents that steer around a little 2D canvas. And a bunch of the behaviors are things seek, arrive, path following. And all of those involve this idea of a desired velocity and their current velocity and looking at the error as the difference between the speed and direction they want to go and where they're currently going and then applying a steering force in that direction. That is exactly the same concept as what Christian is formalizing here in terms of the mathematical equations and applying it to robotics. So this is kind of an amazing thing that happened to me that made me realize all the ways that I might be able to expand and augment those examples. And we're going to get to this. You'll start to see this. But I'm really only scratching the surface by mostly just using this idea of proportional control. So anyway, I just wanted to make that connection for any of the viewers who have been following The Nature of Code book project and those simulated steering agents. This is really just sort of peeling back some of the layers of those even further. And we'll see the connections of those more once we bring this code into p5. So I just wanted to mention that, because people were discussing it in the chat. That's awesome. Now, that's exactly the kind of thing this is a core concept that applies to lots of different fields. The PID control is well over a hundred years. And control theory as a field, it goes back to especially the 1800s was a big time for that. But these concepts creep into lots of different things. And it's really intuitive. And let me just break this down a little bit here. We call this a proportional term, because the amount of force you apply is proportional to your error. And how much is it proportional by? We have this constant. Who gets to choose that constant? We do. We're the control designers today. And this constant has a name. It's called a gain GAIN. And we get to choose what that is. And in this analogy of the spring, us choosing that gain, if it's really high, that's a really stiff spring. If it's really low, it's a very soft spring. So that's what that term is. But like I said, in a lot of systems, you put a spring in there, it's going to start vibrating. And we don't want this to vibrate. We want it to come to a stop. So we need to add another term called the derivative term. And it's going to be KD, which is another gain. Who gets to choose it? We do. We get to choose it as the control designer. This is another gain. These can be different and almost always will be different. We get to choose. Times the derivative of de with respect to time. Now, I know I just jumped into derivatives, which are calculus. I don't want to scare anyone who hasn't seen calculus or bore anyone who has already. But all the derivatives in calculus if you ever had to explain and sound smart to someone who's never heard of calculus before. Calculus is about change. It's basically the mathematics of change. And so the derivative is describing how much your error is changing over time. The thing we classically say is that a position that's changing over time if I want to see how much it's changing over time, I take the derivative with respect to time. And it gives me my velocity. So here I'm moving around. I took the derivative of my signal here of me moving back and forth. You would have this velocity going up and down, always moving. It's coming to a stop. If I held my arm out constant, took my derivative with respect to time, something that's not changing. And you're asking how much it's changing, the answer is o. So this is basically saying that we're going to add a term that's not just looking at how far away we are from where we want to get, but how much that error is changing. Now, to give you a little intuition as to how that works. We just talked about a spring, how the proportional terms like a spring you pull back that spring [GRUNTS] boom. It's going to try to drive you to where you want to go. The derivative term is something like a damper. Now, not everyone has heard of damper. Most people have heard of springs. But dampers are very important mechanical systems. My PhD is in mechanical engineering as well. So I'll wax philosophical here. But in a car, if you were driving around and every time you hit a pothole, your whole car goes kagong, kakong and it starts bouncing around. It's bouncing around because there's a spring in your car called the suspension. But not just a spring. There's something in your car that also stops the bouncing. Otherwise, you'd bounce forever. And that's called a damper. And normally, what it is it's a piston. It's a piston that when you push on it, there's a little fluid that you push through. And it resists your motion. And you might see these in your everyday life when you walk around in a building. If you've ever seen a door that if you were to try to slam it shut, there's a little mechanism in the door that might try to stop it. It's up by the hinge that slows it down. That's a damper. And you can even hear the air whistling through it sometimes where the air is the fluid that brings it to a stop. So the d term acts like this damper which gets rid of oscillations. So where we once before had this p term that's going to go boiboiboing, if we add this D term, it's going to slow it down. So it doesn't oscillate as much or at all, potentially. And how big that determines this gain is kind of how goopy our damper is, how much it's going to stop us. If it's very little, it's like pushing through air not much. If it's really big, it's like pushing through molasses. So that's a p and a D term. And we just add them. Now, sometimes in control, this will get us a lot of the way to where we want to go. The blue robot I was showing before with tennis shoes, we used PD controllers on all of the joints of the robot. We had a fancy algorithm that would tell us that, oh, what our desired angles are of all of our motors, this algorithm would tell us, oh, we want to make this motion. But on board the robot, a pe controller was making the motors drive the joints through those motions. That's how it works. So often, a PD control is enough. But sometimes, you want another term. And it's called the integral term. So it's going to be KI integral from 0 to t e of tau d tau. And you add them together. And I'll bring up the equation on the board on my PowerPoint slide, so you can see it again. Is there any meaning to the order? Obviously, you're adding three numbers together, so there's no mathematical meaning to the order. Or is it simply to get the nice PID acronym? Or is that an initial? Is it? So we've got a number of questions you're touching on here, Daniel. So the order, it's just established canonically PID just that's how it's stuck. Probably because you could say "pid." But no one says "pid." People call it PID. And people call it PID. But honestly, the term is the one term I use the least in my work. But it can be really helpful. So the P term gets you to where you want to go or at least it gets you there pretty quickly probably pretty close there. The D term slows you down. The I term, it's useful when you've run your controller, but you are not all the way there. Here's an example. Imagine that this block we're trying to get to there, and we have the P term. But the ground is really sticky. There's really a lot of friction. And at some point, you're driving your PD controller. And you push on it. And so the force is big. The force is smaller. The force is smaller. The force of smaller. The force is smaller. At some point, the force will be small enough that the friction with the ground will stop you before you want to get there, before you're all the way there. And it'll just sit there. It's not going to do anything. It's just like, well, I say I'm going to apply this much force. And then the friction is going to fight me. And I'm just going to hang out there and just forever. And so that means we'll have an error that isn't 0 forever. You call that a steady state error in controls. And one of the most common ways to get rid of steady state error is this integral term. And for those who have not done calculus, an integral is just really adding up the past to get the future. It's hard to see, because my equation spacing is terrible. This is why I wish that they did PDI control, because when I do this lecture, I can do the I at the end and have plenty of space. But it is doing integral of the error, meaning it's adding up all of the error from the past and then multiplying it by another gain called KI. So if you are sitting with this steady state error for a long time, all these other controllers, they are chilling out, doing nothing new. But this I controller's saying, there's an error. I'm going to keep adding that up, adding, adding, adding, adding, adding, adding, adding, adding, adding, adding, adding, adding. And eventually, that will add up enough that it gives us an extra push of force to push us forward again. And interestingly enough, I think I could tie this to one of the examples that I've used heavily in a lot of tutorials and projects is this flocking simulation where birds are attempting these pseudo birds called Boids are attempting to match various match their neighbors in certain ways, like stay together but don't get too close, match their velocity. And I think I was watching one of the PID videos that you sent me as an explanation had this example of if you were driving a car, and you want to drive at the exact same velocity right next to your friend's car if you don't have the integration, you might always trail right behind them. I don't know because you're and so it's kind of like with the birds flocking. We don't use integration in flocking, because the idea is just to match the velocity but stay actually a little bit behind your neighbor. But I'm imagining if we wanted to catch up and be in some type of perfectly horizontal formation, we would maybe need that aspect. Yeah. And these concepts have expanded. It extends well beyond robotics. In fact, these were invented before there were robots. One of the things was the initial applications of PID was ship navigation for trying to keep a ship on course for an autopilot, so you don't need some Navy sailor sitting at the wheel all the time. And that loses interest for me after the first 12 hours or so. So that's where these things are used in a lot of automation tasks but also in modeling how organisms move around. I have the good fortune of going to biology conferences every year just about each year. And people will use control systems like this to model animal behavior at times. So that's the big picture. And that's what we're going to try to implement today with a primary emphasis on the P and the D control. We can do the I control as well, but the P and the D will get a lot of your job done for you. Let's go back to the board. Just so we have these links up for you all to look at, I'm going to be building atop this base code here from cartpolepython here. And that's going to take you to a Deepnote link which should be publicly shared. And you should be able to see. Let me know, Daniel, if you have a hard time getting to it or anything. But feel free to make a free account on Deepnote.com. They have, I think, a hundred hours a month or something you can use for free, which is normally plenty for the tasks that I need to do. And I'm going to be going to cartpolecontrol. Yes? There's a question in the chat, which asks, just to clarify, the constants are positive, right? Are the constants always positive? Obviously, they need to the direction of the error is what's sort of controlling the direction of the force. But are the constants always positive, I guess, is the question we have. The constants should almost always be positive. In fact, I will say always positive. That's a great question. So we will be dealing if you are dealing with negative gains, you probably flip the sign somewhere else in your code. The reason being let's just take this D term. This D term, if it's positive, it is always pushing against the motion of your object. Should be trying to slow things down. Which is good, because then you are taking energy out of your system. If you ever had a negative damper, those things don't exist in real life, because they basically just shoot energy into the system out of nowhere and will drive things to be unstable. So negative gains tend to be unstable. I think there's the classic there's a joke that is the most professory joke I've heard in a while, which is the story of the curmudgeonly old controls professor that the controls professor was always really hard on their students. And by the end of the term, the students who worked really hard didn't understand why they were still being berated for not doing well enough. And the controls professor said, well, when you're in a control system, if you have a negative gain, that leads to positive feedback. And positive feedback is always unstable. So that's why I only give you negative feedback. I don't like telling that joke, because it's the most professory joke I've heard. So basically, it creates unstable systems when you make the gain negative. And for how you choose gains, we're going to do some strategies today that are good heuristics good rules of thumb. But you can take entire courses in engineering departments and math departments on how to choose these numbers. There are some really sophisticated mathematical ways to take your system, take your task, and then these numbers pop out, these gains. But today we'll do it with rules of thumb. Thanks for the question. Let's go away here. So now if you go to the URL that I had before, you should see some kind of interface like this where this is Deepnote. And Deepnote has notebooks in Python that you can write up codes and just execute the notebook. And this prevents you from necessarily having to have your own interpreter on your computer. So this way, you can just go to a web browser and just start working on things. Also, Deepnote is good for sharing books for collaboration. I know a lot of people like Google Colab. That's great too. That's totally a great resource. This is just one I've used for my class in the past. And it also interfaces with some of my really technical collaborators at institutions like Toyota where they're pushing the Toyota Research Institute's doing lots of robotics research that they will have Deepnote versions of, which is really cool. We will have to get into that in a future stream. So what you do is you click on the Run button up here. And then it should run the code at the link that you're at. And what you'll see is that oh, it looks like it should be done. And it will run all this code. And this code is our cart pole. And you'll see at the bottom there's just an image of what the cart pole looks like. But when you run the code, you'll notice on the righthand side I'm sorry. A couple people are saying that the font size is a little bit small for them. Is there a quick way to zoom into the page? Thank you. Good to know. So let's see if I can get rid of that, so that way, we can see a little better. Thank you for letting me know. Let's see if I can make this a little smaller over here. Hopefully this will be a little bit good. Thank you very much. So anyway, thankfully I was not explaining any part of the code specifically. But if you click this Run Notebook button, it will run it over the course of, I think, about a minute just because it has to get the servers to do it. And over on the right will pop up this little thing that says simulation.mp4. And that's going to run that's an animation that you can then download. This is why I especially look forward to seeing how you handle this, Daniel. You have a much more real time way of getting your animations up here. And so I'm going to download that. We're going to run it. And it'll give you an MP4 file that you can run on your computer. And there's this little cart pole where there's a mass to the cart. And then there's a mass on the end of that little pole. And it just swings around. See that? Cool. Right? Currently, zero control in it, though, right? Zero control. So that's what we're going to add today. So the first thing we're going to try to do is we're going to try to control just the cart. We're going to move the cart from where we start, which is at 0. And let's move it to position of 3. And we're going to use the PID controller to do it. So let's go for it. So we'll go back to the code. And I'll give you a little tour of what's going on. So this is code that was originally made by my PhD student Jacob Hackett thank you very much to Jacob that is set up to automatically generate this simulation of the pendulum on a cart. And up at the top here is some code using FFmpeg that's just baseline code to start making how to in setting up how to make a video in code. That's all it's doing. Don't have to worry about any of that. I've carefully partitioned out where you do have to worry about stuff. So here you have all of your libraries in Python. And in Python, a super popular one is called NumPy "Numpi." I don't know who pronounces it in what way. But this is how you do a lot of your good numerics and mathematics in Python and a number of other things that we use. And that's all going to go into basically the simulation part, the thing that is simulating the mechanics of this thing swinging around. Then we're going to define the parameters of our cart pole. And you'll see that there is gravity. There's a length. There's the mass of each cart. Ignore the little popups that keep coming up here. They try to be helpful. They try to be helpful with these popups. And so you can change those parameters around as you would like. And here are some parameters of the simulation. For those of you who don't know how these computer simulations work, they work by taking little time steps in time and saying, hey, I'm currently at this position and this speed. Now I'm going to use what I call the equations of motion and compute how much this thing should move over the next tiny bit of time, some little time step. And that's what dt is. And then it will compute how it moves over that time step. It says, this is where I am now, reuse those equations to figure out where I need to be next, and then next, and next, and next, and then repeat until you have a full simulation of the motion of your system. So that's what this little time step is. And there are many ways to do that. We're using a fairly simple method called Euler's method. That's for another time. Did you ever cover Euler's method on your stream here, Daniel? Is this a thing that I imagine you have to simulate things. This is a frequent discussion. And so yeah, Euler's integration that's the primary integration method I use in almost all of my examples, yes. And we've talked about various other techniques, like Verlet integration, then there's like the Runge cutoff, which I'm always mispronouncing. So it's come up before and is also a big aspect of the various different kinds of physics simulations I've done. Great. So yeah, that's what's happening here. So nothing you haven't seen before. And we do some initializations of our variables. And I think that one of the things that we do change is we can change our starting position of our pendulum on a cart. I said that I'm going to start at position of 0 with a speed of 0. And then I'm going to change the pole angle to be 9 pi over 10, so 9/10 of pi, so very close to pi kind of. So kind of close to pi. And with an initial angular velocity of 0. So we set those initial conditions there. And so that's how we set where the cart starts. And then we get down to the simulation loop. This is where we are taking steps through time to get our simulation, simulation, simulation. I blocked off this handydandy little section here. This is where we're defining our control input. So that's going to be our controller right here. And the level of Python we'll need to use is very simple. So you don't have to worry about it too much if you haven't learned Python before. But if you have, you can tear it apart and do what you want with it. And then down here, we have the actual simulation calculations for the pendulum on a cart. And I know that you simulated the double pendulum in the past, which is a pretty darn complex system. So there are a number of ways to do it. Here we actually set up the equations of motions on a matrix operation that we then solve and then come up with our accelerations for equations of motion. That's what we do here. And then at the end, there's all of the stuff where we define our animation. So any Python wizards or Python enthusiasts or Python learners want to mess around with how the animation looks put a cat on the end of the pole by all means. So that's all that's going down on at the end. So what we're going to clearly focus on, though, is the controller. So let's go back up to our control. And I have commented this up already. So that way, you know how to reference what variables and how. So let's start by just moving the cart to that position 3. So let's have a desired x, which I will label as xdes is equal to 3. And I'll resist not typing a semicolon from my other languages. This is our desired cart position. And we're going to do a P controller to start. So let's do a Kp. And let's just set Kp equal to 50. Kp is equal to 50. Now we need to know what our error is e. So I'm going to define e as being our desired minus actual. I always remember desired minus actual like district attorney by some mnemonic device. Desired minus your actual. So our desired is xdes. And our actual, I gave you a neat little thing. You can grab x_vec i we have to do minus 1 to put in here. So basically, it's our last measured position is what this is. So xi minus 1. So here is our actual force. And notice it says u. And you're going to say, Christian, force doesn't start with u. That's correct. In control theory, control inputs are often designated as a u. That's just the convention we like to have. Control inputs are u's. And so we're going to say, K so our proportional controller is going to be Kp times error. Simple enough. So what I'm going to do is I'm going to scroll up and just run this block I'm in. That'll save you from having to run this block. You don't need to run this top lock every time. This just installs FFmpeg so we can make animations. So you can run the whole thing. That's fine. It'll just do this command. And that's not the best. And are people able to see the text OK enough? Or should we It looks good, I think. Good. Great. I can always make it bigger. I'll just wish I had a bigger monitor, that's all. So I'm going to click that little arrow that was right there. And it's just going to execute everything in the second big block which has the simulation. This will take a little bit. And while it's waiting for the server to run our code, I'll point out that this is going to try its darndest to keep the it's going to try to push the block toward that position, but it's not going to know how to stop. This is the spring attached to our block. And I chose 50. And people say, hey, is that big or is that small? It honestly depends on your system. And is this a sort of idealized system? Is there any friction between the cart and the ground or other forces at play? This is a pretty idealized system. This is a pretty idealized system. There is friction with the ground, but I turned it off, just because for demonstration purposes. But very idealized system, Daniel. Looks like it's done. So I'm going to download this and cross my fingers, see how it goes. Whoa. Hey, look at that. It's a spring just like we anticipated with a little pendulum swinging around. Again, we don't care about the pendulum. So pretty much as we anticipated. So that's the p control. Let's add the d controller here. So we have a proportional gain. Now let's make a derivative gain. Now, my rule of thumb is I try to make my derivative gains about 1/5 of the proportional gain if I'm just messing around, if I don't have any math to tell me otherwise. It's a good starting point. So I'll make it 10. That's our derivative gain the thing that's going to slow us down. And that's going to be proportional to the derivative of our error. And I'll go back to the board and say, well, what's the derivative of our error? And I'll use a little basic calculus. Don't fret if you haven't seen calculus before. If we are taking the derivative with respect to time of our error, and our error swing my microphone around. And our error is your x desired minus x actual. That's equal to taking the derivative of each of them individually and subtracting them. This is just a property of calculus. So this is the rate of change of x desired. And this is the rate of change of our x actual. Now our x desired, who decided it? We did. Is it changing? No. It's just a constant. So we draw a little arrow that goes through it that says it goes to 0. That's zero. Now, the rate that our actual position is changing over time we talked about this before. That's the velocity. That's the velocity term. So our time derivative of error is equal to minus d dt of our actual position to our measured velocity. And in our simulation, we've measured that information. So we can use that directly. So back to the code. So we're going to create de_dt. That's our derivative. Sometimes we would say e dot. Whenever you take a derivative respective of time, sometimes you just put a little dot above it. It's easier. Saves us precious marker stuff, marker magic. And so it's equal to minus the derivative. And we have that stored in dx_vec. So right there. That's the velocity minus that. So we have the ddp. Now we're going to add together we're going to add our d term. So you can say Kd times de_dt. See what happens. I'm going to rerun this block of code and hope I didn't screw something up. I know it will be the first time anyone's ever screwed up a line of code on your screen. So I don't want to be setting any records here. But I guess if I'm going to do something on But you can see how simple that controller is as we're waiting for this to go. You might have thought a robot controller might be a bunch of if then statements, a bunch of catches, a bunch of cases, a bunch of do this, then do that. And that can be in a robot controller, but it doesn't have to be. It can be these continuous little math equations. And while this is running, I'll say that, hey, there's theoretically nothing stopping you from making these gains enormous. You can make them a million. And in the simulation, sometimes that works really well. Sometimes. But on real robots, the reason you don't do that did I screw up something? Do we have that? Kd you run it. I see an error going on here. It didn't like something. Let me just give it a little bit. Run that again. So yeah. Is yours working? I see you put in here it's still waiting here. So you can tell if it says if it's still running, you can tell if it has a little stop, little swirly wheel. And if you go through it, it looks like it errored on the making of the video part, which I sure hope it didn't because that's the part I'm least happy to debug. While it's running, there is I had a question, actually, in my mind. And some people are asking them. I have a good sense of how I tune these kinds of parameters, these constants, in a simulation that I might be doing for a code example that goes on a website or an animation. But you're dealing with and maybe this is what you're getting to real physical objects. You have it on too big. It could like crash and break. So how do you what is the process for tuning all of these parameters? Do you actually do a lot of simulating first on a computer before you apply it in physical reality? So the short answer is yes. When we can, we try to build a simulation of a robot and try to get gains on it. Now, we know that that simulation will be imperfect. I don't know if this has been said on your channel, but I know it's been said a million times in all kinds of engineering and sciences. But all models are wrong. But some are useful. But some are useful. And so we'll have a simulation model, and it will tell us if we're in the right ballpark. But you will almost so that will give you a good first guess for the gains. But I will say and we do this with our robots all the time some of the robot testing is exciting when it's trying to walk. Some of it's incredibly boring where you'll have a hardworking student will go to the robot and take its arm and will just try to jerk it a little left or to the right, a little bit. And what is he doing? He's tuning up the gains. He's starting very, very small, so it's applying almost no force, and then almost as a knob, dialing them up to where he expects them to be good and where she might say, OK, that's good. That's about to the range where I expect that they'll be good, but is it good? Does it need to be a little tighter? Does it need to be a little looser? So there's often, in robots, a little bit of manual play. And that's fine. So let's see. Did this run here? I just ran my simulation. Oh, look at that. Look at this. Look what's going on here. This is awesome. Look what it's trying to do. So it is trying to keep it in that position there, but it's actually got a little disturbance on it. You see that? It's the pendulum being whipped around at mach 3, and it's still trying to hold that position even though it's jittering around. So it's trying to do its best to hold it there. So we did it. I would say we effectively did it. If we didn't have that pendulum on there, it would be almost perfect. So that's a very simple control of the cart. Now, what we really want to control, though, is the pendulum. And this can be a trickier proposition, or it can sometimes be a simpler proposition where we're going to say we want to apply a force that is proportional to the error not of the cart, but of the pendulum. Can you show sorry. Can you show the TinyURL link again real quick? A couple of people were looking for it. You got it. And I failed to get it into the chat. I will put it in the chat. So you can find me so right here, currently, I'm coding on tinyurl.com/cartpolecontrol. The base code you can edit is at cartpolepython. Oh, actually, my face is in the way. Let me get that out of the way for you. Cartpole. I'm putting it into the that chat now, so Yeah. So we can put that maybe in the description or whatever we want to do. These questions are great. I welcome them. Another question came up, actually. I was sort of saving some for later, but since we took a moment to chat here for a second. A lot of my viewers, I know, are people at least I wouldn't say viewers, but also students that I work with at NYU in particular, work with Arduino a lot. And is this a particular is that a microcontroller that you work with at all in your lab? And is the PID controller algorithm something that could be applied to an Arduino, controlling a servomotor or something like that? Yeah, so we do use Arduinos all the time in the laboratory. They're great for especially small robots when we are just trying to prototype something or a proofofconcept robot that might be for a scientific test. I remember I had to make a maybe this is a story that would tie a few things together. I remember when I was on Survivor, as you were mentioning. There was a challenge where it went on for hours, so I had nothing to do but talk. And one of the things when you watch the episode of if you're watching the show, you can't miss this challenge. At least it'd be hard to miss this challenge. If you're watching, you'll know which one I'm talking about. And I mentioned that I had to design a plant root robot, a robot that was basically a growing plant root that would move into soil. And this was a scientific study for trying to determine what strategies for how roots grow would be best for penetrating through different materials. And it was specifically in collaboration with a group at Duke that does genetic knockout studies of plants and noticed that there were some ways that plants grow that they grow straight, and sometimes, the root wiggles at the end. And that wiggle was something that showed up in plants that they could knock out and try with real plants to see if it's better at growing. But they wanted to also try it with a robot. And so I made this motion this wiggle is called circumnutation, circumnutation. And so we used our Arduino to control the wiggle of the plant. And there, we used something called a stepper motor. And a stepper motor, you can just tell it to click one wheel at a time. It'll just click to a position. And so you don't need a PID controller just to do that, the click to a position. However, if you have any kind of motor where you're applying current or a torque or a voltage that you control up or down, PID control is great for that. But I also got the project I was talking about during that challenge was using an Arduino to control the circumnutating plant robot. So yeah. All right. So it looks like that so that ran, and it managed to hold that position at roughly 3. I bet if we if you could turn off the pendulum by making it massless or very, very close to massless, if you went up to the top if you went to the top of the code and changed the pendulum mass to, like, 0.001, it would probably do extremely well. So now let's try to control the actual angle of the pole. So let's go well, maybe we can make this super easy. So instead of having an x desired, let's just have a theta desired, an angle, so thetades. And we're going to make that theta darn it. It teleported me in the code. All right. So thetades so we want our desired theta to be pi, so not down to 0. Up is half a rotation. Half of 2 pi is pi. So in Python, you have to say np.pi because the NumPy package is the one that tells you what pi is. All right. And now we're going to come up so now we to say our error now, instead of being xdes minus xvec, it's thetades minus thetavec. And de_dt, instead of being dx_vec, is dtheta_vec. And we'll see how this works. We'll see how this goes. I'm just going to run this block of the code. I don't need to scroll up. I just click that little arrow over there. And we'll see how this works. I haven't tried the set of games before, so your guess is as good as mine as to how this goes. But yeah. And you sorry. I was answering questions in the chat while I was halflistening to you, so I was curious. So you had to change both obviously, you're changing the desired in the error to calculate it based on the angle, but now you're also looking at the angular velocity of the pendulum, no longer the velocity of the cart itself. So the cart's position plays no role anymore, its position or velocity. You're only looking at the you're sensing, basically, just the movement of the pendulum. That's exactly right, Daniel. So yeah. So we've now changed it so we're just caring about that thing staying up. We don't care where the cart goes. It's like if we are balancing a rod on our hand. We can move our hand all over as long as the thing stays up. All right. It looks like it ran. This time, it didn't error in that weird way that I can't explain. The first time that's happened. Let's see. All right. Let's see what happened when it ran. It's trying to catch up. There it goes. It really doesn't care where it's going. It really doesn't care. All right. So it didn't fall down, at least as far as we knew. So we can mess with the gains a bit more. And we can also start where let's have the cart start a little bit closer to the top. So maybe it doesn't have to make as much extreme maneuver while we're trying it out. And this is a good strategy if you're trying to test out a controller and you want to know if you got it right at all. Try to get it started off really close to where you want to go and see if it'll get it there. And then if it goes wild, if it flails around anyway, you know you probably are doing something wrong. 50% chance it's a sign error somewhere. You have a negative where you shouldn't. So I'm going to make did I rerun it? OK. I'm going to stop execution. Didn't mean to run it. So I'm going to change instead of I'll go up to my initial starting position, where instead of having 9 over 10 pi, I'm going to change it to 9.5 out of 10 pi, so pretty close. We can even go 9.8 out of 10 pi just to see if it works. We run this code here. And what we should expect at least what I expect to happen is that it's keeping the system pretty close to up. It keeps it from going down. Now, if it runs off to the distance, what I'm going to first try to do is increase my p gain. Because what I want the system to do is to push harder on the cart when there's an error, so that way, it might push it past where the pendulum is. And so it might start going back. But we might have to play around with that a little bit. But I will point out the thing hasn't fallen down yet. So good. That's not too bad for gains we just plucked out of nowhere. You just need infinite space. Yeah, just infinite space, right? And so this will be the game. And one thing I think will be fun when you're doing the JavaScript version of this that we have ability to rapidly try new things. Yeah. This is I am learning so much and fascinated and just enjoying this so much. But the amount of time between changing a variable and seeing the results is very painful to me because that's so that's why I'm so excited for this collaboration, because I think there's some well, JavaScript and the browser obviously have a lot of limitations in terms of scientific computing to be able to quickly demonstrate and change we could interactively change the game with a slider, for example, and have it continue to run. So anyway, we'll get there. No, it's fine. And I'll point out that, hey, look, it managed to balance the pendulum. It was a little bit of an error, and it managed to actually looks like it managed to stick it there. Yeah. So it balanced it. And so at least those gains at least worked in principle for the small error. Now we can tune them up in JavaScript, and that maybe will be our next step. But before we go there, I'll talk just a little bit about the integral term, the integral term. Because sometimes people are like, how do you do the integral, Dr. Hubicki? And that's often the one that gets people just a little bit confused, and justifiably, because it's a little bit more complicated. Because you actually have to start keeping track of how you're adding up, over time, this error. So you need some kind of variable in which you are storing this addedup error. So let's do that. And I'll add this to our I'm going to have to actually made some changes to the base code in order to do that. So what I'm initially setting up here are what I call state vectors. And these are vectors, just lists of numbers, that are storing the position over time, the velocity over time of all the things that are moving around. We're just going to add another one for the integral of our error. So I would say we can even simplify it a little bit more. So we're going to say right before the simulation loop, we're going to say our initial error integral is 0, a creative variable called error.int. And this is just above the simulation loop. That's what we're doing this. Equal to 0. And then inside the loop, we're going to create we're going to update our error.int let me just call it error.int as being equal to the previous error.int plus the current error times you remember that little time stamp that we talked about in the simulation for this tiny little step of time? We're going to multiply it by that. I believe it's dt. I'm just going to check and make sure that's the right variable dt. So a 1,000th of a second, this tiny little period of time. dt. There we go. There you have your error integral. Now, what else do we need to add an integral term to this controller? Well, we have we have goodness. Teleported me again. You have a gain for your proportional term, gain for your derivative term, a gain for your integral term, so Ki. And we'll make it 1. This is often my smallest term, my smallest gain when I'm doing PIE control if and when I want to use it. It's the integral gain, which I have a disorder in which I could only spell it integral every time, integral. Every time I spell it wrong. So integral gain. So then we add this term, so Ki times error_integral. Done. That's our integral gain. So now we have p, i, d, all three components. And if we decide we don't need i, guess what we can do? We can teleport away and then come back and then do what I was going to do in just a second. We can make the integral term 0. Doesn't exist. Turn it off. So I'll do one quick run of this. And I think that that is the core of what we need to start doing this in JavaScript. Yeah. I've got a few questions that I've been noting down. Well, I guess while it's running, maybe I'll ask you some of them. Yeah, perfect. I have no idea what this means. Somebody asks whether this relates to something called an LQR regulator. Is that something you recognize? Is that a term you recognize? It absolutely is. We have some ringers in the chat today, the LQR regulator. So the short answer is yes. And I mentioned before that we're picking gains. And there are these rules of thumb we're using, but there's an entire mathematics to choosing gains more intelligently. So that way, theoretically, you don't have to guess and check. With a robot, I can do a little bit of guess and check. But what if I was doing gains for a power plant and observing how much I'm going to open the valve that's going to the coolant? You don't want to guess and check on that. However, if you have the equations of motion we'll call it the system dynamics of your system you can use control theory to come up with the gains, one of which is called LPR is one method for doing that. That's a method of what we call optimal control where we instead of defining just where we want to go, we define what we call a cost function, which we say, oh where we define how much it costs to operate our controller. And so that could be saying that we have a cost that penalizes how far we are away from where we want to be but also penalizes how much effort we use to get there. And this is the proportion that we want to care about both. And theoretically, LQR, if you run this process, will give you the optimal best gains to minimize that cost. And that's what LQR does. So it will give you the PID that's absolutely best. But it requires us to do a little bit more math and to take the system the methods of this pendulum on a cart and do some little bit of trickiness with it. Yeah, it's interesting. One of the things when I was poking around looking at this topic I saw a paper about using genetic algorithms to evolve the optimal gains for PID. So I think there's lots of interesting methodologies you could use to tune those parameters. Yes. And they all have strengths and weaknesses. So the LCQ, it stands for Linear Quadratic Regulator is what it stands for. But if we break down what that is, that first word, "linear," says that your system should be what we call a linear system, meaning that you put in a little bit, you get out a little bit. You put in a lot more, you get out a lot more. But the pendulum part of this is not a linear system. It's not linear because if I put a little bit of effort when the pendulum is at the bottom, it'll move a little bit and come back. If I put it a little bit of effort when the pendulum is at the top, it's going to go crazy. So it's nonlinear. So theoretically, the LCQ doesn't work. Now, in practice, we're good at making it work. In control theory, we learn ways to linearize the system, pretend it's linear. But genetic algorithms don't care, much like the Honey Badger. The genetic algorithms you can give it whatever you want, and it will try to come up with a solution. But you don't have those guarantees. LQR mathematicians from 100 years ago figured out the proof that says these are the best gains for that system. So it's this balance between what you can prove and what you can do. So it looks like the [? i term ?] didn't do much. It didn't kill the system. Didn't do much either. Still going. But we can balance. I think this is a good time to hand it over. What do you think? Yeah, no, this is perfect and a good segue here in that a good segue in that there's some other questions that maybe we can come back to towards the end that I've been noting down here. But a lot of the discussion in the chat, which was super interesting to read, was, oh, I think I saw somebody try this in Unity. Or, oh, you know what you could do? You could use Pygame. So if you wanted to have it in Python but have it be real time and interactive, you can use Pygame for that. Absolutely. This is really, I think, where we're going now with this stream. I'm just so excited about this topic that I have to my eyes are too big for my stomach, I think, is the right, maybe, metaphor here, that I just want I want to try to work in JavaScript and P5 to take a few steps towards beginning the idea of an interactive simulation around this topic now that we've been taught about it in such detail. But I do think it's something that I would really like to come back to, and we can maybe do some additional live streams, or I might make some I really hope to do a specific coding challenge video about a PID controller. So yeah, so I think this is a good time to segue. Let's see if I can press this button. Hopefully this works. Great. So now what we're looking at is and I'm just going to make Christian a little bit smaller here to not block the code. So does my voice pitch get higher when you do that? Is that how that works? It's funny. I have a video about there's a JavaScript array function called reduce, which is a way to summarize an array of numbers all into one value. I mean, that's a very crude way of describing it. [LAUGHS] I have this shtick where I keep making myself smaller in the video. Nobody should watch that one. That should be deleted from the internet. So let's see. So a couple of thoughts here that I want to just begin with. So one is oh, so before I go on, though, everybody stick with us. If you have somewhere to go, don't worry. This will all be archived. You can come back and watch it later. After the stream is over, I'll make sure to update the video description with all of the links of Python code that have all been demonstrated as well as any other extra material. And then we'll also make sure we share on social media. Speaking of which, just so we get this now for anyone who's here, if you look at the video description currently, you will find Christian's Twitter, Instagram. Probably what I would really like to highlight is Twitch channel, where, if I'm not mistaken, you do a bunch of different things, but sometimes popup lectures on various topics related to science and robots. Yeah. Actually, I should plug those things. So I do occasional Twitch streams, which I'm still figuring out how to save videos on Twitch. But I'm doing it. I'll sometimes just run to the whiteboard, and I will put a concept up there. And we might throw together some code or just turn it into a lecture or just a Q&A session about a number of topics. So feel free to follow me on there. And I look forward to hearing your feedback on Twitter or any of these platforms. And I encourage you to use all kinds of ways of adapting this code. I'm doing it on Deepnote because we use it for other things. But copy that code. You can put it on your own PyCharm on your own computer, whatever will run it faster for you. That's all great. So I welcome all that. So I appreciate your patience and listening to the lecture. No, this has been fantastic. And we're not saying goodbye. I just wanted to make sure because I know sometimes these streams, they go on for quite a long period of time. And I try to wrap up at the end. But I wanted to make sure that people who wanted to know more about Dr. Hubicki's work and follow the labs research, you can find all that. And again, after the stream is over, we'll make sure to update the description with all the stuff. And of course, you can join the Coding Train Discord where we have discussions and sharing about the various topics. So you can ask questions and things there. So I'm going to start to jump in. I don't know what the ratio of people who came here from Python and robotics control versus people who came here from creative coding and p5.js. But just to set the stage for a moment, what I am going to transition to doing it's funny. I think that my output is a little bit it has the night shift on for some reason, so the screen is a little bit I've never seen this before in this setup. But anyway, it's fine. You can see it. But I'm going to use a library called p5.js. And p5.js is a JavaScript library for what is referred to as creative coding. It's a very broad term. But essentially, if you're interested in art and design and animation and play and experiments and games, it's a very beginnerfriendly environment for doing realtime animations and graphics and more in the browser. I also think and I'm a little bit torn about this, but I am going to start with this physics library called matter.js. So I've been going back and forth in my head all week about this. If you look at my I'll just pull this up here in case you're not familiar with it. But if you're new to the world of physics simulation in JavaScript, you can take a look at this particular book that I have online all about vectors and forces and oscillation. And if I scroll down in here, we're going to find all about pendulums. And so this is a whole book that is the foundation of a lot of the coding examples and tutorials that I do. And for the most part, I am always coding these it's wrong to say from scratch because I'm using P5 and all sorts of other dependencies and libraries. But I'm not using a physics engine. I am doing, though, what Christian referred to as Euler integration in the code. And in fact, I'm just going to pull up this example really quickly, which is about the seek behavior. If we look here where is the update function? This is Euler integration. We take the acceleration, and we add it to velocity. We take the velocity, and we add it to position. And we're accumulating all the forces in the apply force into the acceleration variable. So I would like to investigate PID controllers as they are connected more to the raw physics simulations in nature of code. But I think I'm curious to see, how does just applying this concept in a very quick and dirty way to a basic example that uses a physics engine and to be clear, what the physics engine is doing is I'm able to just say, hey, there's a round thing over here. There's a square thing over here. There's gravity. And I'm going to put this force in this system. Go. So we'll see how well this works. But can we set up a little cart on a ground? Can we apply forces by pushing it right or left and giving it a calculate those forces based on PID control? So that's my goal. I don't know. Do you have any comments or questions about that, Christian, as I'm setting this up here? No, this is great. I'm very excited to see all the new ways to and as you're getting that set up, sometimes, some of the bringup process for when I'm trying a new system is the time it takes for me to code up the simulation. That's the first step that we have to do when I want to try to code a new robot in a simulation, is I need the simulator. And I think there's a lot of room for interesting ways to generate physics simulations. Sometimes I'll go straight to the equations. But jeez, it would be good to do something where you pop in stuff in the system, and they just bump around and go from there. So that's exciting. Great, yeah. I'm really stuck on the fact that I'm going to have to just let it go, but something is going on with my screen. Look at the top right here. This is not the correct back bar. Some weird glitch just happened, and night shift turned on. It's like it thinks it's the middle of the night, and I should be sleeping, so it's reduced to blue light or something. But I think we'll be able to keep going. If anybody knows where that setting is and wants to pop it into the chat, I might like to fix that. But OK. Well, you're a professional that cares about that sort of thing. I was like, I didn't even notice until you told me. Yeah, well yeah, I'm recording everything to disk, also, from today. Because as the viewers know, I often take content from live streams and remix it into a shorter edited video, which I was thinking about maybe doing. And so it'll bother me forever that the recorded you know what I can do? I'm going to let it go, though. It's going to be fine. Because I know where to turn this off. But look, this if this is the only time wait, wait. This disappeared. System yeah, see, my System Preferences is frozen. I have the rainbow of death here, spinning rainbow of death. So I'm just going to force quit out of that, not worry about it. And you can change it in the Control Center, I know. But look. The Control Center button is missing. It's disappeared. Control Center. Yeah, Elgato. So I'm going to if anybody has trouble seeing what's on the screen, let me know. I think we're fine. All right. So I have put the pinned comment in the chat and I should have done this for the TinyURL link from earlier is a link to this particular P5 sketch. So again, I whoops. Whoa! Things are just appearing out of nowhere. I wonder if I should restart my computer. Look at that. That's interesting. I mean, if you want to handle that, I can always I'm engaging in the chat right now if anyone wants to jump in. And if you want to handle that business, I can talk about this sort of thing. I'm going to restart. I'm going to ask you one of the questions that came up which I was kind of curious about. Somebody asked whether you could use PID to land a rocket like a SpaceX rocket. And I was actually curious. I don't know if I've been following the James Webb Telescope with all the images that have been coming out. And I know there was so much that went into the design and engineering and production of the telescope and the fear of any little slight angle of a mirror setting up. Do you know to what extent does the work that you do in robotics research apply to these kinds of mechanics that happen in space, I guess, is what I'm asking. So yeah, I am interested so the short answer is reliability of controllers in space is super important. And I need to be more up on what is actually being used on some of these particular spacecraft. But something like landing a rocket, you look at how that if you watch a SpaceX selflanding rocket, you can almost see the PID in action. Now, under the hood, we don't know exactly what's being used necessarily. But a lot of different control techniques, even if they're not explicitly PID, they end up acting like PID. If you need if we want it to be slowed down, we'll start applying a force in the opposite direction. Now we're seeing in the chat there's something called MPC, which is called Model Predictive Control. But what MPC is is it's basically, more or less, acting like PID, except it's able to reason about the fact that you might have limits on how hard you can push. On our PID controller, if you had a limit on how much force you could push, it would try to ask for things beyond that limit. And it might not be able to deliver, and so it will do the best it can. However, there are methods that will understand that I am limited in how much force I can do. And that's going to require me to think ahead and push more later because I have to push less now, for instance. So even if PID isn't used directly in all these cases, the core principles of it are often present. And I would not be shocked at all if, in these space settings, that they will be using PID to orient different elements of the spacecraft. But one thing that they also want to be careful about is if something fails on the spacecraft, that it still works. So one thing that a PID controller requires is that you have sensing, that you can sense what your angle is. And I guess, what happens if that sensor is gone? Is the whole spacecraft down? So a lot of the very bright mechanical engineering things is that they'll try to make this idiot proof, that even if the sensor is gone, you just have to apply a torque, and then it will go against a hard stop. That way, you don't have to have a sensor. It just deploys. And that's not just PID control. This is any form of what we call feedback control where you're getting feedback from sensors. You're getting information from the sensors. Has that component and inherently adds at least a little bit of complexity. Yeah. That's great. Thank you. And look, thank you for talking through that in that beautiful amount of time of restarting the computer. The menu bar thing looks correct, and I no longer have that slight tinge to the hue of the screen. So we're back and ready to go. So I also just wanted to I'm going to jump back into that matter.js sketch. But I just wanted to show here that this is the seek example I was referring to, which is this simulation of this steering vehicle that is attempting to seek this target, which is a red dot. And little did I know, really, all along, that ultimately, this seek function is essentially which is what I've covered in great detail in many videos is this is the error. I am looking to find the difference between the target's position and my position and creating a force out of that, scaling that force according to this max force variable, which is much like the gain in the PIP controller, and then applying that force. So we're going to do something similar, but I'm going to switch over to using matter.js and looking at the cart pole scenario. So let me stop this. So if anyone is interested in that, hit me up after. I'm sure we'll get through some nice online searches you can find, the Nature of Code book and the Nature of Code videos and all of that. But if you're interested in going down that road and you can't find it, let me know in the comments or in the chat, and I'll be able to answer that later. OK. So let's take a look. I put a little sketch together at first just so we didn't have to in a lot of my video tutorials, I always like to try to show the entire process of coding something. But I wanted to at least have a foundation to start with to try to save a little bit of time here. Let me show you probably the most important piece of this, which is that and I'm actually not using all of these, so I'm going to take these out now just to simplify. Whoops. Maybe I was using one of those, and I didn't realize it. But I'll just leave that in there right now, and I'll figure it out. But the important part that I wanted to show you is I'm importing both the P5 library here as well as the matter.js library there through the CDNs, or Content Delivery Networks, where the JavaScript libraries are hosted online. So this merits a longer discussion in terms of how you build all the components of a web page. But the P5 Web Editor, for the most part, will really help you along. The only thing you need to add if you were starting from scratch with the P5 Web Editor is this link to the matter.js library. And hopefully folks in the chat can help answer questions about that if you're struggling with that. Oh, I need Matter Helper. That's right. I just can take these out. So was simplifying this sketch, and I left a couple of things in here that I'm going to take out now from a previous example. So one thing I'll also note is that there's this JavaScript file called Matter Helper that I made. It's a little bit silly. But anytime I want to refer to something in the matter physics world, I have to access it via the matter namespace, like matter.engine, matter.render, matter.world. And so I made all these little aliases to each one with just the single word "engine" or "vector" or "constraint" or "body." And I'll talk through what each of these are as we start to build the code example itself. But this just allows me, in the code as I go back to here, to say things like create an engine as opposed to matter.engine.create. Least important detail of today, but a little helpful thing. OK. So let's look at what's happening. So this is the setup function. And I actually made the font a little bit smaller than I usually do because some of this code is kind of long. Let me see if I can up it just a couple of points. So let me know if anybody has any trouble reading the font. So the only variables I'm starting with right now is I have an engine. That's the physics engine that's going to handle that Euler integration, all of the figuring out where the bodies move and how they move for us. I need to also store in a variable the world associated with that engine. The world is basically like a variable holding on to a big list of everything that exists in the world that we've created. So you could have multiple worlds and do all sorts of interesting things, but we just have one world. And then anytime I want to make something in the world, I need to create it as a shape. It has to have some geometry. I don't know what these weird underlines are showing up now too. There we go. But I'm going to ignore that, all the weird extra things that are happening today. So I want to make, for the ground you can see I'm drawing it there this rectangle. And this will be very familiar to any of you who use P6 regularly. But for Christian watching or anybody else who comes maybe a world of more true mathematics, this canvas that you're seeing on the right here, it is a Cartesian plane, but it's a very odd one. First of all, it's very typical of computer graphics but odd in the mathematical sense. 00 is up here in the top left, not in the middle, and the yaxis is pointing down in the positive direction. So that's quite standard for computer graphics but odd if I were doing like a lesson about a pendulum. We would draw a Cartesian plane and point y and up and have 00 in the middle. So that's where this rectangle is positioned at. 200 is the x. 295 is the y, very arbitrary number. It's about there because I wanted the ground to be the full width of the window, the canvas, and have a height of 10. I gave it a little friction. Restitution is a variable that refers to the bounciness of it, the elasticity of it, if you will. And then I'm saying it's static. It's something it's like an object of infinite mass that can never be moved. So that's the ground, and that's where we're going to put the cart. I also just added a couple of variables to this ground body so I could store there might be a way to access them through Matter. If anybody knows, feel free to let me know in the chat. But I just put the width of it in a variable called W and the height in 10. Because what I'm doing here in the draw loop the draw is that same animation loop that Christian had in the Python code, that for loop. But here with P5, because we have an animation program that's showing us every frame draw shows us each and every frame. So every frame, we want to update the physics engine and draw the ground at its x position, its y position, with its width and height. So let's look at just adding a cart to the system. And Christian, you should absolutely stop me if you have a question or if you notice a question from the chat. I'm not keeping as close an eye on it. So let's add a cart. And I'm going to do the same thing cart equals bodies.rectangle. Let's put it in the middle. So I'm going to do a little mental arithmetic, which is I don't know if you've ever experienced this it's really hard to do when you're suddenly live broadcasting. You're sitting at home, drinking your tea. 295 plus 5 equals 300. That's, like you could tie all my hands behind my back and tape over my eyes. I don't know. I could do that. But all of a sudden, here I'm drawing a little bit of a blank. But let's put it at 290, so 5 pixels up from the ground. And then we'll give it a width of about 20 and a height of about 10. And then I need to also set all of these parameters. So I A going to I've got a little syntax error here, which I'm missing a comma. I am going to maybe we'll turn the friction off at some point, but we'll leave it for now. Base friction, base restitution, angle of 0. This is very important, though false isStatic. Because this is not a static object. We want this to move. And in fact, maybe just for the sake of argument right now, let's give it a y value of 250. Because if everything is working, it should fall. Now, two things. We don't see it on screen. There's two things I'm missing. You can think about, what am I missing? The first thing is I can make a body, but it's not actually part of the physics unless I add it to the world. So let's do world add and add this cart. Oops. No, no. I add to the world the cart. But we also don't see it because and matter.js, I believe, has some functions that will draw things automatically to you. But again, the ethos of the Coding Train is I'm demonstrating algorithms and behaviors, and you, the artists of the world and programmers, will put your own creative twist on this. So I think it's good practice for me to always be additionally drawing the elements myself. So let's draw it with a nice we'll use the Coding Train colors. So I have this little website which has a bunch of colors. Maybe I could let's pick this nice blue. And we'll set that we'll set that to be a fill. And by the way, I totally forgot to duplicate the sketch. So if you go to that link at any point apologies for this it's actually going to be where I am with the code now. Why don't I duplicate it now? That way, this is the new base code if somebody wanted to actually start along. So I'm going to do I'll just call this I'll rename all these to something that makes more sense later and link them in the description. So let's add a fill of that color. Let's put a rectangle at now, what is this? The cart position this is very longwinded. One of the reasons why I don't if you've been paying if you're a person who's seen every Coding Train video ever, you would know that I usually often take these matter.js objects and wrap them inside my own class, my own objects, to be able to have more control and authorship over them and keep the code a little bit more concise. But I think for today's demonstration, it's simpler just to use it directly. So we're going to draw it at the y. And this is my little weird hack where I'm going to give it a width of 20 and a height this is bad practice in that I have these redundant variables, and if I update one and forget to update the other one, it's going to cause problems later. But we'll refactor this later. Maybe I'll look into how Matter works, a better way to I know it gives you the vertices of the geometry, so I could pull that dynamically. But now we can just say cart.w, cart.h. And let's run this. And we can see. There we go. So we can see the world. Things are working. Because as soon as I run the sketch, the cart is falling. And we could always have it fall. But let's position it and it's so small. Let's make things a little bit bigger, and we'll see what I mean. I have to now change everything everywhere in its position so that it's actually, falling, it will actually settle in the right place. Let's put it at I now have lost track. The ground is, like, 10 pixels from the bottom. This is 20 pixels high. So I think the bottom is at height 20, which would be, like, 290. That should give us a good plot. All right. Anyway, it's going to adjust itself because Matter is smart, being like, no, no, these two things can't physically be in the same space. Let's push them apart. OK. Cart.h did I forget that somewhere, somebody is saying in the chat? No, it looks like I'm good. OK. So great. So we've got cart pull I mean, no, not pull. We have cart. Cart. We just have cart. We're maybe going to get to cartpole. We'll see. By the way, the planned amount of time for the stream was till 100 PM, which is about 15 minutes from now. Do you have a time that you have to go by just so I could keep that in my head? That's fine. I always As long as I'll grab a drink of water if that's all right. Yeah. So you could go have a little break to yourself at any point. I can actually also remove you. But if Just bring me back in a minute. As long as you're OK me jumping in and talking about the controller, that's cool. I'll just grab my water bottle. OK. You are off. Christian, you might be able to hear me, but your audio and video is no longer on the screen. OK. So Johnny is making a good comment, which is, maybe we should start the rapping into classes sooner rather than later. I would agree with that, really. I think that's a very good point. I think I'm just going to hold off. Because ultimately, I think I might come back and record, do this again as more of a coding challenge video. And I might think more about might do it without Matter. But let's keep going here. So I'm going to now add a force. So we're going to create a variable. I'm going to call it force. I think the proper way to do this let me just show you how I figure out how to do this stuff. If I go into the documentation here and let's make this a little bit bigger and I go under Vector and I think, Christian, hopefully I can still hear you. So when you're back, just talk into my ear, or I'll just check in a bit. So basically, I want to create the force as a vector. So I can use matter.vector.create, or in my case, just vector.create. And let's go back to here, vector.create. And let's make a force. Now, again, what are the units of measurement? The units of measurement are pixels. And we're going to have to just make our best guesses as to what makes sense. I've talked about this before when using and I'm going to bring Christian back here. Let me just press this button. Great. I've talked about the physics engine box 2D, which was famously used for it's probably still used, but at least for early casual physics games like Angry Birds. And that is a physics engine where the units of measurement are real world. They're meters. They're seconds. And then you have to do all the conversion before you draw them into pixels. I actually like an engine like Matter because of the simplicity that I can just my unit measurement is pixels. So again, we have some issues in terms of simulating true physical reality. But again, this is only a 2D world, so that's not even a real thing anyway, although I'm getting off track. So let's make a vector that just 1, 0. And actually, what I'm going to do is let's see if we can control these control the cart just to get started through key presses. So I'm going to add a key press function. I'm going to check if the key code is right arrow. And these are all builtin variables to P5 that let me build in interactivity really quickly. I could put buttons on the screen and do other things. I'm going to create this force, and then I'm going to say and now I don't remember how to do this. So I think it's under Body. Let's take a look. I think there's a Body.applyForce function. Yeah. So I need to apply the force to a particular so the force is the factor I'm applying. That will eventually be the force we calculate through PID or just PD. I don't know. I don't know that we're going to get to the I here in the JavaScript version. The position is interesting because while, in a lot of my examples, I just consider all objects a single point mass, so it's like there's no geometry, we can actually apply a force to the topleft edge of the cart or the bottomright edge. But I'm just going to apply the force to the center of the body and then the body. So I can go now into the code, and I can say whoops. Every time I say whoops now, I have this I can't help but stop for a moment and then imagine I don't know. You probably haven't seen these, Christian, but I have these super cuts of me saying whoops over and over again with all these different videos. I make a lot of mistakes, and I say whoops all the time. Where am I? I pray no one does that for me, because it would be too long of a video. OK. So force, then we're going to say a Body.applyForce. We're going to apply it to the cart. We're going to apply it just to the cart's position, so the center of the cart. And I'm going to apply this force. So I'm assuming, if all goes well and also just note, I have this auto refresh on, which is a little bit risky because if you're writing a for loop and you have auto refresh on, and you don't get the exit condition in there, sometimes your code is going to restart and then get stuck in an infinite loop. But it allows the sketch to continually update as I'm editing the code, which has a lot of convenience for it. So let's see what happens. Whoa! That was kind of a big force. So we know that the values we want should be much smaller. So let's try a smaller number. There we go. We can see I'm kind of pushing it along here. Now it's kind of jumping up into the air. I'm not going to worry about that too much. There probably is a way that there are constraints I'm going to use a constraint if we get to the pendulum. But there are all sorts of ways that I could think about it more as, like, it's got wheels. It's locked to a track. What's the friction? What's the gravity? But I'm going to let this be very raw and just whatever Matter does by default. Now that we see this is working, let's make the force a bit stronger. And let's also just add in a force for the left arrow. Obviously, there's a lot more sophisticated ways we could do this, but just hardcoding in a negative force. Oh, look at that. Look at them. It's like a flying cart. We've got SpaceX going on here, just with a little horizontal force. I wonder what the liftoff is from. It's interesting that that is occurring. So I'm going to stop worrying about tuning this because we're not really there yet. So the idea now is that what I want is to have if I'm recreating and stop me if I've got this wrong. What I want to do is say I want to have a controller move the cart to a desired x location. So let's say my desired x and I'm just going to call it desired for short because I'm not going to use a y in this case is 250. So now, the next thing we need to do is calculate the error, which would be the desired minus the cart's actual position. Am I getting this right so far? You're perfect so far. DA. D minus A. Now we need a gain. Now we need a gain, right? So let's just try a gain. Let's just start with a value of 1 because I have no idea what it should be. And then the idea here is that I'm going to create this force now not with keyboard control but with my p controller. So this is the p controller. I have the desired position in one dimension, which it could be a vector, I assume, correct? A twodimensional vector, that is. A threedimensional vector I look forward to seeing all the posts of people doing this in Unity or Three.js, hopefully, that you'll share back with me. I have the gain, and then the force is just going to be and I'm going to make a variable called FX, which I'll say is the gain times the error. And then I'll create an actual vector. Again, I'm oversimplifying here to just eliminate having to deal with any vector math or the y. But how's this looking so far? Looking great so far. You got me at the perfect time. Let me drink my water. Sorry. It's perfect. This is yeah. And now I'm going to apply that force. So the first thing I like to do is I often just turn the engine off. So I see why it's jumping up in the air. These are the see, my little bit of arithmetic was off. So let's move this up. I just want it to start more at the there we go at the proper spot on top of the ground. So now the engine is off, so no physics are being applied. And as soon as I turn the engine on by uncommenting this line, it's gone. So this gain is clearly much too high. Let's give it a lower gain. And we can see we've got this unstable oscillating behavior. That's what you would expect, right? Yeah, yeah. So the gain is currently .01? Oh, there we go. Yeah. It's probably because I imagine pixels is a very tiny unit. Yes. And so as a result, it's not meters. There was probably a ton of pixels on that thing, so that makes sense. So people have to consider what the units are of their gains. It's like force per unit distance for the p gain. And distance is in pixels. And I'm guessing when we get to velocity, it's going to be pixels per second is what we're going to get. So that's perfect. I'm kind of fascinated by this levitating behavior we've got. Again, even though I'm choosing to ignore the y value in terms of this world, this physics world is not a onedimensional physics world. And again, if I were doing this more with my own custombaked physics engine, I would have more control over simplifying it. But I'm curious to see where we get with Matter. So I think we'll just have fun with this extra y that's happening right now. I probably could increase the gravity. Like, Matter let's just look. I'm just curious, if we want it, just so we have it. Matter.js world gravity. So I assume there is oh, world.gravity has been moved to engine.gravity. So engine.gravity is that something that I can just set directly, or do I need to call a function that's like oh, there's a scale factor. So it's probably internally got this sort of scaling that it does between what would be realworld measurements and pixels in some way, although this is the scale for just the gravity, so I'm not sure. I'd have to do a deeper dive into the ins and outs of this physics engine. Is there a set gravity? So let's just try I'm just curious. Let's just try hardcoding it. Let's go to engine.gravity.y equals, like, negative 10. What just happened? Yeah, see? OK. So I made a gravity in the inverse direction. Here's the gravity pointing down. So with stronger gravity, whatever sort of weird anomaly that caused it to lift up into the air is not really happening as much. But I'm going to let it stick with the default. But if we need to play with that later, we can. OK. Levitating. Actually, maybe let's keep the gravity a little bit stronger. It looks a little bit more realistic. And actually And we'll really know when we look at the pendulum as well. If we get the pendulum, that'll be pretty clear. Right. The pendulum is going to have to deal with the gravity that way. The other thing is, I think I should turn the friction to 0. Because right now, the friction is probably playing a fairly large role in how it's able to slow down and stop at the proper location. You can see now and in fact, the restitution, that might be how it's levitating into the air. Because I have each of these as slightly and I don't know if they're not there's a little bit of bounce between them, elasticity there. So I think actually, by setting the friction to 0, the restitution to 0, we have a much more idealized scenario here. Oh. I'm liking this. OK. So am I right in that if let's turn the gain up a tiny bit. And actually, because we're in an interactive place, let's just go for it right now and immediately attach a slider to the gain so that we can demonstrate we're already leaps and bounds ahead not in terms of the math and accuracy of the simulation and the ability to code the simulation in the Python version, but we're leaps ahead in terms of being able to run it in real time. So let's even just by changing a variable and having it run. But let's create a gain and I guess I'll call this pGainSlider in case we end up making a bunch of these. So I'm going to make a pGainSlider. And again, P5 has all these nice hooks to doing this very default interaction, GUI interactions. Any of you who are CSS wizards and have done a lot of web development, you might have ideas about a much more thoughtfully designed interface, and I would welcome those. But for right now, I can just make a slider. I need to give it three different values the starting value, which let's make the gain 0 just to start, and the minimum and the maximum. And then actually, I do also need a fourth value because the default step is a unit of 1. So if I want to be able to slide between 0 and 0.1, I need a smaller unit of measurement. So let's do 0.01. And this should allow me to now come on. If I could if I could figure out how to use a mouse. You know what? I must have made some weird mistake in the order of these parameters. Create slider P5. Let's look. Minimum, maximum minimum, maximum, then the value, then the step. Got it. So I did make a mistake. Minimum, maximum, start at 0, then the step. Now I can use the slider. And all we need to do is have this be pGainSlider.value. So when we start, there's no gain. I can ramp up the gain. It's way too high. I think that's too high of a maximum value. Let's try this. I don't usually work with such small numbers in sliders. Yeah, there we go, so we can see, it's way too big. I need a Reset button to put it back. I was just going to say. I was just going to say, a Reset button would really help you here, especially when we get to the cartpole. Great, let's add that in. Let's add a actually, I don't need to have a global variable for it because we'll just do it this way create button, reset, mouse pressed. So what I'm doing is and it's going to add a button. Oops, what did I oh, mouse pressed function. I've forgotten how to use JavaScript. So you can see now, quickly, and I'll zoom in here just to make it a little bigger, there's a Reset button. Any time I click this button, whatever code is inside this anonymous function that's inside the mouse press event will execute. So I suppose this is a little bit of a weird way of doing it, but let's actually just let's write, actually, a function called resetCart. I'm actually just going to we'll put it in a separate function, and then I'll call resetCart just by making a new cart. I could probably go in and set the velocity to 0 and set its position back, but I think it would be easier to recreate the cart. I can always just rerun the sketch, but it's nice to have a Reset button. And then I can just say right here whoops, reset cart whenever I also press that button. So if I make this big, resetCart oh, interesting. Now, why what did I do that caused it to no longer apply? At the moment, I'm stumped here. I recreate the oh, you know what it is? Adding the oh, so this is actually I've done a terrible thing. I can't do this. This is how I usually do things, but I would have to remove the cart. Let's see, maybe it's as easy as doing this. Remove the old cart. Make a new cart. Let's see, we'll have to look into we'll have to look into the world object. I don't want to get too off here on a tangent, but here, add. World has an add. Oh, usage should be migrated to the Matter.Composite. That's fine. So is there a remove? Composite.remove interesting. Let's do it a different way. I'm going to investigate. I'm looking at the chat. Reset let's just see, resetCart, mouse pressed, resetCart. Let's just see matter.composite. Oh, IF, IF the cart exists. You'll have to bear with me for a second as I try to sort this out. And then let's see I guess it's changed to matter.composite.add, so let's see. And then reset yeah. And I might as well also reset the slider, pGainSlider.value. I'll reset the slider to 0. So anyway, that was a lot of oh, and I need to make sure this happens after I've made the slider. So that was a lot of extra the one thing about adding interactivity is we easily so easy to lose our way from the actual simulation that we're trying to focus on because there's so many little extra edge cases and things that come up with the interactivity. But that's what we're here for, so we'll go with it. So I'm going to add a little bit of gain. If I hit Reset, it sets everything back to 0, and I think maybe, we'll leave the maximum gain a little bit lower, so we can see. All right, great. All right, so we now have a PCONTROLLER moving the cart to a desired location. Now, I want to add the D. So here's the question. Here's one question the force. So this is where I guess, I'm still, if I'm following the earlier Python code, what I'm doing is I'm adding the let's just hit Stop here so I don't get errors. This is the D. This is a comment here, not a real thing. DCONTROL, I'm going to add that here. So I can leave it as one force, and then apply that same force the same way. It's just a matter of adding that. And so in order to do that, I need to look at the cart's velocity. Is that correct? That's right. So let's look at so first thing first, I haven't used matter.js, other than a few tests yesterday, in probably a couple of years. And I didn't go this is as far as I got, basically, in the tests, so we'll see how this goes now and how far we get. So I need to get, I'm just going to call it v, the cart's velocity. Let's console.log that and see if that shows up. Great, so we can see here that I'm getting the cart's velocity. Now, there is this tiny, infinitesimal y velocity, which I will choose to ignore. I just want the x component of that cart's velocity, and this actually often occurs in JavaScript. One of the pitfalls of JavaScript is the way that it rounds floating point numbers is a really odd behavior. So you can add 3.0 plus 3.1 3.0 plus 0.1 and get the number 3.1000000006793214. All sorts of weird stuff can happen in JavaScript because we're not this code is not going to help us land the SpaceX rocket. It's just for us to simulate in the browser to get the idea of it going, so we can live with those kind of errors. So now, I need a you're going to have to talk me through this a little bit here, Christian. I know that I need a we'll call this the PGAIN. Now, I need a DGAIN? That's right. Which you had said something like 10% of what your gain usually is? Is that right? Yeah, I go for 20% generally, so I'll go 50% for you. Yes, so Sorry, sorry, oh oh, that's a gain, yeah, 50. So 2. 0.2. I will make this its own value, but just to have something in there, let's start with it as half whatever the PGAIN is. And then the and now I'm blanking here because the elements that I want to multiply together in the equation help me with this part here. So it's going to be, first, is your DGAIN that you just divide. Then you're going to want to multiply it by the derivative of your error, which is going to be negative velocity. And just in the x direction, in this case? Yes. Yeah, great. Perfect. So let's see. I'm like, no, it can't be that easy! The derivative of the error is the negative of the velocity because velocity we're talking about derivative as a way of describing the change. The change in a position is the velocity. Incidentally, the change in a velocity is the acceleration, and force equals mass times acceleration. This is where all that Euler integration stuff comes together beautifully. Here we go. Oh, wait, I've got to turn up the gain. I'm afraid. Look at that. That is fantastic. That's a PCONTROLLER. We did it. [BLOWING A TRAIN WHISTLE] See you all tomorrow. No, no, we're going to keep going. [LAUGHING] But that's great. So let's give the controller just as it continues to rerun itself, let's give it a default. So actually, maybe we should what do you think is a good next step? Should we leave the DGAIN as a ratio as calculated from the PGAIN, or should we give our own control over that? I'd say it'd be very informative to put a slider on there because then you can see. You can do the reset. Yeah, it'll be interesting to see how that behaves. So let's do a DGAIN slider. Let's add that. Now, I'm not going to add any labels to the slider, so we're just going to have to remember which one's which. I would really one of the things that maybe I'll all do after we're done today, is I'll put this in a GitHub repository and accept pull requests for people to help improve the interface and add things to it. I don't know if you saw this. I'm going off in a little bit of a tangent here, but I just want to show you one amazing example of this is let me just go sorry for the slight digression. But I just want to show everybody what's possible. So I'm going to go to one of my recent videos about horizontal directional drilling, and this was a really basic simulation of how horizontal directional drilling works with changing the bias of this particular kind of drill and turning it. This was the basic simple code example from the video, and then if I go here to the expanded game, which the viewers contributed to, and I try it here, you'll see this is what it looks like now. It has this animated drill. It has these obstacles that are hidden, but you get these clues. It has a goal. You get a score. So we don't need to go down that road, but I just want to encourage people who are interested, anybody who helped with this, if you want to help augment whatever simulation we do here, I would welcome. I'll put this all up afterwards. So now, I need to get back to where I was. So let's think about this. The DGAIN slider will have a default starting value of 0. Let's have its range go to half. We can actually just make it the same because we can let's just make them the same for right now. We'll see what the gains are by their literal position along the slider. And then we will do this, DGAIN. Oh, yeah, sorry. Yeah, sorry, this is DGAIN slider. I have a lot of redundant variables here, but I think it helps us follow what's going on. The value of that slider, and then this so now, what we can see here is this is with the PGAIN on. And as I turn up the DGAIN, it's like this dampening or damping? I can never get that right. Do you have a nice way of remembering the correct terminology of damping versus dampening? One of those is making something wet. Yeah, dampening is the wet thing. You dampen a cloth. It's damp. But the problem is because something is damp in the rain, so people think damping. So yeah, dampening is the I got to come up with a great mnemonic device for you. Yeah. Until next time. Until next time, yeah. I'm always getting that wrong. It's like the other thing that I always get wrong is modulo versus modulus. Modulo is the operator. The modulus is the result of this value modulo, this other value. Anyway I'm, off topic. So I think we're in good shape here. Let's add just let's give these some default values that we can see stuff happening as I'm whoops, no, not point let's do 0.05, 0.025. So every time the sketch oh, no, wait. Oh, again, this is I have the order of this wrong. I can't seem to remember that. This is 0.005, and then 0.0025. Did that work? Oh, wait, DGAIN slider what have I got wrong here? Why is the PGAIN slider oh, because of the reset. Ah, this is a very awkward thing that I've done, that I've just got to live with. Great. So I just wanted to, every time I change anything in the code, it's going to automatically start and resettle. MinMax oh, right, you think maybe I should have a variable for the default value? That would make sense, but this is fine. I want to add the pendulum, the pole if you will. So the way that I'm going to do this is by first creating a circular body. So I'm going to call this the bob, as in the thing that's hanging on the end of the pendulum. So let's have a variable for bob. We're going to create and I suppose this should go in the reset. I've really locked myself into a corner here with this, but let's not worry about it right now. Maybe I won't use the Reset button much. That's something I can refactor later because there's so many things now that are going to start to need to be reset. So the bob is a body creates body circle. I think it's bodies.circle, and then I give it an x and a y. So let's have it be at the I want it to be at the cart's location, but that's fine. Let's see, do this. You know what? Let's put it in reset and realize we're going to have to fix this later since this is our build world function now. So I'm going to create the bob because I want it to be directly above the cart, so I'm going to say the cartposition.x. And then I will just use 100 pixels. Actually, this is kind of silly, but let's say y 100 because let's have a variable for the rest length of what's going to be the pendulum. I mean, I'm thinking of it as a spring. Ultimately, I'm making idealized, fully rigid spring. That's what the pendulum arm is, so that's why I'm using the rest length term. And then what else do I need? We need an x. Oh, we need an r. Let's have it be 10. And then I need all the options, these same options, which I probably could just again, I will refactor this later. But this is the bob now. It is a bob that exists at the cart's position, but 100 pixels higher, and it is not static. And I need to say matter.composite.add to the world the bob. Let's also just store that radius value. Again, kind of silly that I'm doing this. Let's just store it in a variable attached to the object. So now, I can draw. This is drawing the cart, and I think I have more room here that I can put this here. Make my coat a little bit wider. I think I'm slightly and if I stand over here, my setup's a little bit better now. Drawing the cart. Now, let's draw the bob. We'll get a different color. Oh, I closed it, but that's fine. The color is not the important detail here. And the it is a circle, which is at the bob's position. Oh, why did it fall through the ground? That is strange. We're going have to figure that out. Bob.r times 2. What did I miss? Oh, did I not add it to the world? No, I added it to the world. Did I not add the ground to the world? Oh, you know what it is? I wonder if all right, let's go back to I'm just curious because the I'm just going to go back to my old fashioned world.add, and let's see. What am I missing here? Let's give it a little restitution and friction. This is strange. I'm trying to think of I'm going to look at the chat. "You forgot to remove the bob after resetting." No. All right, I'm going to take out this idea of the Reset button right now. And take this out. So this is just creating the world. Let's take a look at this. We make the rectangle. Bodies.circle all right, I'm going to go to my code from looking at the chat. "I think the gravity is so high that the Euler integration is starting to mess up." I have seen this. I probably need to change the time step. Let's change the gravity. Oh, yeah, so that was Simon, a great comment in the chat. So this is something that we have seen when I write my own physics engines, that if and in Christian's Python code, there was a variable called dt, which controlled the time step. And you can imagine, if this desk here I'm going to raise this up a little bit. If this is the ground, and this little Elgato HDMI capture thing is the bob, if I were to drop it, it's really falling continuously through air. But our simulation is doing this calculate a time step, and then teleport it to here. Then teleport it to here. And so if those time steps are really big, boom. It's going to skip past the ground. It will never actually make contact because it's able to leap over it. And there are all sorts of ways in programming physics engines. Box2D has a very sophisticated methodology for this. I think there's probably a way for me to alter the time step, but I'm actually just right now, I'm just going to leave the gravity by default, and we've got it working. Looking at chat, the gravity, the gravity. But now we've got that working, and I made some unnecessary changes trying to debug that. But I'll just leave it as is. The next thing we need to do is create a constraint, so let's go to the Matter website. The constraint so if you go to the home page of matter.js let's just see. See these demos? We have this Newton's cradle. We have this double pendulum right here. We have these springy things. Whenever two bodies are attached to each other via a spring, however, springy it is look at all these wonderful examples that's called a constraint. So I'm going to look at the documentation under constraint, and basically, I want to create a constraint with a set of options. And let's do that here. So I'm going to do this in my I'm just going to now call this createWorld, this function, and I probably should put the ground in it too, but we can fix that later. Let's add a constraint. And again, after the stream today, I will go through and kind of comment all of the code so that the released version has more explanations in it, and I'll do some cleanup as well. So we need to say constraint I already forgot create, constraint.create where is that? Create. Create, and then I believe we give it a set of options. So now, I think it's I'm just assuming it's giving me an error because let's turn off auto refresh for a second. Now bodyA I believe the first thing you do with a constraint is you say which two bodies are attached. So bodyA is the cart and bodyB is the bob. And somewhere in this documentation I should see all of the usages or examples. Let's try here. Let's go to examples. While you're looking that up, Daniel, in dynamics, multibody dynamics, when we add a constraint, we add something that's called a a variable called lambda for every constraint, and it's called garage multiplier, and that's how we handle the math and deriving the dynamics. Basically, it's the force that holds that makes this constraint happen. Obviously, that's not relevant in any way to you fixing your problem, but just tying this back to how we do it in robotics. So there's probably a better example I just sort clicked through and found this example. And we can see this is actually I found an example of a ragdoll simulation with matter.js. And you can see here is the chest to the upper left arm, or maybe that's el I don't know. I don't know what part is what on an actual anatomy here, but you can see we have two bodies, and then we have a stiffness. That should be all I need, I think. There is a point A and a point B. I think that's just if you want the constraint to be attached to the offset from the center of the body, which I don't need for this. So let's see if that's all I need. Where's my sketch again? BodyA, bodyB, stiffness of 1. BodyA is not defined oh, wait. No, no, no. All right. You know what I'm going to I'm going to do here? Is I'm just going to look at the thing that I was making yesterday and see what the constraint code is there because I think I we've been going for a very long time, so I'd like to kind of get this wrapped up here, and I think this will help us get there a little faster. Constraint. Body oh, length, I'm missing. Constraint.create so let's just take this. Let's grab this code here that I wrote yesterday as I was trying this idea out. And so we're going to go to the cart, the bob, the restLength, which I set up here, and the stiffness. Why is it saying bodyA is not defined? So let's take a look at what am I missing here? Is cart oh, is cart not made yet? No, cart is a body. Bob is a body. Hmm. I'm not this is where the chat always comes in and helps me out. I disabled auto refresh. Yeah, yeah, yeah. Oh, OK. No, we're fine. The constraint is there. The constraint is there. I think I just I hadn't run I hadn't fixed it and run the code in the right order. The other thing I want to do is render that constraint. That constraint, by the way, by default, doesn't have any mass. It's not there's no geometry associated with it. It's just a force. But for our purposes, let's not worry about color here. Let's draw a white stroke with a thickness of four pixels, and we'll just draw a line between the cart and the bob. Oh. Now, OK. So what am I what's wrong here? Stroke cart.position.x what is undefined? Cannot read the property of undefined line 110. Look at the chat again. And everyone's telling me I forgot to press play, but that's not the issue here. What is going on here? Cart.position.x, cart.position.y. Bob.position.x we just drew a circle there, we just drew a rectangle there oh, there's a weird typo. You have a dot [INTERPOSING VOICES] It's the comma. There we go. Yeah. OK. Here we go. Oh, and I've added this very thick stroke to everything now, so before I draw these elements, let's put no stroke. And I'll put auto refresh back on there we go. All right. Look at that. Now, of course our pendulum is just falling over because my controller is not attempting to balance the chat, by the way, so the chat is like 30 to 60 seconds behind us so you can see like comma, comma, comma, comma, comma, comma, comma OK, I got it. Got it. Let's add let's take out the friction, but let's put a little bit of bounciness in there just because I think it'll be kind of nice to see it the pendulum bounce when it hits the ground. Let's see. Yeah, there we go. That has a nice kind of feeling to it. Again, I need to really do some tuning to my cart so it doesn't go flying off into the air, but so be it. All right. We're getting really close to the end of this, I think, right? Yeah. So the next thing I need yeah, go ahead, Chri Go ahead. I'm sorry. [STAMMERING] why don't you tell me? OK. So I need to only the thing that I need to do is calculate the error now as not the difference in x positions but the difference between my ideal angle and what the current angle is. So my ideal angle, if my reference point is the yaxis, would be 0. Now, how I get that angle might end up being that might be 90 degrees or negative 90 degrees. So let's see. The question is, is matter going to give me the angle, or should I calculate the math for the angle myself? I think I'm just going to do it myself in a very ridiculous way, unless Let's just check the matter.vector let's check the matter.vector object because maybe it has a heading function in it. I like an angle vector angle. Yes. Well, that gives me the angle between two vectors, which I could certainly use, but that's not what I want. I want the angle of just the heading of a vector. I know how to do this myself. I was just wondering if matter would give it to me. So maybe somebody in the chat will tell me, but I'm going to just do this in a very crude, raw way myself. So let's add a comment here. What is the pendulum arm angle? So I'm going to make my own p5 vector. So here's a really terrible idea that we will correct later, but I mixing I'm not mixing metaphors, I'm mixing physics libraries, in that matter has this vector object called vector.create, but I know the p5 vector object, like, in and out. Like, it's burned to my brain so I can get an angle from it really quickly. I could also use the A arc tangent function so many ways I could get this, but let's just do it this way. So I want to create a vector, which is the I'm just going to create an empty vector, and then I'm going to say v.x is the bob's position minus the cart's position. And I could go over to my whiteboard here to diagram this, but I let's and did I use oh, I used v already. Let's just call this arm. It's a vector to describe the arm. And then bob.position.y minus bob.position a cart.position.y, and then I'm going to set the angle to be the arm's heading. So again, I could do this mathematical calculation myself, but basically I drew a vector pointing from the cart all the way up to the bob, and then I'm getting its angle. Now, let's look at what that angle is, and I'm going to convert it to degrees, just because my ability to understand what an angle is in radians is so we can see it's about well, when it's it's at negative 180 degrees when it's there, which is correct. So what did it start at? Thank you, sir. All right, let's turn the engine off so you to see. What is it what is its correct angle? It's correct angle is a pi divided by 2. Right? In radians. In radians. Pi over 2 in radians, you use radians, degrees or not, because pi over 2 would be like 1.7. Yeah. That's I converted it, and then I converted it back in my head. OK. What? Do I have something wrong here? Let's see. Hold on. One of the ways I like to one of the ways we can debug this is I'm going to do this. I'm going to very quickly translate to a little spot and draw a line. I'm just drawing this line here, and I'm going to rotate by that angle. Weird. So I definitely have a mistake oh, there's a y there. I make so many typos. There we go. I knew, like, my math is not right. OK. There we go. We're good. We're good. I'm sure the chat like, the chat's already got this. OK. This is actually nice, though, to see this because if I turn the if I turn the engine back on, where's that? It's kind of fun to see that little extra dial kind of rotate with it. It's like but I don't know that we really need that debugging because we have the actual pendulum arm, but that's going to be useful. So I'm going to just comment that out, though, for right now. So now. One thing I want to alert you to is the fact that we're going to get the derivative of that angle that you're measuring numeric. Right. So I don't know you have a plan for that, but we could certainly come up with one. I don't have a plan for that, so you can start thinking about that. Yeah. Yes. I guess I could I don't have a the objects have angular velocity, but that's it rotating. I will have to track that angular velocity myself, I guess, by looking at the change. Yeah. Yeah, that's why I was wondering. Can you store something or grab something for the previous loop attempt variable Exactly. Yes. That's what I'll do. That's what I'll do. So first, let's so one thing I'm going to do right now is I'm going to just comment out the dGain. So this is now it's just got a pGain. It's only this is just a p controller. And again, it's still trying to do the cart location, not the angle of the pendulum. OK. But the error now should be where did I calculate that? OK. So this is let's move this up to here, let's take actually, just take this out so that we can see things more in one place, and now what I want to do is change this error calculation. So this is I'm going to just leave that there for reference. This is now the desired angle, which I said was what did I say it was pi divided by 2? I mean, pi divided by 2 should be the assuming 0 is horizontal right, and that's No, it's actually not. It's so the unfortunate thing is oh, it's negative pi divided by 2 because the yaxis in my world is flipped. So rotating down along the horizontal axis is 9 degrees. So there could be some reasons for, in a different kind of demonstration of this, to actually make the world with the yaxis pointing up to reduce these kinds of problems, but in my world of just getting this to work, like, oh, no, I just remember we need a negative here. OK. This is cool. All right. So it's perfectly balanced because there's no offset. So just to see if what the p controller does, remember these forces I had here? Let's actually I'm going to be able to, with a key pressed, apply a little bit of wind, almost as if a gust of wind comes blow, or somebody flicks the bob because it's not a wind because the wind would push the cart, conceivably, as well. So presumably now, when I press the key, pressed to the right, a little force is going to act on the bob, pushing it to the right, and that should cause every the p controller to start to move the cart. All right. Maybe we should Little less wind. A little less wind. A little less wind, and maybe a little less restitution. A little more conversation what's the song that I'm somehow referencing now? I wish I knew. There we go. OK, now, when in the wrong it compensated, but in the wrong direction. So I must have something flipped. Well, it's possible like, the I mean, I know you had to have to change the direction of pi over 2, that's your desired angle, but theoretically, it should be OK. It shouldn't require maybe it's the fact that it drives it in a different direction? You could try flipping the gain, even though it technically should be positive, but we can give that a shot. There you go. There you go. So why is my direction wrong? Interesting. It has to follow how you would define your angle. So let's consider 0 being the yaxis, in which case oops. But wait. Hold on. Hold on. Let's not let's turn the engine off for a second. So right so this angle is now 0 because I'm offsetting it by pi divided by 2. And one thing I'll also point out is people are saying we didn't that the d term might still be on and still working based upon the cart position, so it would be a mismatch. That's something that can be mismatched. It is. I commented that out. Pretty sure. No, yeah. You did. And then, this would be the desired angle is 0 minus the current angle. But if the current angle is let's see. So now let's do I turn the engine back on? No. We don't have to get stuck on this. We can think it through more later. I'm sure it will oh, there we go. So there's something this is once I've now oh, no. I still have the negative. I didn't realize I had the negative there. All right. So I'm not going to worry about this right now. Let's we'll put our heads together. I'm sure it will appear to somebody's It'll pop out. Somebody line 71, 75. 71 am I? Oh, cart position. That's not a big deal, but that is a problem. So if I look at the one thing I can do here that I've done before is we can make the ground much, much higher. So basically the ground so that it can't skip past it as easily. It's thicker. Thicker, yes. So the ground could be like 100 pixels thick, and then obviously now, it's and the h is 100, so it's obviously it's there. But actually, that's kind of fine. I was going to say like, oh, I want to have to shift it down, but let's just that's actually much sort of nicer to see it there anyway. So let's now I just need to adjust it would be nice to adjust where the cart starts, which is, like, around 2. I sort of forgotten I'm just going to click there we go. Perfect. OK. I don't remember what it was. So, OK. So, great. So, now cool. So now do we now go on. I'm sorry. But I was going to mention that we could up the gain now and see if it will get the [INAUDIBLE] faster and it'll be good. Yes. Yes. So where is I just want to see where this console.log that is filling up the console. There it is. OK. So let's now put the gain higher and hit a little force to the right. Yeah. You could see I mean, it's one thing I could also do, I was doing this in what I was doing test, is I could add little walls on the sides so that it's forced to stay on the screen, it'll bounce back and have to readjust. Maybe we'll do that just for because I think it'll make the simulation kind of interesting. I don't want to get too stuck in this, but let's do and I don't even have to draw those necessarily. We can just say like, hey, let's make a left wall, which is a rectangle at the width, at the I'm going to just hard code this in because it's a little bit more concise right now at 200 pixels down, it's just like 10 pixels wide. It's the full height. So now oh? And let's make it 100 pixels wide, just like oh, I didn't add it. No, it's just, I didn't add it to the world.add, world, leftWall. And that's the right wall, by the way. I don't know if I've this is I was saying this to Christian earlier this week, I try never to stream for more than 2 and 1/2 hours because that seems to be the threshold where my brain completely starts to shut down. It's like my classes at NYU are 2 and 1/2 hours long, with a good 15 minute break in the middle, which we did not take, which is I guess I had a little bit of break because we were passing things back and forth, but OK. So let's see here. Oh, that's the giant the wall oh, the wall should be at 400. Sorry. This is the problem with not drawing it. I don't know where it is. There we go. There you go. Let's just add a left one. Maybe this is a different kind of problem I'm introducing, but at least we'll have this option. OK. So now, and we can make them very bouncy so as to force the things to bounce off them more. OK. Oh, let's see. LeftWall, 0, 29, and got to add the left wall to the world. OK. And I think I also might like to I think it'll help us sort of see what's going on by having this force be even less. So let's I'm going to just many magnitudes less, right? Because we can see now there we go. We can see it more trying to balance it. And I don't know why it decided to, like this Filled your wall, but I don't know what happened. Yeah. But I love that. I love the way you're winding it back and forth. I think end stuck at the end. I might be I wonder if the walls are actually in the wrong place because 290 what am I doing? Yeah, the wall should be I don't know what I was doing. This should be 150, the y position. This is the problem of not drawing it. The wall is actually not was like, I had it all the way at the bottom. I don't know what why I did that, but this will and we can up the gain. But yeah. OK. Great. So we've got a nice p controller that can push it, and it'll sort of try to get it balanced. Look at that. That is awesome. Yeah. OK, this is around my we should really stop here. Quit while you're ahead. OK. So I'm going to by the way, I'm going to put a hard stop on us at 200, so that gives us 15 more minutes to maybe see about adding the d controller, and maybe one or two short questions. We can always come back and do this again, or be available on social media or Discord or in the YouTube comments if people I mean, Christian, you're welcome to go back to your life, but I will pass along any questions that I can't answer to Christian and answer for you. You know what? You're working so hard, I'll stick to 200 PM to moral support for your challenge here. OK. OK. We're going to wrap this up. We're not going any more than 15 minutes. So let's start adding the d control here. So what we need is the angular velocity, and the easiest way to do that would be to just store the current angle and the previous angle, yes? Correct. So let me create a variable for a previous angle. We're going to have the previous angle start I don't need to put it in Setup and I'm mixing different code styles here. I will go back to what I usually use with the camel case for JavaScript. Previous angle is 0. So this is me where am I calculating? This is actually going to be pretty fast. As soon as I calculate the new angle, the angle velocity is the current angle minus the previous angle. Yeah. And we get it divided by delta t, right? The dt? Right. So in my case, delta t is 1. But we might need to match it because I'm just using the frame rate, basically every frame is 1 there might be an issue with that in terms of how we scale things, in which case, we can and how matter.js is working, but let's start with that. But yes, we should I guess to be more to be correct, I should have a variable for dt, and take this and multiply it by dt. Is that correct? Divide it by dt. Divide it by dt. Yes. Sorry. That's what I meant. So we're going to leave it like that, that way that is a parameter we could adjust if need be. And then I just need to, as soon as I do that, previous angle is the current angle, so that I pick that up for the next time. So this should give us the angular velocity. And then, I guess I don't really just to be consistent, I'm having many extra unnecessary variables here, but I will just put this as the angular velocity. Oh, and there's no it's a scalar value, so there's no x component I'm dealing with. And so I have no idea. I think I put everything in the code. Fingers crossed here. Oh, yeah. I mean, it's hard to tell how much of a factor that's having, but let me ramp that up. Wow. So it's possible we might want to keep my lead to change the direction of the other gain. Right. We should probably so we might want to change the direction of the other of this other one. Which is not a theoretical problem. It would be like, what if your force you defined as out going in the opposite direction, for instance? That's not a crazy thing. So let's look at that. It's coming to a stop. Look at that. This sways slowly to a stop. How about that? Whoa! What, now it's going? Oh, you're doing that. No, I started I'm pressing keys. Yes. What happened? The man said it shouldn't do that? No, that's good. That's why we better have buttons or some interface, or like the for I could use something that we use a lot on the channel, it's something called Perlin noise, which is this sort of smooth noise, which would be nice for just this kind of like arbitrary wind that's kind of like chaos introduce a little chaotic wind into the system that's not just totally random but sort of smoothly changes over time and have it always balanced according to that. KD can always absorb dt term. OK. So I'm going to make a list of things that I this we're going to we're wrapping this up I was going to say 10 minutes early, but not really. I just want to make a short list of things that I want to address so I remember them. And then what it's not going to happen immediately, because I got to go back to the Christian, I'm sure you do as well go back to regular life for a little bit of today, but sometime later this weekend or certainly on Monday I'm going to add the code to GitHub, let's investigate the direction of the gain constants. Like, I have some error there maybe related to the axis being flipped or something that I just cannot I cannot find right now in my head. So we'll investigate that. I'm almost certain. I'm almost certain that's what it is. I mean, that's not I know I talked I know I talked about how the gain should be positive, but that's it could be dependent upon which direction you put your force. And then, I don't know, does anybody else quickly in the chat is there there's actually not and then I'm just going to do some clean up and commenting of the code. But we're not going to keep going with this, but I, just out of curiosity, if this were let's say this were a demonstration for a lecture you're giving in one of your robotics classes, like, what would be I mean, I guess the I adding the I could be something next. But what would be sort of like the follow up to this? Well, I think what you would do so in a robotics lecture, like we would learn what the margins of stability are. Like, there is like we have these methods of knowing not just what makes the controller perform better or worse, but there are thresholds for what's stable and not stable. And you can technically test those out. Now, that's not a super necessary thing for what we're doing here we're kind of tuning it up. The I term would be interesting to show. The tricky part would be getting it to not only balance, but also hover back to the right position. Right. Yeah. And someone in the chat somebody in the chat just said that would like to see the desired position of the bob, not oh, so people are doing, like, adding various comments to the chat, but that's interesting. So not only does the robot need to balance the pendulum, but or the pole, if you will, but it also needs to balance it in the center of the space that it inhabits. Exactly. Exactly. And there are ways to do that. It's a little trickier, but you can still do it with the PID control framework. Great. So one more I'm going to take one or two more questions from the chat before we wrap up. One is, what is your favorite control algorithm? And the options that you could go off this list of options, but the ones listed in the chat are LQG, MPC, sliding mode, et cetera. Do you have a favorite? So, yeah. So just I'll zoom in on this one that's called MPC, which stands for Model Predictive Control. I mean, they all have the short answer's they all have their uses in different things. The thing that's interesting about Model Predictive Control is that it is not just taking the current state of the system, like what we're doing with PID and saying, do this based upon the current state of the system. I'm far away, push hard. The MPC is what it's doing it is predicting into the future what it should do. It is rapidly figuring out not only what to do now, but a little bit after that, a little bit after that, a little bit after that, a little bit after that. It's doing what we call a trajectory optimization on the fly. It is and one of the sort of undersold to the public tools that we do that we can do in robotics now is we can run really fast optimizations called quadratic programs, and they will generate on the fly the best trajectory it can, not only for now, but into the future. And so you can do really cool stuff with MPC because it is just rapidly changing its prediction. You can push it around. It's like, oh, I should do this now, I should do that now. And we use that in our robots now a lot. Wonderful. There's a great oh, now I lost the comment. There was a really nice comment in the chat that said, if we added friction, that would be a nice way to demonstrate the need for the I because we would have to push harder, I guess, in a way, like accumulate that error to get it to balance properly. Yeah. And I'll make a quick comment on the I term, and that's yes, that's a great thing for friction. The I term is also the easiest way to make your system accidentally unstable. You got to be careful with the I term. It could take something that was stable and then suddenly crank it up too high and it starts like, it will go from, like, oh, I'll correct this little bit of safe state error to it'll overshoot, and then it'll overshoot again, then overshoot again, and it goes wild. So that's what it'll do. Wonderful. So let's see here. Let me just check so, I'm trying to think of what else I want to say to wrap up here. So first of all, thank you so much for joining. This is really fantastic. Oh, I know what I was going to say! Another thing I wanted to add. So one of the things that I'm hoping that I've been working on for a while one of the reasons why I'm so excited about this is I've been working on a new chapter for The Nature of Code book about neural networks. And I've done demonstrations of this where we use a technique called neuroevolution to evolve the weights of a neural network to control an agent in a simulation, and this, I think, would be a really nice example of comparing and contrasting, that that kind of like, what would the inputs to the neural network be of it's the it could just be just the angle the angle of the pendulum and the current velocity of the cart, or something like that, and sort of compare and contrast. But what I love about this is I often have students who are like, oh my god, I need to learn reinforcement learning and q learning and all this stuff to be able to control my thing because and then but no. Just something as simple again, everything is relative. There's lots of complexity here, and calculus, math, but something as simple as just looking at your agent's, your object's position in the world, where it wants to be, that error, and applying a force scaled according to that error, and just that proportional controller is a really nice way to add intelligence into a simulated system. And obviously, with a physical robot that you built within Arduino, like, sticking a neural network in there could be quite overkill, although interesting as well. So I just think it's really exciting to see this as a complement and counterpoint to some of these other systems that I'm working on, and I think there's lots of potential here to continue and look at more controllers, and hopefully we can stay in touch to work on this some more. Yeah, absolutely. I'll just throw a little point on the end of that. I was talking in the chat, I was mentioning that people are bringing up neural network controllers. And it is a great compliment because even some of the really coolest robots you see that are using reinforcement learning, there's a beautiful example of taking the Cassie robot, this biped, and people use reinforcement learning to train a good walking controller. It's amazing. What they're doing, the neural network is what it's producing are the desired values for a pd controller. That's what it's doing. They work together, and that's really effective. Great. All right. So is there so I'm just going to go thank you I'm just going to go over here just to show quickly I've zoomed in here. This is currently what's in the video description. You can find Christian's Twitter, Instagram, Twitch, and YouTube channels here, so please go and follow Christian. We are both on Twitter. I plan on definitely sharing some of the results here, so maybe we can get a thread going with some additional links to explanations or examples. And if you've made something, there's no page on the Coding Train website currently for this live stream I might have one in the future, and there's a way that you can submit things but stay tuned because I will be releasing a GitHub repository and updating this video's description with links to all of these materials in case you want to make your own. And I always say this, but very little in life there's lots of things that make me happy, but one of the things that makes me happiest in life is when somebody sees something in a video and makes their own version of it. However, whether even if you just made it and you changed the colors and you added a little design of a cart, like, think just, whatever kind of creative fun you can have with this don't worry about accuracy of the physics of the simulation. Just have fun with it, play with it, and share that back. I would love to see what you do. Is there anything else you want to say or plug or point people towards before we oh, I know I know I'm [INAUDIBLE],, but one thing I did want to ask is because I do know that I do have a lot of students who watch the Coding Train, whether they're in high school or an undergraduate so if people are interested in the field of robotics or mechanical engineering, where would they look? What would you point them towards in terms of your lab and your program that you teach at, would be one nice thing to wrap up. No, it's great. So I'm an assistant professor of Mechanical Engineering at the FAMU FSU College of Engineering in Tallahassee. So it's a joint college between Florida A&M University, which is a historically Black college and university, and Florida State University, which is a wonderful R1 research institution. So I'm down here in Tallahassee. You take engineering courses, you might take them from me. You can find me on my personal website at ChristianHubicki.com CHRISTIAN. Hubicki. HUBICKI. And you can find me there. I've actually I give public lectures as well. Sometimes people pull me up and this is my laboratory, the OptimalRoboticsLab.com. And so that's where you can find some of my work, and this is one of our robots walking around. And feel free to reach out to me. You could find my contact information on my website, and of course, through Twitter, which is at @CHubicki, which I believe is Chewbacca's younger brother. Awesome. All right. Wonderful. Thank you so much for being here. This was great. I'm so glad the tech seemed to all work. Thank you to everybody for watching. I don't have any particular updates about when the next live stream will be or when the next videos are coming out, but hopefully something next week. You can everything I always announce everything on the Coding Train Discord, so you can go to the CodingTrain.com/Discord, join the Discord channel. If you sign up for the notifications role, you'll get pings if you want for when I'm scheduling things. And I just appreciate all of you watching. Please go and enjoy making your own p do something else. Maybe take a break from your computer. It's been, like, many hours. But when you come back to it, if you make a PID controller in Python or in p5 or Unity, again, share it with us on Twitter. And I look forward to seeing you next time on the Coding Train. All right. I'm going to go to the end screen. And a little music here. [MUSIC PLAYING] And my mic is now going to mute. Goodbye, everybody. [MUSIC STOPS] Sorry, everybody. The music is not on. I don't know why. [MUSIC PLAYING] Oh, well. Sorry, everybody. There won't be any music in the outro today, but I'm going to shut this down soon anyway.