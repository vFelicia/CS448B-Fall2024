Hello. Welcome to another chapter 1 video for Nature of Code on vectors. So I am building to something. I am getting somewhere to a place, where I'm going to make this example for you that looks at something called acceleration, and in fact has this walker or mover or particle, whatever you want to call it, object, accelerating towards the mouse. There are some key concepts, however, that I want to talk about that doing this example require. So if I go back to where I just left off, looking at how to pick a random vector using p5.Vector.Random2D. So this picks a random vector always of length 1, but any random direction. And then I'm scaling it randomly. We get this nice pattern. But this here, p5.Vector.random2D, might look a little strange to you. And this is an example of a static function. Random2D is a static function. It's called on p5.Vector, rather than like this function, mult for multiply, which is called on v the object itself. Let's look at this a bit more closely. This is the conventional way that I have looked at objectoriented programming in most of my videos. I have this object v. It's a p5 vector. And then I'm calling a method on that object a function on an object. This is what would be referred to as an instance function or instance method. The one thing that's a little bit unique here is that instead of, say, new p5.Vector, I'm saying createVector. And that's just something specific to p5 itself, which has in it a createVector function to make the vector object. But sure, in most cases, like this one right here, I'll be making a new walker object. And then I'm calling instance methods walker.update, walker.show. Those execute the code to run the functionality of this particular walker object. So the term I'm using is instance method or function. A static method, a static function, is one that is not called specifically on an individual object itself, but rather on the class as a whole. So notice how I'm calling a function random2D just like I'm calling a function add. But instead of on a specific instance of p5.Vector object, I'm calling it on the name of the class itself, p5.Vector. That's because this bit of functionality isn't associated with a particular object. I want to add something to this specific vector here. But here, there's no actual specific vector I'm talking about. I just want to make a new random vector. So this begs the question, why is it done this way? The story here is that this is really a decision that the creators or maintainers of the p5 library have chosen. There's no reason why there couldn't be just like there is a global createVector function that makes an empty vector, or a vector with 0, 0 in it. There could be a createRandom2Dvector. So I could be sitting here in an alternate parallel universe saying this is the function to make a random 2D vector in p5. But in JavaScript, or in other programming languages as well, it's quite common to want to collect a whole set of functions under a particular namespace. For example, in JavaScript, if I wanted to pick a random number, and I didn't have p5.js, I would say Math.random. And there is a whole collection of mathematical functions under the umbrella of math. They're namespaced under math. They're all static functions. So in p5.js, there are a lot of global functions, which is a whole other discussion. Why are there global functions in p5.js? But I don't want to get into that right now. But all of the vector functions are not part of the global p5 reference. They're all namespaced under P5 vector. So there are some times where I want to call a function that's operating on a vector, and some other operations that I just want to call that relate to vectors that are called under the vector class itself. Some are static p5.Vector dot the function name. And some are instance v the instance of an object dot the function name. But I'm not done yet. One of the weirder things about working with p5.Vector is there are both this is an instance function at a static function random2D. But there also is a static function add. So some of the functions have both instance and static versions of the same function. So I want to look at a practical example of why I might want to use one versus the other. To do this, let's return to the world of scalar numbers just single values themselves. Let's say I have the variable x, and it has the number 5. And then I also have the number and we'll call it xspeed just to go back to when we were doing these kinds of motion algorithms without vectors, x speed equals 2. This is a case where we would write code all the time like this x equals x plus xspeed. We did this without a second thought. I'm taking 2, adding it to 5, and putting that value back in x. So if this were in a draw loop, x is 5, then it's 7, then it's 9, then it's 11, etc. We've now seen that the equivalent is if I have a position vector, And I have a velocity vector, I would say position pos.add velocity. This is the equivalent of this, but with vectors. x changes by x speed. Position changes by velocity. However, what if instead of doing it this way, I wanted to say let new x equals x plus xspeed. What if I wanted to take the result of this operation and store it in another variable? So x hasn't changed after I run this line of code, x is still 5. I have the number 7 in this particular variable new x. Now, in most examples, I don't want to do that. I want x to change and keep saving the new value into itself incrementally. But there are a lot of times where I want to do an operation, not mess with those two variables, and store it in a new result. How do I do that with vectors? So your instinct might be, OK, maybe I'm going to have a new pos, and I would set that equal to pos.add velocity. I mean, it's not correct. It makes logical sense. But by its nature, an instance method that receives another vector changes the object it's acting upon. This is where the static version of add comes in. If you want to add two vectors together, but not mess with those vectors, you can use the static version of the add function. It's a bit wordy and the code looks a little awkward, but it works. Let new pos equal p5.Vector.add position, velocity. Does that fit? Oh, it fit. There you go. So if I want to add two vectors together, and get the result in a new vector, I just need to call the static version of add, which is namespaced stored under the p5.Vector class itself. So while this is very common in our physics algorithms, position changes by velocity, and in a moment, we'll see velocity changes by acceleration, there are certain times where I want to do an operation like this. And there are more examples of that than just add as well. And this, in fact, is exactly what's demonstrated on the P5 reference. You can see here v equals createVector v.add It actually changes v's components themselves, versus having v1 and v2, and then saying p5.Vector.add v1 and v2. And putting that in a new vector V3. So hopefully now, this video gives you a bit of a sense of what the difference between a static method is and an instance method. And by the way, I'm just, for better or worse, using the word method and function interchangeably. Technically speaking, a method is a function that's part of a class in an object and a function as well a function that exists maybe on its own. But I am a little bit looseygoosey with this stuff. So I'm using them interchangeably. But the point of this video is to give you a sense of what static functions are and instance functions, static methods or instance methods. And now, as we move forward and start to work with more vector operations in future videos and examples, you'll have a sense of why I might be picking one versus the other in different cases. And this is going to come up in exactly the next example I'm going to demonstrate that's working with an acceleration vector. So maybe you've decided, forget about this. This is where I draw the line. This static method stuff drove me crazy, I'm out. But if you're not, if you want to keep going with Nature of Code, I'll see you in the next video. Bye. [MUSIC PLAYING]