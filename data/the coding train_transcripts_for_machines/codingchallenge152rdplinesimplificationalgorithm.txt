[BLOWS HORN] Hello, and welcome to a coding challenge. In this coding challenge, I'm going to make what you're seeing right here, which is a curve lowering its resolution the same curve is being drawn over and over again with fewer and fewer points. This is known as the RamerDouglasPeuker algorithm. Now, there are many different algorithms for doing this same exact task. But this is a particularly wellknown one. The reason why I want to implement it is I am working on a new example with the ml5js library that allows you to draw with the computer or with a particular machine learning model, that model being sketchrnn, which I've used before in a video about snowflakes. And that model was trained on the Quick Draw Dataset. So here is an example of redrawing doodles of cats from the Quick Draw Dataset that I also did in a previous coding challenge. And in order to draw along with it, I need to capture the person the person who's drawing the path of their mouse. And the resolution of what they're drawing might be capturing so many points along the way, that that's going to confuse the machine learning model. And a researcher at Google, who worked on sketchrnn explained this to me on GitHub. And so one of the things that I want to add to ml5js is this RDP algorithm to be able to reduce scale the resolution of a path that's being drawn. So in this coding challenge, I'm not going to worry about ml5 or sketchrnn or any of that. I'm just going to try to recreate exactly this. I'm going to start with this formula. I'm going to draw this graph. And then, I'm going to vary a parameter called epsilon and see if I can lower the resolution of this particular graph. I'm not really sure if resolution is the word I'm looking for here. People in the chat are suggesting granularity, fidelity. But I think all of these words kind of describe what it is I'm going for the number the distance between individual points along a path. And on Wikipedia, I think a nice way of describing this is the purpose of the algorithm is to find a similar curve with fewer points. So depending what that epsilon is, let's say can we approximate that curve with the least number of points, you know, fewer points turning the epsilon up, more points turning the epsilon down? I wrote a little code beforehand so that I had it to get started. If you to see me write this code you can find the link to the live stream associated with this edited coding challenge. And so what I've done here is just taken that mathematical function, which is right here f of x equals e to the negative x of cosine 2 pi x, where x between 0 and 5. And I've graphed it in processing. So if I run this, we'll see I have this graph. But what I need to do now is create an array with all of the points in it. And I think I'm going to end up using an array list, which is always a little bit awkward. But let's do that. So I'm going to say ArrayList. It's going to have PVector objects in it. And again, when I eventually if I make a JavaScript version of this, it's much simpler to just have a plain array. But a resizable array in Java is a little trickier. So I like to use array lists. We'll call this allPoints is a new ArrayList with PVectors in it that is empty. And so now, I can say here allPoints.add new PVector in P5, it would be createVector x comma y. I think it's an interesting question of, should I perform this algorithm on the units that are in the sort of range of 0 to 5, negative 1 to 1, or should I perform the algorithm on the pixels? I don't think it really matters. But I'm going to do it on the pixels, because that's going to be closer to when I do it with, like, a userdrawn path. So I don't know how long I want this coding challenge to be or how much time I have. But ultimately, if I can get this to work, the next step would be have a user draw a path and then play with that curve. Maybe I'll leave that as an exercise to you, the viewer. OK. So now, let's actually not draw here. Let's get rid of the drawing here. And let's put that into draw itself. So I'm going to say for every P vector v in all points vertex and endShape. By the way, if you were wondering what this surface.setLocation is, it's just so that when I run the sketch, it will appear over to the right every single time. So it's not obscuring the code a little bit. That's how you can set the processing window to a fixed location. Now that we have all of the points in a list, we can iterate over that list presumably and implement the algorithm. So what is the algorithm? You can find a narrative description of the algorithm here. And you can also see another nice visualization of it happening. Let me try to diagram for it and sort explain it in my own words the way that I understand it. Well, I don't know if that will be better than you just reading it. So you know, skip ahead a minute and read this instead. I leave it up to you. [MUSIC PLAYING] So here's a path with 1, 2, 3, 4 1, 2, 3, 4, 5, 6, 7, 8 points. Now, presumably, when I actually do the algorithm, there's going to be lots and lots and lots and lots of points very close together. But to be able to describe it through a diagram, I need a very low resolution or low fidelity, a curve or a path. So the idea of the algorithm it's a recursive algorithm. And what I mean by that is we're going to be dividing these set this, like, continuous series of points into subsections and applying the same algorithm to those subsections, which they'd get divided. And we apply it to those subsections, as well. So this is totally going to make it harder to program. But it is also quite elegant and lovely. All right. So the first thing that you do is you we need a list of points that we're going to keep. So we're going to keep start and end. That's the first part of the algorithm keep start and end. So this is the start. And this is the end. So we know at a minimum, we need those two points, right, because in a way, this is an approximation of that curve. It's like the lowest fidelity approximation, but an approximation nonetheless. So now, we have you know, if I label all these A, B, C, D, E, F, G, H now, we have a list with, like, A and H in it. The next thing we need do is we look for the point along the curve that's farthest away from this line segment. By that, I mean we look for this distance, the normal from all of these points to the line segment. And just eyeballing it, it's either B or G. Just to make this more obvious, I'm putting F up here actually, because that way we don't have this it's also like I kind of want something more in the middle. I think it will be a better demonstration of the idea. OK. So I found the point furthest away from the line. So that now I think I then test that point against this epsilon value. But let's come back to epsilon in a second. I'm not entirely sure. I'm going to go back to the Wikipedia page. But what I do is I say, I want to keep that point. So I'm going to keep that point. Now, this is the recursive part. Now, I have another path that goes from A to F and one that goes from F to H. And I apply the same algorithm again. So now, I take this line segment and look for these distances from C, D, and B. And I would say eyeballing it, C is probably the one that's furthest. So I'm going to keep that. And we can see how now if I stopped here, this is my approximation. I go from A to C to F to H. And I think epsilon has to do with this distance threshold. I think at a certain point, we realize the point that I'm keeping is within a certain distance from the curve itself that I can just stop and discard it. I think that's what epsilon is. Let's go back and confirm that. And here's the highlighted section. This is exactly right. If the point furthest from the line segment is greater than epsilon from the approximation, then that point must be kept. So the algorithm is going to recursively call itself over and over again as long as the points it's keeping are greater than epsilon. Once it finds they're less than epsilon, it will stop. So it's not about an exact number of points. It's about a threshold of approximation to the fidelity of the curve. Quick correction [LAUGHS] thanks to Simon in the chat I sort of forgot that I had this point E here, which if this is my approximation, this one is actually the furthest one. So this is actually the one that I would be keeping next. And then, I would be recursively subdividing the segment here and checking these. But the idea was correct. I just forgot about the point E . Let's go try to implement this. I'm not entirely sure the best way to do this. But I'm going to try with creating another array. And I'll call this, like, rdpPoints. I also want to have a variable called, like, epsilon. And let's just set that at I'm going to set that to, like, 10 pixels right now. That's a kind of maybe that's a high number. I don't really know. And I want to make this ultimately interactive so that I can change the epsilon. But let me just do it right now with a fixed epsilon in setup. So I should have two curves. So for example, if I say rdpPoints [MUSIC PLAYING] So this is the first step. Give me the start. Give me the end. And add start and end to this new array. Then, presumably, I could also draw the new array and just make it a different color. [MUSIC PLAYING] So here we go. That's my low super low fidelity visualization of this curve as a line just from the first point to the last point. I think the way to implement a recursive algorithm the way that I'm thinking about it is to have a function that returns a point. So I'm going to call the function rdp. I'm going to get a list of points. I'm going to get a two index values. I'm going to get a I'll just call it A and B, so A being the beginning, B being the end. And then, let me just so it doesn't give me an error, let me just write return null here. And the idea is that I am going to find the I'm going to iterate this is point A. This is point B. I'm going to iterate through all the points and find the one that is furthest from that line segment. So I want to go from i equals a to i is less than b i++. And I'm going to have a distance I'm going to have, like, the record distance. I want to find the furthest one. So the record distance can start at 0. I could make it negative 1 just for the sake of argument. And then, I need some another function that's going to give me the distance between a point and a line. And a way that I could do that is if I think of it this way. I have a point A. I have a point B. I have a point C. If I take this line segment, find this normal point, and find the length of this [? normal ?] point, that would be the distance. So I need a function that takes three P vectors and gives me the distance between the line between A and B and the point C. So I'm going to create a function float distance line distance. Let's call it lineDist between a point C and a point A and a point B. And that's going to return some value. Just put 1 there for right now. I'm going to have to get the code to do that at some point. So if the OK. So the start point is start is points.get(a). end is points.get(b). And then, actually, I'm going to go from a+1 all the way up to b minus 1. And I'm going to get the I need to get the, you know, current point is points.get(i). So the distance is line distance between current point and start and end. If d is greater than the record distance, then that's the new record distance. And what I want to do is return that point. I'll call it furthest. And furthest equals record equals currentPoint and then return furthest. OK. Oh, am I blurred? [DING] Sorry. I was out of focus there. I fixed the camera now. OK. So this is my algorithm. It's going to return that furthest point. And where am I calling that function? PVector nextPoint is rdp right? This is going to be this is where it needs to be recursive. So I want the next point. So I'm going to call my rdp function with allPoints, and starting at the index, 0 and total1, starting at the index 0 and total1. Oh, I need the index. When it comes back, I actually want it to return the index. So I don't want to return I want furthest index, because I want to add it here. furthestIndex is negative 1. And then, return furthestIndex this returns an int. So int is nextIndex is rdp allPoints. So then, I would say rdpPoints.add(al lPoints.get(nextIndex)) and then call rdp again between OK. So I should also say startIndex is 0. endIndex is total1 start, endIndex. rdp between and I haven't I have to make this recursive. But I'm just thinking this through right now rdp(allPoints,startIndex, nextIndex) and nextIndex, endIndex, startIndex this has to be startIndex. I think I have an idea for how I can make this happen. I think this isn't actually the rdp algorithm. What this function is should be called is findFurthest, right? This is a function to find the furthest point, given a list of points with a start and end index. findFurthest all right. That's the index. And then, nextPoint is allPoints.get. And then, if nextPoint if the oh, I need that distance. If record distance is if it's greater than epsilon, return furthestIndex. Otherwise, return negative 1, right? I need an exit condition. So as long as it's actually that distance is greater return the furthest distance and then, here, I'm going to say, if next index is not equal is greater than 0, then rdpPoints.add(al lPoints.get(nextIndex)). I'm having trouble, like, finding the recursive moment here. So then what I want to do because I have to do this because I could just do this, right? while nextIndex is greater than 0, rdpPoints.add(al lPoints.get(nextIndex)). And then, I could just say this. allPoints if we can startIndex and nextIndex and nextIndex and endIndex so but this doesn't work. This is where the recursion needs to happen. So this has to be a function. Yeah, OK. Let's try making this a function just for a second called rdp not function sorry void rdp startIndex endIndex. Then, I want allPoints and rdpPoints. I mean, I could just keep those global. But let's do this correctly. So now, let's add those. Then, let's call rdp(0,total 1,allPoints,rdpPoints). And then, nextIndex is find the furthest. If it's greater than 0, rdp this. startIndex, next and it has allPoints. I mean, it's a little silly to have these arrays here. But I'm going to just keep going with it rdpPoints and this nextIndex, endIndex. All right. I think my logic is sound here. So there is the findFurthest function, which just gives me the index to the point that's furthest away between in a list of points between A and B. So first, I'm going to just call it and do the whole list. Then, as long as it's a valid point, I'm going to add it and then check the other two ways. And I should also say I mean, this is a little weird, but if as long as start index there's probably a more elegant way of doing this, but let me just write it this way for a second. if startIndex is not equal to nextIndex like, if they're the same, I don't want to do it. And same thing here if endIndex is not equal to and I could probably do a greater than or something, because I don't want to go past it. But this is all I'm protecting myself here. Like, I want to make sure that I have it'll exit even if epsilon is 0. So let's just say like, this should actually work if the distance is always 100, right? So I don't I need the actual but if I run this right now, I believe my rdp should be the reduced fidelity line curve should be the same, because I'm not actually calculating the line distance. Basically, I'm creating, like, a fake scenario, where all the points are always within 100 pixels. So they're all above epsilon. They'll always all be kept, I think. So I can test if my recursion is working. [LAUGHS] Infinite loop recursion not working. [BUZZ] This is definitely the problem here. I had a while loop in there before, because I was thinking about the rdp loop do this again and again and again. But that's before I implemented the recursive algorithm of the function calling itself. This is just an if statement. As long as I get a valid index, then add the points and call the function again. And this should work. Now, why do we still have this line in there? The reason why it was drawing this weird extra line is because I put the start point. Then, I put the end point. Then, I put this point. So I my actual line is drawing like this. So what I actually need to do, which is quite lovely, is first add the start point, then perform the RDP algorithm, then add the end point. There we go. So I have this working, where the RDP algorithm, the RamerDouglasPeuker algorithm, just adds all the points, because it's not actually calculating the distance. Luckily for me, I have worked through this line distance problem before. And in fact, if you refer to my Nature of Code book, in chapter 6, I work on a particular algorithm that is related to path following. So in a pathfollowing algorithm, I have the start I have a line segment that has a start and an end. And I have a vehicle that's moving at a given velocity. So part of the algorithm involves projecting out its future location and finding the normal from the point to the line. So I actually have already written a code example that does this. And I would encourage you to pause here and maybe go look at this chapter if you want further explanation. But in the interest of time and I can come back and do this. I actually already have this example ready to go here, which shows this scalar projection. So this is showing if I have two points, A and B, and I have another point C, I can always find the normal point of the line. This is called scalar projection, because you can imagine if I bring this down here for myself if I had a light [LAUGHS] if this were a flashlight oh, I can't do this if this were a flashlight shining, down it would cast a shadow there. And I would find that's like a projection onto from 3D from 2D into 1D really. OK. So I should actually be able to just take this exact function, which is called scalar projection, which gives a starts with a point, P, which is C in this case, and calculates the scalar projection between A and B. So let's do that scalar projection and it has to do with the dot product and all this sort of stuff. So I'm going to come back here. And I'm going to paste this in here. So I want to find I'm going to call this the normal point is the scalar projection between C, A, and B. And then, I just need to return the distance, the PVector distance between C that point C and the normal point. So again, if I have point C, I have point A, I have point B, my function that uses the dot product calculates this point, which I'm naming Norm. Hi, Norm. You're such a nice point, Norm. And then, that is the normal point. So now, the distance between C and Norm is exactly this particular distance that I've been looking for. So I dare I say that this is going to work. [DRUM ROLL] Especially why I use this the drum roll that means it's not going to work. I got sad trombone ready. Oh, what? [TRUMPETS] It kind of looks like it did definitely did something. That is nuts. That is amazing. So it does it just once. Let's try different epsilons epsilon of 1. Ooh, oh, it's adding stuff in the wrong order. If you look at where I'm adding the point, I think if I just add for I think if I add it in between these two checks, then everything is going to, like, sort of ripple into the array in the correct order. Let's see. I need to add the point there. Yes, yes, yes, yes, yes, yes, yes, yes, yes, yes, OK. OK. We've really got it now. So now, what I need I want is to animate. So I need to do this particular algorithm in draw. This needs to happen in draw. And rdpPoints has to be recreated every time. That's a new so I'm doing this over and over again. So I'm every time through draw, I'm starting with a fresh array before I draw everything. And then so that's good. So this should now work, right? Now, all I need to do is change the epsilon. So if I start with an epsilon what happens if I have an epsilon of 0? There we go. So I'm going to have an epsilon I believe 10, by the way I seem to remember 10 pixels was the correct epsilon for the sketchrnn model I referred to the beginning of this video. But so I'm going to start with epsilon at 0. And I'm going to say here epsilon plus equals 0.01. And then, I'll just say if epsilon is greater than 10 let's just set epsilon back equal to 0. And let me see what happens here. Are we seeing it change? It's very hard to detect this. But we are it is there. Let me get rid of this. And let me say fullScreen. Just for the sake of argument so you can see this more easily, I'm going to have this go up much faster. And then, I'm going to let epsilon go all the way up to 100. So what I've done here to really demonstrate it is I have epsilon going up much, much faster and all the way up to 100 pixels. So you can see I'm now approximating this curve with only seven points. And I don't know if it's going to ever get less than seven as it gets up to 100 if it starts over. So now, you can see it very, very quickly reducing the number of points in the curve. Thank you so much for watching this coding challenge RamerDouglasPeuker algorithm. Stay tuned for how this gets implemented hopefully into the ml5js library. And a example of an interactive sketchrnn drawing application makes use of this particular algorithm. And so what I would encourage you to do is make can you find a creative use of this? And as a technical exercise, make a version, where the user draws. And you alter the fidelity of what they're drawing. But maybe there are some other things you could try that are more artistic by layering different f with different colors. I don't know. I can't imagine. I hope that you come up with something. Share it in that thecodingtrain.com in the link that you'll find in this video's description. And I will show community contributions on the (SINGING) next live stream. We're going to keep this in. I'm back. The cameras are shutting off again. That's always a mystery here on The Coding Train. See you in the next coding challenge. Goodbye. [BLOWS HORN] [MUSIC PLAYING]