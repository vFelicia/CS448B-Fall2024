hello and welcome to another genetic algorithms video in this video I want to talk about something called pool selection based on Fitness and actually this this this video is inspired by a comment that came in on GitHub from Sinclair zx81 who writes thanks for the video regarding genetic algorithms in this video you suggest an algorithm for pool selection based on Fitness now if you remember what was my algorithm my algorithm was I have a bunch of elements in a population like a b and c they each get a fitness score like a fitness score of eight a fitness score of Two and a fitness score of one and what I do is I create a pool a mating pool not a swimming pool or I don't it's not any of these things it's just some computer thing which is an array but essentially I create that pool and I put a in eight times a a a a a a a a I put B in twice and I put C in once so their the amount of times are in the pool is relative to their Fitness function and then if I go and say magically pick me a random element from that pool I am four times as more likely to Pick A over B I'm eight times as more likely to pick a over C etc etc so you can see how their Fitness in this case maps to probability but this solution is not the greatest greatest Solution on Earth or in the universe or whatever um and this and the reason for this as Sinclair writes is the method you described involves populating a large array of elements um and this this can actually you might have noticed while I was doing the smart Rockets coding challenge like there was a lot of like stuttering at the end of the generation so this can really be a problem suddenly I made this array that has like 100,000 or a million elements in it and things can run really really slow so uh Sinclair suggests a different approach for selection a bit more generalized and supports arbitrary Fitness values and should be fairly quick so I encourage you to look at Sinclair's code I'll link to this GitHub issue thread um but uh a lot of this code uses sort of advanced JavaScript array functionality stuff which is kind of beyond the scope of what I'm doing so I'm going to try to implement this strategy that Sinclair outlines um in a sort of simpler way perhaps less efficient but I'm I'm going to try to do it in this video now what this strategy is also referred to as uh often referred to as rejection sampling or accept reject algorithm and um this is a kind of Monte Carlo method I always just if anytime I could say Monte Carlo I like to say Monte Carlo if I could just leave and go have some I I I don't want to talk about gambling in Monte car there's no reason that let me come back over to the Whiteboard um and so let's talk about how this algorithm is different what if I could pick so in this case I'm picking a single random number a random number and index into this array what if uh we forget about this giant array thing and what if I were to just pick a b or c I would be picking If This Were an array 0 1 or two right I would be picking a random value 0 one or sorry between zero and three and I would say floor so what that's going to give me is this function uh is going to give me zero one or two so if I do that if this is all I do then and this should be a one up here if this is all I do then I have a onethird chance of picking a a onethird chance of picking b and a onethird chance of picking C this will not do because I want to have a higher probability of picking a a higher a medium probability of picking b and a lower probability picking C scaled according to their Fitness so let's think about what I mean by accept reject so I'm still going to do I'm going to have this is going to be a twostep process step one is going to be this pick a b or c now though step two with an equal probability for each accept or reject that's the question I need to ask I picked 01 or two but am I going to accept that as my pick or I'm going to reject it and try again and here's a way I could do that what if I also picked a random number between 0 and 10 and if that random number happened to be less than the fitness score then I'm going to say accept if it is not less than the fitness score I'm going to say reject right and you could think about how this might work pretty often if I pick a random number between 0 and 10 that's pretty often going to be less than eight but very rarely going to be less than I mean rarely going to be less than one or only 10% of the time it's going to be less than one but 80% of the time it's going to be less than eight so you can see how this idea and if I accept then I keep it and I use that parent if I reject it then I go back and pick again so I might have to do it multiple times per pick but in the end I'm going to have a way of mapping the uh mapping the fitness values according to mapping the probability of picking an element according to its Fitness value so this is the theory behind it and let's go try to implement that in code okay so coming back over here I want to show you something I actually have a processing example that I will uh link to the source code for this uh and and before I get to the genetic algorithm I'm just going to run this example and what this example is doing right now is it's picking random numbers between zero and the width of this window and it's graphing the distribution of how often they've been picked and look at that I'm getting kind of an even distribution from the and it's kind of normalizing them to the height of the window it's doing all this stuff so you can see over time a good random number generator should put pick an even distribution of numbers across the spectrum of what you're picking but I'm going to uh now change something really quickly in the code and I will uh and run it again now look at this distribution so this is now a program that's picking random numbers between zero and the width of the window but it's much more likely to pick higher numbers than it is to pick lower numbers and it's you can see this graph is actually just a linear graph of like yals X and how is that working well I have have this function called accept reject and notice what it does is it picks two random numbers why Am I Casting it I must have written this at one point in like eclipse or something because it's totally unnecessary to I don't know why I have that there the that extra it still works um you can see that it picks two random numbers and what it does is it says and this really I'm going to change this variable name like probability the probability whether or not we should accept random number one is equal to random number one so the higher random number one is the higher its probability and then I just check was R2 less than the probability if it was return that value otherwise go back and pick again and I you know I have this like goofy little thing here this hack where I'm like if for some reason I tried to pick a random number 10,000 times I didn't get anything then something is going wrong and let's at least get out of here and not like be an infinite Loop but you can see how this code kind of works so what I want to do now is try to take this same idea and bring it into the genetic algorithms but rather than have the probability be based on the random number itself right I want the probability be based on the fitness of that of that particular element okay so I'm going to go back I'm going to leave processing and I'm going to go back to uh JavaScript and I'm going to look for this uh natural selection function so let me just make sure I'm going hit save this is the example that I'm running it's this to be or not to be that is the question example example which is trying to evolve to be or not to be uh and I'm going to go back to here where uh I'm creating this mating pool so I am now going to get rid of this mating pole tunks goodbye mating pool okay so I'm going to uh keep this maximum Fitness you're going to see that I'm going to use it in a second but I don't need this whole thing where I build this extra mating pool and in fact this whole function is kind of irrelevant except for this maximum Fitness value so I'm actually just going to take this out and do this maximum Fitness thing in the generate function so right here this is the issue I need to replace this part of the code this is the part of the code where I pick parent a and parent b as an index into that particular mating pool but I don't want to do that anymore instead what I want to say is I'm going to just have another function I'm going to say accept reject um something in the popul I'm going to I need to pick a random element in the population and I also need to know I need to pass in that maximum Fitness will be a value I need to write a new function called accept reject and you know what I it can just be in this uh object so I just I think it would be nice to encapsulate this in another function rather than write the code here especially since I have to do it twice so I'm going to write this down here now as oops um this do accept and uh I forgot oh my goodness never mind I was trying to use my sound for it uh I'm G to write a function called accept reject okay and what I want to do is the first thing I want to do is pick a random index so I need to say random number between zero and this. population. length and the Z is kind of an optional argument that I don't need so I need a random number between zero and the length of the population and I want to floor that then what I need to do is pick another random number I'm just going to call that R which is a random value between zero and maximum Fitness so I want some value that goes between zero and the maximum Fitness if R is less than oh sorry sorry if okay so now sorry the uh the uh member of the population the partner the parent is this. population index so this is the actual partner that I picked so I'm picking a random element from the population this is kind of and then I want to get and then I want to get like that the index into the array and then I want the actual object itself because what I want to test is if that partner's Fitness is less than R let's think about this no no no if R is less than that partner's Fitness let's think about this right if the fitness values go between zero and 100 I'm picking a random number now between 0 and 100 if the partner if this particular element has a fitness value of 100 this second the random number is always going to qualify I'm always going to re accept it if it has 50 it'll be 50% of the time if it's 25 the is 25 it will'll be 20% of the time and I can say return that partner otherwise what do it again so I want to say while I'm just going to do this while true over and over over again the return will get me out of this function so this accept reject strategy is going to always pick a random population member of the population pick a random number and if it qualifies if it should be accepted return it uh I'm forgetting some I I'm forgetting some this dots people are telling me in the chat uh line 51 and 52 uh yep thank you so now this should be this. accept this. reject this. accept reject okay so the other thing I want to do is I'm just going to say uh um be safe be safe equals zero be safe Plus+ and if B safe is ever greater than 10,000 return null I don't know what this is really doing but I just want to like get out of that infinite Loop like I feel like something's wrong if this takes 10,000 times to find uh to find a a correct value so uh so let's look at this and let's just see I don't know how I do let's run this okay so clearly I'm getting an error uh the error is population. natural selection is not a function right I eliminated an entire function from this particular scenario sketch. JS uh line 40 um so I'm going to go to line 40 and I'm going to delete this function doesn't exist anymore uh Max Fitness is not defined uh in um so um I'm back I after a little bit debugging I had some sort of significant issues you can see right now what's happening is I'm not kind of getting any Evolution um there's a couple reasons why this isn't this happening um number one is that uh my the fitness function that I'm using at the beginning when I pick a lot of random phrases a lot of them don't have any correct characters and I'm getting a fitness function of zero and in this new algorithm that we've designed if the fitness value is zero this thing has no chance ever of being picked because I can never pick a random number between zero and something that's less than zero so as a like a little bit this isn't the best solution but as a little bit of a hack I'm just going to in the fitness function add 01 so I can at at a minimum the fitness function is 0.0 the fitness value is 01 so everything has at least like a 1% chance of being picked according to this uh rejection sampling model that I'm now using but there's another significant problem and I could run this um uh I could run this again now and it's sort of doing some stuff now it's going to break here and there or do weird things so there and it's not really evolving very well there's also a major issue um if you notice in the code if I go back to this code this is what I'm doing and the comment says it all refill the population with children from The Mating pool so what I was doing before is I had a separate array that I was pulling from to create child objects to put in the population but I'm no longer doing that I'm now actually picking from the population to put things back into the population but I can't be putting the Next Generation into the population while I'm continuing to pick the current population so what I need is a whole separate array um I'm going to call this new population and it's just an empty array and instead of filling the existing population I want to fill that new population and then at the end I can happily say this. population equals new population so that is a fix that I also need here um and now I should be able to run it and we should see that we're back to our old tricks again we've got to be or not to be evolving now it actually I think there's going to be an issue see it got to be or not to be but it's still going there's a reason why it's still going because I have a bit of code that says I uh somewhere I believe in the um in evaluate here yes it says if the best fitness is equal to the Perfect Score then you finish the simulation the problem is the fitness the perfect score is one but remember I added 01 to it so I'm just going to change this to if it's greater than or equals to the Perfect Score being one 100% of the character is correct but I'm just going to check if it's greater than that now because I had that I added that 01 thing so now we should run this again and we should see this is doing exactly what we did before so there's really H you know my assumption here is there's not a significant difference between the behavior of this version of the genetic algorithm and the one that I did with the building the large array mating pool um but using this uh accept reject strategy this rejection sampling strategy I've done away with this giant array thing which I think in a lot of scenarios can be a useful solution to use as well so as an exercise you might go and find the um the uh uh smart Rockets example that I built in a previous video in the coding Challenge and see if you can take that and apply this except reject uh algorithm and in that one in particular I know I was building this really big array which was making it run kind of slow and see if it runs faster with this algorithm okay thanks for watching this video