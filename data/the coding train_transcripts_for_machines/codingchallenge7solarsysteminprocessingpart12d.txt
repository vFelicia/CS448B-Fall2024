Hello, and welcome to another Coding Challenge video. In this video, I am going to attempt to program a solar system generator or simulator or systemlike thing just like the one you see over there in 3D. I'm going to do it in a bunch of steps starting with 2D and moving to 3D. I'm going to use the Processing Development Environment, which you see right here. Link to download Processing will be in the description of this video. Now, you might be asking, why are you doing this? Look, you did it already. This, in fact, is one of my examples. It is called Gravitational Attraction 3D. It's one of the examples that comes with Processing. This is actually doing a simulation of a solar systemlike thing with the actual formula of gravitational attraction. I will link to a video from my Nature of Code series where how to make this is explained, but I'm going to do it in a different way, which is really, ultimately, a lesson about transformations translate, rotate, push matrix, pop matrix, how those types of things work in object oriented programming in Processing. And so I'm going to do it in a different way, and hopefully, by the end of this somewhere between 10 and 20 minute video, you're going to see how to use all that stuff and make yourself a little solar system. And you will be much more creative and interesting at doing it than I will be, and hopefully, you will share what you do with me then, too. I've got to get started. Let's get started. So as always, I'm kind of just got a blank slate here. I should really at least enter this in beforehand, but I'm not. I'm going to add setup, and I'm going to add draw. And I'm going to add size, 600, 600. And space is a dark, black place, so I'm going to just use background zero. I'm going to run this code. I'm going to move this over here. Here we go. This is my outer space simulator. Do you like it? Very few lines of code. Now, the first thing I want to do is create an object. I'm going to call it a planet. So I'm going to make a planet class, and I really think it's going to be useful here for me to use p vectors. So I'm going to create a p vector yeah, yeah, yeah called position. I have to think about this while I'm doing this on the fly. I'm not so sure about this. And I'm going to say, when I write the constructor, yeah, the constructor is going to get an x and a y. And that position will be a vector at that x and y. Now, let's think about this for a second. Oh, and createVector is a function that's in p5 JS. I'll just say new PVector here. I've got to think about this a little bit more. I have a marker here. Let's think about this. So what I want is, I have a planet object, and the planet object, ultimately so let's just think. Let's imagine the first planet object I'm going to make is a sun or a star. Then I'm going to make another planet object, and what are the things I need to keep track of? So I'm not going to do proper orbital mechanics, Kepler's law stuff. That's a great topic for another video. Encourage me to do that. I would love to look into that and do that more, but it's not going to be in this particular video. But what I need to keep track of is it's distance, I'll call r, from the planet, and it's going to rotate around in a circular orbit. So in order to use the rotate function in processing, I need to keep track of an angle. So actually, what this planet really needs is not an xy location, but a radius and an angle, or really, a this is the idea of a polar coordinate, by the way. So instead of x, y, a radius and angle. And you know what? Forget about this p vector stuff. I was really thinking along the lines of my [INAUDIBLE] space simulation, which I do have other videos that you could look into. And I think what I'm going to do in this planet is give it a radius and an angle. And so just to start, we can fill it with radius, and I'm going to say sorry, I lost my train of thought there. The radius equals r, and the angle always let's just say it always starts at 0, or it could be a random angle, that sort of thing. So I definitely need to have a function to draw this, and what I'm going to do to draw it is just draw an ellipse at 0, 0. And I'm going to make oh, sorry. It should also have a size. So I wonder actually if radius should actually be the size of the planet, and I should also have a variable called d, which is I'm going to call this distance. I'm just going to make it longer winded. Distance losing steam. This has been a long day. Distance is the distance from the sun. Now, what I'm trying to do, by the way, is think of a generic model because I might have a bunch of planets that have a distance from the sun, but I might have other planets, which are essentially like moons, which have a distance from their parent. So I might have this treelike structure where some planets rotate around the sun, other planets rotate around the planets. So really, this is just a body. This is a celestial body object. It's not really a planet object, but I'll just call it planet for simplicity. So back to here, so I'm going to draw an ellipse at 0, 0 with the radius which is not r, whoops. Radius times 2. So let's just see sorry, I'm anally retentively getting rid of all the extra space. Here's my planet object, a radius, an angle, a distance; a radius, a distance, an angle; and a show function which draws it. So what I want to do is create a planet, and I realize the sun is not a planet. And I'm going to say sun equals new planet. Its distance from anything else is just going to be 0, because it's going to start in the center. And then I'm thinking, I'm thinking, it's size that's what I need. It's going to be 100. And then I'm going to have sun.show. Let's run this. And where is it? Now, I have a feeling number one is I didn't give it let's give it a color, fill 255. And what am I missing? Oh, distance should be 0. Radius should be 100. There we go. Now, notice where it is. It's in the top left. So I want my sun to be in the middle of the window, so I'm going to start by saying translate width divided by 2, height divided by 2. I've got a light that keeps going on and off up there. It's a little disorienting. So here we go. We're getting somewhere. We're getting somewhere now. We've got the sun in the middle of the window as an object, so now, clearly, I need more data structures to store the information about these planets. Where should those go? Well, I have an idea. You might think that, ordinarily, the next step that I would do would be to create a planet array, because ultimately, I want to have a lot of planets. But really, this is my data structure. I have a sun, and the sun might have three planets rotating around it. And this planet might have two moons rotating around it. This might have one moon. That might have no moons. Well, each one of these is a planet object, so what are the properties of a planet object? The properties are oh, dramatic moment ruined radius, angle, distance. Radius, the size; angle, where is it in its rotation; and distance, how far is it away; and also children planets, things that are rotating around it. So the sun has three, this has two, this has one, this has zero. So each planet should, inside of itself, recursively, self referentially, store a reference to an array of planets. Now, I'm going to be very simple about this and just say every single planet gets three so I got an idea. Hold on, hold on, hold on, hold on. There's lots of ways we could approach this, but I think what might be useful right now is for me to write a function. And I'm going to call it spawnMoons, and in the spawnMoons function, I'm going to create that array. So maybe, I can create a certain number of moons. I can say planets equals a new Planet array with sum number of moons, and then for int i equals 0, i is less than planets.length; i++ planets, index i equals a new Planet. And maybe each moon should be half the size of the planet. This is totally arbitrary. This could all be random, and I figure out different ways of doing it. And then its distance should be sum amount, so I'm going to say I'm also going to say distance. And I'm going to say some amount. I think maybe we could actually make this an argument here. No, let me try just doing something random for right now. Let me try doing something random right now. Random 100, 200. I got to figure out a better way of thinking about that. And I kind of want to put these as separate lines of code to make this easier to see. When a planet gets a bunch of moons, it runs through a loop and creates all of them with a smaller radius and some distance away from it. So what I want to do here now is say sun spawnMoons, and I want to have five. So I make a sun, and then immediately say spawnMoons and have five of them. We can just run this. There's no errors, but I'm not seeing anything. Why am I not seeing anything? Because when I show the planet, I also need to show its children moons. And remember, those children moons I should call them I'm calling them planets, I'm calling the moons, whatever. The children should also are just planet objects. So when I show this particular planet, I draw it as a circle. Then I loop through and show all of its subplanets, so let's see that. And so we have a null pointer exception. Why do we have a null pointer exception? Let's think about this. So what's null here? Let's println planets, and actually, let's say printArray. And we got to debug this here. So it looks like the array has oh, so why did I get null for that's weird. Hold on, 0, 1, 2, 3, 4. What's planets.length? Oh, 5. What's null? I'm losing my mind here. This part might get edited out later. Weird how I'm getting a null pointer exception, and yet it seems to be working. Hold on. No null pointer exception. Oh, hold on, sorry, everybody. Oh, I'm sure so that's working. Planet index i equals new Planet. Something must be is spawnMoons not happening? Oh, I meant no, this seems right. This seems right. Hold on. Hold on, everyone. Let's see here. Let's make sure this is happening correctly. Println planets index i. Let's run this. Five planet objects were generated, so those are not null. Oh, I know what happens! Oh, my goodness. Ahh! So because of this whole recursive system I have of course, of course. People watching this, probably you've all been yelling at me for the last 30 seconds. Because of this recursive system I have, I say, hey, planet, show yourself, then show your children, boom, boom, boom. And each of your children, show your children, and each of you children, show your children. Oh, you don't have any children? Null pointer exception. So at some point, one of the planets will that array will be null. So I need to make sure that I check that. So all I need to do here is just essentially say, if planets does not equal to null, meaning if this planet does have some moons, if it has some children, only then call show. So that's just a quick little check. Everything was right. I was creating things correctly, but I'm forgetting that the new planets I created also have arrays. Let's go, and let's run this. Wonderful. So you can see, I see one circle, and I see a bunch. Now, what am I missing? So what I'm missing is a crucial key step, which is that if I have the sun, and I have a planet, and it's supposed to be at a certain distance from the sun, the orbital distance, I need to use a function in Processing called translate. What translate will do, it will say, I drew the sun at this location, then translate out this far, and then draw the next planet. So I need to add everything is only just being drawn at 0, 0. Oh, I'm in the wrong place. Everything is only being drawn at 0, 0, so I need to add, before this, translate by r comma 0, and I also want to rotate by some angle. So I'm going to rotate by some angle, which is and not by r, by distance. So now if we run this, we should see here are the planets, and let's do something to make things a little more visible here. Let's give the color some alpha, so we can see what's going on. Let's also think about how far these planets are from a couple of things. One is let's make the sun quite a bit smaller, and let's make the planets between 75 and 150 in terms of distance. And you can see now, how come there's only two of them? There should be five. Now, let's think about why I'm not seeing five. Let's take a look at planets.length. I think they're just oh, I'm being silly because they're getting spawned off the screen. So we're not seeing five, so let's sorry about that. That seems kind of obvious to me now. So let's just randomly put them between 75 and 100. Did I do the distance? Oh, of course! Oh, yay! The next thing that I need to teach you guys about the important concept is, I completely forgot, so translations doesn't matter what I do. Translations are cumulative. So I draw the sun, then I translate by 75, and I draw the next planet. Guess what? Let's say the next one got picked 85. What I want is to go back to the center of the planet, translate by 85, and draw the next center of the sun. Translate by the next one. But actually, what I did was I translated by 75, then I translated by another 85, which I don't want to do. So this is where object oriented programming and push matrix and pop matrix come in. If, in my object, if, in the show function, I always put at the beginning of the show function, push matrix, which is like a save, and at the end of the function I put pop matrix, which is like a restore, this function becomes sort of its own thing, its own world. Whatever translations and rotations happen inside of here, they get undone the moment I say pop matrix. So whatever translations happen for this object, they don't affect any of the other objects. And you can see now that they're all, of course, bunched up right there because I kept trying to reduce the amount, where really what I want is for this to be between, like I said, 75 and 300. So now, you can see I'm picking some random planets. Now, notice they're all along the xaxis. Why? Because my angle is always 0. Let's change that. Let's make a random angle between 0 and 2 pi. So wait, wait a second here. What is going on? That should not have happened. Let's look here. Angle, float angle that's crazy. Why is it picking one angle for all of them? What did I do to deserve this strange result? Translate, then rotate by the angle. So let's hold on. Let's take a look at this angle, and we don't need we can get rid of this println planets.length. I have a feeling I've missed something rather obvious. So it's getting different angles for each one, but somehow the same angle is being used here. Do I have a no, hold on. Let's just change the variable name to make sure I'm not losing my mind. What did I miss here, everybody? Hold on, this is certainly confounding me here. I've got to have to figure this one out. Translate by the distance. Rotate by the angle. Ohh, oh, oh, oh. No, that's right. Oh, oh, wait a sec. No, that's right. And then come back, translate by the distance, and rotate by the next angle. That seems to make sense. Hold on, let's I'm going to do a couple of things. I'm going to say no loop, and I'm going to just make two. This is a good way to figure this out. So the loop is only running once, and then I'm going to take out this println. And I'm going to oh, guess what I did. So important. Oh, these mistakes. I always make these mistakes. Oh, my god, I'm rotating after I translated, which is absolutely incorrect. In this case I mean, you could be doing that, but let's think about this. What I want is, here's my sun. And I'm, right now, my registration point where the world is, my point of view is the center of the sun, and the angle is 0. So what I did is I translated out, and then I rotated, which was meaningless. And those things were actually appearing in a different angle only because the sun also had its own rotation. But what I want to do is not that. What I want to do is the following. I first want to rotate, and then I want to translate out. And then I'm going to go back and rotate again, and translate out to get them in different spots. So the order of this stuff is so unbelievably important, and I made a classic error. I want to pretend that I did it on purpose, but I did not. So I put that there. I can get rid of all my printlns, and I can run this again. And we can see there we go. And there's only two, so let's go back and give me five again. And let's get rid of no loop, and let's run it. And we can see we've got our solar system. We've got five planets and one sun. Now, we should also add a function. I'm going to add a function called orbit, and in this function, I'm going to say angle equals angle plus orbitSpeed because I want the angle to change so that they rotate around. And I'm going to replace theta with angle everywhere to just use angle. And then I also need another variable, orbitspeed, which I am going to make random orbitspeed equals random some speed between 0.1 and 0.3, or something like that. And now, let's run this. Angle, orbit, let's use the camel casing oops, or whatever. It doesn't matter. Just have to be consistent. Everything is case sensitive. So now, oops, float a float distance, and now, I also need to add in oh, interesting. So if I say sun.orbit, I'm asking the sun to orbit. But what does it mean for the sun to orbit? Well, it needs to do this, but also and why is angle now not knowing what it is? Oops, I lost angle. Sorry, everybody. Angle. And now, what do I need to do here? Whenever the sun orbits ah! Oh, come on. My keyboard is going crazy. Whenever the sun just like when I show the sun, I have to show all of its children, when I orbit a planet, I need to say, as long as there are planets. I need this if planets is not null, then I want planets index i.orbit. I want all the children planets to orbit as well. I don't have a timer. We can see something crazy is going, so let's think about this. So first of all, they're all kind of spinning out of control, so something has got to be wrong here. Let's look at I've got push matrix and pop matrix, which would lead me to believe oh. So one issue is that I have the sun spinning as well, and I don't want the sun to spin. So I just want the other things to spin, and things are spinning kind of quickly. So the issue is I really should make the sun probably as this static object, a completely separate thing, but I can what I'm going to do is add a argument here, which means that I can set the orbit speed. And when I make the sun, I'm going to set the orbit speed to 0. And when I make the other planets, I'm going to pick a random orbit speed. And now, that should fix it. There we go. So we can see, look, everything is rotating, and those speeds are quite fast. So let's pick much smaller random numbers. And you can see, so now, we have a bunch of circles all spinning around the center circle. Pretty good. They could have different sizes. They could be more we could do more variety with the speed, but we're getting somewhere. Now, to really make this magical, nothing that I've done here right now is the two things that I want to do to make this magical is, number one, have planets have planets have planets, and number two, make this happen in 3D. So let's see if we can if you still had some pause this video, go outside, take a walk. I don't know. Then come back if you want to watch it more. But I'm going to keep going with this. Here we go. So the first thing that I need to do is say that, when I spawn moons, what I want to do is have my planets also spawn moons. So if I were to write this so if I were to write this, for example, so the sun gets made, and the sun spawns a moon. Then I make new planets. If each of those planets spawn their own moons, and so each object has an array of other objects has an array of other objects. So while this would work, this would result in an infinite forever loop because every planet would make five more planets, which would make five more planets, which make five more planets, which would make five more planets. So I need some way of having an exit strategy. Here's a way that I propose which is really dangerous, actually. I probably shouldn't do this is, well, first thing I'll do is just I'm trying to think of a good way there's a bunch of different ways I could approach this. I could keep track of levels. So I could say, after I've spawned after I'm on the fifth orbiting planet, forget about it. I could also, right now, just only do the sun with some planets, and those planets have moons. I don't need those moons to have moons. But I also could randomly decide if planets get moons or not, and I would, by chance, eventually have this stop. Let's do the levels thing. So what I'm going to do is I'm going to add a second variable, spawnMoons 0, meaning I'm at level 0. So I'm going to add an argument called level. This is going to be useful, too, because level is going to help us determine the size and speed of these maybe. And then I'm going to say level minus 1, so when I spawn the moon oh, no, plus 1. So the sun will call spawnMoons with 0, and then it'll make a bunch of planets that will call spawn moons with 1. And they'll make a bunch of planets I've been doing this for half an hour, I guess. They will spawn a bunch of planets with level 2, and so on and so forth. So I only want to do this if level is less than 2. So let's actually only do this if level is less than 1. Let's see what happens. Whoa! Level is less than 0. Yeah, that's interesting. So why did it even do it oh, right, because I'm already spawning 1. So this is if level is less than 0, I'm getting these five planets. And if level is less than 1 whoops. Whoops. Level is less than 1, all of those planets have things orbiting it. Now, this is totally out of control because the distances and the sizes are all over the place. So what I want to do probably is figure out number one is figure out the number of moons they should have, and maybe I'll make that random. And it's going to be between 0 and 4, and so it's going to have that many. So number one, this, right now, you're going to see there's a lot fewer things, and also the distance the submoons should be much closer to those. So I can use this level variable quite effectively. So level, so I'm picking random distances, and what I could do is divide by level. So first of all, I'm going to make the level 1. Start with 1 because I don't ever want to divide by 0. And I'm going to have the distance be divided by level. And also the radius, I'm already multiplying times 0.5, so I could also oops. I could also say divided by level. And that way, this should now be 2, and you can see here now, look what's going on here. It's sort of hard to see because I don't have a good sense of sizes. So I guess divided by level I started with 1, so I should say divided by level times 2. There we go. So you can kind of see here, if I zoom in, what's going on. This particular planet has its own thing orbiting around it as it orbits. By the way, they all only orbit in one direction. Not the band One Direction. Insert One Direction song right now. That orbital speed, I really should pick where do I pick the orbital speed? Right here. I should really pick some value also that could be negative. So that they could rotate spin the opposite direction. So you can see now and it's sort of hard to tell what's spinning around what, but you can massage the values and stuff yourself because I've got to move to 3D. But I at least want to see that I could have another level here. And can we find it? I think I've shrunk stuff too much, so let me at least see if I can get you let's make things generally just quite a bit closer. And also, let's not have the size be that radically different. So you can see here the multiple levels of moons. I'm going to try to zoom in here so you can see the multiple levels of this thing rotating around that thing, with that thing rotating around that thing. And I could even add one more level if I wanted to be so crazy, like 4. And I'll let you enjoy this on your own to try to see everything rotating around everything. Now, so I would encourage you to take this. Add some color. Think about the distances, the values, the ratios, all of that much more thoughtfully. But this idea of nesting systems is kind of interesting to play with. Let's at least see if we can move this to 3D.