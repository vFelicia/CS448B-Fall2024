this I think is the last video in this section all right that maps to chapter 2 of the nature of codebook so we're looking at forces in this chapter we started by just understanding that force is a vector it causes an object with mass to accelerate we looked at Newton's law we wrote an apply force function we figured out we could just make up some forces this force is this and this force is that we could calculate some forces you could make you know you could make forces that are random perla noise you could make forces that are based on formulas and in this last video what I think is useful to look at here is another case study of a formula a force that has a formula that you find in a physics textbook gravitational attraction that's we're going to look at and also I think what's useful to look at with this force is that we have objects that what I'm never going to use these again this is the last video that I'm using this but this object attracts this object and this object also attracts this object how do we have this kind of dance of the particles so to speak tenth of the grey circles that moving around our screen so that's kind of what I want us to look at in the context of this video okay so first what is the formula for gravitational attraction okay and I should say that what we're doing now is you know even though it's all the same we're taking earth out of the picture here right every time in all of our previous examples that we're kind of simulating gravity there was this invisible earth maybe below the window that was pulling everything down now we're actually moving into outer space this makes no sense whatsoever but do you make sense in my head we're moving to outer space and we're looking at gravitational attraction between bodies so if you wanted to kind of create the beginnings of a solar system style simulation you could you could use from the stuff we're doing here although I should say we're not kind of we're not going to be really rigorous about our scientific accuracy we just want to look at the formula for gravitational attraction and try to build it into our code loosely so let's look at that again the force of gravity equals G times m1 the mass of one object times the mass of another object m2 divided by distance squared and then I'm going to say times are the unit vector R so remember a force has a magnitude and direction and in this case this whole section right over here is the magnitude and R I'm just taking our unit vector that's going to be our direction so I think I did this backwards what probably would have made more sense was to start with a diagram but let's do it backwards and now let's look at the diagram that matches this formula so we have an object one with a mass so this is object one and it has a mass and this is object it has a mass and what is our R is a vector that points all the way from one object to another right so object the gravitational force on object one is a vector that points from one to two the gravitational force on object 2 is a vector that points from two to one but let's just actually make things simple to start with in our example we're going to have something called an attractor that doesn't move and we're going to have this is our mover okay so the attractor is this fixed thing and the force is going to map from mover to the attractor okay so you know we kind of did this now this is it this is our you know what's the direction of the force it's our it's our normalized okay we have to I got it I got it this is what we're doing right hopefully we understand this diagram it's pretty simple this thing is being pulled to that thing this is the magnitude that's the direction we need to write this in code so how do we get a vector that points from one position location to another location I wish you were here because you would totally answer this question now and I also wouldn't be so lonely but anyway so what we could get the answer is subtraction we can subtract location 2 minus location 1 gives us R so what I'm going to do is right up here I'm going to make a called direction and it is going to equal and I'm not going to have enough room on this board but I'm going to write down here P vector dot subtract and I'm going to just say location 2 minus location 1 so I'm kind of making up that variables exist we'll go look at a practical example in a second but assume that we had two location vectors the direction is the difference a vector that points from 1 to 2 is location 2 minus location 1 but we need to normalize it so now we can say di r dot normalize and di r is the direction that the unit vector R we're done so we have the the forces Direction once we have the forces Direction we just need to scale it according to its magnitude what is its magnitude G times n1 times n2 divided by distance squared so a couple things here what is G G is the universal gravitational constant it's some number that I absolutely do not have memorized because I know I like program things in processing I don't actually like look at stuff in the real world and how it interacts so you know we don't need the real world number in our processing code we just real what we that is a constant what we can use that constant for is is the force strong is the force strong or is it weak how is that force so for right now we could say G is 1 or whatever it's some but constant but we could um and I'm gonna um I'd like to use it's going to be flat it's fine I'm gonna I gives me a little anxiety to make a variable that's a capital letter because you know that could be breaking some conventions but let's just do it for effect right here so I'm going to say G is 1 now mass of 1 and mass of two those are going to be constants variables scalar quantities floats so we could assume that we have mass 1 and mass 2 and distance what is the distance between location 1 and location well processing has a distance function that we could use processing also has a distance function to give us the distance between vectors but if you remember what did we do right here we said give me a vector that points all the way from object 1 to object to that we normalized it what we could do is say hey right before we normalize that vector what is its magnitude right the magnitude of the vector that points all the way from 1 to 2 the magnitude of that vector that's the distance between those two objects so right up here now this is where we really need to insert a line of code we could say float D equals dir dot magnitude and if I wanted to this is what I kind of fumbled in my last video but there is a method in processing called mag squared which will actually give you the 92 squared but maybe for right now for simplicity I won't use that but that that will optimize the code a little bit if we use that ok so now that we have that dir multiplied times G times you know the mass of object 1 times the mass of object 2 divided by D times D so right this is the magnitude as it maps to this formula and again we have something very special here it's very special and nice about this what we're doing remember I you know I'm not suggesting that gravitational attraction is like this force that's going to make all these magical beautiful wonderful projects what I am suggesting is that you coming up with a creative way of calculating a force might be able to create a behavior an effete emotional quality some form of interaction that's going to be successful in a project that you're making what's interesting about this force is divided by distance squared the further the objects are away the weaker the force the closer they are the stronger the force maybe you want to do something different maybe you want a force that's weak when they're close but strong when they're far maybe you're creating some type of like these circles on the screen that are in love and the further apart that way they more they must come back together but once they're together they can just kind of beat I don't know what the what I'm talking about here but you know we should all aspire to create love in our prosthetic sketches so okay but that the point of what I'm saying here is this is a really this divided by distance squared again we're seeing the properties of the system itself are informing the magnitude of that force and how you build that into things you make is very important I think so okay so now that we have this we could look at how do we apply this in code now here's the thing let's okay let's I'm gonna just unbelievable anxious about this because don't really know where this is going but let's let's I'm gonna tiptoe slowly over here and we do have a processing sketch that we can look at now it's actually not going to run because I deleted some code out of it and I'm going to just save I should have done this before but I'm just going to save it as I'm working with in in in the nature of code book this is example 2.6 simple attraction so that's the example I'm working with here and if we run it we're going to see it can't find this method attract this is the method that I want us to add to this program together I guess it's really just me but let's feel like we're doing it together in this video so one thing I should point out about this is that we have both an attractor and a mover so we have two separate objects and in fact if I just briefly for a second comment out this part that we're eventually going to use and I run this we can see this is our sketch we have this attractor in the center and we have this mover up top and we want the mover to experience a force that where the up we're to track to the object and I shouldn't have commented I just notice I shouldn't have commented MDOT update what's really happening here is that mover is moving to the right so instead of just moving at a constant velocity to the right we want it to be attracted pulled into that object okay so how do we do that so this is what I'm talking about in terms of nice objectoriented programming syntax this is only one way of doing it there are countless ways you could organize your code but what we're doing is we're saying hey the attractor has a method that can receive a mover calculate a force and then we can store that force in a variable and apply it to the mover so we're having objects communicate by saying the mover a truck I'm sorry the attractor attracts the mover okay so how what this this tells us let's actually I don't know where we are in time this is nine minutes so far so I'm going to keep going to I'm going to belabor this point for a second so if I come back over here you know if you if you're really familiar with objectoriented programming you might want to just kind of skip ahead a couple minutes but I'm going to I'm going to just cover this I think is it's kind of important we wrote code that says a dot attract M and the result of that gets stored in a vector so this this is I think a nice strategy a is an attractor object M is a mover object and this kind of reads nicely it says attractor attract the mover return that force and then we can say mover dot apply force F that force can then get sent back into the mover now okay so well what's what's going on here we wrote this code but we haven't written the attract function it doesn't just magically exist right there's no attract function just magically in an attractor class but we wrote it this way it's kind of a an indicator to us that what is the function we need to define the function we need to define is called attract it receives a move or object which I'm going to call other and it returns a P vector so this here is that method signature it's a function called attract that's going to go in the attractor class it's going to receive a mover object and it's going to return a P vector so I just wanted to go over this kind of a this is important this is kind of how we have a nice way we can have objects communicate with each other by having one object receive the other one is an argument to the function and then they can you know do stuff in that function together ok let's go back and let's put this into our code now okay so if we go into the attractor class we now need to write a function called attract which receives a mover as its argument I got it these things are going to fall off this little podium okay so we're going to write a function called attract the mover is its argument it's going to return a P vector so what's the first thing we need to do we need to know the direction of that force so I'm actually going to miss make a variable called force which equals we're going to subtract the movers look on the location of the of the attractor minus the movers location now notice here in the attractor object so since we're in the attractor object its location is just location the movers location is the argument the mover is the argument so we need to refer to that mover ends location so the attractive location the movers location then we're going to normalize that and then this is the so we have the direction this is us direction of the force that's the direction now once we have the direction we need the magnitude magnitude of the force so what is the magnitude it is I'll call it strength equals G times the attractors mass which is just mass times the movers mass which is MDOT at mass divided by and just be safe here let's put some parentheses around here divided by distance squared now notice if we run this it's going to say it can't find anything named D so D is the thing that we haven't actually calculated yet but remember distance we have a vector pointing from the at one locations object to the other look up one locations object put hot chicks location to the other objects location we've got a vector pointing between those two the length of that vector is the distance between the two so right before we normalized force we could say hey what is your magnitude so this is us saying hey we're getting that vector we want to normalize it but before we normalize it just wait a second we please have your length because that's the distance once we have that this will work all we need to do is then put magnitude and Direction together by multiplying by that strength and I think I spelled it wrong so this is putting magnitude nough tude and direction together and now we have force multiplied by strength so this is the direction this is the magnitude this is them together let's say return force and we do we have everything on we have all that commented back in we're getting the force we're applying it we're updating it let's run this it's going to be very dramatic and exciting and good ok so what happened here it didn't seem to work so let's go back in look at this code again why might this not have worked it's really tragic because we really very careful to put everything in here here's the thing I have something to mention this is not the real world right that's a little gray pixel circle on the screen this is some madeup code we're kind of correct this is where we have to say you know what the real world has this formula but we want to make the appearance of something we've got a kind of adjust and tweak here and what's the problem the problem is that distance times distance in pixels can be really large and as soon as these objects get like 150 200 250 pixels away that force is so weak that it's it's just floating off in the distance at the same time when the object gets so close that force could suddenly become so large that some really strange behavior could create could happen so this is a nice moment where we could use the constrain function we can kind of constrain our world in an unrealistic way but in a way that's going to just make us feel happier in our lives so let's do that we're going to say I know this is the actual distance but what I want to do is constrain that I'm going to say between 5 and 25 so even if you're more than 25 pixels away just consider yourself as 25 pixels away note I'm not actually constraining its location it can be anywhere what wants to be I'm constraining the result of that distance calculation so now if we run this again you can see we get this kind of attraction behavior so you could see it's like this almost orbiting around of the attractor in the center so this is really it in terms of getting that gravitational force to work but I want to just we can see here we have the attractor which is fixed and actually if you go and look at this example one thing you'll see is this attractor can actually be moved which i think is kind of a useful thing to look at but you can look at the code for how that's done but what I want to look at though however is one thing that this example isn't doing so this example is saying hey have an attractor attract a mover and if we wanted to we could expand that very quickly by I must change the size of the sketch we could expand that very quickly by having a lot of objects be attracted to that singular attractor so here we can see like oh we could do that in a loop we could say hey all of the movers every mover I be attracted to the attractor so that's a sort of instant change we have a single attractor we have an array of attractors but what's a little bit more difficult is and you can kind of consider this as an exercise for yourself I guess is how do you have mutual attraction every object is attracted to every other object a hint of that is you need a nested loop for every mover be attracted to every other mover so for every mover for every mover again and then of course you want to make sure that one mover is not a try any mover is not attracted to itself we need to build in something for that and if you're looking for the answer to that it is example in 2.8 so if you're falling on the book example 2.8 will show you that mutual attraction and one thing you might think about to go beyond that is a how could you do that in 3d and B I'm looking at these how could you change that force from an attraction force to a repulsion force and could you have objects attracted to something in the center but repelled from each other how could you mix this up to create a dynamic system with multiple different behaviors happening at the same time just while we're here I also thought that I would just kind of quickly bring up this kind of a classic project of use of attractors this is called Metro pop denim I actually forgot the year but this is clayton cubit and tom carden's for many many years ago I think this was done with like the alpha version of processing that's before you know before this 2.0 beta before 1.0 etc before 1.0 beta so but you can see that this this there is a if you were to trace the pathways of particles being attracted to may be invisible attractors you can create these kind of patterns and these patterns were combined with fashion photography to create these spreads for a magazine and really I don't know if they did this with the project but you can imagine positioning the attractors according to some properties of the photographic imagery in such a way so there's lots of possibilities that you can use this for and so I don't know have a good time drawing the stuff out and leave some comments or ask some questions or I don't know something this is the end of chapter 2 in the next set of videos which will all be numbered three points something we'll be looking at oscillating motion and reviewing trigonometry Seacrest out is that something I could say I'm not Brian Seacrest so that make any sense okay goodbye