So we've covered the basics of objectoriented programming and we could probably Easily go on and on, for video after video after video, to look at all sorts of different scenarios and complications and different ways of..., and we will get to some of that as we start to look at lists and arrays multiple objects, but there's a few kind of key pieces that I think I want to kind of mention I originally intended this would be like three or four videos But I think I'm gonna give you a survey of a couple added features of object oriented programming that even if we don't get into in depth here... will get you kind of like thinking and know some terminology so you kind of do your own google searching or look at examples, and you know? Complain to me to make more videos at some point too. So the first thing that I want to mention is just the fact that We spent a lot of time kind of understanding the idea that a class is a template for making an object and the class has data in it and functionality in it. Some variables and some functions a key piece of information, I think to realize and think about is that this data doesn't just have to be a float or an int or just as a bunch of simple numbers it could be other objects and I Think there are a lot of scenarios where it makes sense to program this way for example Let's say you were making a body object so we had a class called body and the body conceptually has a head and torso and an arm and some legs and a hand right you know my terrible drawing skills aside You can see that this body is made up of multiple pieces And we might start having things like oh head x head y head size arm but what if we thought about this that actually what a body is is it is a head it is an arm which is like the right arm and it is another arm object. Which is the left arm right and so what does this mean? Oh, I need to write a class that is the head class, I need to write an arm clas. So this idea of a hierarchy that the data of an object could actually be other objects and later when we see when we look at lists of objects, what if I have a particle system with a thousand particles? I might have an object that has a list of a thousand other objects in it. So this is all of this this idea of nesting of creating some type of organizational hierarchy is something you should be thinking about as you start to build out larger and larger programs, okay? So I just wanted to briefly mention that another thing that I think is worth Kind of briefly mentioning even though you kind of don't really need it that much but you might see it in some examples. As you can actually write more than one constructor So I just want to come over here this very simple example. Where I just have a particle class particle class is just an x a y and a size and here we have two particle objects, um... notice the particle constructor receives three arguments a temporary x, temporary y, temporary R to fill the, those parameters of this object. So What if I wanted to do this? And say okay well if I specify the three arguments? then I want those arguments to be the... pieces of data for that particle object. But what if I don't specify any arguments then I just want you to make a random particle well? This is actually quite allowed and common. I could write a second constructor that takes no arguments where the lo... where something different happens? To those variables, so this is what's known as overloading I've overloaded the constructor, meaning I made two different versions of it one that requires three arguments one that requires no arguments. I could make a version that requires two arguments or one that requires four arguments And this is actually quite common in fact this is not just limited to the constructor after all in Processing you can say fill and give it an RGB or you can say fill and give it a just a single grayscale value. You could give it four arguments for an RGB and alpha and this is something that the designers of Processing have put into the API many different versions of the same function that expect different numbers of arguments. And this might be something that you think about as you start to build out programs yourself. So, if I come back to this... we could now... I'm going to get rid of this third particle. I could say hey... let me make this second particle, just be random. As you can see, whoops when I run it... Why is it always in the top... left. Something is wrong here. x is random width. y is random height. I don't see why that should happen... for p2 I'm after size.... oh, it's... I'm sorry. I forgot that I had this extra piece of code in it. That's putting it where the mouse is. Sorry. So you could see that every time I run this that second particle is... Somewhere else. And now if I go back to what it was before Something like this you can see now I'm specifying, it's always going to be over there. So this is something, this idea of overloading is something that you can do. Okay. So there's one last piece here that I want to look at and Gonna just sort of scratch the surface of this by looking at a kind of simplified scenario. But this way of thinking, I think will apply to lots of things that you might do who ever you are might try to do at some point. So let's think back to this Processing sketch we have, where we have these two objects on the screen. How do we get these objects to communicate with each other? How do we know when they're overlapping or not overlapping? How do we know? How do they know their distance apart? What if we want something to happen when they hit when they get close versus when they get far? So this idea of having two objects communicate with each other. This is a kind of key concept that involves some techniques that are a little bit beyond just the basics of objectoriented programming. So let's look at this for a second. There's a few different elements here. One, so let's just take for a second. How do we know if two circles are overlapping or not? So each circle has a radius R1. This circle also has a radius R2. We can clearly see that these circles are not overlapping and I can clearly see... That these two circles are overlapping. The key piece of information. We need to know whether they're overlapping is the distance between them. The distance between them and what we can... the way we can determine if they're overlapping is if the distance... is greater than the sum of the two radii this being one radius, this being another. Clearly if you add these two together... The actual distance is longer however if we look at this radius plus this radius the distance is shorter than the sum of those two radii. So this is one way that we could determine if two shapes on the screen are overlapping. So let's come back to this program and let's sort of see what we... if we can figure that out here. So I can say for example. What is the distance? between p1 x and p1 y and p2 x and p2 y and if that distance is less than the sum of their radii, then let's draw a green background. So if we run this... No green background, and if I were to put them at as overlapping Yes, a green background, so let's do something where... aaaa... I can put this piece of code back in here where I can just kind of move this one's location as soon as I come over here. We can see we get this green background. And let's make the... let's make the... Stroke weight a bit bigger okay, so just so we can see here okay, so you can see we get when they're overlapped. No we're not but while I've done this what I haven't really done is I don't like the way that I did this I just kind of had some gobbledygook code out here That's like checking these values together, but really what I want to say is the following if p1 overlaps p2 then draw a bit green background. if... p1 dot overlaps p2... Then draw a background. Okay, so how do I make this happen? How do I write code like this? This is so nice actually? This this is what what is what's going on here? I... you know, I know we have... you know I have a display function. I can display p1 I can display p2 I'm now saying if p1 overlaps p2 Then do something. So what's going on here. Just like there's a display function. I now need to write a function called overlaps. And... What is the argument, what are the arguments to this function? Okay... So let's start doing this what the reason why I'm sorry I kind of like lost my train of thought here But the reason why this is useful is this way of thinking in terms of object orientation and having a... calling a function on object and passing another object into that function This is now unlocking the key to what code I actually need to write I need to write a function as part of the particle class called overlaps so I can actually go ahead and do that But I'm missing some stuff right what I said... When I say overlaps I'm passing in another object. So now what I need to do is Pass in some other object. I'm just going to call it other. So the overlaps function takes an argument which is some other object. This is a little bit strange conceptually because we're in the particle class and yet I have a function which receives another particle what you have to remember is the idea here is you could call the overlaps function on this particle in reference to another particle. You could actually check if a particle overlaps itself But that would be kind of conceptually flawed the other thing that I think is key here is... Notice this function is inside an if statement so p.overlaps p2 has to evaluate to true or false. Right it either does or a doesn't. Which means that this function... needs to return a boolean varia... a boolean value. So the function overlaps receives another particle and answers the question am I overlapping that other particle? Yes, or no, return true, or false Just for right now. I could just say let's not bother to implement this let's just write return true in there... and I'm going to take this out of here and Get rid of this stuff we worked out before... and now I'm going to run this and of course it's always green because I'm always returning true. Now I could go back to this function, and I could return false and now it's never going to be green. But this isn't what I want to do obviously. In here, now here is the place where I want to write that code where the object that I am right now the particle object communicates with the other particle object. So... How do we do that? I want the distance between what? Okay, I'm a particle object. I'm in the particle class. I want my distance between my location... x comma y and Then I want the distance between my location and some other particle that's coming in as the in the argument its location other x other not y. And then if that distance is less than this my radius plus the other radius return true otherwise return false. So this is now a function inside of an object which receives another object as its argument so that the two objects can talk to each other. They could compare their locations they can compare their size and if we run this Now you can see it's working again The reason why this is so useful and it's not really emphasized here. Is that... I could now check if I have five different particles I could just check if p2 overlaps p5 or if p3 overlaps p1 or p4 overlaps p2. So I have a generic function that checks if one object overlaps another object. Now, I realize in making this quick example this is a little bit tricky, and it might actually been a little bit simpler if I had you know particle objects and bubble objects and the particles check if they're overlapping the bubbles because then you wouldn't have this thing where you have a Single object checking another object of the same type which can be a little tricky But this is kind of a way of thinking that you I think want to get used to so as an exercise I might give you the following exercise Take this idea reimplement this basically this exact same code and Instead of having two particles have three and can you make something different happen when these two overlap versus when these other two overlap and I think that would be kind of a good A good way to start so how could you have one how could you have maybe try four particles or five but particles and have different things happen with different combinations of overlapping and see how that goes for you. You might also want to file this in the back of your mind that later when we get to looking at arrays and lists of objects. How would you have every particle checking if it's overlapping every other particle? Which is kind of a tricky problem. Okay, hopefully this video. Did some good... and I'm going to stop now.