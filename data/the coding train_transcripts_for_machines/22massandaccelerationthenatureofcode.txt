Welcome back. In the previous video in this section on forces, I built this particular example where there are two forces that play a gravity force that's always being applied to the mover object. And when I click the mouse, a wind force is being applied to the mover object. What I want to do in this video is look at how I might consider this mover object to have the property mass and how that might affect how the gravity and wind forces behave. And in truth, for me to be able to demonstrate this effectively, it's only meaningful if I have two objects with different masses, because if I just have one, scaling the mass is just something that will ultimately scale the strength, the relative strength, of those forces. So let's quickly add a second object to this example. Now, you might already be thinking to yourself, ugh, what did you just do there. If you're going to have more than one object, should you use an array? Or isn't there a different way of doing this? And yes, yes, yes. And ultimately, what I want to do with these examples is build arrays into them to collect many objects and sort of add and subtract them from the canvas itself. But just for demonstration purposes, I'm going to leave these as two separate variables, mover A and mover B. I'm going to apply both forces to them and call update edges and show on both of them. Let's see if that works. There we go. Let's apply the wind. You can see how they're kind of in lockstep together. Maybe mass will change that. So both are bouncing and responding to the wind force. Now let's think about where I want to add mass. So looking at the mover object, there is position velocity acceleration in r. And r is a property that is tied to the size that I'm drawing the ellipse. Let's just add mass as its own property for a moment. this.mass equals 1. And the reason why I want to do this is remember Newton's second law, force equals mass times acceleration, or restated as acceleration equals force divided by mass. And remember, the way that I'm implementing this is all of the forces divided by mass are being accumulated into the object's acceleration. So first and foremost, I need to incorporate this divide by mass into my apply force function. Right here, I can then say force.div by this.mass. Before I add the force into the acceleration, divide by mass, let's try running this. Good. Same result. Well, the mass is just 1. So let's now add mass equals 2, which I should see the acceleration the force remains the same. But the strength of the acceleration should be divided by 2. Wait, what's going on. Something weird going on. Why are they different? They shouldn't be different. They don't have different masses. Something crazy's going on. Do you remember, oh, a few videos back, I spent all this time talking about static functions? Random 2D is a static function. It's called on p5.Vector rather than, like, this function, mult for multiply, which is called on v, the object itself. There was a purpose to that. There was a meaning to that. There was a reason for that. And that reason, that moment is right now. I want to divide force by mass but not the actual force vector itself. I just want to take that vector, get a copy of it, divide it by mass, and then add that to the acceleration. The reason is because out here, I'm taking this wind vector and applying it to A and B. And I don't want A to mess with it because wind should stay the same when it applies to B. But this function itself is actually taking that force vector and dividing it by 2 and changing its value. So there's different ways I could do it. I could make a copy of it and then divide it. But I could also use the static version of divide. In other words, I could say and I need a new vector to store the result in. I'll just call it f. p5.Vector.div force by this.mass. So here I am saying, take that force, divide it by mass, and store the result in a new vector f. And then that vector f is what gets applied to the acceleration itself. And of course, I need to remove this line of code, which I no longer want. And there we go. So now mass is playing a role, but it's not affecting externally the environment. And it's just a property of the object that's affecting the way the force changes the acceleration. So let's take the logical next step and give each of these objects a different mass. So I'm going to add a third property to the constructor, call it m. And then when I create the objects, let's give one a mass of 2 and one a mass of 4. And again, I'm just picking numbers out of a hat totally arbitrary. So remember, the one on the right will have a higher mass than the one on the left. Interesting. This is correct according to Newton's second law. If acceleration is force divided by mass, if an object has a larger mass, it will accelerate less. And this makes sense. Think about the force that you have to apply to an object. An object with a greater mass is going to be you're going to need a much stronger force to get it to accelerate than something with a much smaller mass. Think about bowling ball versus a ping pong ball. How much force do you need to apply to get those both to accelerate equally? Something is not right here. You might recall or have heard about Galileo's famous Leaning Tower of Pisa experiment where, as the story goes, in the late 1600s, Galileo was said to have dropped two spheres of different masses from the top of the Leaning Tower of Pisa. And did they fall did one fall faster than the other? No, they fell at the same rate, independent of their mass. And the reason for this is because the weight of an object, weight being the force, gravitational I'm really using the wrong term here. I really should be saying the gravitational acceleration. The force is the weight. And the weight of an object is scaled according to its mass. The bigger the mass, the bigger the force. The smaller the mass, the smaller the force. So for this to work more accurately, I should really say, let weightA equal p5.Vector multiply gravity times moverA.mass. And weightB is that same thing, multiplying mover B's mass. And then I'm going to apply weightA weightB. So this is a little bit I'm, like, sort of fudging things a little bit just to like take this gravitational vector and then multiply, scale it according to mass before I apply it in, where it then gets divided by mass. Let's just see if this works. Perfect. They're both falling at the same rate. Now let's apply wind. The acceleration due to wind is less when the mass is larger. And that's the way it should be. The thing is, it's kind of hard to see what's going on here because I'm drawing them at the same size. This is a nice moment for us to think about, if I have two objects and I'm going to just erase this here if I have object A and the mass of object A is 2, and then I have object B and the mass of object B is 4. Well, certainly if the density of these things is the same and what is the density? I mean, these are just pixels. But let's consider the density to be the same. Then I might want to draw mass B, object B, larger than object A. So one idea could be, like, oh, the radius could be equal to the mass. So here, the radius is 2, and here the radius is 4. But that's not really the right scale because what should really map, at least in my mind, to the mass is the area. So the area of this should be twice the area of this. What's the formula for the area of a circle? Pi r squared. So in that sense, I think a proper mapping would be to take the square root of the mass. And why is that? Let's say in this case the radius is square root of 2 and in this case the radius is square root of 4. Well, the surface area, the area, pi r squared, would be 2 pi. And here, pi r squared would be 4 pi. Whereas if I used 2 and 4, I would have 4 pi and 16 pi. Because I'd be squaring 2. I'd get 4. Squaring 4, I get 16. So take that mass. Take the square root of it, and apply that to the object's radius. In other words, this.r equals the square root of this.mass. Let's take a look at what this looks like. Well, those things are so tiny. They're so tiny. So I'm going to scale it arbitrarily, multiply it by 10, and we can see this object has a higher mass. Now, why are they kind of bouncing out of sync now? Well, it's because they're hitting the bottom at different times because their size is larger, which is fine. That's visually what I want. And now you'll see the acceleration of the smaller one be much higher with the wind. Ultimately, I'm making so many arbitrary decisions here, and there's many inaccuracies. But I'm attempting to at least take the ideas from real world physics and apply them to the best of my ability in a way that feels accurate. So one of the things I might suggest to you are there things that you see that I've missed, things are inaccuracies or don't feel right to you in terms of how, if these were physical materials, they would behave? Certainly they would collide with each other. That's an interesting that's a whole other can of worms to open that I'll come back to another time. But what types of elements can you apply to this? Could you add an array now? Could you think about how you visually design these objects? Maybe you want to represent the different masses in a different way, through color or some other way of visually indicating that. But for me, the thing that I want to do now is I want to revisit essentially what I'm doing in these two lines of code, where I say, let wind equal createVector number comma number. Let gravity equal createVector number common number. Is there not a better way or a different way that I might approach the calculation of a force vector in the environment? And that ultimately is looking up a formula for how a force is calculated based on the properties and conditions of the environment. And so the three forces I want to look at are friction, drag which is kind of like friction, but different and I'll explain that as well as gravitational attraction between bodies in space. So I'm going to look at those as kind of case studies in different formulas. Maybe you'll have some ideas of ways you can look at other forces or invent your own forces. But I'm going to return at least in the next video and just think about friction. Specifically, when these two objects are in contact with the edge, how might they realistically slow down as if there's a contact friction between those objects and the surface or the edge of the canvas itself? [MUSIC PLAYING]