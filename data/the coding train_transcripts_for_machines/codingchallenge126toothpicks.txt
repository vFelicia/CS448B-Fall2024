(train whistle) Hello and welcome to a coding challenge. Toothpicks? I know, seems a little weird. What? I'm really doing a coding challenge about toothpicks? And in fact I have all these toothpicks on my desk over here and I'm trying to, I thought, "Oh I'm going to have this really amazing video "where I arrange them." And I just, I just, I can't. I'm terrible at this sort of thing. So I'm going to, but I do have an overhead camera, which is exciting. There's some possibilities there. So what is this toothpick pattern? Terrific toothpick pattern. So first of all, I would suggest pause this video right now. Go and watch this wonderful Numberphile video which explains the toothpick pattern. And you can use it to generate interesting fractallike visualizations in a two dimensional space. This actually comes from the research of N. J. A. Sloane who is the founder of my absolute favorite website. I mean, I don't know, but there's other wonderful websites so I don't know. I don't want to play favorites here, but the Online Encyclopedia of Integer Sequences is a pretty awesome website. It's just a website of sequences of numbers. And I've used it before and there's so many things to explore in terms of these sequences of numbers, but one of these, a particular sequence of numbers comes out of this toothpick sequence, Omar Pol's toothpick sequence. So this is a nice interactive demonstration of the toothpick sequence. You start with, oh, wait, wait, wait. We can do this. You start with a single toothpick. Let's just say next. And you put two toothpicks, I can zoom in on that, two toothpicks. I'm doing it! I'm making content with multiple (mumbles). You put two toothpicks like this on the ends and then you say next and I also put toothpicks on the ends, but the next step is the key step. So once I get to here and I say next again, notice how no toothpick goes here, right? Toothpicks can only go on what's called a free edge, an edge that's not touching any other toothpicks. So this is touching here, this is touching here. I can actually point over this way. I don't know. I don't know the best way to do this. Let's get rid of that camera shot. But so and then if I keep hitting next, look at this. I keep going and going and going and going and going and going and I can adjust the scale and I could actually just say run and boom. And so I want to make this in the processing programming environment, which is a Java 8 programming environment. Can I make this? So a couple of things. One is this is fun to play around with. You can play with different, you can play with different parameters. You can render out to a PDF. And in addition, what's going on here, why is this a number sequence? What's kind of fascinating about this and if you watch the Numberphile videos, can you create an equation, a formula to sum all the given toothpicks at any stage of iteration? And that's exactly what this particular number sequence is which I will now do a dramatic reading of because I like to read number sequences. (gentle lullaby music) Zero, one, three, seven, 11, 15, 23, 195, 207, 223, 251, 283, 303, 319, 347, 735, 763, 795, 815, 859, 895. Okay, that's good enough. (laughs) (claps) Let's start coding. Let me make a window that's 600 by 600. Let me draw a background that is white and let me hit run and we can see. There it is. There's my window. This is where I need to draw the toothpicks. So I think what I need to do is, you know, skip a few steps here, like I might, if I'm really trying to do this, the first thing that I might do is just literally draw a line. But I know that I'm going to need some kind of toothpick object. This is a good case of objectoriented programming because I need to create a class that describes what it means to be a toothpick. What does it mean to be a toothpick? Then I can have an array of many toothpicks. I'm going to say class toothpick. And what do I need in a toothpick? So, I know that I need a toothpick. I need to have two endpoints. What's the xy location here and what's the xy location here? So I'm going to call those ax, ay, bx, by. And I'm going to write the constructor. And the way that I'm going to do this, the way that I think this is going to work the best, like when I create a toothpick, what I'm going to do, the toothpicks can only be horizontal or vertical. So I'm going to create a toothpick by giving it the center point and then giving it a value like one or negative one whether it's horizontal or vertical. So in addition, it is also going to each toothpick will have a variable called dir for direction or orientation. So I'm going to give each toothpick an x. And I'm using integers very specifically because I think this is going to make my life easier to sort of almost think of this toothpick as living on a grid and you can't have spot 1.37 or 2 point, like I really want to be like as close to pixel perfect as I can. So, and I also, I mean this is really a global variable for the whole system. I'm just going to make a variable called length for how long a toothpick is. And I do want an add number because I do want to have that center point be perfectly, have each half of the toothpick be equal in size. So for example, if I had a toothpick of length nine, then the center point is at five, no four. Zero, one, two, three, five, six, seven, eight. Hold on, let me explain why this is important. If I have something of length three, right, this is the center, the total length of this is three, this is the center. I have one spot here and one spot here. If I have something that's of length five, then I've got two here, two here, and a perfect center. So this is going to be important in terms of, I think, the sort of evenness of how I place the toothpicks. Alright, so length. Let's just start with a length of nine. And what I'm going to say is that, oh, and I get to get a direction. So I'm going to say that if the direction, oh, so first I'm going to say that, let's just call this d. Direction equals d. If the direction equals one, let's make that a horizontal toothpick. So then ax should equal x plus length divided by two and ay, no sorry, and bx should equal, oh so ax should be x minus length divided by two and bx should be x plus length divided by two. And then the y's are the same. Ay is y and by is y. And then let's make a toothpick that is vertical. So I'm going to do all the same stuff, but these are now going to be with the y, higher and lower. And let's get rid of this white space here. And so now, then I'm going to write a function called like show and I'm going to say, I'm just going to draw. I'm going to say stroke zero. Let's make a little, stroke weight like two just so we can see it. And then I'm going to say line from ax, ay to bx, by. So this is the idea of a toothpick. A toothpick has two points a and b, axy, ay, ax, ay, bx, by and it has a direction. Just to be clear about this because this is so fundamental, this is the toothpick. This is point ax, ay. This is point bx, by. But also the toothpick could be in this orientation as well. So now in my main program, I'm going to make an, I know I'm going to need to have a list of toothpicks. So I'm going to make an array list full of toothpicks. Let's call that picks equals new array list toothpick. Now if you've, if you're coming from all of my JavaScript tutorials, this is a pretty weird thing that I've written because in essence, if I were doing this is JavaScript... Why does it not know? (bell rings) Silly me, I have a capital P there for no reason. So what I was saying was, if you've come from my JavaScript videos, you would see me do something like this, like making an empty array that I'm going to fill in JavaScript is super simple. In Java, which this processing is built on top of, I've got to use this data structure called an array list. I don't have to. There's other data structures, which I need to specify what's going in it toothpick objects. And then I need to create it. So there. Now what I want to do is I want to picks add a new toothpick which I'm going to put at 300, 300. And you know what? I'm going to put it at zero, zero and I'm going to give it a direction of one because what I'm going to do here is I'm going to say translate width divided by two. I'm always going to think of the center at the center of the canvas as zero, zero. So I need to translate to that center and then I'm going to say for every toothpick t in picks t dot show. So this now a loop where I'm just going to say whatever toothpicks I have, so I'm starting with one toothpick. I made a class, objectoriented class, a template for a toothpick. Then I made an actual toothpick. Zero, zero, I can't remember. One is either this way or this way. And then I say whatever toothpicks I have, show them all. And so now if I were to run this again, we can there's my toothpick. And let's make the length, let's have length be kind of like a global variable over here. And let's have that be something more like 63. Let's run this again. We can see there's my toothpick. And by the way, I could do something like this. I mean, you know, as an exercise, I could just make a ton of random toothpicks, but that's not what I want to do. What I want to do is each cycle, right, I want to say what are all the existing toothpicks? Check every existing toothpick. Look at its endpoints. Is that a free endpoint? And if there is, make a new toothpick there. So a nice way to do that in the draw loop is to start by actually saying, make another empty array list. I'm going to call it next. So this is kind of like the next generation of toothpicks is another new, boy, there's a lot of typing going on here with these array lists. I'm going to make a new list of toothpicks, the next list. And as I go through all of these existing toothpicks, what I want to say is, I'm going to say, I'm going to, you know what I'm going to do? I'm going to ask the toothpick to create. I'm going to say call create. I'm going to say, I'm going to name these create a, create b. There's probably a better name for that. I'm trying to think, but what I mean is, let's have the toothpick itself, it knows about its edges. Maybe I need to, when I call those functions pass in an array to all of the existing toothpicks. Like hey, check yourself before you wreck yourself. No, check yourself against all the other toothpicks to see if your edges are touching any of them. If not, make a new toothpick. Ah, and these should be and then I should say toothpick. This function should return two new toothpicks. I'm going to call them a and b. I should probably call them, if I'm being consistent here, like next a and next b. So, right, and then, so okay. So what if, and then I want to, what I think I'll do is I'll have this function. I'm kind of planning this out as I'm going. This might be a bad idea. We'll find out. I'm going to have the function if the endpoint is not actually free, just return null. So it will return a new toothpick if it's a valid endpoint edge. If it's not, it'll just return null. So what I'll say there is if next a is not equal to null, then next dot add next a, and there's probably a way I could do this with one function or something, and if next b is not null, add next b. And then at the end, what do I want to do? I want to say I think toothpicks dot add all next. So I think this is the idea. Like I haven't really written the code for doing this yet, but this is the idea. For every existing toothpick... And here's the thing, I don't want... This would be problematic if I didn't... I think, there's a couple reasons why I want this next array list. And I did sort of think about this in advance. Like you might be thinking why not just add them to the existing list of picks? Well, one thing is if I add stuff to the end while I'm iterating through it, things could go pretty awry. Also, visually what I want to do, I might want to draw the new toothpicks each time like as a different color. There might be some separating out what the next generation of toothpicks is from the current generation might actually be somewhat helpful. (claps) Okay, so now what I really need to do is write this, these create functions. So let's say, let's first write the create a function. So with this function, it gets another array list, whoa. I'll call these others and return null here. The idea of this function is I want to check this toothpick against any other existing toothpicks to see if they're sitting on the edge and if they're not, I'm going to create a new toothpick on the edge. So, here's how I'm going to do that. I'm going to say for every toothpick other in others, oh geez, if and let's try... So I'm going to write some pseudo code for a second. If this pick is touching other and I also, first I want to say, actually by the way, if other is not equal to this, like I only want to check, I don't want to check this, if this toothpick against itself. And I'm going to say, oh this is, boolean available. So I'm going to assume the pick, the toothpick is available. So and then I'm going to loop through all of them and if I find that its edge is touching any other edge, then it's not going to be available. So how am I going to do that? Now because I've written this in kind of what is now arguable a silly, whoa, toothpicks went flying! Somebody slowmo that down. (deep slow motion voice) Do we have Smarter Everyday's like slow motion camera somewhere available? Okay, if because I wrote this in a sort of silly way, I'm writing a create a and a create b function, what I actually just want to do here is check the a endpoint against every other toothpick to see if two toothpicks have the same endpoint as each other, to see if they're intersecting at that same endpoint. And you know somebody did ask about toothpicks. A toothpick right, I'm looking for the case where this is toothpick one and this is toothpick two and this is like point a and maybe it's the same as point a or b of another toothpick. This is what I'm looking for, but it is the case that toothpicks could also be intersecting the center of another toothpick. But I'm pretty sure I don't have to check for that because once I add a toothpick, if I add two more toothpicks, sure this toothpick is intersecting here at the center of these two toothpicks, but it's done, like I never have to check this toothpick again. Once I have added something to that toothpick, I can call it quits and only check the endpoints of these new toothpicks and by definition, there can't, there could only be, the way this algorithm works out is, you know, these two, the two toothpicks here are intersecting at the endpoints. So I'm pretty sure that's how it's going to work if you look at the demos of it and how it works. I don't think I need to check the center. Okay, at least I'm trying to convince myself. So as long as it's not the same toothpick and intersects, I'm going to write this rather awkwardly. I'm going to say intersects ax, ay with other, with other, then available is false. And so maybe what I want to do is say like other dot intersects ax, ay. So this is actually like available equals false. So maybe this is kind of like a function inside of the toothpick class, that it can check if it's intersecting any generic point. So this is a little bit confusing what I'm doing. I'm going to write a boolean function that says intersects any arbitrary xy. And I can say basically if ax equals x and ay equals y, that is a case where I should return true. Otherwise if bx equals x, I'm just checking both points. And again easily, there's probably a better way to do this. I'm also going to return true. Otherwise, return false. So basically this is the idea and these are integers. And I can check for equality here because I'm doing all integer math. If I used p vectors and floating points, I'd be worried about, you know, I'd have to use the distance or something. But as long as the a point and the b point of this toothpick is not equal to this arbitrary x and y point, then I want to return false. So now here comes the fun part. Right isn't this fun? I'm having fun! Weeping emoji. If it's still available, then what I want to do is return a new toothpick. And the new toothpick center, the new toothpick center is where? It's at that point. So the new toothpick is at ax, ay and it's direction is what? It's direction is always the inverse. So if this one's one, this one's negative one. If this one's negative one, this one's one. So it's just direction times negative one. Otherwise return null, okay? So now we're going to go back here. Let's forget about next b. Let's forget about create b. I also want to do something. I'm going to say no loop. I want to control the looping and then I'm going to add mousePressed and in mousePressed, I'm going to call redraw. This is so I can click the mouse through every frame. So let's see if this works. Let's see if I can kind of condense the code a little bit so we can look at more of it at once. And now, oops, if other does not equal this and other, oh, I'm missing a parentheses there. Let's run this. Okay, so now if I click, I got a new toothpick. I got a new toothpick, new toothpick, new toothpick. So this is actually working, but it's just doing that one endpoint. So again I really shouldn't, there's no reason for me to have two separate functions here, but why not? What I'm going to do now is in the toothpick, I'm going to, just this is terrible. I do not like this at all, do not like copy pasting. I'm just going to call this create b. I'm going to say bx, by and bx, by. So this is exactly the same function, but checking the b endpoint. And I can do this because a toothpick only has two endpoints. But this doesn't scale. It can't generalize this to any kind of shape with any n number of endpoints. So, definitely going to have to rethink this for maybe a future video I might make. Oh, look at that! That kind of looks like the toothpick pattern. (bell dings) So in some sense, we're done. But couple things I want to do. Number one is I would like to, I need to, there's a big optimization I can make here which is to only check the new toothpicks. So one thing that I'm going to do is, let's make these two different loops just to, let's separate out the drawing from the like picking the next stuff. The other thing I should do is when a toothpick is a new toothpick, so let's call it new pick, oh, that's weird, is true. So and then the, what I want to do here is when I draw it, let's try it. Let's just try this for a second. If it's a new pick, say stroke, let's make it blue. And then by definition, then new pick would be false. So I just want to and actually let me not do that here. So this should be, now they're all blue. Okay, so they're all blue. All the new toothpicks are blue. And then what I want to do here is I would say if t is a new pick, again, I could probably keep it in a separate list, but whatever. If t is a new pick, then I could do all of this checking and then say it's not a new pick anymore. Alright, so this is going to limit all of the checking to only the toothpicks that were actually new the previous time. And I could keep the next array list from one cycle to the other, but this I think will do the trick right now. Blue, you can see this one is no longer blue. Only these are blue. Only these are blue. So in theory, I have now optimized this a bit faster. Okay, so now going back to the code, I can, to get rid of this no loop, I can let it just go on its own and we see it sort of filled up the screen really quickly. So this is what I want to do here. I want to use the scale function to, as it grows, sort of zoom out on the drawing. So scale is a transformation that can scale what I'm seeing. So, for example, if in the draw loop here, I just say scale 0.5, you can see there it is at half the size. If I say scale 0.1, we can see, now we can see all those toothpicks being added at a much lower scale. Okay, okay, so how do I have that dynamic? So the way to have that dynamic is one way would be let's try to figure out maybe what the, what toothpick is furthest to the left edge and furthest to the right edge. So what if I have some global variables like min x, which is equal to zero, and max x, which is equal to width? Oh and actually these should be negative, so I, because I am considering this around zero, min x would be negative width divided by two. Max x would be positive width divided by two. So negative 300, that's the sort of the minimum and maximum range to start. So I could say the difference is the scale, the scale that I want, let's call that like a factor is the maximum x minus the minimum x divided by the width, right, or actually the width divided by that, right. Because if the distance between the furthest toothpick to one side and the furthest toothpick to the other side is twice as long as the actually width of the window, then I want to scale it to .5. So, but of course, I need to find out these maximums and minimums. So the way I could do that is I can actually just, right here as I'm looping through all of the picks. And you know in theory like I'm going to get the scale for the next round, but that's fine. Min x is the minimum, whichever is smaller between the current picks. Let's just use one endpoint. I mean, I could probably check both endpoints, but let's just make sure this works. And the current min value and the maximum is whatever is the biggest between bx, sorry sorry, ax and max x. Right? I think this should work. Factor is, what did I get? Did I get like a, the value of the local variable factor is not used. Oh, sure. Oh, scale factor, but that's not the error I'm getting. But divide by zero. Oh no, no, no, no, no, no, no, no. This has to be max x. (bell dings) Oy! I had the wrong for awhile there. Okay. Oh, you know what? Are these, these are all integers. These are all integers. So integer math is going to give me zero. There we go. Okay, so now I am scaling according to, and you know actually these are getting... I'm scaling according to the distance between the sort of like furthest toothpick and the furthest toothpick along the x axis. I could do this along the y axis. There's probably a lot of smarter ways to do this, but this will work right now. So, the other thing that I might like to do is calculate this factor. I should probably store this as a global variable also because I kind of want to use it. And you know what I could actually do? I could just do this. I could pass it in here because what I want is also the stroke weight to be maybe inversely proportional to the factor. So like as the factor is getting smaller, I want the lines to be thicker so that maybe they show up better. Yeah, I don't know if this is really reading, but like as they're shrinking, the lines are getting thicker. Goodbye Youtube compression algorithm, but you can see the idea here. So it's going to run really slow. I have not super optimized this, but what would be fun to try is, and maybe I should just make them a little bit thicker like two times that. What would be fun to try, what I would like to do is to see if I can make a nice full screen version of this in P2D. Will that help? So here we go. Here is the, I'm sure the Youtube compression algorithm is making this impossible to watch, but here is the toothpick number series from the Numberphile channel visualized using Java in processing. Now, it's running super slow. I kind of, what I want to do, but I should check the number series. So let's actually check that number series. Let's do print. One more time, print line. What do I want to do? I want to check how many toothpicks there are, picks dot size. And lets change the frame rate to one. And let's open up the console. Let's put it back to a smaller size and let's open up the console so I can see this better. Alright, so here we go. (gentle lullaby music) One, three, seven, 11, 15, 23, 35, 43, 47, 55, 67, 79, 95, 123. Is this right? I really hope this is right. Let's check. One, three, seven, 11, 15, 23, 35, 43, 47, 55, 67. (upbeat music) Thank you. Woohoo, it worked! So by the way, you should watch that Numberphile video. You should look at these. You should try, there are so many other ones and there's different shapes. Toothpick on a hexagon. Whoa! Reset, reset, reset. Look at this. Oh no wait, hold on. Reset, reset. Toothpick on a hexagon. Oh boy, whoa. So there's so many interesting possibilities here of things you could try. Lets look at, there's one that's like a nice, maybe it's the e toothpick that's kind of like snowflake like. Yeah, look at this one. Oh, that is so, I really wanted, so maybe next week for my holiday special, I'll try to do this one. But you should explore all these. Watch the Numberphile video. Expand this, refactor the code. Make it your own version. I will release a version of this that also runs in JavaScript that you can do that to run in the web browser. So you can check this video's description and share with me your variations in color and animation and how you think about doing this. I can't wait to see what creative stuff you make. Okay, goodbye. (bell dings) (upbeat music) (bell dings)