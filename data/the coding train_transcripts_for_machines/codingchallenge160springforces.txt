[TOOTING THE TRAIN WHISTLE] Hello, and welcome to a coding challenge about springs. This is the example that I make in this coding challenge. This is the end product. I'm just going to jump right in, but let me say, this one's a little bit long. I mean, some of my videos are a lot longer than this one, but I'm going to go through this very slowly. So I'm going to start with this idea of calculating a spring force with just a single variable, like the y value moving up and down. Then I'm going to look at vectors. What does it mean to have a spring force be calculated with a vector? And that's going to allow me to transition into making things like this, where I have a system of particle objects and spring objects, and everything is connected, and everything is all boingy boingy boingy all day long. So without further ado, enjoy. I'm going to begin this journey through exploring springs with Hooke's law. So Hooke's law is named for Robert Hooke, a British physicist, yes, who developed the formula, this law, in the 1660s. So Hooke's law was originally stated in latin as ut tensio, sic vis, as the extension, so the force. But it's more commonly written out as an equation, and the equation looks like this. As the extension, x standing in for the extension another word for that might be displacement so goes the force. K is a value commonly referred to as the spring constant, so it's how stiff is the spring, how springy is the spring, if you will. To understand what the extension is or displacement is, let's draw the diagram as follows. A spring is made up of three things an anchor, a bob hi, Bob and the spring, the boingy thing, the spring itself. This thing is really the spring. So if the spring is at rest, meaning it's not moving at all, then we have something called the rest length, which is the distance between one end and the other end of the spring, or in this case, the anchor and the bob. This is the rest length. Intuitively, you probably understand a spring as, if I were to pull it down and release, it would spring back up. If I were to contract it and push it in, it would spring back out. That contraction, or that extension, is the displacement, or the extension. So let's say I were to pull it down to here, the distance between where this bob currently is and where it would be at rest, this is known as the extension, or in this case, x. And the reason why the negative 1 is there is because, even though the extension is positive, the spring is being the force is pulling it back in a negative direction, the opposite direction of that extension itself. Ultimately, I want to do this with vectors, these little things known as arrows, so that this could be anywhere, and the spring could point in any which way. But let's work it out just in a sort of one dimensional spring with just a single y value first. I'll begin with just this really basic sketch, just one variable, just y itself. So y, being 200, so we'll say I got it. We'll say that y position 200, the spring will assume as attached to the top. And then the rest length would therefore be 200 or 200 minus y. So the displacement, or x, would be wherever the current y is minus 200, and I should make that rest a variable. So in this case, the displacement is 0. The spring shouldn't move, which is what I see. But what happens if the displacement is not 0, like if I make it 250? So clearly, it should spring back up, so I need to calculate that force that I've got over there. And I can make up a spring constant. Let's just use the value 1 for lack of anything else right now. So what do I do with that force? How does that force change the y position? Well, this goes back to core foundational principles of my Nature of Code series. An object has a position. The velocity changes the position. The acceleration changes the velocity. I cover that extensively. I'll link to those videos here. Other thing that's really critical about that series is Newton's second law force equals mass times acceleration. And if I were to simplify that law, just say, well, forget about the mass. It's equal to 1 for everything in our world. Force equals acceleration or acceleration equals force. So if I were to say the velocity changes by the force, which is the same as acceleration, and the position, which is y in this case, changes by the velocity, that's all I need. Change y by velocity. Change velocity by force. The only thing is, I need a velocity variable, and I need it to start at 0. Oh, boy, interesting. I'm getting something. It's springy for sure, but I think the issue here is my value of k is much too high. So let's use a lower value, and we can see, there it is, springing back and forth. Look at that spring. Oh, it's so springy. Let me add a little damping in here and just say velocity times equals 0.99, meaning it's going to lose 1% of its velocity every frame, and that's how you might imagine maybe there's some air resistance or some other kind of force that slows the spring down over time, and eventually it comes back to at rest. So you could pause this video now and maybe try some interesting things, have more than one spring. Could you move it up and down with the mouse? Could you have it go left and right? But really, there's not a lot that I can do with this without adding in the idea of a vector, so let me redraw this diagram with it at an angle so that we can bring in the concept of vectors here. I mean, the concept of vectors could have existed with my previous diagram. It's just I think I'm going to be able to illustrate it better if it's an angle. Now, if vectors are unfamiliar to you, again, I could refer you back to that whole video series about vectors, but the idea of a vector in one sentence is an entity with magnitude and direction. And so I could draw it in this diagram here as an arrow. This could be the spring force. It has two elements to it. It has its direction. Which way is it pointing back towards the bob or towards the anchor, I suppose? And it has a magnitude. How strong is it? What is its length? This formula still gives me the magnitude, the force of the spring, the magnitude, the length of this vector is negative k, the spring constant, times x, the displacement. The issue is, I need to figure out the direction, and the way that I can figure out the direction is, if I know the anchor point, if I know this as position a, and I know where the bob is currently down here, if I call this position b, I can create a vector that points from a all the way to b by taking b minus a. If we think of a vector as having two components, an x component and a y component, I just need to subtract b's x minus a's x to get this value, b's y minus a's y this is very awkward to say to get this value, b minus a. So coming back to the code and let me create a new version of this. Instead of y, I want to have position, or maybe I'll call it bob. And let's also have a vector that keeps track of the position of the anchor. So you can see the Create Vector function creates the vector, and it's really just storing an x and a 300 for x, 200 for y; 300 for x, 0 for y. Let's draw both of them. I'm going to comment this stuff out, and we can see I have two vectors, one for the bob position, one for the anchor position. Now, I need to get a vector that points from the anchor to the bob. Now, this might look like a totally insane line of code to you. It would be much nicer if I could just write bob minus anchor. I have to use the specific vector functions. This one is for subtract. I can make a vector from subtracting bob minus anchor. Again, all this stuff is covered quite more extensively in my vector videos, but for now, we can just realize, in that side, that variable v is a vector that points from here all the way to there. A vector that is exclusively noting the direction is what's known as a unit vector of length 1. So I can call this function Normalize to take that vector and normalize it to a unit length 1. In a way, I can add it to this formula here, v with a hat on it. This means the unit vector, this is the direction. So I have a unit vector pointing in this direction. I just need to multiply it by the spring constant, the displacement, and then reverse its direction a negative 1 to go this way. v.multiply times k, v.multiply negative 1, and then v.multiply by the displacement. How do I get the displacement? Aha, guess what? Remember when I got this vector that pointed all the way from a to b? The magnitude of that vector, the length of that vector, is the distance between those two points. Perfect. So before I normalize it, let's say let x equals v.mag, and obviously, I'm being silly by having these three lines of code. I can multiply it by negative 1 times k times x. That is now the spring force, and I think I'd rather rename this variable now to force. And I've done essentially exactly what's in these two lines of code, but now with a vector. Now, I just need to adjust these two lines of code to work with vectors. I need to have velocity has to be a vector. Oh, so this has to be a vector, and force is already a vector. So I could change this to adding the force to velocity. That's the vector way of adding, and then bob.add velocity, and then velocity.multiply by 0.99. So again, I'm doing everything exactly as before. I just needed instead to oh, interesting. Oh, look at this. Ah, I made a mistake! Hold on, but let me finish my thought. I basically just changed everything, but one of the things about working with P5 vector is you can't use plus, minus, multiply the traditional operators. I've got to use the mathematical functions velocity.add, velocity.multiply, et cetera, et cetera. But I forgot something. I forgot about the rest length. We still have this rest length of 200. x is not just the raw magnitude of this particular vector. It's this particular vector minus the rest length. It's this displacement. So I should say x equals force.mag minus restlength. Oh, well, I should move the bob down 50 pixels, and we could see it springing. I should probably draw a line just to have that line in there. And silly, but I think I prefer having the line before the circle, and there we go. We've got our nice spring. Let's see what happens if I take the spring and move it off to the side. If I've done everything right with vectors, I should be able to position that spring anywhere, and it will move in the same fashion. So let's give it a start of 350 comma 250, and there you go. Now, you might be wondering, that's weird, it feels like it should be falling down or coming around to the center. Well, maybe if there were gravity, but this is just a totally made up thing. So this is just it's almost more of a top down view, where I'm looking at a table, maybe where you're pulling something out and springing back and forth. But it is interesting to think about, what if I do add gravity here? And yes, this is an oversimplification because I'm not thinking about math and all sorts of other factors. But I could just make gravity a vector that points down, and then I could also add that force to the velocity. And now, you see it's kind of, interestingly enough, acting like the pendulum. Let's move it all the way over to the side and see what happens. And it's kind of awkward and weird, but we've got a springy pendulum swinging back and forth. Maybe that gravity should be a lot stronger. Maybe I should be thinking about math. I'll leave you to play with all of that. Just to add one more thing to this, I think it would make sense for me to be able to move the bob around with the mouse. And I could do this in a much more elegant way, but I'm just going to say, if mouse is pressed, I'm going to set the bob's position to the mouse location, and then also, I'm going to set the velocity to 0 because I'm locking it in place. It's no longer moving. So I can click the mouse, and I can move it anywhere I want. So if I move it over here, it should spring back up. And then if I click the mouse again, I can move it here, and it'll spring back down. So that's just one thing for you to see. You can play with it. Again, awkward interaction. I encourage you to see what kinds of things you could add to this to make it feel a little bit more elegant and visualize it in a different way. But I'm not done yet. I have barely scratched the surface of what's possible to do with springs, and in order to get further with this, I need to expand my thinking beyond the idea of just there's one anchor, there's one bob, there's one spring. I should really not even be distinguishing between the idea of an anchor and a bob. Really, what I want to have are particles and springs. Let's say I have a bunch of particles like this, and each one is connected with a spring. I pull one, it pulls the other, which pulls the other, which pulls the other. I can start to create simulations of soft bodies. I can even make a square, attach the edges with springs, put some crosshatching in it with springs, and I've almost got a skeleton of a squishy, spongy body. Now, ultimately, I have video tutorials that show a lot more about how to do this with physics libraries, like toxiclibs, and you could go explore those. You don't need to code your own spring forces. But I'm just going to go with it. What I want to do is create a particle class, which would represent any one of these dots, and then a spring class, which would represent any one of these lines, and have the spring class be responsible for the spring force calculation, and see what happens. Now, as much as I might like just to sit here and type out all the code for a particle class, I've done this in so many videos before, and it's outlined in chapter 4 of the Nature of Code. So I'm going to go over to that example that I have on GitHub, which has an entire particle class, and I'm going to bring that into my code. I'll talk through what the bits and pieces are in there, but rather than type it all the way through. Going to make a new file called particle.js, reference it in index.html, and then paste in that code. Now, there's a few things that I don't need. For example, I don't need this idea of lifespan because I'm not going to have particles that fade away in this example, though you could conceivably have that. I'm going to get rid of this Run function because I want to just use update and display separately. I like to call this show these days, so I'll change it to show. No real reason. And I also don't need this IsDead function, because again, the particles are going to live forever. It's a wonderful place where particles live forever. So what is this particle? It's an object that has a position, a velocity, and an acceleration. It happens to have a mass, although the mass is just 1. It has it apply force function, which takes any given force, applies it to the acceleration, and it has an update method, which once again, I can get rid of this lifespan. Add the acceleration to the velocity. Add the velocity to the position. And then it has a show function which draws it. Going to the sketch, I want bob and anchor to be particles now, so I want to say bob is a new particle. Anchor is a new particle. And I'm passing them the xy position of where they begin, so just checking the particle system class. I did this in a slightly different way, so let's give the constructor arguments xy and say create vector xy. I guess this particle also is initialized with a random velocity, but I don't want that, so create vector 00. Now, I should be able to get rid of velocity from here because velocity is part of the particle itself. Gravity, you could still consider part of the world, so that could be a global variable out in the main sketch area, but I'll worry about that later. Ultimately, let me get rid of circle these two calls to circle and all the fill and the stroke, and I just want to say bob.show, anchor.show. Get rid of this, and I'll comment all this out. Great, so there are the bob and the anchor. Let's move the bob down a little bit, and also I mean, this is all a little bit silly, but I'm going to make them a little bit bigger. I can get the nice blue color I had before, and there we go. So what's next? I want to take the idea of a spring, which is here of the rest length, k. It's the idea of being connected between the bob and the anchor, and I want to package that all up into a spring object. For example, ultimately, velocity shouldn't be here. I just need one more variable. I need to call it spring, and these would not be separate variables anymore. I would then just say spring equals a new spring, and maybe it has a value of k, of 0.1. It has a rest length of 200, and it connects the bom and the anchor. These are all the pieces of data that I need for a spring. What is it connected between, what is k, and what is the rest length? Clearly, I need another JavaScript file to put my spring class. Let me fill out the basic skeletal structure of the class. What are the elements that I need? A value of k, a rest length, and two particles. These can all be arguments to the constructor. Then when it's time to update the spring, what do I do? Hooke's law. This is where that should go. The idea of updating the spring is calculating the spring force and applying it to those two particles. So all of this code that I worked out before can go right in there. Now, I've changed the name of some things. So the force, I'm subtracting a from b now inside of this generic spring class. The rest length is a property, so I need this dot. And k is a property, so I need this dot. And then I need to apply those forces. However, there's a little bit of an issue here. If the force is being applied to both particles, the force if this is the spring, and I were to extend it, the force for this particle would point inward, and the force for this particle would also point inward, pointing in opposite directions. So let's take out the negative here, apply it to this particle, then multiply it by negative 1 to reverse its direction and apply it to the next particle. I might have gotten which one should be negative wrong. I could think about it and probably get it right, but I'm just going to keep going. I also want to draw the spring. I'm going to say stroke weight 4. So this became a little bit convoluted. I almost just typed this dot a dot x, this dot b dot x, but I forgot the actual x value is inside of a position vector inside of the particle a. So I've got to draw a line between a's position x, a's position y, b's position x, b's position y. So let's go back to sketch and try adding in spring.show. Now we see that line, and this is very silly, but I want to have these after that. So now, we see them connected, and I don't know. I show play a drum roll or something. If I just type spring.update, is that force going to be applied, and it's going to work? I'm going to type it very slowly with my eyes closed. [DRUM ROLLING PLAYING] There's no chance this works. No, OK, got an error. Good. Well, it wouldn't be a coding challenge if I didn't get any errors. There's an error as copy could not be called. v.1.copy is not a function. Spring line 11. All right, let's go back to spring line 11 oh, look at that. So the mistake that I didn't make inside of line, I made up in update. I want to subtract b's position minus a's position, but not the particles themselves. I need to say a.position and b.position. Good. I don't know. I don't have any errors, but I don't see anything moving. Oh, guess what? So I'm applying the spring force to the particles, but the particles, I'm not calling the update method. The update method is once that spring force ends up in the acceleration, in updates their velocity and updates their position, so that is something I also need to add bob.update, anchor.update, spring.update. Whoa, I think maybe I had the directions wrong, so most likely, it's the other way around. If I go back into the spring, this makes sense. I want to take the one without the negative 1 and apply it to b, and the one with negative 1 and apply it to a. No? Oh, yeah, whoa, this is kind of interesting. Something is wrong here. Oh, look at this. There's just a literal typo. I said this dot position. I don't know what it's getting there. There we go. That's what it should have been all along. And actually, I had it right in my head, but I should have said b minus a, and then this would be a, and this would be b. There we go. Now, there's no other forces in the system. There's no friction or drag force in the system. So I might here, in the particles function, if I wanted to, optionally, I could include that back. And over time, you could see it would eventually spring to being at rest. Let's add back in the mouse control. So now, you could see, as I drag this around, I'm pulling this thing that's attached to me by a spring, and I can swing it around and do all sorts of fun physicsy things with it. But I'm still missing those wonderful possibilities of creating an entirely interconnected system. So I don't know there's just so many different directions this could go in, and I really want you to try and experiment on your own. But I'll just give you a little bit of a starting point. Let's create a line of springs. So first, let me give myself a lot more vertical space to play with, and instead of a separate bob and an anchor and a single spring, let me make two arrays. Then let's space out particles by an arbitrary number. I'm going to say 50 pixels, and I'm going to create five particles. And instead of showing and updating each individual one, let me do that in a loop. Great, there's all my particle. Let's space them out a little bit more. I also want to make them smaller. And there we go. Now, I need to connect each one with a spring. How do I do that? Looking at this, I can see that the second particle should be connected to the first. I mean, they're index 0, index 1. So index 1 should be connected to index 0, index 2 to index 1. So as long as I'm not in this loop in the 0 element, as long as I'm not in the first particle, then a is particles index i, and b is particles index i minus 1, the previous one. And so the spring that I want to have is a new spring. Maybe the rest length is spacing. What was the order of the things in the constructor? k, rest length, a, b. I'm going to make a global variable, k. They obviously could all have individual k's, but I'm not going to worry about that. k, spacing, particle a, particle b, then let me add that to the array of springs. So this is a way of saying, every particle connect to the previous one in the array. Then I want to update and show all the springs. So far, so good. So how do I know if this is really working? Everything's at rest, so nothing's moving. Well, what if I were to say the I'll consider the tail, meaning the last one. I'm going to say let tail equals particles index the length minus 1, which is the last one, and if the mouse is pressed, set the tail's position and the tail's velocity. There we go. Look at them, all squishy squashy with each other. That is awesome. And I can do things like make the spacing 20 and have 20 of them, and I can start to pull them like this. I could also consider having an option in the particle class itself to have a Boolean variable called lock. Basically, if this particle I'll call it "locked." If this particle is locked or if it's not locked, update all the physics. So basically, if a particle is locked, no physics. It can't move. It can't do anything. Then I could say, in the main sketch, after I make all the particles, particles index 0 locked equals true, so that first particle will always be locked to the top. Now, I've made is the rest length still 200? No. I wonder if I want to make I'm just curious. This is a very squishy. What if, I guess, maybe if I increase the actual k value? Yeah, this is more what I might have imagined. But also, now, I could add back in some gravity to make it feel like it's a thing that's hanging, so let's actually add back in the gravity. Basically, I'm also going to say p apply force gravity. So take that gravity force that I created, and you can see, oh, it's pulling them down. So that makes sense. It would always pull it down slightly. I almost don't want to see the particles, so I'm going to take out the showing the particles. So I just have this string, and I can move it around. Let's give myself a lot more space to work with. Set it in the middle and go back to 50, and just have five. And we can see all the kinds of different behaviors I get. So there's lots of parameters of this system that could be played with. A place where you might start is just change the way this is being drawn. Am I drawing the particles? Am I drawing the springs? Which things? How am I drawing them? How am I connecting them? For example, what if I used begin shape and end shape instead of the positions of all the particles to connect them with vertices? Let's see. Look at this. It's actually a closed shape, so it's almost as if I have this piece of cloth that I'm swinging around. And incidentally, I could use curve vertex, and now, it's going to look much more curvy along the side. Now, strangely enough, it looks like where's the top point and the bottom point? One of the things about curves and this is a bit of an aside here, but curves need an entry point into the curve defined and an exit point out of the curve defined. One quick thing that I could do is just I mean, I already have this tail. I could well, I'm just going to do it. I can just say, let's add an additional vertex for the tail, and then also for the head. So I'm just doubling up on the first and last point, and now, we can see and I kind of want to I love this idea of this cloth. But ultimately, let's just see what happens if I say no fill. We can see this feels much more like this soft string that I am curling around. So I really hope that you've enjoyed this long process of starting with just a single variable, moving to vectors, and then moving to objects. If you create something from this, please look in the video's description. There's a link to the Coding Train website where there is a web page that you can share a link to your own creation. I think there's a lot of possibilities here, whether you explore the way this is visualized, whether you explore how you are mapping out your whole structure. Can you make like a little squishy robot character out of a head and a body and some legs? There's a lot of things you could do here. Of course, I should also note that this is a common enough technique that there are many other physics libraries that you could use that have particles and springs built into them. Box2D, Matter.JS, ToxicLibs, and I do have other videos that cover those. And a lot of them have more robust and accurate techniques in terms of how the actual physics is calculated, so I encourage you to explore those. I'll leave links in the video's description for you to explore those, but there is something nice about having it right here in your code. This will integrate into any p5.js sketch you already have. If you've been working through the Nature of Code, and you have sketches with different forces in them, spring forces will just add right in seamlessly because this is set up in the way that all those examples are set up. So there's a lot of possibilities here. Thank you so much for staying all the way to the end of this video, and I'll see you next time on the Coding Train goodbye. [TOOTING THE TRAIN WHISTLE] [MUSIC PLAYING]