(bell ringing) Welcome to another Pi Day. Approximating the number Pi coding challenge on this date March 14. I should probably be doing this once again on July 22nd. But well that's another story for another time. So in this video, I'm going to find Pi somehow in the Mandelbrot set. Which is really kind of nuts. The nice thing about this is I can piggyback off of a coding challenge that I've done before coding challenge number 21 the Mandelbrot set. So the Mandelbrot set, if you're not familiar with it is a special fractal invented by Benoit Mandelbrot the mathematician. Which is a fractal shape, a selfsimilar shape that appears in the complex plane. Let me give you a quick summary of the Mandelbrot set coding challenge and you could go back and watch that if you want to see all the code built. But the idea is that the canvas, the window in processing represents something called the complex plane. And the complex plane is a plane of complex numbers. What is a complex number? So first of all complex numbers are something I spent a little bit of time talking about in the Fourier transformation series. You should also go and watch those. And I'll try to refer you to some other videos that talk about complex numbers and socalled imaginary numbers. So complex numbers of the form A plus Bi where I is the solution to the equation I squared equals negative one. So you can kind of think of I as the square root of minus one. This is also sometimes referred to as a lateral number but anyway naming the side the idea here is that if B, if the complex plane where the X axis represents the real component. Oh, just real, RE for short and the Y axis represents the imaginary component. Then we have all of these points in this plane are of the form X equals, oops, sorry, X plus Y times I. So the Mandelbrot set appears when you take this idea and apply to this strange equation. So C, let's C be all the possible X's and plus Y times I that's in this plane. And if we take the equation Z equals Z squared plus C and we're going to do this over. We going to start with Z equals zero basically and we're going to do this over and over again. So we're going to... If we forget about, let's just forget about complex numbers for a second and let's just say Z is the number two, I mean sorry C is the number two. We're going to say Z equals zero, Z is zero squared plus two. So now Z is two. So that's, this is like Z sub zero. Then the next one Z one would be, what's Z? It's two squared plus C is two so Z one, the next Z is four... (laughing) Four plus two is six. And then if I say Z... This is important cause we're going to have to do this to calculate the digits of Pi. That's why I'm emphasizing this. then the next Z equals six squared plus two which would be 38. So this is doing this with just a real, just the number two. Which by the way it could be one of these numbers because what that is, is two plus zero I. All numbers in essence are complex numbers but the real numbers that we think of, the numbers we use more commonly just have their imaginary component as zero. So this is the idea. Now, what's the deal here? What Mandelbrot set that weird pattern? So if we do this, with any given X plus Yi this number will sometimes go, can go to infinity and sometimes just sort of oscillate around a smaller number. Basically what, to find the Mandelbrot set is we look for any numbers, any of these X plus Y I's where when you apply this iterative formula, you get past a certain magnitude. So you could also think of this as a vector A plus B and so if we did something like took the square root of A squared plus B squared is the magnitude of this vector if that magnitude is greater than two it is a member of the Mandelbrot set. And when we look at all those complex numbers within a range you can see all of these black pixels right in here are members of the Mandelbrot set. Now why do you see these spiky things and these the grayscale values? This is because I'm actually specifically counting the exact number of iterations it takes before we get and I'm going to say A squared plus B squared is greater than four because that way we don't have to do the square root. And then each pixel color is colored based on the number of iterations it takes. And before it escapes, before it escaped out, before it gets past four. Okay that's the Mandelbrot set. Now, was it there something about calculating the digits of Pi? So I didn't really know about this. Where I learned about this is from Holly Krieger a mathematician who appears often in the YouTube channel Numberphile, number PI. And there's this video PI and the Mandelbrot set where Holly Krieger goes through and explains this discovery and how it works. And I would really recommend you just stop right now and watch this, maybe you're going to come back here to see me code it maybe you're not cause that's enough for you. I'll also refer you to this page I found on the interwebs here called The World of Pi which has a little bit more information about this here that I'm also going to want to refer to in terms of this special place not in the Mandelbrot set but in the complex plane 0.25 plus X. So what do I mean? So let's say, so this is our Mandelbrot set. I'm going to like loosely draw it like this, it kind of looks like this, this is my like a crappy but horrible drawing of the Mandelbrot set. If we look at this diagram here. You're going to actually see the values of X and Y. So you can see that this is the 0.1 comma zero, right? So the 0.1 comma zero is somewhere over here and it's not in the Mandelbrot set. So the way we're calculating Pi is not actually something in the Mandelbrot set but it is this iterative process applied to a particular location outside of the Mandelbrot set. And there are by the way some other locations that you can do this same math to and that's covered on that webpage but I'm going to do it not at one comma zero but at one and 1/4 comma zero. So if one comma zero is here maybe one comma zero, 0.25 over here, this number when this formula is applied reveals the number Pi in an interesting way. The good news for us is that this, while a complex number the imaginary component is zero. So we can actually work this out in a much simpler way. We don't have to do the complex number multiplication although that's an interesting thing to do and I probably should have been... I feel like I botched that in the previous coding challenge so I should come back and do another video about building a complex number class and Java and multiplication all that. But so let's just look here all right. All right, so now that I think of it I think what I want to do is actually just sort of start over like I could use this code but we don't actually need to draw the Mandelbrot set to actually, to emphasize this actually don't need a set up function right now. Let's think about this. What I want to have is of my complex number C which is really at this point just the number 1.25, okay? So I have the complex number C. It is really A plus Bi and the 1.25 but we're simplifying things. The complex number has no imaginary component. Then what I want to do is I also want to have the value Z starting at zero. And what I want to say is... Well the thing that I want to do is I want to say Z equals Z times Z plus C. And I want to do this over and over again. So maybe I want to do it for some amount of iterations. I want to do it while Z is less than two because when this eventually gets greater than two that's the number of iterations. So I'm going to say int, oh, yeah I want to count the number of iterations, sorry. So each time I'm going to say iterations plus, plus. And then let me print line this is very sad. I should draw it, it'll be more interesting. So let's do size 600, 400. Let's say fill 255, text size 32 and a textAlign center and text iterations, width divided by two height divided by two. Two, no, no this is good okay. But, so it only took two iterations. (bell ringing) I just realized I've made a fundamental mistake but fortunately I haven't gotten too far before I made this mistake. And I remembered now why I'm starting with 1.25 and I should have reviewed this more recently and I wouldn't have forgotten this. But the place that I'm looking at which is really special is actually not 1.25 comma zero. It's o.25 comma... 0.25 comma zero. Let me actually draw you where that is in the Mandelbrot set in my previous code. So if I, I want to go to my other code here and what I want to do is I have this mapping which is Xmin Xmax. So if I want to get a pixel spot for 0.25 comma zero. So I'm going to map 0.25 between Xmin and Xmax between zero and width. And then I'm going to get the Y value at zero and I'm going to draw a nice red dot there. So let me say fill 255 zero, zero and I'm going to draw an ellipse PX PY, let's make a nice small ellipse. Let's make it a circle, let's make it a circle, Okay. Oh, that's not right. Ah, this is Ymin Ymax yes and this is zero comma height. Come on Shift man, okay. There we go, look at that how strange. This is a really... And let's make this much, much smaller. Oh, it's hard to see, let's zoom on in this spot right there is called the cusp. So the cusp of the Mandelbrot set you know, which a little bump there is actually 0.25 comma zero. Now why did I think, oh, I'm supposed to talk about 1.25. The reason is, the idea here is that I'm also going to introduce another variable epsilon. And epsilon is a little bit of space or a lot of space after that cusp. So what happens when I'm full 1.0 units away from that cusp, right? And I say the cusp 0.25 plus epsilon, if this is my C, what happens with this iterations? How many times does it take me to escape past two? So now we could go back to my code and I can correct myself. And I can change this to the cusp is 0.25 and E for epsilon I will say is one. And what I'm really doing is I'm saying C, I'm really saying C equals its self plus Epsilon. So if I do that, what do we get? Two iterations, so when E epsilon is one, we get 2 iterations. Now let's go back to this page, oops, sorry. This page and see look at this. If I have epsilon as 0.01 it's 30. 0.0001, 312 let's see if we can get that result. Let's try 0.01. 0.01 30 ah, so what is this? This is one divided by a 100 to the power of something. Hmm, it actually kind of reminds me of that whole collision thing I just talked about. 1.0 divided by 10 the power of 100 to the power of one. That gives me two digits interesting. Let's now create a variable called digits equals I want two digits, this is to the digits minus one. Two digits, 30. Three digits 312. Four digits three, one, one, nine hmm. (laughing) No, that's not right. (bell ringing) What's the problem? I have very, very, very little precision with floating point numbers. So I didn't get the right result. Let's try changing these to doubles. Double which you don't typically see in processing cause processing kind of ignores the existence of doubles. I'm going to need to change this to math.pow to use doubles and now in theory 3140, is that correct? Yes, so now let's try getting five digits, three, one, four, one, four. Six digits three, one, four, one, five, seven, in order to test this. I've got six digits right now, I've pulled up a text file that actually has the digits of Pi in it. So we can see one, five, nine, one, five, seven, we've got a close approximation with six digits. Let's try seven digits one, four, one, six, two, five. Eight digits okay, we're getting way off one, four, three... It's getting worse. So I think we've now reached the limitations of what kind of precision we can have with Java's builtin double. So this is a time where I think it would be worth trying a class that will give us greater precision. So there is something in Java called a BigDecimal. I can pull up, I'm going to go to the Java eight Doc's page. This is the BigDecimal class and we can see ways of creating a new BigCecimal. There's all sorts of settings. I can create a BigDecimal out of a big integer blah, blah, blah. So, BigDecimal is a class in Java that allows me to have greater precision with a decimal number. So let's try converting all this. All this is going to be a pain. I'm going to say big decimal okay. So first I need to do an import. Import Java.math.BigDecimal. So you might not realize this but in processing you can import any Java class. I think it's going to be upset with me now though without a setup function. Yeah, so whoops! Yeah, so let me just put in a setup function I don't know that I need it but let's put that in there just in case. Okay, so now I want to change C to a BigDecimal. I think I can just do this. Oh, ah, this is going to be kind of crazy. I needed to change E to a BigDecimal and so this is BigDecimal one that's saved divided by... So I need BigDecimal hundred equals new BigDecimal 100 and then I would say hundred.pow digits minus one. Is that going to work? Oh, no dot divide. Dot divide, so I can't use the regular standard operators anymore. Okay, so this is E is BigDecimal one dot divide. It had to be BigDecimal hundred to the power of digits minus one. Then I can say C equals C add E. BigDecimal Z starts as BigDecimal.zero this is the number of iterations. I mean I don't think do I need a big integer for iterations I might, I'm not sure. Let's do that BigInteger... Well, let's just do, let's leave that as an integer for right now. While Z compareTo, I have to use the compareTo function if it's less than two, I think that the comparedTo function will give me a negative one. Oh, and this should be a BigDecimal the value two. Z equals Z multiplied by itself adding C to it. I think I can chain these and this should be the full word multiply iterations plus, plus. So let me just put this back down to like digits one. So if I wrote my code correctly, I should still get the number two. Great, beautiful, now let's try to get two digits. (laughing) Well this is taking a long time or I've messed up. (bell ringing) So I've just looked into this and I'm printing the value of Z to three decimal places and I realized it's actually working fine. It's just really slow like it's stuck. It's like hasn't even done the calculation for the next one. I think that I need to, what I need to do is the problem with this BigDecimal math is it's really slow. And so let me import this thing called Java.math.MathContext. And what that allows me to do is create a math context which is, I'll call it MC which is a new math context and just to like... Let me just give it to like five decimal places or you know, 10. Like a really small max MathContext then I think what I can do is I can always put as a second argument to these functions like divide the MathContext same thing here, MathContext same thing here. And I think if I do that the operation will be much faster cause it's doing less precision. Right, so I got to 30 really quickly. So, now I can do three digits and I got to 312. I can do four digits and I got the three, one, four, zero. Five digits three, one, four, one, five. I don't want to have this print line in here anymore. And then let's go to like seven digits and we can see we're dying already. (bell ringing) So I have figured out a little way to debug this. Which is that what I'm just doing here now. I'm trying to calculate eight digits with a MathContext of 50. I'm just looking at what that number is with a MathContext of 50 to 50 places. And it is just taking forever. But I will point out that if I go back to seven digits, right? I'm trying to approximate Pi to seven digits and if I take the print line is really slowing it down. So if I take out the print line and run this again. I am going to get seven digits of Pi 3.141591 of course the one is wrong the actual number is two. But I got pretty close but with only doubles this is my old code from earlier in this challenge. If I'm trying to calculate seven digits of Pi without BigDecimal. Just with the raw java double, I'm getting something way more off 3.1416. So at a minimum, I have using BigDecimal I have improved things and I've gotten to seven digits of Pi. Hold on, I'm back I got eight digits; three, one, four, one, five, nine, two, five it didn't take that long; three, one, four, one, five, nine, two, six. So you can see I'm close, how did I get eight digits? Well thank you to whoever in the chat@hv said is the nice heuristic to use is the precision that I need is the number of digits I want squared plus one. So in this case 65 eight squared plus one. (bell ringing) Another way now we might watch the progress of this that's a little bit better than just like console logging the value of Z is I could move to doing 10,000 iterations or some number of iterations every time in draw and I quickly just took a break and move the code from set up into draw. And you could see now with seven digits. It counts up pretty quickly to that number with seven digits. There we go, I should also should make that much bigger. Now let's make the size 64. So this is seven digits. It might be nice to like, it's visually just to like have the counter go up in a more interesting way. But now we could watch like if I go to eight digits. And I probably should number format this, so we could see like when we're getting close to the end. For example if I say number format, the number of iterations as eight digits or the number of digits. We can see how close we're getting to the end because at a certain point this last digit all that last digit has to do get to three. So I'm going to just leave. Let's just leave this livestream going all day hold on. Well, that would be crazy, right? What if I just left this streaming change this to fullscreen and put it to 11 digits. (laughing) And I should also put the Mandelbrot set in the background probably, right? (bell ringing) I loaded the image of the Mandelbrot set, I put it in the background I set the digits to 11 we're going to let this run. It might, I don't know how long this is going to take. There's a big problem with this. I am using integers to count the number of iterations. And guess what? There's not enough integers. We're going to overflow the number of integers the computer can store in the int datatype. So I definitely could fix this, I'm pretty sure if I'm making this along which gives a lot more space probably like about 19 digits worth which is more than 11. But I think just for consistency let's use BigInteger. So if I use BigInteger and I say it is BigInteger zero to start with then I can also import BigInteger and I can say iterations.add... Iterations equals iterations.add one. I guess I probably just say BigInteger one. Let me stop this from running. So this would be increasing the number of iterations. and then aaah, so then I want to take string S equals iterations to string, this will convert it to a string and then I could do something goofy here where I could say S equals S.substring the first digit zero comma one plus period. This is just to make it look more like Pi and then S.substring one to S.length. Oh wooh, that oh, no, no, no, this is bad. (laughing) I want, I need extra digits even for when it hasn't gotten that high. I could say int difference equals the number of digits minus S.length. And then I could say S equals, like if I add another zero right? If I just add like one more zero like I get that. So then I could just add the number of zeros for int I equals zero is less than diff I plus, plus and then I could add a certain amount of zeros. And is that 11 digits? It's one, two, three, four, five, six, seven, eight, nine, 10, 11. Yeah, I think that's right. Okay, that was ridiculous. Well, if you made it to the end of the video you've now see my Mandelbrot set processing sketch running and counting the number of iterations for a very, very, very, very, very small epsilon next to a certain location in the Mandelbrot set. So I really needed a lot of stuff for this. I needed BigDecimal, BigInteger. I'm going to let this go now to try to get 10 digits after the decimal or eleven digits total including the three. It's probably going to take about 12 hours. So that's going to be in a live stream that's just going to be a 12 hour live stream of it running which I will link to in this video's description we'll see if that works. We'll find out. But thank you if you have an idea for how to visualize this in a different way to illustrate the idea to explain how this works with the Mandelbrot set. Maybe there's a more beautiful way to animate it to connect the concepts of how this is working with the visual result that the viewer is watching. I would definitely encourage in a big thanks to the numberphile video and Holly Krieger for that wonderful explanation which led me to do this. I would love to see your version of this. Maybe there's a way you can optimize this to get more digits more quickly. I don't know, I would love to find out. So look at all the references that I'm going to link to in this video's description and share with me your ideas at the http//www.codingtraining.com and see you in a future, see you next Pi day. (gentle music) Oh my God! Oh my God I'm really stressed out. (applause and gentle music) Three, one, four, one, five, nine, two, six, five, three and of course the last digit will be incorrect. Because it's an approximation. (upbeat music)