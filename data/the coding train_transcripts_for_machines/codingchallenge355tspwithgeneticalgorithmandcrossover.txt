hi okay I'm back so this is where I left off in the previous video I have a genetic algorithm attempting to find the shortest path between all of the cities which are these just two dimensional points innocent and the traveling set with the traveling salesperson problem so what I'm doing in this version that I made in the previous video is I am just looking at the borders the path that had the shortest distance and I am cloning those for a new generation and then kind of shuffling some about randomly but I am not actually applying crossover so then what one thing I want to do in this video is apply a crossover so in other words I have a set of points like 1 2 3 4 let me write this again 1 2 3 4 and 1 order might be something like this and another order might be you know something like this so what I'm doing right now is we can see I don't know this it's hard to see these are by others so let's say this has a distance of some number that maps to a fitness probability score of point 6 and this has a distance of some number that maps to a probability score of point four what I'm going to do for the next generation is I'm going to make 2 if I only have a population of 2 I'm going to make two new orders can you guys hear that so loud noises in the hallway ok I'm going to make two new orders and I want to pick I'm going to make these two new orders out of the one that have done the best so I'm going to throw a dart at the wall and I hope I don't ruin this mark this beautiful marker I have a 40% chance really really a 50% chance of hitting either I have a 60% chance of picking this one a 40% chance of picking this one if I pick this one I'm going to clone it to the next generation but maybe swap two points so instead of you know the order goes from here to you hear I'm going to go from here to here to here then or something and then I might pick this one so I'm just doing I'm creating new elements of the next generation from the previous generation by making a copy what I want to actually do is have a mechanism for how I combine two of them into a new order and that's what I'm going to look at in this particular video now before I do that let me see if I can just add some simple little improvements to this so for example one thing I want to do is I'm only drawing the best ever and so what might be useful for me to also draw just to sort of see how this is working is what I could do is translate to the bottom of the window and I'm going to do this I could also draw just the current best so where am I evaluating the best one I'm doing that here so I could have another variable which is just sorry where I have a variable called bestever I'm going to have like current best and what I'll do is here I will also say current record equals infinity and if I will now say also I will also check if d is less than current record then current record is this and current its best or best current I can't remember what I called it what did I call it current best current best is this so I don't know if this is that useful but I thought I would add it so I can also see now this is me drawing this is V drawing the best ever and now I also want to draw the current best so let's run this and we can see so we can see that it's you know the population is doing a lot more stuff internally but every time eventually as it's trying your life sometimes gets a better one so this is a little East we have something more to watch here to sort of see like that it's continuing to animate to try and guess future options okay so now Ken how else could we improve this let me look and first of all one thing that I did kind of weirdly which doesn't make too much which I feel like needs is a mutase function needs some improvement so what you take does is every time it clone something it just swaps two elements but I do have this idea of a mutation rate so I don't know I sort of feel like what might make sense is for me to say like well let me have a loop that goes through the total number of cities and then just says like if a random number one is less than the mutation rate then perform this swap so this is just a way for me to say like if there's ten cities then maybe I have a chance of like doing ten swaps but maybe I only have a 10% chance of doing a swap or something at any for any given city for any given spot I don't know this I'm not sure if this really makes a lot of sense but I am going to I'm going to try it this way and then where I say mutate I could give it like a mutation rate so if I give it a mutation rate of zero we would see that it's never ever ever going to get any improvement if I give it a mutation rate of one we're going to see it's just like really really really making a lot a lot a lot of swaps all the time I don't know if that's so optimal so maybe I would try something like a mutation rate of 0.1 and maybe that's like a little bit better so I don't know what's going to be an optimal mutation rate but at least I have some structure for saying do more random shuffles or less random struggles and that could probably be improved okay so now what we need to do is add crossover so first I got to think about how we're going to do a crossover algorithm but right now what I want to do before I do that is just find a place in the code where I'm going to do crossover okay so we're this is where I make this is where I I create a new order from I pick one from the population based on its fitness and then I mutated and at it so really what I want to do is I want to change this now to be order a and order B I want to pick to order a and pip order two and then I want to save our order equals cross over order a and order B so what I want to do is I want to pick to cross them over then mutate and then get a do now whether this is actually going to improve the performance of this it's unclear to me but certainly this would be something that's typically found in a genetic algorithm and worth giving a try but here's the really tricky thing so I'm going to come over to the white board and then we have to discuss how we're going to do crossover so remember let's say this these were the orders 0 1 2 3 these are the index size 0 1 2 3 so one order is 0 3 1 2 that's one order another order is 0 2 3 1 okay so typically if you've watched any of my other videos about genetic algorithms the way that you could perform crossover with two arrays of genetic information is to take half of one and half of another and put them together in which case my new order would be 0 3 3 1 but there's a major problem here this is invalid in other genetic algorithm examples that I've done there's no such thing as an invalid DNA array because it's just a bunch of numbers but this is a special kind of DNA array that must have every single instance of each index or once and only once so this kind of splitting it half and half it won't work you know the flipping a coin algorithm won't work I can't say you know pick a or B 0 pick a or B okay pick B to pick a or B okay pick a 1 okay pick a or pick me one once again even if I'm flipping a coin I now have ones in two places and I don't have three I'm sure there are lots of strategies for doing this kind of crossover and I would love to hear from any of you of your own ideas of what might be a good technique but here's one that I'm going to try one way that I could do this oh I shouldn't have a race that I can put this two hours in is where I start to lose it okay I erased okay not to please save me only one order again is zero three one two another border is zero two three one so what if I take some random part of one of these so let's say I just randomly decide I'm just going to take 3 comma 1 and I'm going to start my next order 3 comma 1 I have two empty spaces I need to fill well what if I then said ok I'm going to take oh this was a bad example because I'm going to let let me just pretend this order is a different one because I want to make an example that's a little bit that actually is something you can follow so so this is 0 1 2 3 and I'm going to go 1 3 0 2 1 3 0 2 so what I'm going to do is I need to fill in these last two spots and then it takes them from here in the same order that they're here as long as they aren't a 3 or a 1 oops again I don't like this order can I just please have it be it's fun it's like you guys are going to get the idea what should I put a 1 here no it already exists 3 should I put a 3year know it already exists 0 should I put a 0 here it doesn't already exist should I put a 2 here yes doesn't exist so what I wanted this to be is in order that's something like 1 0 you know 3 2 I would still get the same thing right because I would one can't go there cuz it's already there zero can three can't go in the next spot but to Kent so I'm going to just pick a random part of the order and then fill the rest from the other I think it other than has a name for it I don't know what it is we've got somebody watching can tell me okay so let's actually implement that now okay let me let's look at that so what do I do I need to write this crossover function okay so coming down here I need a new function I'm going to put it above mutate and we're playing some music in the hallway cross it over order a order B so the first thing I want to do is I want to take a random slice of order a so I'm going to say start equals floor random 0 comma order a just random order a dot length and then I'm going to say N equals some value between start and the end of random a we could always just take the first half or something but this is just I'm getting a random spot anywhere in here so maybe I pick this spot and then I want a random spot anywhere between here and here I probably should say plus 1 right plus 1 okay so now I should probably say start plus 1 I think because the the when I'm about to use slice so I must say new order equals order a slice start comma end and I'm pretty sure that was slight if I give it 3 at the start and 3 at the end I won't get anything let's let's actually just look in the console to sort of see like if I have an array that's 0 5 0 1 2 3 4 a dot slice 0 comma 3 what do I get I get 0 1 2 I get I don't get 3 I get 0 1 2 and if I set a dot slice 3 comma 3 I get an empty array so I always want at least get if I would say a dot slice zero comma five that would be the whole thing so I think that makes sense okay now what I need to do is figure out how many things do I have left so I have a total number of cities new order lengths so this is how many I need to add right because if the total number of things should be ten and I get this slice of six then I have four more that I need to add so I now I have a loop I equals zero I is less than left actually but here's what I want to do actually though is what I want to do is I want to say var I want to I want to actually loop through I want to loop through the order B's everything in order B right because City equals order B index I I want to know if new order concludes I think this is a JavaScript function that will tell me if it already exists in the array let's see so this is my array a a includes two is true a includes five is false so this is going to work for me I can say if new order includes I'm sure there's some fancy super JavaScript es6 array operation way to do this I look forward to hearing about that in the comment if new order includes city if new order does not include city then new order push city so I guess I could just I guess I don't need this left because by definition this should just work if I've done everything correct if I if I've done everything correctly then this should have the right number of stuff in it I think what I'm going to need to do is is definitely just try this function house so and then at the end I want to say return new order so let's try this so the program still running as it ran before I and actually introduced crossover or did I I don't think I actually put crossover in yeah oh I did it's actually doing it but let's let's see if if this actually works a equals an array like 0 1 2 3 4 and B equals I'm going to say 4 3 2 1 0 so what I want to say is cross over a comma B let's just see what I get 0 4 3 2 1 that makes sense I mean it work it's a random order but how is that a cross over it must have only picked 0 yeah only pick 0 from a and then it got 4 3 2 1 okay that makes sense then it got it got 1 2 3 and then it got 4 and then 0 so this is working this algorithm appears to be working so now is this actually improving anything unclear let's uh let's reduce I think now we could really reduce that mutation rate because crossover is going to give us a lot more variation and I would love to just increase the population size to the point as large as I can increase it without it running too slow so let's try 500 so yeah this looks um this looks pretty good like I'm kind of seeing it slowly over time improved you know how many cities is this 10 cities when I put 20 cities let's give it some more space let's give this canvas like a bit more room to work with and see what we get now yeah well let's take a pause here I'm going to come back in a minute after I've let this run for a while okay I'm having a little rest there is my lullaby that's and I back so I let this run for a while you can see that it's doing pretty well it seems that this is the best one it's found and sort of sticking with that for quite a while so I'm going to see maybe we can do one or two more small improvements and I'll give you guys some ideas of things you might do with the code to improve it and then I'm hoping you're going to submit some user submitted improvements okay so a couple things one is that includes function that I'm using is actually part of es6 which is a newer version of the JavaScript syntax that I'm actually using in most of my videos and es6 also has something called it set which I guess is a which could be a data structure that would be useful here other than just a plain old array the other thing that I want that I should mention is that the distance function that I'm using to actually calculate the distance which is right here this is a pretty inefficient or slow algorithm because it uses the square root so one thing that I could do is add my create my own distance function that doesn't use the square root but just uses the squares of the differences because I all I care about is relative distance so I or the other thing is there's a fixed number of cities I'm only ever looking at distances between them so I could create a lookup table that just precompute all the distances I'm just summing up what it is but anyway that aside those are some things you might think about adding there was a great suggestion in the chat from Cole noxee the second wonder what that name is but that may be what I should try in mutation is instead of swapping to randomly actually swapping to neighbors so where do I do the youtaite so what if I pick index a and index B is actually index A plus one so it's the next one and I could say if index B is greater than total cities dot length then I could say or greater than or equal to right if I've gone off the edge then I could say actually index B is index a minus one there might be a nicer way to do this but so what if I only swap two that are next to each other would this be a better algorithm okay so let's run this we're going to lose everything we had from before but I'm going to run this okay so I made some sort of error here can't read property ex of undefined calc distance so that's this there's something wrong with my own app total cities not length total cities is just the total number of cities let's fix that okay so let's hope I'm gonna I'm going to take a little nap again and I'll be back in a while so by the way I'm letting to let that continue running but I realized this would this would be a nicer way of doing this would just be to use modulus operation so that I could just because I could swap the last one with the first one and so this would actually I think be just cleaner way to write this little bit of code I don't want to say rerun it because this has been running for a while I don't know did that improve it did it not 20 cities is a lot let's feel better about ourselves and the world and the traveling salesperson problem let's just quit 12 cities which twelve cities there's a lot of possibilities 12 factorial is how many that's the nine million 479 million possibilities which would take quite a while to iterate through all of the possibilities but I have a feeling that if I run it with 12 we're going to get something pretty good pretty soon like really fast that was like a pretty good I don't know if this is optimal found something even better oh I'm pretty sure oh you could definitely make it better by going from here today or then to there so anyways hopefully it's going to get even one job talking but we've done something that works pretty well so here's my request to you the viewer please once I post this code go to the link to the code will be a readme file there if you make an improvement add a link to your improvement in that reading file with a pull request if you don't know how to do that and I do have a video about how to make a pull request but just write a github issue comment or tweet at me at Schiffman I would love to see a couple things number one I would love to see what kind of efficient what kind of things can we add to this to make it more optimal let me there's a better way to do taste a better way to do swap a better way to do crossover so what can we add to this to make this optimal the other thing that I really have to think is what is a better way to visually tell the story I don't have this isn't really so great I'm kind of seeing like a bunch of random stuff and sort of the current best but could I see the full population of everything could I watch a graph of how it's improving could I see some annotation is there some interactivity to speed it up and slow it down so I would love to see variations and ideas for how you can tell the story of this problem and how the algorithm is working so thanks for watching these videos I finally did it I kind of I have completed I think the set of videos about the traveling salesperson problem and I look forward to hearing your comments and questions in the comments on YouTube I think oh I have somebody told me I should remind people to LIKE and subscribe so please like and subscribe there could be like an end screen thing popping up around me maybe we'll add that in like and subscribe if you watch these next videos and I'll see you in a future video I hope okay talk to you soon or whatever this is that we're doing here on the Internet did it fix that no okay wait like maybe it got better no no it should go up here and then there would just be so much shorter okay I'm going to watch off stick around and watch it I'll tell you what happens another time goodbye