we're we're doing the anterior in this video I want to look at one more fractal pattern the the Franklin pan that I want to look at is something we talked about the very beginning this branching tree a tree which has two branches and each have two branches in each have two branches why do I want to look at this one we've looked at a bunch of fractal patterns already the reason this one is important is in our implementation we're going to make use of translate and rotate transformations in processing and when doing so we're also going to make use of push matrix and pop matrix which is going to be a very interesting technique inside of a recursive function how we do this so let's just first remind ourselves what is this what is the production rule right we start start with a branch which is a line start with line at the end of the line that's one at step two is at end let's say we rotate I don't know 45 degrees or rotate 45 degrees and draw another line then we rotate rotate negative 45 degrees and draw line 8 now for each for 2 & 3 we want to do the same thing go to the end rotate 45 degrees and draw two lines for each of these rotate 45 degrees in Grutter lines so the thing I guess I missed and described in these production rules is also shrink the length of each branch each time so you can sort of start to see that this is the rule so let's start to write code that implements this rule so here I have a very simple processing sketch it's over here right all that it's doing is it makes it window and it draws a line from the bottom of the window to the middle of the window so let's write that in a slightly different way what if the first thing I did was translate to the bottom of the window then what I'm really drew it doing is drawing a line that goes from 0 0 to zero comma and let's just say negative 150 so I'm gonna make a line there that goes translate to the bottom and draw a line from 0 0 to 0 comma negative 150 great now what do I want to do what did we say I want to rotate by 45 degrees pi divided by 4 and let's draw another line from where though oh wait what do we need to do right we went from here we drew a line from the bottom to there now I want to rotate to draw another line I need to after I'm done translate up to there so I'm gonna say hey let me translate from zero comma negative 50 right now if I were to draw a little circle at 0 0 where is that little circle it's at the top right we translate just to make clear here this is our processing window the first thing we did was translate to the bottom then draw a line here then what we did is translate to here the reason why we're doing that is now we're gonna rotate draw a line rotate draw a line so let's go back and we're gonna say hey instead of just drawing that ellipse let's rotate by an angle and draw another line 0 0 0 comma negative and little shorten it to negative 100 and look at this now we have our line going to the right we need our line going to the left hmmm how do I do that rotate negative PI / 4 line 0 0 0 comma negative 100 well this get it oh this is going to get it it's gonna get it oh no right because what did we do we rotated 45 degrees and drew this line and then we rotated back 45 degrees but really what we want to do is rotate then pop back to where we were originally and then rotated the direction this is where we can use push matrix and pop matrix push matrix saves the current transformation state where am I where have I translated rotated to then pop matrix restores it so what if I actually just said push matrix here pop matrix here let's simplify some things and then rotate the other direction and look at this we've got the beginnings of this now right we're able to draw a line from the bottom to the middle rotate draw a line pop save rotate draw a line pop back rotate draw a line and in essence you know we could look at this and say well we're going to do be doing this over and over again recursively we should probably push matrix and pop matrix around this particular branch as well right so this is the trunk of the tree right let's put some comments in here trunk branch right branch left right if we look at all this stuff together we can see what's going on we drew the trunk we move to the end of the trunk we branched right and drew a line we branched left underline so this is how transformations work and processing but why are we doing this we want to do this recursively we want to say for every line push translate rotate draw a line pop rotate draw a line for every branch so what I want to do is look at these three steps and look at this branching algorithm what if instead of drawing a line there what we're actually doing was calling a branch function what if this was somehow a function called branch which at the beginning just draws a line whoops sorry and then always calls branch itself where it needs to draw the next two lines right what if what we're doing is we're recursively drawing the line branching right branching left draw another line which branches right which processes left to draw another life and you're always pushing you're popping along the way so we can always remember and pop back wherever we need to this is what this is very very hard to picture in your head this is one of these instances we're writing all this textbased code and picture and there's got to be a better way before this video has I'm doing a Google search for this but I want to show you a really wonderful project which allows you to draw fractals in a procedural code like way rather than write the actual code because I'll link to it below okay but let's actually now just go and say hey well this must be in an example whoops I'm going to open up our examples oh boy in Chapter eight fractals and the one that I want to look at is just eight point four tree so let's run this one and see it whoops it's so tiny let's make it a little bit bigger let's run it and let's see what's going on right so look here we can see right here's the tree and the angle is being controlled by the mouse and you can see here's our root which has two branches that's two branch the two branches another thing that's interesting about this is not only are the lengths of the branches changing but the thickness of the line is it getting thinner no it's not but that would be an interesting exercise and I do have one of the examples that does that right the branches are getting thinner since order could the actual thickness get thinner as well so let's just take a look at the code and what we can see here is exactly what I just talked about so maybe it isn't this so what I was sorry boy I'm not doing a good job here so this is exactly what I'm talking about we have a branch function which draws a line and as long as that line that line shrinks by twothirds every time and as long as that line is still greater than two pixels push matrix rotate to the right branch again push matrix rotate to the left branch again which calls the function again so interestingly enough this is a great thing that you could do is take this code print it out get a piece of paper again a pen try to be processing and execute it and you'll see an interesting result I encourage you to do this on your own here's my eraser but just for a moment one of the things you'll see that's actually happening here is we've draw the first line and then we call branch to the right but that's called recursively so it calls branch to the right and that's called recursively so it calls branch to the right which calls branch to the right eventually we're done and we pop back and branch to the left and pop back and branch to the left but here then we have to branch to the right and then we have to pop back and branch to the left and then we pop back and pop back and that's the right branch of the regulan puppet right it's kind of I can't even do it you know I could do it if I sat down slowly and did it very methodically and I think this is a really useful way to understand where are we pushing and where are we popping how does this recursive structure work when we are kind of walking through almost in this in this turtle graphics right if you remember programming with logo this idea of a turtle being able to move forward turn move forward draw a line this is all we're doing here we have a turtle that can move forward but can also remember where it was at any point to pop back and continue off in another direction so you know another exercise you could try would actually need to animate this and see if you could draw one branch at a time to actually see that order by the way a clue to doing all of this that we're going to look at in a slightly more sophisticated way is going to happen in the next video in the next video we're actually going to look at lsystems which is really going to implement a turtle graphics drawing engine so a few other things I'll note about this this is the basic example and you can see the basic results here but a couple other things you should note about this which are interesting to think about is that if one thing you might look at is thinking about all those angles and lengths and how many branches this is a place where a stochastic fractal one that involves randomness and probabilities for example what if each branch has zero one two or three branches attached to it what if the angles are random you know randomness isn't exactly getting us more organic a more organic quality it's giving us variety but what if you use Perlin noise or had some other systematic approach to how those trees are formed what if you thought about those branches as paths paths like we had with steering behaviors there's a vehicle moving along the trunk it breaks into two vehicles may move and are seeking a target we might get some curved paths there that could give us a couple more curvaceous tree there's lots that you could think of with doing with these examples and you could also by the way which I believe is in the repository and I need to maybe make a better version of it is you could also I think in these exercises you can also apply the ArrayList up this is with different thicknesses you could also apply oops I'm sorry everybody exercise 8.6 nope where is it doing a terrible job okay so I have failed you tree ArrayList leaves there we go exercise eight point eight and nine one thing that we can look at is how can we get the positions and make objects right we could use the ArrayList technique so this particular example is using the ArrayList technique to keep track of the locations of all those branches these branches could actually wiggle and move you can see I deposited if you zoom in it's really close there's little circles at the end of each branch which are like leaves because I know the end positions right with that with the translate rotate this magical recursive function I'm not keeping track of all those locations but if I make objects out of every branch then I can start having leaves fall from the tree branches swaying the wind and this is something you might also think about as well so that a rail is technique that we looked at it can also be applied to this tree example and it might be worth perhaps going through this in more detail at another time but I think that this video is it is what it is right now so okay thank you and there's a lot to think about with this and boy anyway we're gonna talk about houses