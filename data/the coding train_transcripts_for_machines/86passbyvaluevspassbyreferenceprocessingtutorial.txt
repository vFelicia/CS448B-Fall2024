Okay, I want to record one last video today it occurred to me while I was making that video about looking at how objects might communicate with each other. That there's a kind of a key principle going on in how variables are passed in as arguments to other functions that has been missed throughout all of these videos. So I don't think I'm going to have an example for this I'm just going to kind of dia... Talk you through this and diagram it and we'll see what's missing and what needs to be added and what's confusing but So I'm going to make up kind of a silly function almost a function that has no point I'm going to call it change and it's going to receive a single number as an argument and Inside this function, I'm going to say that value equals value times two. okay, so this function receives a number and and multiplies that number by two and stores it back in itself. So if I say int x. Can you see that? No you can't. Let me write it a little lower. int x equals 50 and then I say change x and Then I say print Line X What is the result of this print line going to be so let's think about it x has the value 50? change x means x goes into val So val now has the value 50 then val equals itself times 2 so val Now has the value of 100, but when I print x am I going to see 100 or 50? Think about that you know as the designer of the programming language. It's up to you to decide. What it should be. The Java Programming language on which processing is built on top of What we're going to see is the number 50. Why is that? This is known as pass by copy. When you pass a primitive value a number, integer, float ETC into a function you pass a copy of that value meaning in the computer's memory x is Referencing a place in the computer's memory with the value 50 then val is Referencing another place in the computer's memory with what the value 50 gets copied in there then over here val gets multiplied by 2. Val now equals 100, but x which is pointing to 50 is unaffected Pass by copy. The reason why I have bringing this up and to realize why this is so import.. this is so important. Is if you pass an object into a function. It does not work this way. It works with something called pass by reference. So let's pretend There's a madeup particle object and that particle object just has an x and a y. So I'm going to say a Particle p equals new Particle... you know 50 comma 100. And then I'm going to say, change p and there's a function called void change which receives a Particle object call it a... blah. It just needs to be a different variable name, it's terrible. I hate that I just made up a variable name blah. Let's think of something particle... I'm going to call it some p, aP. A particle. aP. Now if I say aP dot x equals 300. What's happening? Okay, so... This is my equivalent of int x equals 50 change x now I'm saying particle P equals new Particle change p. This change function, I should've... instead of multiplying it by 2 I'm just setting it to the value 300 and remember x was 50 and then we made a new variable val was 100. So here I have a particle p and it is pointed to somewhere in the computer's memory. Where both 50 and 100 is stored. Now here. I make a new particle. aP. Some p at tempP, whatever. I do not make a new object when you pass an object into a function You're passing the reference. The at... the location of the the data in memory, not a copy that data. So aP is actually pointing over here, and if I change... the aspects, parameters, data of that object like x becomes 300. I'm changing the original variable as well. Pass by reference, so in Java when you pass a primitive value into a function, as an argument you make a copy of it and the original variable is unaffected. When you pass an object into a function, the original... you're passing just a reference and if you change that object in the function it is also changed as well. Let me... let me show you an actual scenario where this matters. So if we come back to this... right. What if my... this is... this example where I'm just changing the background color so I'm going to... Save this as a version 2 and I'm just going to make a function called p1 overlaps p2 and it's not going to return true or false anymore. Ok and in that function, it's just void. I can I'm going to do something if they overlap. And what am I going to do? I'm going to give? the the particle a color and that color is going to be... Black to start. And I'm going to say fill that color And when it overlaps I'm going to say other dot color equals red. otherwise other dot color equals... Black. So I know I'm doing this kind of quickly you may or may not be following along But let me show you why this is so important. Notice when they overlap this particle changes its color. I'm passing p2 into the function. A copy is not made. I'm passing the... a reference to the actual object and p2, the reference to that object, goes into other. And now I'm changing values of other. If I'm changing values of other that means I'm actually changing values of p2 and p2 is now going to be red. Incidentally I could say also, this objects color is green and let me give these each a little alpha... So if we look at this, you can see now... They're both black... one turns green, one turns red, one turns green, one turns red. The other thing to note about this is it seemed like in the original version of this program p1 overlaps p2 was equivalent to p2 overlaps p1. But now if I were to change that Since I'm giving them the p2 is now turning green and the other one is turning red. So there's a lot of goofiness going on here in this sort of like forest and fake example... But I think this is important to realize that if you're passing This object into a function you can actually change that object in the function itself, okay... So I don't know if this makes things better or worse. I think I just said that in the last video... But I'm kind of like today I just have this day where I'm wrapping up all these videos are trying to make extra little pieces of content, so This one's only like 7 minutes long which isn't so bad. ok see you later.