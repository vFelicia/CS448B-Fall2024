part two of my depth first search recursive backtracker maze generation demonstration algorithm thing here we are so all I did so far this is what I'm trying to build this thing that's going to take some time and eventually generate this beautiful uh hopefully will beautiful although mine won't be so beautiful you'll take my code and make something more beautiful but I'm going to show you how to make this maze generation thing now just to recap all we have so far is just this grid so I have this grid and in the code I have cell objects each cell knows where it is what's its column what's its row and it knows whether to draw its walls top right bottom left top right bottom left and it has a Boolean variable to keep track of which walls are currently active in there so we need to now go and look at that Wikipedia page where the algorithm is described so I'm going to go over here and look at this this is the algorithm working recursive backtracker so the whole backtracking aspect that's going to be in part three but we're going to do the forward tracking aspect so the first thing here is that make the initial cell the current cell and Market is visited okay so this is a really key concept what's going to happen here is that the program is going to start on a given cell and it's going to start walking around the cells and just deciding whether or not it should remove a wall or keep the wall there now as it walks around the cells it should never go back and visit a cell that it's already been at so we need a variable to keep track of whether a cell has been visited or not so if I come back over here that's the very first thing I want to add is I want to add another variable here that says this. visited equals false so each cell should uh not be visit so the first it starts as having not been visited sorry now uh sorry in in the main part of the program what I want now also to have is I'm gonna have a variable called current so this variable current is the current cell this is the cell that is currently being visited and in setup we could just have it be current equals grid index0 so I'm going to start the current cell just at Zero in the top left it could be anywhere could start in the middle start to the bottom right this has to do with where you want your maze to begin and end but for now I'm not really going to worry about it so much starting at grid index zero will be just fine and then in draw the very first thing I'm going to do is say current. visited equals true now I think there would be something useful here to do for example what I I just to be able to see be best it would also be really useful for debugging and remember I kept this in here is that we could have put some spaces here if the cell has been visited let's change its color a little bit so that we can sort of see what's going on so I'm going to say uh if this do visited uh draw a re rectangle I'm going to get good at this someday draw a rectangle with uh so much I want to turn off that autocomplete in between this video and the next one of um make it uh a nice like purplish color with a little bit of alpha so what we'll see here if I run this again oh that's the wrong one here is we can see this cell has been visited just that first cell is now kind of a purplish color okay so now we've got a structure for knowing if a cell has been visited and we're also debugging wise can see if that's been visited by highlighting it which will help us as we try to figure out if the program is working or not so let's now go and look at the algorithm and what's next while there are unvisited cells okay so as long as there are unvisited cells so we know that we're going to be finished when all the cells have been visited we worry about that later if the current cell has any Neighbors which have not been visited okay this is probably going to be a pretty complicated piece we need to figure out does the current cell have any Neighbors which have not been visited so let's figure out how we're going to do that I'm going to go back to my code which is over here um and come back and what I want to do is say something like current. check neighbors whoa how did it know that's what I was going to type that's crazy that is insane it's like predicting the future it's got some kind of like deep learning machine learning magic I wasn't even using this editor earlier I did type something earlier today that's a check name gers I don't know what's going on some sort of magic okay uh maybe I opened up a different example already whatever the point is I want to grade a function that's called check neighbors so I'm going to add that function this. check neighbors now it should know is a function so how do I check the neighbors okay let's think about this first of all I don't have I'm in a real place and there could be neighbors outside neighbors are people that are to the right the left in front of me Etc let's look at how that works over here so much like we were talking about in the previous video the top right bottom and left walls now if I have a cell there are four neighbors if this cell is at I comma J this is I + one comma J this is IUS one comma J this is I comma J minus one and this is I comma J + one right y goes up by one down by one I goes up by one down by one so this is what we want to check check the neighbors we need to know are any of these neighbors visited or unvisited Okay so let's start doing that I got to come back over here and say something like so I'm going to make an array called Neighbors and I'm going to say um write equals grid and now this is where it would be nice if I was using a twodimensional Ray and you know what I want to start with top remember top top right bottom left this is how I'm always going to track everything so the top is grid you know you would sort of think of it as like this right if I had a twodimensional array I would say i j minus one that's the cell above me right but I don't have a twodimensional array I have a onedimensional array there is a magic formula the magic formula to get an index into a onedimensional array where everything 0 1 2 3 4 5 6 7 8 9 10 11 12 the the where everything is ordered going across rows but I want to think of the column and row coordinate is as follows index equals i+ J * the number of columns I will link to a separate video where about pixels where I go through this algorithm specifically if you haven't seen it before but for now you can sort of trust me that that works so what I'm really saying here is this I'm saying I want this particular right neighbor and that's not the right neighbor that's the top neighbor right I want to check is that top neighbor visited or not now because I'm going to need this formula so many times in this program I'm going to write a function and I'm going to call it index an index gets an i and a j and just returns I plus J times the number of columns so I can actually just do this I don't need this code here I could say the top neighbor is index i j minus one the right neighbor is I + one J and I I'll you know what I'm going to live dangerously today and I'm not going to fix all the formatting here I'll fix it after the fact when I post the code it'll be all nicely indented in Space the way I like it um but I'll fix a few things right uh bottom I can't help it I'm doing it anyway uh index bottom is i j + one and then left is grid uh I minus one J what J uh I'm losing my mind here I minus one uh J right because the the Y is the same okay so these are the neighbors top right bottom left now first of all have they been visited if top has been visited if top has not been visited then I want to add top to uh I want to add top to that array neighbors. push top now I should really probably condense I right now I'm doing something that I do often which is like I'm just writing things out very explicitly I know there's only four neighbors and I can just like have these four neighbors and then duplicate this code four times I could easily do it differently and kind of like figure out a nice way of um uh a nice way of like condensing this code but I'm going to just sort of live with being happy with this because I'm just to do this four times and do if bottom has not been visited put it in if uh right has not been visited put it in and if left has not been visited put it in and you know what I want to keep the same order even though it doesn't matter right yeah it does it might matter top right bottom left top right bottom left so I want to build an array of things that have not visited yet but I also have a little bit of an issue I need to deal with it's really unfortunate I wish I didn't have this problem but what if I'm over here I only have three neighbors there's no neighbor to over here and I could do something fancy where if you go over here you could come on that side but I don't want to do that so I also need to figure out to make sure my I the the neighbor that I'm looking for is not negative one or past the width so I need to deal with that H I wish I didn't have to life would be so much nicer if we didn't have these edge cases by the way that's why you call Edge case CU it's actually on the edge it's an edge case I can do something different for it I don't know if I ever thought about that before but you know um so one way I can deal with that is I think um uh I I'm gonna do it over here this is a little bit weird but I'm goingon to say uh if I because it's invalid I I I want an invalid index if I or J is less than right if I is less than zero or J is less than zero or I is greater than the number of columns minus one or J is greater than the number of rows minus one all of these are invalid index values right I has to be between zero and columns minus one J has to be between zero and rows minus one and then I'll just return a negative one so I'm going to get a totally invalid index otherwise I want the correct index and then down here do you know if it get negative 1 you know what's going to happen here top is going to be undefined or right is going to be undefined or bottom is going to be undefined so you know what I can just do as long as top is a real thing and it hasn't been visited then it can go into the array as long as right is a real thing and it hasn't been visited as long as bottom is a real thing and it hasn't been visited and as long as left is a real thing and it hasn't been visited boy this check neighbor's function it was a lot to do but we're kind of like we're really like practically there now what we figured out now is are there neighbors that haven't been visited if so select randomly one of those so now what I want to do is if neighbors is do length is greater than zero let's pick a random neighbor so I need a random value between zero and the length of that array array and then I'm going to say return that random neighbor otherwise uh what return let's just return undefined it probably would return undefined anyway if it doesn't return a neighbor but I'm going to explicitly say undefined so this is what we're doing we are in a Cell that's the current cell we're looking at all its neighbors we're finding any that haven't been visited and then we're going to visit that one so let's go back to this the main sort of part of the sketch and what I'm going to do here is say neighbor equals current check neighbor so this function should check the neighbors find a random unvisited one and return it and I'm going to say if neighbor is not undefined right then what neighbor and you know what I'm not going to call this neighbor I'm going to call this next because this is really the next cell current the next cell is one of the available neighbors as long as neighbor is not defined now next is not defined now next has been visited and current should be next right so this is like what we're doing we're marching through so let's just look at this if I run this now I probably made a mistake so check neighbors is not current. check neighbors is not a function so let's see what did I miss current check neighbors this check neighbors I spelled neighbors wrong okay so now let's run this again look at that so so you can see and let's let's reduce the frame rate so we can see what's going on I'm going to say frame rate uh just at at 5 frames per second so you can see here it's marching along and eventually it's going to get to a spot and there's no more available neighbors so we're doing pretty well and actually this is going to be the end of this part because we got to a good part we got the part of the algorithm where we're marching along to find neighbors until we get to a spot where there's no neighbors anymore now I haven't been removing the walls that's going to removing the walls I'm going to do in the next part but this is pretty good I can hit refresh again and we can see it's going to do this differently every time but you can see it's going to get stuck pretty fast so the next thing I need to do and uh is in the algorithm is actually start removing the walls so that we're carving out this maze so to speak okay see you in the next video