We're back with our "Oh noes" countdown. What if we wanted to make Oh Noes Guy get bigger as the countdown gets closer to zero, to make it seem more like impending doom? One way I can do that is to animate the CSS styles of this image with window.setInterval. For the first step I'll find the image and store it in a variable. ohnes = document.getElemenyById("ohnoes"); And I'll set the starting style so it starts off at some width. That way we have something to get bigger from. And now I'll write a makeItBigger function and that will be responsible for making it bigger each time. And in here we need to change the style.width and take the previous style.width and add one to it. Finally I'll call setInterval with this function. window.setInterval(makeItBigger), and how much bigger do we want Or how often do we want to make it bigger. Well we want a smooth animation, which usually means somewhere between 24 frames per second and 60 frames per second. I'll try 30 frames per second, which is 1,000 over 30. Mm. Okay, so it's not working. Do you see why? It's a little tricky. Let's go here and think about this. What is the value of ohnoes.style.width after this line here? Well, you might think 50px goes to 51px, but let's just log out and see what ohnoes.style.width is. We have an infoDiv that we can put this in. So it equals, let's see... 50px, okay. And then we try to add one to 50px. What id 50px plus one? You might say 51px, but JavaScript thinks of 50px as a string, so it actually becomes 50px1, which doesn't really make sense. So the browser is probably just ignoring our attempt to set the width property to this nonsensical value. What we need to do is convert this number with a unit to just a number, then add one to the number and then add "px" back to it. We can do that by first wrapping this in parseFloat, that turns it into a number. Then we can just wrap all this, then we'll plus "px" at the end of it. Woo! It's working. He's getting bigger! Now you can see the tricky thing about animating CSS properties. They often have these units attached so you have to parse out that unit Oh my God, he's getting bigger. You have to parse out that unit and stick the unit back on. He's getting really scary, and actually there are a few scary things about using setInterval to animate CSS properties. First, the browser does not guarantee that it will exactly obey this delay here. If other things pop up, like user interaction, like the user typing, then it might call your callback later so you won't get this smooth animation. Second, the browser will call your function even if this tab is hidden, which uses up computer processing power unnecessarily. That's why there's a new function, available in modern browsers, designed specifically with DOM animations in mind, and it's called window.requestAnimationFrame. To use it we'll get rid of the setInterval line and call requestAnimationFrame from inside the function and we'll actually give a reference to the makeItBigger function. Then we'll just call makeItBigger on page load. Ooh! All right, he's getting big and really fast this time. The browser is now calling makeItBigger right before it repaints, which is about 60 frames per second, which is double what we had before. And we're adding one pixel to the width each time. So you do the math, and we're great at math here, then we're adding 60 pixels per second. In just a few seconds it grows bigger than the page. Now it's gone. How do we slow down our animation? There are a few ways, but one way I like is to keep track of how much time has gone by and then calculate what the new width should be based on that. We start by remembering the start time, in milliseconds, before the function is called. var startTime Woo, getting bigger again. new Date().getTime(); And then inside makeItBigger we store the current time. var currTime = new Date().getTime(); And for our calculation, let's say we want it to grow 30 pixels per second and start it off as 50 pixels. So let's just calculate this here. So newWidth equals 50 our starting width plus current time minus startTime. That's in milliseconds so we're gonna divide that by a thousand, and then times that by 30, because we want to go 30 pixels each second. Okay, so that's our newWidth and now let's set the style.width to that newWidth. newWidth Ahh, there we go. That's that nice, smooth 30 pixels per second. And we can change this number if we want it to grow slower or faster. (chuckles) What about stopping the animation when it gets too big? We can just wrap this line in an if, this line here, and only do it if the currentWidth is less than some number, like 300, let's try that. Actually currentWidth is No, newWidth. Okay, let's see if it gets 300. (imitates fanfare) Go Oh Noes, you can do it. (gasps) Beautiful. This technique of using requestAnimationFrame should work as long as a user is in Chrome, Firefox, or IE10+. There are various JavaScript libraries and shims that will use requestAnimationFrame when it's available and then fall back to setInterval in the older browsers. That's the thing about web development The web is changing all the time, browsers are adding new features, developers are discovering new ways of using those features. You have to be constantly learning about what's new and what's best for what you want to do.