[Instructor] This is a JavaScript implementation of the factorial function using recursion and memoization. We're going to walk through it to see what the computer does. So first we have the creation of the memo data structure, in this case it's a job script object which we're going to fill later. Then we have the definition of the factorial function and then at the bottom, the first thing we do is call factorial for two. So let's see what happens. We go to the function and two is not equal to zero so this is false. The memo does not have a value for two so this is also false. So we go to the else and that calculates by recursively calling factorial for n minus one. So it's going to immediately call factorial of one. And now we're in the function when n equals one, this is false, this is false, so it goes here and needs to calculate factorial of n minus one again, this time that's going to be factorial of zero. So it calls that and now we're in a function for when n equals zero. This time this first if condition is true so the function's going to return one. So that one gets returned and now we're back in the function when n equals one and now we get to update the memo and say that memo of one equals one. So you can see that the object updates, it now has one key with a value. We return that value of one to whoever called us. So now we're in the function when n equals two. And we have a result for this as well which is two. So we update memo of two to be two and we return that result of two. All right, so we've got factorial two and we now have a memo that has two keys in it for the values of one and two. So let's see what happens when we call factorial five. So we go into the function and five is not zero so this is false. The memo does not have a key of five so this is false. So we go here and it wants to call factorial of n minus one which would be factorial of four. So immediately it does that and we're in the function for n equals four. It's not equal to zero, it's not in the memo, so we go here and it calculates factorial of n minus one so that's factorial of three. So now we're in factorial for n minus three. Three is not equal to zero, the memo does not have three, so once again, factorial of n minus one is gonna be factorial of two. So here two is not equal to zero but the memo does have a property for two. So we are gonna return memo of two which is two and this time we don't have to recursively call anymore functions because we already know the answer for two. So this goes back up to when n equals three in the factorial function and now we have this result of six so we get to update the memo for n equals three. Then we go back to when n equals four in factorial and now we have a result of 24. We update the memo. We return back to when n equals five. We have a result of 120. We update the memo and we return it. So you can see that we saved a few recursive calls there because we already had a factorial of two stored in the memo and if we continued and called something like factorial 10, we would save calls as well because we've already got factorial five in there and then it could stop.