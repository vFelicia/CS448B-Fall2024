With timestamps:

00:00 - hello and welcome to today's coding
00:02 - challenge wave function collapse this
00:04 - was originally suggested in
00:07 - 2017 on the coding trains github
00:10 - suggestion box the algorithm itself was
00:12 - originally pioneered by
00:14 - mxgmn on github in this wonderful
00:17 - repository with lots of sample imagery
00:19 - and explanation the core idea of the
00:22 - wave function collapse algorithm is to
00:24 - take an input image and generate an
00:26 - output image many output images that all
00:29 - mimic the style the pattern of that
00:31 - original image now you might be thinking
00:33 - aha don't we have giant deep neural
00:36 - networks that can do this yes
00:38 - but this algorithm is incredible because
00:40 - it uses none of that and it is just a
00:42 - joy to watch i should say if you're here
00:45 - thinking oh goody here comes a
00:46 - step-by-step tutorial on how to
00:49 - implement the wave function collapse
00:51 - algorithm it's probably not what you're
00:52 - going to get i have not done it before
00:54 - other than a brief failed attempt that
00:56 - didn't get very far so i'm here to try
00:59 - it again what you're seeing to the left
01:00 - and right of me is hopefully the end
01:02 - result of this video and if i've gotten
01:03 - there if i've succeeded it hopefully
01:05 - looks interesting and like something you
01:07 - might want to watch so stick with me all
01:09 - aboard let's try to make wave function
01:12 - collapse happen in addition to the
01:13 - github repository which has the source
01:15 - code for the original implementation of
01:17 - the algorithm as well as a full
01:18 - explanation of the algorithm as well as
01:20 - many many many links to forks and
01:22 - spin-offs and variations of it the other
01:24 - resource that i am following closely for
01:26 - this challenge is the wave function
01:29 - collapse post on the processing forum
01:31 - itself uh thank you very much to solab
01:34 - who started this thread tons of great
01:36 - information there i highly recommend you
01:38 - take a look at all the explanations and
01:39 - diagrams and source code as well let's
01:41 - begin by answering the question why is
01:44 - it called wave function collapse well
01:47 - this is an algorithm for procedural
01:49 - generative images which could be applied
01:50 - to art and games and so many different
01:52 - kinds of creative things that you might
01:54 - try the term itself comes from quantum
01:57 - mechanics what does it mean to collapse
02:00 - a wave function to answer this question
02:03 - let's talk about another term
02:06 - entropy i want to talk about entropy in
02:09 - the context of information theory
02:13 - if you're a fan of the game mortal
02:15 - there's a wonderful three blue one brown
02:17 - video that goes through how to optimize
02:20 - your solution for any given wordle of
02:22 - the day
02:23 - with the concepts of entropy and
02:25 - information theory i'm going to attempt
02:27 - to explain it to you in the context of a
02:29 - different game sudoku
02:33 - sudoku is a game where you fill an
02:36 - entire board with the digits one through
02:38 - nine each digit needs to appear uniquely
02:41 - in every row in every column as well as
02:44 - every three by three section this means
02:47 - if i have a blank sudoku board every
02:49 - cell has nine possible digits that could
02:51 - be in it the average entropy of this
02:54 - system we could think of as nine
02:57 - what's exciting about the concept of
02:59 - entropy as applied to games like wordle
03:01 - or sudoku is when we know some
03:04 - additional information like aha we see
03:06 - the board comes with one number already
03:09 - filled in like the number nine here
03:12 - then suddenly the entropy is reduced for
03:16 - these two cells all of these cells all
03:19 - of these cells and all of these cells
03:22 - here right all of those cells only have
03:25 - eight possible numbers that could go in
03:27 - them if i were to say that there's a two
03:29 - here then suddenly all of these cells
03:32 - only have seven possibilities in them
03:34 - and how does this relate back to wave
03:37 - function collapse
03:38 - and quantum mechanics the idea of
03:41 - collapse in the context of entropy is to
03:45 - collapse all the possible states down
03:47 - into one remove all the entropy from a
03:50 - single variable of the system so this
03:53 - cell in sudoku is collapsed to nine this
03:56 - cell is collapsed to two as certain
03:58 - cells collapse and their state is
04:01 - revealed to be a single option the
04:03 - entropy is reduced for its neighbors and
04:05 - we can start to make guesses there and
04:07 - further collapse and further collapse
04:09 - and further collapse until we've solved
04:11 - the sudoku board i'm going to start over
04:13 - with an example sudoku board that i got
04:16 - off the internet
04:21 - [Music]
04:24 - the process of solving a sudoku puzzle
04:27 - is exactly the same process that lives
04:30 - inside the wave function collapse
04:31 - algorithm the idea is to start with a
04:34 - set of tiles in this case many of them
04:37 - have been collapsed already and look for
04:39 - the tile with the least entropy meaning
04:42 - the fewest possible numbers that could
04:44 - go in it so i'm going to look at this
04:46 - for a minute here let me use my brain
04:49 - power
04:50 - so i've been going through and noting
04:52 - what numbers are possible in any given
04:54 - tile and as i was working through it i
04:56 - noticed well there has to be an eight
04:58 - down here somewhere and there can't be
05:00 - an eight in either of these two columns
05:02 - because of these two eights there can't
05:03 - be an eight here and there can't be an
05:05 - eight here so the only possible number
05:07 - in this particular cell is an eight so i
05:09 - can collapse it and fill in the eight
05:12 - i'm looking for the tiles with the least
05:14 - amount of entropy collapsing those tiles
05:17 - and then going and looking for the next
05:18 - tile with the least entropy and so on
05:20 - and so forth if at some point i don't
05:23 - have a tile that has only one option
05:25 - left i might just have to make a guess
05:27 - and go with it unless i get it realize
05:30 - i'm stuck and have to backtrack and try
05:32 - a different option
05:35 - [Music]
05:39 - now that i've finally solved this sudoku
05:42 - puzzle we can look at a p5 canvas
05:46 - and try to understand how does the
05:49 - process for solving a sudoku puzzle map
05:52 - to the process for generating an image
05:55 - through wave function collapse
05:59 - now there are two ways to approach wave
06:02 - function collapse there's the tile model
06:05 - and the overlapping model
06:08 - i'm going to start with the tile model
06:10 - the idea of the tile model is that you
06:13 - have pre-made tiles
06:20 - i'm going to first implement a tile
06:22 - model with a simple set of five tiles
06:25 - one will be blank one will have a small
06:27 - line pointing up and a horizontal line
06:29 - across one with a smaller line to the
06:31 - right vertical line smaller line down
06:34 - smaller line to the left my p5 canvas i
06:37 - can think of as a four by four grid that
06:41 - can have any one of these tiles
06:43 - in any spot on the grid
06:45 - so right now the average entropy is
06:48 - uniform across all the tiles there are
06:50 - five possible tiles that could go in any
06:52 - of them maybe i pick this tile then i
06:55 - need to pick one of these random five
06:57 - options let's say i pick one
06:59 - and i fill it in
07:01 - now this is all an arbitrary made-up
07:04 - system that i'm doing right now and
07:06 - trying to keep it somewhat simple the
07:08 - possible tiles for most of these cells
07:11 - is still just five
07:15 - however
07:16 - by placing this tile here i have reduced
07:19 - the entropy for the neighboring tiles
07:22 - the only possible tiles that can go to
07:25 - the right are ones that connect to this
07:28 - line right here that would be
07:31 - tile 4
07:32 - tile 3 and tile 1.
07:35 - so there are only three possibilities
07:38 - here the only possible tiles that can go
07:41 - here are
07:42 - tiles three
07:44 - two and four i need something to connect
07:47 - to this so three possible tiles and
07:49 - we're gonna see this in all of these
07:53 - so now if i'm looking for the next tile
07:56 - to do
07:57 - i want to pick one that has the least
07:59 - entropy so now i'm only rolling a
08:01 - four-sided die to pick one of these four
08:04 - times
08:06 - let's say i pick this one
08:08 - and i roll the dice
08:10 - and i happen to pick tile four
08:14 - now the entropy for this spot is now
08:18 - also only three let's say i roll the
08:21 - dice
08:22 - and i happen to pick
08:24 - this tile
08:27 - let's look at what is the entropy for
08:30 - this particular tile now i need a tile
08:33 - that has connections on both the bottom
08:36 - and the right look at that only this one
08:39 - now
08:40 - so only this tile can go there by the
08:43 - way i made a terrible error
08:46 - i was just starting to fill all these
08:47 - out i kept i was right about there being
08:49 - three possibilities three possibilities
08:51 - three possibilities this one here
08:53 - actually only has two possibilities
08:55 - because if there is no connector
08:58 - pointing down then the only two options
09:00 - that have nothing connecting to the top
09:02 - are three
09:03 - and zero something with a blank top so
09:06 - this actually had a entropy of two so if
09:09 - i wanted to keep going i could flip a
09:11 - coin maybe i come up with three
09:14 - tile three and this goes here let's see
09:16 - what happens if i keep going
09:23 - and voila i generated this image with
09:26 - wave function collapse i could run this
09:29 - again
09:30 - roll the different dice again and get
09:32 - another image and another and another
09:34 - and another it took me quite a long time
09:37 - to work this out with my brain and draw
09:39 - it hopefully if we can write the code to
09:42 - load these tiles to know which tiles go
09:45 - next to which tiles we can
09:48 - generate these images lickety-split i am
09:51 - finally ready to start writing the code
09:53 - all i need is a blank p5 sketch and then
09:56 - i have here
09:57 - pre-made tiles blank down left right up
10:08 - to start i'll load all the images using
10:11 - preload into an array let's just draw
10:13 - them to make sure they're there
10:22 - whoops
10:23 - i forgot the tiles are in a directory
10:26 - that i called tiles
10:30 - this algorithm even though it feels like
10:32 - my explanation is going around around in
10:34 - circles is quite simple
10:36 - i think the complexity here is figuring
10:39 - out what kinds of data structures do i
10:41 - need to hold on to the information about
10:44 - the grid of tiles as well as
10:47 - which tiles are allowed to neighbor
10:50 - which other tiles
10:52 - let's use an array to store the state of
10:56 - every cell in that grid
10:59 - i want to start with just a four by four
11:02 - grid actually let's be even simpler
11:04 - let's start with just a two by two grid
11:06 - and i'll use this variable dim short for
11:09 - dimensions
11:12 - i'll start with putting in negative one
11:13 - to indicate nothing's been picked yet in
11:16 - every spot on the grid
11:18 - actually no let's not do that let's make
11:20 - an object for every spot of the grid and
11:23 - i'm going to create a variable called
11:24 - collapsed
11:25 - which is false it's not collapsed and
11:28 - then i'll call it options
11:30 - and they each should start with all
11:32 - five options
11:34 - this might be silly but
11:36 - let's set up some like
11:38 - variables to keep track of what these
11:41 - index values are
11:47 - now i can go through every element and
11:50 - draw it if it's been collapsed
11:52 - [Music]
12:02 - [Applause]
12:03 - [Music]
12:12 - all right i didn't mean to do that but i
12:14 - just wrote out a ton of code let me walk
12:17 - you through it step by step so first of
12:19 - all i need to calculate the width and
12:21 - height of every cell on the grid that's
12:24 - the total width of the canvas divided by
12:26 - how many columns and how many rows that
12:28 - dimension variable then i'm going to
12:30 - count through every row and every column
12:33 - find the index into that one-dimensional
12:35 - grid array this is the same thing i do
12:37 - in all of my videos about the pixel
12:39 - array and then if it's been collapsed
12:42 - there's only one option left so find the
12:45 - correct image and draw it otherwise just
12:48 - draw a black rectangle so if i'm doing
12:51 - my job correctly if i were to refresh
12:53 - the page i should see all black
12:55 - rectangles and let's actually give them
12:58 - a white stroke so we kind of see this
13:00 - grid
13:01 - great no cells have been collapsed
13:04 - let's collapse one of the cells manually
13:06 - just by hard coding it and see if the we
13:08 - get the proper result
13:12 - it's collapsed and we should see the up
13:14 - tile in it
13:17 - options is not defined
13:19 - oh cell dot options
13:22 - and we need to make sure we draw the
13:24 - image the right side
13:27 - there we go
13:28 - so what's next here i manually collapse
13:31 - the cell but what i should have done is
13:34 - looked at all the cells evaluated and
13:36 - measured their entropy and picked one
13:39 - that had the least entropy so let's do
13:41 - that
13:44 - i'm thinking about how to do this oh let
13:46 - me sort the array i mean i can't sort
13:49 - the array it'll be out of order but i
13:50 - could sort a copy of the array
13:53 - because i have objects in it oh this was
13:55 - a good thing that i put objects in there
13:57 - because the arrays just point to the
13:59 - object so i get multiple arrays with the
14:01 - same object the same data in them but in
14:02 - different orders oh this is great
14:06 - and in javascript the slice function
14:08 - will just make a copy of the array
14:11 - then i can call the sort function if i
14:13 - was just sorting an array of words it
14:15 - would be easy to do alphabetical order
14:17 - or ascending or descending order but
14:19 - here i've got to define my own compare
14:21 - function order to say how i'm going to
14:23 - sort them
14:28 - if this strange arrow syntax is
14:30 - unfamiliar to you let me refer you to
14:33 - some video i made 100 years ago about
14:34 - the arrow function but essentially this
14:36 - function is defining given two elements
14:39 - in an array a or b how do i define which
14:42 - one goes before or after the other and
14:45 - the number of options left for that
14:47 - particular cell is what defines which
14:50 - one should go first or second
14:53 - let me just hard code that element two
14:57 - only has two options so when i sort this
15:00 - array
15:02 - i should see that third element in the
15:06 - first spot of the array so let me log
15:08 - the regular grid unsorted and the grid
15:11 - copy sorted and let me just add to the
15:14 - end of draw no loop because i only want
15:16 - to do this once right now oh beautiful
15:20 - the first array is 5525 and then the
15:24 - second one is two five five five
15:26 - wonderful
15:27 - now
15:28 - hmm what if there were two cells that
15:30 - only had two options left the wave
15:33 - function collapse algorithm would say
15:35 - take all of the cells with the same
15:37 - amount of entropy and pick randomly
15:39 - amongst them let's go through the array
15:41 - i'm trying to think how to do this
15:44 - i'm going to create a variable called
15:46 - stop and go through the array until i
15:48 - find one that has more options than the
15:51 - one previously okay let's actually let's
15:53 - say
15:54 - length equal
15:56 - grid copy
15:58 - i'm going to have a baseline length
16:01 - which is the length of that first
16:02 - element of the array
16:09 - i'm going to go through the array if any
16:12 - given element has a
16:14 - length of options and i'm always
16:16 - forgetting this
16:17 - greater than what that first element
16:19 - does break out of the array and save
16:21 - that stop index because then i can say
16:24 - grid copy
16:26 - splice
16:27 - starting at the stop index
16:30 - all the way to the end so how many
16:31 - elements splice removes elements from
16:33 - the array and i want to remove from that
16:35 - element all the way to the end there's
16:37 - got to be a more elegant way of doing
16:39 - this but i'll just say
16:40 - grid copy dot
16:42 - length
16:43 - minus stop index
16:48 - there we go i have now sorted the array
16:51 - according to its the entropy of each
16:53 - cell and i have a new array with just
16:56 - the elements that have the least entropy
16:59 - so now i can pick one randomly
17:03 - so i'm going to pick one randomly from
17:05 - the copy of that array and then i need
17:07 - to collapse that one
17:09 - let's call this cell
17:13 - and then this is the pick
17:15 - is
17:19 - now as is always true on the coding
17:20 - train this could all be refactored in
17:23 - many more elegant ways and i look
17:24 - forward to hearing all about it in the
17:26 - comments about how you're doing it but
17:28 - basically i want to pick the cell
17:29 - collapse it pick from its available
17:31 - options and then i'm just overwriting
17:33 - the array the what should be left over
17:35 - is an array with one thing left in it so
17:37 - if i were to do that i should see either
17:41 - element two or element zero with either
17:44 - blank or up in it
17:47 - that's element zero with up
17:49 - element two with up so running this a
17:51 - bunch of times it works it works we're
17:54 - getting somewhere
17:56 - breaking news
17:58 - the live chat on twitch is telling me
18:00 - that in the splice function if i don't
18:04 - give it a second argument it'll just
18:05 - remove everything until the end boy i
18:08 - spent a lot of time working that out
18:09 - this is much simpler we're not that far
18:12 - away i think from the end here
18:18 - [Music]
18:19 - let me get rid of these hard-coded
18:22 - options
18:24 - sketch line 51
18:27 - oh because the stop index
18:30 - oh
18:32 - my stop index has a flaw in it i will
18:35 - just say if
18:37 - stop index is greater than zero
18:40 - splice it out i removed everything from
18:42 - the array because they were all
18:43 - equivalent okay there we go so now this
18:45 - is its random first pick happening here
18:48 - the next step is to reevaluate all the
18:51 - tiles and reduce their entropy where
18:54 - necessary so for example this tile right
18:57 - here same entropy but the one up top and
19:00 - the one to the right the entropy changes
19:02 - because by picking that tile in the top
19:04 - right it reduces the number of options
19:06 - that go to the left and underneath i
19:09 - need to create a new array which is the
19:11 - sort of next generation of tiles
19:20 - if it's already been collapsed then it's
19:23 - just a copy of what it was before right
19:26 - it can't change it is what it is
19:30 - and i can just bring it over directly
19:33 - otherwise i need to
19:35 - look
19:36 - above look to the right
19:43 - i need to determine what are the valid
19:46 - options based on its neighbor up to the
19:49 - right down and to the left here is where
19:52 - i need yet another data structure
19:55 - i have five tiles what if i had an array
20:00 - where every element of the array stored
20:03 - a list of valid neighbors so what are
20:05 - the valid neighbors for a blank tile oh
20:08 - wait wait wait wait wait wait oh my
20:10 - goodness
20:13 - each element of the array needs to also
20:16 - be an array
20:18 - this should really i could really think
20:19 - of this as a lookup table because i'm
20:21 - using numbers
20:23 - to number the tiles it's really doesn't
20:26 - really matter whether it's an object or
20:27 - an array but you can kind of think of
20:30 - this as a lookup table because the zero
20:33 - blank tile it needs to have
20:35 - things that can connect to it
20:38 - up to the right down or to the left
20:42 - so i'm always going to store the
20:44 - information in this example in a
20:46 - clockwise direction
20:48 - so the tiles that can go next to it
20:51 - pointing up
20:52 - are like a tile that can go above this
20:54 - blank one would be another blank one
20:58 - and then
20:59 - tile one because this does no connection
21:02 - down so zero and one
21:05 - to the right could be a blank one
21:08 - and
21:09 - tile two
21:11 - it's a down
21:12 - could be a blank one and tile three
21:16 - to the left we could put tile four could
21:18 - go there which is or a blank one zero
21:21 - and four so now if i were to look at
21:23 - tile one however
21:26 - and again this is just me coming up with
21:28 - a way of doing this right now there's
21:30 - probably a more standard or optimal way
21:32 - of doing this i'll hopefully address
21:33 - that at some point later in this 700
21:35 - hour video but here what could go above
21:39 - it for tile number one tiles that could
21:41 - go above it are two three and four
21:45 - but not a blank tile tiles that could go
21:47 - to the right are
21:49 - well another one three or four
21:53 - that could connect below
21:55 - below is blank so it could only be a
21:58 - zero or a three
22:01 - and then to the left what tile can go
22:03 - here
22:05 - two can three can or another one
22:08 - the good news here is i've assigned
22:10 - variable names to
22:12 - each of these tiles so that it'll be
22:14 - easier for me now that i start to write
22:16 - this out in code i don't have to
22:17 - remember the indices i could just think
22:19 - if it's a blank one the things that
22:21 - could go above it are an up or another
22:24 - blank to the right a right or another
22:27 - blank let's start putting that in the
22:28 - code so let me create a variable i don't
22:31 - call it rules let's call it rules
22:33 - let's make it an object
22:40 - now what can go next to a blank tile
22:44 - above it we said could go a tile
22:47 - pointing up or another blank
22:49 - to the right a tile pointing to the
22:51 - right or another blank
22:56 - a tile pointing up above it a tile that
22:59 - goes to the right the left or down is
23:01 - fine let me see if i can just quickly
23:03 - put in the rest of these
23:09 - [Music]
23:16 - all right i fit all of the rules here i
23:18 - believe this is correct i'm going to
23:21 - think about this for a bit and check the
23:23 - chat to see if i mess something up
23:25 - all right here's one that i found is
23:26 - wrong for the tile pointing up below it
23:29 - is either blank or down and then to the
23:32 - left is right up or down
23:36 - let me address something i think i've
23:38 - made this a little bit more complicated
23:40 - than it needs to be for this particular
23:41 - scenario maybe the way i'm doing my data
23:44 - structure is good for all broad set of
23:46 - possible tile arrangements
23:49 - but in this case
23:51 - even though
23:53 - i do have five tiles each with four
23:57 - neighbors each side is only one of two
23:59 - possibilities so really i could say this
24:02 - blank tile can only connect
24:06 - to other tiles that have a blank
24:08 - represented by a zero on any side of it
24:11 - this tile that is pointing up
24:14 - i could say connect to
24:16 - any tile that has a connector a one or
24:19 - that is blank or zero so really for each
24:21 - of these i only need to store four
24:23 - numbers and then zeros need to connect
24:26 - with zeros and ones need to connect with
24:28 - ones i'm not gonna double back and redo
24:30 - mine this way yes i will
24:36 - i'm just going to categorize the edges
24:38 - as a or b or zero or one
24:42 - but this is a good exercise for the
24:44 - viewer looking at it in this simpler way
24:47 - about the kinds of connections that
24:49 - exist so now we need to build
24:52 - what are the remaining options left i
24:55 - need to build up what things i could be
24:58 - by looking at my neighbor
25:02 - and only if
25:04 - j is greater than zero
25:06 - so i'm going to look at the tile above
25:08 - me only if i'm not in the first row now
25:11 - of course i think if you look at the
25:13 - wave function collapse in the original
25:16 - implementation it does wrap around and
25:18 - uh that could be done here but let's
25:19 - simplify things by just not looking at
25:22 - the neighbors above do i start with all
25:24 - the possibilities and then remove them
25:26 - if they don't exist yeah that would be a
25:29 - way of doing it
25:32 - so i'm starting with a baseline of this
25:35 - tile could be anything and this should
25:37 - actually be
25:39 - outside of here because i'm going to do
25:41 - this for all of them
25:43 - now i'm looking at the neighbor above
25:45 - and looking at what possible tiles it
25:48 - could be
25:51 - then valid tiles i could be
25:54 - are from the rules
25:56 - this is the list of valid tiles
26:04 - i'm this tile
26:05 - and i'm looking at the tile above me and
26:08 - maybe the a tile above me only can be
26:11 - like left
26:12 - or right
26:14 - so i need the valid tiles that go below
26:18 - down to a left tile and i need the valid
26:21 - tiles that go below are down to the
26:24 - right tile
26:25 - in the original array
26:27 - up right down left the order is zero one
26:31 - two three so i'm looking for
26:34 - two
26:35 - the rules for that particular tile
26:39 - the ones that are valid down
26:41 - i think i need to rethink my naming but
26:44 - now what i want to do
26:46 - is
26:47 - look at what i have in my
26:49 - range of possible options
26:52 - i'm going to remove them if they're not
26:54 - valid you know what i should do
26:56 - i'm going to make a function we're going
26:58 - to do this so many times
27:00 - check valid
27:02 - options
27:03 - valid
27:04 - so i'm going to pass in these are the
27:07 - existing options
27:09 - and i'm going to pass them into a
27:10 - function to check if any of those
27:13 - options are included as
27:15 - valid so somewhere else in my code right
27:18 - here
27:20 - the this is the array and these are the
27:22 - valid options is that the order i put
27:24 - them in
27:25 - the array is options and what's valid
27:31 - if
27:32 - valid includes
27:34 - array index i
27:36 - great so i want to check or i'll say not
27:40 - if
27:41 - the
27:42 - option that is in that array is not
27:45 - something valid then i should remove it
27:51 - it's confusing what are in these things
27:53 - but let's just remember maybe a valid
27:57 - is blank and right
28:01 - basically what i'm doing is i'm going
28:04 - through every element of this array
28:06 - blank up right down left let me see is
28:09 - it in the valid options oh if it is
28:11 - that's good don't do anything if when i
28:13 - get to up it's not valid let me remove
28:15 - it out of there this would result
28:20 - so hopefully that helps you make sense
28:21 - of it i don't love maybe i should i'll
28:23 - just say like current equals array index
28:25 - i
28:27 - maybe just
28:28 - element so this helps maybe helps you
28:31 - read it a little bit let's look at every
28:33 - element in the array if it's included if
28:36 - it's not invalid get rid of it so now i
28:39 - think i can just do the same thing for
28:40 - all of these
28:43 - looking to the right
28:44 - make sure that i
28:46 - is less than
28:48 - dimension minus one
28:53 - if i'm looking to the right
28:56 - i want to know what's valid to the left
29:00 - of that one which would be up right down
29:03 - left zero one two three
29:06 - let's grab this one for looking down
29:12 - i probably should have checked this with
29:13 - just one of the rules first but i'm just
29:15 - going to put it all out and we'll find
29:17 - out if i've gotten this totally wrong or
29:18 - not
29:23 - i think this is good if it's collapsed i
29:26 - don't need to do any analysis it's done
29:28 - it's picked if it's not start with all
29:31 - possibilities look up to the right
29:35 - look down to the left
29:37 - check that options array and then at the
29:39 - end
29:41 - next tiles index options okay
29:47 - are these new options
29:50 - it's still not collapsed i don't know if
29:52 - i need that or if that's redundant but
29:54 - this is me updating that and then after
29:57 - all of this is done
30:00 - hiles becomes
30:02 - the next tiles and so this can't be a
30:04 - const oh my goodness boy did i just
30:07 - write a lot of code without testing
30:09 - anything let's run this
30:12 - okay write dot options is not iterable
30:15 - iterable
30:17 - oh grid not tiles grid oh my god i was
30:21 - using the images
30:23 - i have an array called tiles which is
30:25 - just the images the array that i'm
30:27 - working with is called grid
30:28 - oh
30:31 - great
30:32 - let's call this next
30:42 - so this can be a const and this has to
30:45 - not be a const
30:47 - all right that's fine still have an
30:49 - error but something slightly better 147.
30:53 - so i just want to look at the rules for
30:55 - a second here there's a flaw
30:58 - the rules is an object so if i were to
31:01 - say rules blank why is that undefined
31:07 - well rules dot blank works i guess i
31:10 - should just make that an array i'm not
31:12 - sure what the best practice is here but
31:16 - if i were to do this this should fix the
31:19 - issue
31:20 - i'm just gonna make this an array since
31:22 - i have everything ordered numerically
31:24 - i don't love this but i think it should
31:26 - be okay
31:27 - oh but now i don't need this i don't
31:30 - need these it's just gonna i just have
31:32 - to have it in the right order
31:34 - well i liked it better when i was
31:35 - referencing it with a name
31:38 - i can't do everything right in this
31:40 - first attempt
31:42 - okay
31:43 - got we got down to 163.
31:46 - we got through all of these
31:48 - next grid index
31:51 - oh next grid doesn't exist
31:53 - so i just need to make it
31:57 - a new object
32:00 - i actually need to create the object
32:02 - it's going to not be collapsed it can be
32:04 - collapsed if there's only one left but
32:07 - that'll happen by virtue of the next
32:09 - round
32:10 - and then give it the options okay
32:15 - no errors amazing i'm just gonna take
32:18 - out these console logs famous last words
32:21 - and let me now add
32:25 - if i click the mouse let me redraw run
32:28 - through draw again
32:32 - so it picked that tile
32:35 - okay
32:36 - sketch.jsjs okay so i got an error the
32:38 - next time through
32:40 - ah this is grid index i forgot it up
32:43 - there so if it's collapsed don't get the
32:45 - image get the other thing
32:53 - there's a flaw in my algorithm
32:56 - let's just look at the grid oh you know
32:58 - i could do i can do console table so
33:00 - console table is a nice thing to just
33:02 - show me the array
33:04 - this is the array
33:06 - none of them are collapsed and they all
33:08 - are five possibilities now when i click
33:10 - it i should see the first one is
33:12 - collapsed and then none of the other
33:14 - ones but what happened in grid copy
33:18 - oh
33:19 - but they still all have five
33:20 - possibilities which is absolutely wrong
33:23 - so there's a big flaw in my algorithm
33:26 - for reducing the possibilities
33:28 - oh by the way
33:30 - when i copy the array i need to filter
33:33 - out
33:35 - any elements that are collapsed
33:40 - filter is a higher order array function
33:42 - that will keep the elements where the
33:45 - function evaluates to true so that
33:48 - should and then so this can't be a const
33:50 - i guess i could make another copy
33:53 - let's look at the grid copy also
33:57 - so now i have all four with five options
34:02 - and now i only have three i got rid of
34:04 - the collapsed ones one which is good but
34:07 - they all seem to have five options still
34:10 - let me look at my
34:11 - check valid function
34:14 - i wonder if this includes is not
34:16 - right this is a list of what's in the
34:20 - array these are the valid ones
34:22 - and so this
34:24 - should be left without a 0 and a 2.
34:28 - oh
34:29 - why do i put those brackets there it's a
34:32 - function that i'm checking if it
34:33 - includes that element
34:35 - these are parentheses
34:37 - not brackets
34:40 - i don't think it worked still
34:41 - oh this needs to be a one
34:44 - splice i took zero zero would take
34:47 - nothing out of the array
34:50 - wait why do i have nothing in the array
34:52 - now
34:53 - oh my goodness
34:54 - ah
34:56 - i need to accumulate all the valid
34:58 - things all together i can't do them
35:01 - individually oh this is totally wrong
35:04 - this is a blank array and then
35:07 - valid options
35:10 - should be itself
35:12 - concatenated with
35:14 - these are the things that are valid put
35:16 - them in the valid options
35:18 - these are the things that are valid put
35:19 - them in the valid options these are the
35:21 - things that are valid put them in the
35:23 - valid options these are the things that
35:24 - are valid put them in the valid options
35:27 - and then
35:29 - check valid
35:30 - options
35:31 - valid options
35:33 - so i've accumulated all of the valid
35:35 - options and then as long as my option is
35:39 - valid across them all then it should be
35:41 - fine
35:42 - is this right
35:44 - i was so confident a second ago
35:48 - no
35:49 - it's giving me all the possibilities
35:51 - wait i was so close for a second there
35:54 - oh no no i still want to check valid
35:57 - individually in each one i want to
35:58 - concatenate all the i was right i was
36:01 - right i just
36:03 - i did it across everything but i need to
36:05 - concatenate for each individual
36:08 - possibility hold on hold on hold on i'm
36:10 - gonna double back explain this
36:20 - there you go
36:21 - that's the correct answer
36:24 - there you go weight function collapse
36:26 - okay hold on
36:27 - like it appeared in my head and i don't
36:29 - know if it appeared in your head also
36:31 - while watching this so let me see if i
36:32 - can go back and explain that
36:35 - this is me i am the tile that's what
36:37 - it's become
36:39 - let's say the tile above me can only
36:42 - possibly be left or right
36:44 - for whatever reason
36:46 - it only has two possibilities
36:50 - so what i need to do is look at all of
36:52 - the valid things that can be below a
36:55 - left tile and a right tile concatenate
36:58 - those together and then as long as
37:00 - anything i can be is included it's fine
37:03 - i think we've all suffered enough that i
37:06 - can change the dimensions to like
37:08 - i don't know let's just try eight
37:15 - well look at that would you look at that
37:18 - that is just absolutely lovely
37:22 - i'm clicking there's no need for me to
37:24 - click i can get rid of
37:26 - no loop
37:28 - and let's let's really go for it people
37:30 - let's make the canvas
37:33 - 800
37:34 - by 800
37:36 - and the dimensions i don't know 80 by 80
37:39 - 20 by 20.
37:44 - i've never been so happy to see a result
37:47 - it broke so i have a feeling that i'm
37:50 - gonna need to add some backtracking to
37:53 - this when in doubt take out random seed
37:55 - and run it again
38:00 - so close to making it to the end
38:05 - okay so it can get to the end
38:08 - oh my god i have more to add to this i
38:10 - thought i was done
38:12 - if
38:14 - grid
38:15 - copy dot length equals zero return
38:22 - oh no
38:24 - oh let me put the drawing separately let
38:26 - me draw everything
38:29 - and then
38:31 - if there's nothing left if everything's
38:33 - been collapsed return
38:38 - there we go
38:40 - let's run it again
38:42 - isn't this delightful
38:45 - four days later i'm back a few days
38:48 - later and i know you've been watching
38:49 - what is already like a very long video
38:52 - about wave function collapse and i did
38:54 - get to a point where i made something
38:56 - which is pretty great i'm looking at
38:58 - this example of this printed circuit
39:00 - board seeing that there are 14 tiles
39:02 - there
39:03 - some of those tiles represent four
39:05 - possible rotations looking at the way
39:07 - that i've implemented this code with an
39:10 - element of an array for every tile with
39:14 - all of the possible adjacencies i think
39:16 - it would be incredibly difficult for me
39:18 - to hard code
39:20 - all of the possible tiles and
39:22 - adjacencies for more sophisticated
39:24 - pattern like this so i'd like to keep
39:26 - going and instead of thinking of the
39:29 - tiles that i started with as five
39:31 - possibilities i'm gonna start with just
39:33 - two possibilities
39:37 - and rather than enumerate what's
39:39 - possible here i'm just going to
39:41 - categorize the edges as a or b or zero
39:44 - or one
39:46 - what this means is when i'm going to
39:47 - place another tile next to another one a
39:49 - zero has to match with a zero a one has
39:51 - to match with a one and i could automate
39:54 - the rotation of this tile
39:57 - into its
39:58 - other possibilities
40:03 - and then enumerate all of the adjacency
40:05 - rules with code and i think if i create
40:08 - a tile class
40:12 - that keeps track of what image is it
40:16 - and
40:18 - what are its edges
40:20 - still going in the same order
40:22 - top right bottom left
40:25 - that this will make the code more
40:26 - readable and easier to
40:29 - figure out and work and make for more
40:31 - fun wave function collapsing of
40:33 - everything i think my brain is
40:35 - collapsing so let me start by making the
40:37 - tile class
40:43 - i had used the tiles array to load the
40:45 - images so now i'm going to actually have
40:48 - an array called tile images
40:52 - now that i've done that i only need to
40:54 - load the blank and up tile
40:58 - the first tile
41:00 - can be the blank one
41:03 - with those edges
41:07 - the second one would be the up tile
41:11 - with those edges
41:13 - now what if i allow myself to create new
41:16 - tiles
41:17 - based on previous ones
41:22 - what if there were a function that
41:25 - returned a new tile which is one
41:27 - rotation two rotations or three
41:29 - rotations of another tile
41:34 - the rotate function needs to do two
41:35 - things
41:36 - rotate the image and rotate the edges
41:42 - so i make a blank canvas with the same
41:43 - width and height of the image
41:47 - set the image mode to center
41:51 - rotate by half of pi or 90 degrees times
41:55 - the number of rotations so one would
41:57 - just be one rotation
42:00 - let me store the width and height in
42:01 - separate variables which i think will
42:03 - make our lives a little bit better today
42:09 - i'm going to call this variable new
42:10 - image because i'm getting confused
42:11 - between this dot image which is that
42:13 - tiles image and a new image
42:16 - i have the new image technically it's
42:18 - not a p5 image it's just a p5 graphics
42:21 - object but those two things are going to
42:23 - function the same way so i think it's
42:25 - fine now i need to rotate the edges
42:32 - so each new edge
42:34 - is the previous edge
42:38 - plus the number of rotations
42:41 - or minus is it minus
42:43 - this edge was previously down here and
42:46 - the index values go zero one two three
42:49 - so the new edge is the previous edge
42:52 - minus one however if i'm edge zero minus
42:56 - one isn't negative one it's three it's
42:58 - gotta wrap around and get index three a
43:01 - way i can do that is
43:05 - let's create a variable to store the
43:07 - number of edges
43:10 - i can add that to the total so
43:14 - zero minus one is negative one plus the
43:18 - total number edges of four would be
43:20 - index three but if i'm two two minus one
43:23 - is one plus the total number of edges is
43:26 - four so i'd get five ah
43:29 - so all i then need to do is use the
43:30 - modulo operator
43:33 - and this should give me perfect wrap
43:35 - around always take the previous one but
43:38 - if the previous one is negative you're
43:40 - going to get the higher value and it's
43:42 - not one it's the number of rotations
43:46 - so now i can return a new tile with the
43:49 - new image and the new edges
43:52 - so before i go any further
43:55 - i just want to determine if
43:57 - this at least worked rotating these
44:00 - images the difference now is the image
44:02 - is a property of that tile object
44:11 - something is wrong my rotation is not
44:13 - working so i've made a sort of classic
44:16 - error in p5 here where i didn't think
44:18 - about the origin around which i was
44:20 - rotating so i've rotated the image off
44:22 - the canvas that i'm drawing it to i need
44:24 - to say new image translate
44:27 - to the center
44:29 - then do the rotation
44:30 - then draw the image at zero zero
44:33 - so if you zoom in you'll see that the
44:35 - tiling is a little bit of skew that's
44:37 - really just because when i made the
44:39 - images i didn't make them perfectly
44:40 - symmetrical so the rotation isn't
44:42 - perfect but i kind of actually like the
44:44 - way that it looks with it slightly askew
44:46 - but this is not relevant to the
44:48 - algorithm it's just a matter of
44:49 - designing the tile images and ultimately
44:52 - i'm going to use the tile images from
44:54 - here to see if i can create a more
44:56 - sophisticated pattern so now instead of
44:58 - having this big array that's just a mess
45:01 - of all these rules
45:03 - could i procedurally generate the rules
45:06 - by analyzing the tile objects that i'm
45:09 - creating and as long as i'm doing that
45:12 - why not put in the tile object itself
45:15 - lists of valid neighbors
45:22 - this is terrifying but i'm just going to
45:24 - delete
45:25 - all of this from the code
45:28 - now that i have tile objects looking
45:30 - down here would make sense for me to
45:32 - have a cell object i mean i have cell
45:34 - objects they've got a list of options as
45:36 - well as whether they're collapsed or not
45:38 - but i should make a class with a
45:39 - constructor to generate these
45:48 - these names are no longer relevant the
45:51 - list of options can just be the index
45:54 - values to the tiles array
45:57 - so what i want to pass in is the total
46:00 - amount of tiles there actually are
46:07 - then i can fill the array with if there
46:10 - are five options zero one two three four
46:13 - of course that could be done with some
46:14 - higher order functions like fill and map
46:16 - and from and
46:18 - have a ball doing that i actually just
46:20 - spent a little while doing it myself and
46:21 - it was very confusing and i didn't want
46:23 - to include it in this video but here's
46:24 - what it looks like
46:26 - loaded and created the tiles
46:29 - i built a cell
46:30 - for every spot on the grid
46:34 - and now i need to generate the adjacency
46:37 - rules based on the edges
46:42 - for every tile
46:46 - i'm gonna just write a function called
46:48 - analyze and give it all the tiles all
46:51 - the other tiles so the tile objects
46:53 - gonna have to figure this out
46:56 - let's call this the connection
46:58 - is edges index zero
47:01 - now if we look at all the tiles
47:04 - i mean we should check if a tile can
47:05 - connect to itself that is a valid thing
47:08 - to check so i'm looking at all the tiles
47:10 - regardless
47:12 - so if my connection
47:14 - up
47:15 - is a certain value i need to find all of
47:17 - the tiles that have that same connection
47:19 - pointing down which is index two
47:24 - and i'm sure there's a way that i could
47:25 - not do these as four different loops but
47:28 - i'm gonna do it that way right now and
47:29 - maybe this secondary variable is kind of
47:31 - unnecessary
47:35 - and this is tiled index i and this might
47:38 - actually be easier to read i
47:40 - don't the order of the tiles doesn't
47:42 - actually matter
47:43 - so let tile of tiles
47:47 - so if that particular tile
47:51 - down edge matches the tile that i am
47:54 - my edge which is this dot edges
47:58 - then it's a valid connection so now i
48:01 - just need to repeat this for right down
48:04 - and left
48:05 - oh and i don't need to do a separate
48:06 - loop it can all be in here
48:09 - so right is
48:11 - three is equal to one
48:15 - down is zero
48:17 - is equal to two
48:21 - and left is checking if this tile's edge
48:24 - at three is connected to the tile that
48:27 - it's looking at its edge at one
48:31 - now again there's probably a lot of
48:32 - redundancy here but this is just the way
48:35 - that i'm getting started here trying to
48:37 - recreate what i did originally in a bit
48:39 - more of a generic scalable fashion
48:44 - i think this order makes more sense
48:46 - we're loading the images rotating the
48:48 - ones we need to rotate and defining what
48:50 - all the edges are then we're analyzing
48:52 - all the tiles against each other to see
48:55 - what which tiles can go next to each
48:57 - other then we make a grid full of empty
48:59 - cells each cell could be any given tile
49:03 - to start so drawing doesn't change this
49:06 - however is the part that needs to change
49:09 - before i was looking at my rules array
49:11 - now i need to look at the adjacencies
49:14 - that are defined in the tile objects
49:17 - themselves so up looking at the cell up
49:21 - valid options starts as a blank array
49:24 - then i'll need to look at what are the
49:26 - possible options in up and then get the
49:29 - valid ones now are
49:32 - not rules but tiles
49:34 - dot down anything that i could place
49:37 - where i am has to be
49:39 - something that can be below all of the
49:42 - things that could be next to the tile
49:44 - above me
49:45 - is that the only thing i'm changing
49:48 - look at the tiles
49:51 - and look to the left
49:52 - then look to the tiles
49:55 - up
49:58 - no way it's as simple as that
50:00 - okay cell is not defined okay well
50:02 - that's an error i can fix
50:05 - include the cell file
50:07 - blank is not defined where did i have
50:09 - blank let me by the way change the
50:11 - dimensions to just four by four while
50:13 - we're sort of figuring this out
50:16 - ah
50:18 - so the options are
50:20 - when i'm assuming it could be anything
50:22 - let's use the fancy higher order array
50:25 - functionality thing here
50:27 - i need an array
50:29 - with the number of spots in it as the
50:31 - number of tiles there are
50:33 - i need to fill it with something to
50:35 - start so i'll just dip zero
50:37 - and then i can use the map function
50:39 - to
50:40 - map every value to its index
50:43 - so that's its current value which is
50:44 - zero its index is i
50:48 - if i've done my higher order array
50:50 - functions correctly it's an array that
50:53 - has with five tiles has the values zero
50:56 - one two three and four in them
50:58 - okay cannot read properties of undefined
51:01 - reading up well we can start 137
51:06 - tiles option
51:09 - up
51:12 - what is going on here
51:15 - hi everybody i've been debugging this
51:17 - for a little bit and
51:19 - part of my debugging i said console logs
51:21 - a grid and i'm looking at the grid and
51:23 - the first time i get four cells because
51:26 - i made it two by two only one option
51:28 - left because that one's collapsed five
51:30 - five five and then suddenly look at this
51:32 - cell then rackety brickety brackety
51:34 - brackety
51:35 - those aren't cell objects because i did
51:38 - something really pretty terrible at the
51:40 - end instead of creating the new cell
51:42 - object for the next generation i'm just
51:45 - making an object literal which is not
51:47 - right so i need to say new sell
51:50 - and the options shouldn't this is when a
51:52 - new cell is made
51:54 - how about i could give it options
51:57 - i'm trying to think of an elegant way to
51:58 - design the constructor now so i just did
52:00 - a little testing in the console here
52:03 - that i could determine if a variable is
52:05 - an array by saying instance of array and
52:08 - i'll get true so i think what i can do
52:10 - here in this
52:12 - cell class is i can say if num is an
52:15 - instance of an array
52:18 - then this dot options equals
52:22 - that array it's no longer num it's the
52:24 - array i mean i don't know what to call
52:25 - that variable i'll still call it a num
52:28 - otherwise i'm filling an array with
52:31 - all of the options according to some
52:33 - total so let's just call this value to
52:35 - be a little bit more generic
52:38 - so these are the two different ways i
52:40 - can create a cell object and if i go
52:42 - back to sketch.js i should be able to
52:45 - say make a new cell
52:47 - out of those options
52:49 - oh that's better
52:51 - i see
52:52 - four cells and four cells
52:54 - i still got this error though something
52:57 - is going very haywire here i'm gonna
52:58 - have to do some more debugging oh please
53:00 - hold
53:01 - if tile zero is collapsed
53:05 - i should see
53:06 - one option there tile one should have
53:10 - three possibilities
53:12 - tile two
53:13 - should have two and not be collapsed and
53:16 - tile three should have all five
53:19 - possibilities still so cell number one
53:21 - which is the one directly to the right
53:23 - of the top left should have three
53:26 - options left and it has zero so the bug
53:29 - is there and cell number one is when i
53:33 - is one and j is zero so i have an index
53:36 - so i can debug some things if index is
53:39 - one let's check looking to the left
53:43 - so if index equals one let me look at
53:46 - the tile to the left
53:49 - the tile to the left is collapsed and it
53:51 - is
53:52 - tile index one
53:55 - so it's valid options should be all of
53:58 - the things that can go to the right
54:00 - of tile index one
54:04 - ah
54:06 - the error
54:07 - is not a logic one it is an apples
54:11 - checking against oranges problem the
54:14 - valid tiles are tile objects but my
54:18 - function that i wrote days ago at this
54:20 - point now
54:22 - in the check valid is checking index
54:25 - values against each other so if i go
54:27 - back to this analyze function i
54:30 - shouldn't be putting the actual tile
54:32 - objects in the arrays that are valid up
54:36 - right down and left i should be putting
54:38 - the index of that tile so i do need to
54:41 - have this a for loop with i in it
54:46 - because the index of the tile is what is
54:49 - indicating what's valid
54:54 - [Music]
54:55 - we did it people wait let's get rid of
54:58 - some of the debugging
55:00 - let me go back and make it
55:02 - 20 by 20.
55:07 - wave function collapse exactly what i
55:09 - had before but now and again again it's
55:13 - not always going to find a solution and
55:15 - i got to talk about how to deal with
55:16 - that but now
55:18 - i don't have to create a massive map
55:22 - of all of the tiles and their
55:24 - adjacencies all i need to do is load
55:28 - tile images and some numeric indicator
55:32 - for what's a valid connection of an edge
55:35 - then i can rotate tiles and infer all of
55:39 - the adjacencies this means i believe i
55:42 - can get this pcb generator going thank
55:45 - you to those who are watching live who
55:47 - sent me fixed tiles and the circuit
55:50 - board tiles i'm going to download those
55:52 - now and see if i can bring them into my
55:54 - sketch so i have the circuit tiles
55:57 - and i have my code i think i'm going to
56:00 - need to
56:01 - kind of draw my own version of these
56:03 - tiles on the whiteboard to
56:05 - enumerate all of the edges so there's a
56:08 - blank gray and a blank green tile let's
56:11 - start with those
56:13 - that's tile zero that's this is zero dot
56:15 - png
56:17 - these numbers by the way aren't really
56:18 - relevant although they will be because
56:20 - they'll be the indices into the tiles
56:21 - array i guess
56:23 - and one dot png
56:25 - so the blank one will have zeros as its
56:28 - connectors edges and the blank green i'm
56:32 - just going to say this is blank
56:34 - and this one is green
56:36 - it'll have ones
56:37 - okay what is two dot png
56:41 - kind of looks like this
56:43 - all this area is green
56:45 - so that's a one a one a one and now we
56:48 - need another thing this is a two
56:53 - and this is like gray
56:57 - so green is one and this is something
57:00 - new it doesn't match this because this
57:02 - is green
57:04 - three
57:05 - three
57:06 - one
57:08 - [Music]
57:31 - so i've worked all this out and there's
57:33 - only actually a few different kinds of
57:36 - sides there's a blank side zero a full
57:39 - green side one a light green connector
57:42 - which is two a light gray connector
57:44 - which is three that's what all of these
57:47 - are except
57:48 - for four dot png and five dot png these
57:52 - are not symmetrical meaning if i flip
57:54 - them
57:55 - i have a different tile which is
57:56 - different than how i'm rotating things
57:58 - so i think i need a whole other
58:00 - mechanism for tracking
58:02 - how these connect
58:04 - so for right now in this process of
58:07 - working this through i'm gonna do this
58:09 - without using these tiles
58:14 - so i have 13 tiles ordinarily i would
58:16 - just write a loop now to load them into
58:18 - the array based on their the number of
58:19 - the file but since i want to skip to i'm
58:22 - going to do it manually
58:29 - okay so you can see i'm loading them
58:31 - into an array of 11 tile images skipping
58:34 - 4 and five
58:40 - now i put in the connections zeros all
58:42 - zeros
58:43 - all ones
58:45 - one two one one
58:47 - one three one three
58:55 - i really want to try this
58:57 - without rotating any of them and see
58:59 - what happens images are in a directory
59:02 - called circuit
59:06 - oh
59:08 - oh i've never seen anything so beautiful
59:10 - in my life
59:11 - that's amazing
59:14 - that's promising so now i just need to
59:16 - do some rotations
59:18 - now looking at these images they don't
59:20 - all need to be rotated four times
59:22 - but i might as well
59:24 - because then i don't have to think about
59:26 - it
59:27 - so let index equals 11 i'm gonna skip
59:30 - obviously zero and one
59:35 - i'm gonna go through all of the tiles
59:37 - one through ten
59:39 - oh i'm not i shouldn't be in preload
59:41 - what am i doing
59:44 - i'm gonna go from 2 all the way to 10
59:47 - and i'm going to say tiles.push
59:50 - tiles index i rotate
59:53 - 1
59:55 - 1 2 3 so less than 4.
60:00 - so that should go skipping the first two
60:03 - tiles which don't need to be rotated now
60:04 - there's a lot of extra rotations i don't
60:06 - think i need but starting with tile two
60:09 - going all the way down to tile 10
60:10 - rotating them once twice and thrice oh i
60:14 - don't need this index because i can just
60:16 - push them into the array
60:20 - wow
60:21 - this is wild
60:23 - i guess the blank tile never shows up
60:26 - tile zero it only can connect to tile
60:30 - four
60:31 - let's i i'm so close i think i could get
60:34 - image four and image five in there
60:37 - no i can't
60:42 - one day later
60:44 - welcome to day three this time i'm
60:47 - finally going to complete the wave
60:49 - function collapse algorithm first i need
60:52 - to say a huge thank you to telemacho and
60:54 - garageball who overnight while i was
60:57 - sleeping
60:58 - added some github issues on the
60:59 - wavefunction collapse repository
61:02 - pointing to the keys to unlocking the
61:05 - asymmetrical tiles and placing them
61:07 - correctly that i was struggling with
61:09 - yesterday an incredible demonstration of
61:12 - the solution i'm about to attempt is
61:14 - oscar stahlberg's unity implementation
61:17 - of wave function collapse in it you can
61:19 - interactively start to select tiles and
61:22 - it will visually show to you which tiles
61:25 - are left you can also let it run and
61:28 - watch the process as it selects the
61:30 - tiles and the magic of wave function
61:32 - collapse unfolds over the screen the
61:34 - beautifully designed tiles of this
61:37 - demonstration are not symmetrical along
61:39 - the edges but each edge can be divided
61:42 - into three parts the left part the right
61:44 - part and the middle part and as long as
61:47 - brown matches with brown blue matches
61:49 - with blue
61:51 - half brown half light brown matches with
61:53 - half light brown half dark brown the
61:55 - process will work
61:57 - thanks to the magic of these colorful
61:59 - markers i have redrawn all of these
62:02 - tiles so i think i can make a key to
62:04 - enumerate all of the possible parts with
62:08 - each edge divided into three that could
62:10 - be on any tile symmetrical or not so
62:13 - this first tile which is all black is
62:15 - fully symmetrical along all the edges in
62:17 - all rotations
62:19 - and i think because i've numbered all
62:21 - the tiles it might be easier for me to
62:23 - use letters here so that we can really
62:25 - distinguish what's being matched with
62:27 - what so i'm going to call the black
62:29 - color a
62:31 - white which really is a dark green in
62:33 - the actual tiles i will call b
62:37 - now this side will be a
62:39 - a a
62:41 - a a a
62:44 - one color all around all the parts of
62:46 - the edges same for this but with b
62:52 - finally now with the image number two we
62:55 - will get something a little bit more
62:56 - interesting we've got b's all around
62:58 - these sides
63:00 - those are some very funny b's
63:03 - and then i've got a b here and a b here
63:07 - but now i need a third color for light
63:10 - green
63:12 - we'll call that c
63:14 - the blue color here is actually gray in
63:16 - the image files a new color
63:21 - we'll give that the letter d so now i
63:23 - have
63:25 - b
63:25 - b
63:26 - b
63:27 - b
63:28 - d
63:28 - b
63:29 - and so on and so forth
63:32 - now we've got something pretty
63:33 - interesting the asymmetrical tiles but
63:36 - this system makes them really easy to
63:37 - notate
63:41 - and i can go on and complete the rest
63:43 - [Music]
63:53 - how did i do
63:54 - i think i've got this right one mistake
63:58 - thank you live chat
64:00 - so now back to the code first thing i
64:03 - can turn this into a loop which is going
64:04 - to make all of our lives so much better
64:11 - don't you just feel so much more at ease
64:13 - and relaxed tile images ah
64:16 - no no i'm not relaxed at all in fact i'm
64:18 - totally panicking
64:21 - that would have been very unfortunate to
64:23 - find later but now
64:27 - nonetheless these tile objects still
64:29 - have to be created individually because
64:31 - i'm going to manually notate all of the
64:35 - letters for the edges and by the way
64:38 - there's a key term that i should be
64:40 - using when talking about all of these
64:42 - edges and that is the term socket
64:46 - you can think of each section of an edge
64:49 - as a socket each socket must connect to
64:53 - another socket of the same type for them
64:55 - to match up and by the way i encourage
64:57 - you to try having more than three
64:59 - sockets or fewer than three sockets so
65:01 - many possible things you could do if you
65:03 - we could get this working the one thing
65:05 - that's going to be really confusing is
65:08 - what is the order by which i write the
65:12 - letters for the sockets this side socket
65:16 - is bbb well this side socket is also bbb
65:19 - and i don't have to worry about what
65:21 - order because they're symmetrical but
65:23 - this one i really have to think about
65:25 - this side socket is a b b does it
65:29 - connect to itself
65:31 - well you might think it does right
65:33 - because what it wants to connect to is
65:35 - something that looks like this a matches
65:37 - up with a b matches up with b b matches
65:40 - up with b
65:41 - but if i took this side
65:43 - and put it here i would have to do that
65:45 - by rotating this all the way around and
65:48 - suddenly this side rotated around would
65:50 - look like this
65:52 - these don't match
65:53 - but this side if i were to take this
65:56 - side and bring it up here
65:58 - it would match
66:00 - but this says abb these are not the same
66:03 - while this one says abb and this one
66:05 - says abb those aren't the same
66:06 - orientation
66:08 - i need to make sure i'm notating
66:10 - everything in the same order which means
66:12 - in the clockwise order it's the way i've
66:14 - been thinking about this project all
66:16 - along up right down left up right down
66:20 - left so even though i most definitely
66:22 - want to draw it this way because it'll
66:24 - be way too confusing for me to write bba
66:27 - and not see that match up when i put it
66:29 - in the code i need to notate the sockets
66:32 - as abb
66:33 - bcb
66:35 - bba aaa
66:37 - then
66:38 - edges need to match up with other edges
66:40 - that are inverted so they lock together
66:43 - and i also should note that another way
66:45 - to approach this order would be north
66:48 - east south west which i could have been
66:50 - doing all along but somehow my brain is
66:52 - going up right down left so now as i
66:55 - prepare to enter the edges into the code
66:58 - looking right at the whiteboard
67:00 - for tile zero this is easy it's just
67:03 - going to be aaa
67:05 - in all four spots
67:07 - tile one all b's
67:12 - now with tile index two i've got the top
67:15 - as bbb
67:17 - but i need to make sure i read
67:20 - b c b in this order and b b b in this
67:24 - order oh but these sides are symmetrical
67:26 - so again it's only gonna matter when i
67:28 - get to four and five
67:34 - and here i am at index four
67:37 - abb
67:38 - that's the top
67:40 - bbb that's the right
67:42 - now for this one here
67:45 - even though i'm wired to read it from
67:47 - left to right i need to make sure i
67:49 - enter it from right to left the way that
67:52 - it would look if i had flipped it
67:54 - rotated it so this side were on the top
67:56 - bba
67:58 - and then the last edge is aaa from
68:00 - bottom to top
68:02 - you might be asking yourself isn't there
68:03 - a way to automate this i mean do you
68:05 - really have to enter it in manually one
68:08 - line of code at a time and the truth of
68:10 - the matter is there's probably a way we
68:12 - could look at the color values of the
68:14 - pixels along the edges and generate the
68:17 - sockets based on those color values but
68:19 - that's a project for another time
68:22 - i'm going to stick with doing it
68:23 - manually here let's do the rest of them
68:26 - [Music]
68:35 - sorry one error here with tyler x4
68:37 - that's bcb so now that everything's in
68:40 - here what else needs to change certainly
68:44 - the way i'm checking if two edges are
68:46 - compatible if the sockets fit together
68:48 - that needs to change let's just run the
68:50 - code and see what happens there's bound
68:52 - to be an error somewhere
68:54 - amazingly i'm not getting an error
68:57 - but i'm also getting a pattern that
68:59 - isn't exactly what i'm looking for well
69:02 - now i got an error because it came up
69:04 - against the tile where it couldn't
69:05 - figure out what goes there
69:07 - and here now we're seeing a strange
69:09 - pattern that i don't even recognize but
69:11 - i do kind of love
69:13 - so what i'm doing currently in the code
69:15 - is checking if
69:17 - one side is
69:19 - equal to another side so can bbb go with
69:23 - bbb
69:24 - yes those sockets connect but back to
69:27 - here
69:28 - can abb go with
69:31 - abb no those don't connect
69:34 - but a b b could go with b b a remember
69:38 - this side is really b b a
69:41 - so all i need to do is instead of
69:43 - checking equality i need to check if one
69:46 - edge is equal to the reverse
69:49 - of another edge
69:50 - and i believe that happens in the
69:52 - checkvalid function
69:55 - no this isn't it
69:56 - it's all about how i generate the
69:58 - adjacency rules
70:00 - checkval is just checking to see based
70:02 - on the adjacency rules so i need to
70:04 - regenerate the adjacency rules which is
70:07 - in this analyze function and here i'm
70:10 - checking if tile dot edges ah here's
70:13 - where i'm checking if one edge is equal
70:15 - to another edge
70:16 - so let's write a function
70:18 - compare edge
70:21 - return a is equal to b is there a string
70:24 - function called reverse
70:26 - there's an array function called reverse
70:28 - so i think i need to write my own string
70:30 - function to reverse the string that's
70:31 - not too hard
70:35 - i could make it into an array
70:39 - i think split takes a string and puts it
70:41 - into an array then i can reverse the
70:43 - array and then join it back together i
70:45 - think that'll work and then now i can
70:47 - just say
70:48 - compare
70:49 - tile edges 2
70:51 - with this dot edges 0
70:54 - and that's called compare edge
70:57 - now i want to compare three and one
71:00 - zero and two
71:03 - and one and three
71:05 - all right
71:06 - are we ready is this going to work we're
71:08 - about to find out
71:10 - list list.reverse is not a function oh
71:14 - i've got to give it a empty character
71:16 - from which to split
71:18 - so just like i need to join them with an
71:20 - empty character to put it back into a
71:22 - string i need to
71:23 - split it with that empty character
71:27 - oh no
71:28 - there's a function in p5 called reverse
71:32 - op5 i love you so much you always have
71:35 - these global functions which confuse me
71:38 - so the reverse function in p5 actually
71:40 - does the work of reversing the array but
71:43 - it does say deprecated it will be
71:44 - removed in a future version of p5
71:47 - because there already is an
71:48 - array.reverse function so that all makes
71:50 - sense and everything is right with the
71:51 - world again i just need to call this
71:53 - reverse string which is more clear
71:54 - anyway
71:56 - all right you've waited long enough
71:58 - let's see
72:00 - oh
72:01 - shoot assignment to a constant variable
72:04 - i made it constant
72:06 - let
72:10 - oh look at that
72:11 - oh it's so beautiful
72:14 - no but that's fine that's just the thing
72:16 - where it gets stuck
72:17 - i'm gonna put my random seed back in
72:19 - just to sort of track the error
72:25 - well that one didn't have an error but
72:26 - it is lovely i can't seem to find the
72:28 - random seed that will give me an error
72:33 - aha there we go we got an error so the
72:36 - error happens on line 136
72:39 - so tiles option is undefined
72:43 - let's see what's in up dot options
72:46 - this really slows it down to console.log
72:49 - every like thing that it's looking at
72:51 - but we'll see
72:55 - ah there's a weird clue here the array
72:58 - isn't empty like there's no options left
73:00 - it's got one element but that element is
73:02 - undefined and there's only one place
73:05 - that i put manually one element into the
73:07 - array it's this sort of weird way
73:10 - that over here i pick from its options
73:14 - if there's no options left what i pick
73:16 - will be undefined
73:17 - and then place it in the array so i
73:19 - think i have to say
73:20 - if not any pick
73:23 - what do i do start over
73:25 - let's just say
73:26 - no loop and return see what that gives
73:28 - us
73:30 - so i think there's some optimization and
73:32 - cleanup i could do in the code and
73:34 - ultimately
73:35 - implementing backtracking going back and
73:38 - trying a different solution would make
73:40 - sense here but i'm just going to keep
73:41 - things simple and have it start over
73:44 - i'm going to write a function called
73:46 - start over
73:47 - in setup i create all the tile objects i
73:50 - put them into a big tiles array i
73:53 - analyze all the adjacency rules and then
73:55 - create a new grid i think i could just
73:57 - start over by creating a new grid so
74:00 - we'll call start over also in setup
74:03 - then create the new grid and start over
74:05 - so if we ever get down to a cell with no
74:08 - options we'll start over
74:11 - there we go
74:13 - so let's see how many times i have to
74:14 - run this before it fills
74:24 - i got one but the chat is rightfully
74:27 - pointing out something that i didn't
74:29 - consider
74:30 - which is that if not pick
74:33 - is causing a lot of false positives
74:35 - because one of the options it could
74:37 - legitimately pick is zero so i have to
74:40 - just actually say if pick is not equal
74:43 - to undefined
74:45 - just make sure it's not undefined then
74:47 - you can keep going or if it is undefined
74:50 - sorry if it is undefined
74:52 - you could keep going no if it is
74:54 - undefined start over if it's not
74:56 - undefined keep going i think we finally
74:58 - have it people let's run it one more
75:00 - time
75:01 - yeah now it's getting further along
75:03 - before it will reach that error
75:06 - there now it got the error and now it's
75:08 - going there we go i think this is our
75:10 - second attempt
75:14 - yay and we did it on the second attempt
75:16 - amazing now
75:18 - let's do something really exciting let's
75:20 - get rid of random seed so that it'll do
75:22 - it differently each time we run the
75:24 - canvas is 800 by 800.
75:26 - let's try upping the resolution to 40 by
75:29 - 40. my guess is it's going to run very
75:31 - slow because i haven't bothered to think
75:33 - about are there ways to optimize the
75:34 - performance but let's see what happens
75:38 - [Music]
75:47 - wave function collapse we have it
75:50 - everybody there is so much more to do
75:52 - here first of all i haven't even
75:54 - attempted the overlapping model i'm
75:56 - gonna wait until you're sometime in the
75:59 - future actually watching this this is a
76:01 - video on youtube so i can get a lot of
76:03 - comments and feedback because i'm sure
76:05 - there's lots of things that i've done in
76:06 - sort of strange and odd ways that i
76:08 - might want to think about and address
76:09 - before i move on to the next version of
76:12 - the algorithm which detects the tiles
76:15 - and adjacencies in a way based on doing
76:17 - a pixel analysis that's a little hand
76:19 - wavy but that's the general idea i also
76:22 - have left out a key element of the
76:24 - algorithm which is explained really
76:26 - nicely in this processing forum post
76:29 - from solid
76:30 - the process doesn't stop to the four
76:32 - direct neighbors of the collapsed cell
76:34 - and has to be extended recursively to
76:36 - the neighbors of the neighbors and so on
76:38 - until all constraints are propagated
76:41 - i'm kind of getting it to work anyway
76:43 - because i'm just doing a full pass
76:45 - through everything every time through
76:46 - draw but ultimately i could reduce the
76:50 - entropy by recursively propagating the
76:53 - cells as their options start to collapse
76:56 - now in truth this tile set that i'm
76:59 - using doesn't really need this because a
77:02 - tile when it's collapsed only affects
77:04 - its immediate neighbors and that doesn't
77:05 - really ripple out in the same way that
77:07 - it might in say sudoku but this is
77:10 - definitely something that i would want
77:12 - to add to the algorithm in a future
77:14 - version of this so give me your tips and
77:17 - thoughts about how to do that in the
77:18 - comments of course there's backtracking
77:20 - would love to add that and then but
77:22 - really this is what i'm here for this is
77:24 - why i made this video
77:27 - what possible tiles could you
77:30 - design and what patterns and beauty
77:33 - could you create by just using my code
77:36 - exactly as is not changing anything but
77:39 - just designing your own tiles creating
77:42 - your own key of sockets and just running
77:45 - it and letting the beauty follow i want
77:47 - to see this so badly not to mention this
77:50 - algorithm can be applied in 3d and whoa
77:53 - there are so many amazing
77:54 - implementations of wave function
77:56 - collapse in 3d youtube videos websites
77:59 - i'll try to link a whole bunch of them
78:00 - put them up on the screen oh there's
78:03 - just too many to mention so
78:05 - comment on the video go to the coding
78:07 - train website where there is a place
78:09 - that you can submit your version of this
78:11 - tag me on social media i want to see the
78:13 - world full of beautiful wave function
78:16 - collapse algorithmically generated
78:19 - images and stay tuned for the next
78:21 - coding challenge or sometime in the
78:23 - future when i tackle the overlapping
78:26 - model
78:30 - [Music]

Cleaned transcript:

hello and welcome to today's coding challenge wave function collapse this was originally suggested in 2017 on the coding trains github suggestion box the algorithm itself was originally pioneered by mxgmn on github in this wonderful repository with lots of sample imagery and explanation the core idea of the wave function collapse algorithm is to take an input image and generate an output image many output images that all mimic the style the pattern of that original image now you might be thinking aha don't we have giant deep neural networks that can do this yes but this algorithm is incredible because it uses none of that and it is just a joy to watch i should say if you're here thinking oh goody here comes a stepbystep tutorial on how to implement the wave function collapse algorithm it's probably not what you're going to get i have not done it before other than a brief failed attempt that didn't get very far so i'm here to try it again what you're seeing to the left and right of me is hopefully the end result of this video and if i've gotten there if i've succeeded it hopefully looks interesting and like something you might want to watch so stick with me all aboard let's try to make wave function collapse happen in addition to the github repository which has the source code for the original implementation of the algorithm as well as a full explanation of the algorithm as well as many many many links to forks and spinoffs and variations of it the other resource that i am following closely for this challenge is the wave function collapse post on the processing forum itself uh thank you very much to solab who started this thread tons of great information there i highly recommend you take a look at all the explanations and diagrams and source code as well let's begin by answering the question why is it called wave function collapse well this is an algorithm for procedural generative images which could be applied to art and games and so many different kinds of creative things that you might try the term itself comes from quantum mechanics what does it mean to collapse a wave function to answer this question let's talk about another term entropy i want to talk about entropy in the context of information theory if you're a fan of the game mortal there's a wonderful three blue one brown video that goes through how to optimize your solution for any given wordle of the day with the concepts of entropy and information theory i'm going to attempt to explain it to you in the context of a different game sudoku sudoku is a game where you fill an entire board with the digits one through nine each digit needs to appear uniquely in every row in every column as well as every three by three section this means if i have a blank sudoku board every cell has nine possible digits that could be in it the average entropy of this system we could think of as nine what's exciting about the concept of entropy as applied to games like wordle or sudoku is when we know some additional information like aha we see the board comes with one number already filled in like the number nine here then suddenly the entropy is reduced for these two cells all of these cells all of these cells and all of these cells here right all of those cells only have eight possible numbers that could go in them if i were to say that there's a two here then suddenly all of these cells only have seven possibilities in them and how does this relate back to wave function collapse and quantum mechanics the idea of collapse in the context of entropy is to collapse all the possible states down into one remove all the entropy from a single variable of the system so this cell in sudoku is collapsed to nine this cell is collapsed to two as certain cells collapse and their state is revealed to be a single option the entropy is reduced for its neighbors and we can start to make guesses there and further collapse and further collapse and further collapse until we've solved the sudoku board i'm going to start over with an example sudoku board that i got off the internet the process of solving a sudoku puzzle is exactly the same process that lives inside the wave function collapse algorithm the idea is to start with a set of tiles in this case many of them have been collapsed already and look for the tile with the least entropy meaning the fewest possible numbers that could go in it so i'm going to look at this for a minute here let me use my brain power so i've been going through and noting what numbers are possible in any given tile and as i was working through it i noticed well there has to be an eight down here somewhere and there can't be an eight in either of these two columns because of these two eights there can't be an eight here and there can't be an eight here so the only possible number in this particular cell is an eight so i can collapse it and fill in the eight i'm looking for the tiles with the least amount of entropy collapsing those tiles and then going and looking for the next tile with the least entropy and so on and so forth if at some point i don't have a tile that has only one option left i might just have to make a guess and go with it unless i get it realize i'm stuck and have to backtrack and try a different option now that i've finally solved this sudoku puzzle we can look at a p5 canvas and try to understand how does the process for solving a sudoku puzzle map to the process for generating an image through wave function collapse now there are two ways to approach wave function collapse there's the tile model and the overlapping model i'm going to start with the tile model the idea of the tile model is that you have premade tiles i'm going to first implement a tile model with a simple set of five tiles one will be blank one will have a small line pointing up and a horizontal line across one with a smaller line to the right vertical line smaller line down smaller line to the left my p5 canvas i can think of as a four by four grid that can have any one of these tiles in any spot on the grid so right now the average entropy is uniform across all the tiles there are five possible tiles that could go in any of them maybe i pick this tile then i need to pick one of these random five options let's say i pick one and i fill it in now this is all an arbitrary madeup system that i'm doing right now and trying to keep it somewhat simple the possible tiles for most of these cells is still just five however by placing this tile here i have reduced the entropy for the neighboring tiles the only possible tiles that can go to the right are ones that connect to this line right here that would be tile 4 tile 3 and tile 1. so there are only three possibilities here the only possible tiles that can go here are tiles three two and four i need something to connect to this so three possible tiles and we're gonna see this in all of these so now if i'm looking for the next tile to do i want to pick one that has the least entropy so now i'm only rolling a foursided die to pick one of these four times let's say i pick this one and i roll the dice and i happen to pick tile four now the entropy for this spot is now also only three let's say i roll the dice and i happen to pick this tile let's look at what is the entropy for this particular tile now i need a tile that has connections on both the bottom and the right look at that only this one now so only this tile can go there by the way i made a terrible error i was just starting to fill all these out i kept i was right about there being three possibilities three possibilities three possibilities this one here actually only has two possibilities because if there is no connector pointing down then the only two options that have nothing connecting to the top are three and zero something with a blank top so this actually had a entropy of two so if i wanted to keep going i could flip a coin maybe i come up with three tile three and this goes here let's see what happens if i keep going and voila i generated this image with wave function collapse i could run this again roll the different dice again and get another image and another and another and another it took me quite a long time to work this out with my brain and draw it hopefully if we can write the code to load these tiles to know which tiles go next to which tiles we can generate these images licketysplit i am finally ready to start writing the code all i need is a blank p5 sketch and then i have here premade tiles blank down left right up to start i'll load all the images using preload into an array let's just draw them to make sure they're there whoops i forgot the tiles are in a directory that i called tiles this algorithm even though it feels like my explanation is going around around in circles is quite simple i think the complexity here is figuring out what kinds of data structures do i need to hold on to the information about the grid of tiles as well as which tiles are allowed to neighbor which other tiles let's use an array to store the state of every cell in that grid i want to start with just a four by four grid actually let's be even simpler let's start with just a two by two grid and i'll use this variable dim short for dimensions i'll start with putting in negative one to indicate nothing's been picked yet in every spot on the grid actually no let's not do that let's make an object for every spot of the grid and i'm going to create a variable called collapsed which is false it's not collapsed and then i'll call it options and they each should start with all five options this might be silly but let's set up some like variables to keep track of what these index values are now i can go through every element and draw it if it's been collapsed all right i didn't mean to do that but i just wrote out a ton of code let me walk you through it step by step so first of all i need to calculate the width and height of every cell on the grid that's the total width of the canvas divided by how many columns and how many rows that dimension variable then i'm going to count through every row and every column find the index into that onedimensional grid array this is the same thing i do in all of my videos about the pixel array and then if it's been collapsed there's only one option left so find the correct image and draw it otherwise just draw a black rectangle so if i'm doing my job correctly if i were to refresh the page i should see all black rectangles and let's actually give them a white stroke so we kind of see this grid great no cells have been collapsed let's collapse one of the cells manually just by hard coding it and see if the we get the proper result it's collapsed and we should see the up tile in it options is not defined oh cell dot options and we need to make sure we draw the image the right side there we go so what's next here i manually collapse the cell but what i should have done is looked at all the cells evaluated and measured their entropy and picked one that had the least entropy so let's do that i'm thinking about how to do this oh let me sort the array i mean i can't sort the array it'll be out of order but i could sort a copy of the array because i have objects in it oh this was a good thing that i put objects in there because the arrays just point to the object so i get multiple arrays with the same object the same data in them but in different orders oh this is great and in javascript the slice function will just make a copy of the array then i can call the sort function if i was just sorting an array of words it would be easy to do alphabetical order or ascending or descending order but here i've got to define my own compare function order to say how i'm going to sort them if this strange arrow syntax is unfamiliar to you let me refer you to some video i made 100 years ago about the arrow function but essentially this function is defining given two elements in an array a or b how do i define which one goes before or after the other and the number of options left for that particular cell is what defines which one should go first or second let me just hard code that element two only has two options so when i sort this array i should see that third element in the first spot of the array so let me log the regular grid unsorted and the grid copy sorted and let me just add to the end of draw no loop because i only want to do this once right now oh beautiful the first array is 5525 and then the second one is two five five five wonderful now hmm what if there were two cells that only had two options left the wave function collapse algorithm would say take all of the cells with the same amount of entropy and pick randomly amongst them let's go through the array i'm trying to think how to do this i'm going to create a variable called stop and go through the array until i find one that has more options than the one previously okay let's actually let's say length equal grid copy i'm going to have a baseline length which is the length of that first element of the array i'm going to go through the array if any given element has a length of options and i'm always forgetting this greater than what that first element does break out of the array and save that stop index because then i can say grid copy splice starting at the stop index all the way to the end so how many elements splice removes elements from the array and i want to remove from that element all the way to the end there's got to be a more elegant way of doing this but i'll just say grid copy dot length minus stop index there we go i have now sorted the array according to its the entropy of each cell and i have a new array with just the elements that have the least entropy so now i can pick one randomly so i'm going to pick one randomly from the copy of that array and then i need to collapse that one let's call this cell and then this is the pick is now as is always true on the coding train this could all be refactored in many more elegant ways and i look forward to hearing all about it in the comments about how you're doing it but basically i want to pick the cell collapse it pick from its available options and then i'm just overwriting the array the what should be left over is an array with one thing left in it so if i were to do that i should see either element two or element zero with either blank or up in it that's element zero with up element two with up so running this a bunch of times it works it works we're getting somewhere breaking news the live chat on twitch is telling me that in the splice function if i don't give it a second argument it'll just remove everything until the end boy i spent a lot of time working that out this is much simpler we're not that far away i think from the end here let me get rid of these hardcoded options sketch line 51 oh because the stop index oh my stop index has a flaw in it i will just say if stop index is greater than zero splice it out i removed everything from the array because they were all equivalent okay there we go so now this is its random first pick happening here the next step is to reevaluate all the tiles and reduce their entropy where necessary so for example this tile right here same entropy but the one up top and the one to the right the entropy changes because by picking that tile in the top right it reduces the number of options that go to the left and underneath i need to create a new array which is the sort of next generation of tiles if it's already been collapsed then it's just a copy of what it was before right it can't change it is what it is and i can just bring it over directly otherwise i need to look above look to the right i need to determine what are the valid options based on its neighbor up to the right down and to the left here is where i need yet another data structure i have five tiles what if i had an array where every element of the array stored a list of valid neighbors so what are the valid neighbors for a blank tile oh wait wait wait wait wait wait oh my goodness each element of the array needs to also be an array this should really i could really think of this as a lookup table because i'm using numbers to number the tiles it's really doesn't really matter whether it's an object or an array but you can kind of think of this as a lookup table because the zero blank tile it needs to have things that can connect to it up to the right down or to the left so i'm always going to store the information in this example in a clockwise direction so the tiles that can go next to it pointing up are like a tile that can go above this blank one would be another blank one and then tile one because this does no connection down so zero and one to the right could be a blank one and tile two it's a down could be a blank one and tile three to the left we could put tile four could go there which is or a blank one zero and four so now if i were to look at tile one however and again this is just me coming up with a way of doing this right now there's probably a more standard or optimal way of doing this i'll hopefully address that at some point later in this 700 hour video but here what could go above it for tile number one tiles that could go above it are two three and four but not a blank tile tiles that could go to the right are well another one three or four that could connect below below is blank so it could only be a zero or a three and then to the left what tile can go here two can three can or another one the good news here is i've assigned variable names to each of these tiles so that it'll be easier for me now that i start to write this out in code i don't have to remember the indices i could just think if it's a blank one the things that could go above it are an up or another blank to the right a right or another blank let's start putting that in the code so let me create a variable i don't call it rules let's call it rules let's make it an object now what can go next to a blank tile above it we said could go a tile pointing up or another blank to the right a tile pointing to the right or another blank a tile pointing up above it a tile that goes to the right the left or down is fine let me see if i can just quickly put in the rest of these all right i fit all of the rules here i believe this is correct i'm going to think about this for a bit and check the chat to see if i mess something up all right here's one that i found is wrong for the tile pointing up below it is either blank or down and then to the left is right up or down let me address something i think i've made this a little bit more complicated than it needs to be for this particular scenario maybe the way i'm doing my data structure is good for all broad set of possible tile arrangements but in this case even though i do have five tiles each with four neighbors each side is only one of two possibilities so really i could say this blank tile can only connect to other tiles that have a blank represented by a zero on any side of it this tile that is pointing up i could say connect to any tile that has a connector a one or that is blank or zero so really for each of these i only need to store four numbers and then zeros need to connect with zeros and ones need to connect with ones i'm not gonna double back and redo mine this way yes i will i'm just going to categorize the edges as a or b or zero or one but this is a good exercise for the viewer looking at it in this simpler way about the kinds of connections that exist so now we need to build what are the remaining options left i need to build up what things i could be by looking at my neighbor and only if j is greater than zero so i'm going to look at the tile above me only if i'm not in the first row now of course i think if you look at the wave function collapse in the original implementation it does wrap around and uh that could be done here but let's simplify things by just not looking at the neighbors above do i start with all the possibilities and then remove them if they don't exist yeah that would be a way of doing it so i'm starting with a baseline of this tile could be anything and this should actually be outside of here because i'm going to do this for all of them now i'm looking at the neighbor above and looking at what possible tiles it could be then valid tiles i could be are from the rules this is the list of valid tiles i'm this tile and i'm looking at the tile above me and maybe the a tile above me only can be like left or right so i need the valid tiles that go below down to a left tile and i need the valid tiles that go below are down to the right tile in the original array up right down left the order is zero one two three so i'm looking for two the rules for that particular tile the ones that are valid down i think i need to rethink my naming but now what i want to do is look at what i have in my range of possible options i'm going to remove them if they're not valid you know what i should do i'm going to make a function we're going to do this so many times check valid options valid so i'm going to pass in these are the existing options and i'm going to pass them into a function to check if any of those options are included as valid so somewhere else in my code right here the this is the array and these are the valid options is that the order i put them in the array is options and what's valid if valid includes array index i great so i want to check or i'll say not if the option that is in that array is not something valid then i should remove it it's confusing what are in these things but let's just remember maybe a valid is blank and right basically what i'm doing is i'm going through every element of this array blank up right down left let me see is it in the valid options oh if it is that's good don't do anything if when i get to up it's not valid let me remove it out of there this would result so hopefully that helps you make sense of it i don't love maybe i should i'll just say like current equals array index i maybe just element so this helps maybe helps you read it a little bit let's look at every element in the array if it's included if it's not invalid get rid of it so now i think i can just do the same thing for all of these looking to the right make sure that i is less than dimension minus one if i'm looking to the right i want to know what's valid to the left of that one which would be up right down left zero one two three let's grab this one for looking down i probably should have checked this with just one of the rules first but i'm just going to put it all out and we'll find out if i've gotten this totally wrong or not i think this is good if it's collapsed i don't need to do any analysis it's done it's picked if it's not start with all possibilities look up to the right look down to the left check that options array and then at the end next tiles index options okay are these new options it's still not collapsed i don't know if i need that or if that's redundant but this is me updating that and then after all of this is done hiles becomes the next tiles and so this can't be a const oh my goodness boy did i just write a lot of code without testing anything let's run this okay write dot options is not iterable iterable oh grid not tiles grid oh my god i was using the images i have an array called tiles which is just the images the array that i'm working with is called grid oh great let's call this next so this can be a const and this has to not be a const all right that's fine still have an error but something slightly better 147. so i just want to look at the rules for a second here there's a flaw the rules is an object so if i were to say rules blank why is that undefined well rules dot blank works i guess i should just make that an array i'm not sure what the best practice is here but if i were to do this this should fix the issue i'm just gonna make this an array since i have everything ordered numerically i don't love this but i think it should be okay oh but now i don't need this i don't need these it's just gonna i just have to have it in the right order well i liked it better when i was referencing it with a name i can't do everything right in this first attempt okay got we got down to 163. we got through all of these next grid index oh next grid doesn't exist so i just need to make it a new object i actually need to create the object it's going to not be collapsed it can be collapsed if there's only one left but that'll happen by virtue of the next round and then give it the options okay no errors amazing i'm just gonna take out these console logs famous last words and let me now add if i click the mouse let me redraw run through draw again so it picked that tile okay sketch.jsjs okay so i got an error the next time through ah this is grid index i forgot it up there so if it's collapsed don't get the image get the other thing there's a flaw in my algorithm let's just look at the grid oh you know i could do i can do console table so console table is a nice thing to just show me the array this is the array none of them are collapsed and they all are five possibilities now when i click it i should see the first one is collapsed and then none of the other ones but what happened in grid copy oh but they still all have five possibilities which is absolutely wrong so there's a big flaw in my algorithm for reducing the possibilities oh by the way when i copy the array i need to filter out any elements that are collapsed filter is a higher order array function that will keep the elements where the function evaluates to true so that should and then so this can't be a const i guess i could make another copy let's look at the grid copy also so now i have all four with five options and now i only have three i got rid of the collapsed ones one which is good but they all seem to have five options still let me look at my check valid function i wonder if this includes is not right this is a list of what's in the array these are the valid ones and so this should be left without a 0 and a 2. oh why do i put those brackets there it's a function that i'm checking if it includes that element these are parentheses not brackets i don't think it worked still oh this needs to be a one splice i took zero zero would take nothing out of the array wait why do i have nothing in the array now oh my goodness ah i need to accumulate all the valid things all together i can't do them individually oh this is totally wrong this is a blank array and then valid options should be itself concatenated with these are the things that are valid put them in the valid options these are the things that are valid put them in the valid options these are the things that are valid put them in the valid options these are the things that are valid put them in the valid options and then check valid options valid options so i've accumulated all of the valid options and then as long as my option is valid across them all then it should be fine is this right i was so confident a second ago no it's giving me all the possibilities wait i was so close for a second there oh no no i still want to check valid individually in each one i want to concatenate all the i was right i was right i just i did it across everything but i need to concatenate for each individual possibility hold on hold on hold on i'm gonna double back explain this there you go that's the correct answer there you go weight function collapse okay hold on like it appeared in my head and i don't know if it appeared in your head also while watching this so let me see if i can go back and explain that this is me i am the tile that's what it's become let's say the tile above me can only possibly be left or right for whatever reason it only has two possibilities so what i need to do is look at all of the valid things that can be below a left tile and a right tile concatenate those together and then as long as anything i can be is included it's fine i think we've all suffered enough that i can change the dimensions to like i don't know let's just try eight well look at that would you look at that that is just absolutely lovely i'm clicking there's no need for me to click i can get rid of no loop and let's let's really go for it people let's make the canvas 800 by 800 and the dimensions i don't know 80 by 80 20 by 20. i've never been so happy to see a result it broke so i have a feeling that i'm gonna need to add some backtracking to this when in doubt take out random seed and run it again so close to making it to the end okay so it can get to the end oh my god i have more to add to this i thought i was done if grid copy dot length equals zero return oh no oh let me put the drawing separately let me draw everything and then if there's nothing left if everything's been collapsed return there we go let's run it again isn't this delightful four days later i'm back a few days later and i know you've been watching what is already like a very long video about wave function collapse and i did get to a point where i made something which is pretty great i'm looking at this example of this printed circuit board seeing that there are 14 tiles there some of those tiles represent four possible rotations looking at the way that i've implemented this code with an element of an array for every tile with all of the possible adjacencies i think it would be incredibly difficult for me to hard code all of the possible tiles and adjacencies for more sophisticated pattern like this so i'd like to keep going and instead of thinking of the tiles that i started with as five possibilities i'm gonna start with just two possibilities and rather than enumerate what's possible here i'm just going to categorize the edges as a or b or zero or one what this means is when i'm going to place another tile next to another one a zero has to match with a zero a one has to match with a one and i could automate the rotation of this tile into its other possibilities and then enumerate all of the adjacency rules with code and i think if i create a tile class that keeps track of what image is it and what are its edges still going in the same order top right bottom left that this will make the code more readable and easier to figure out and work and make for more fun wave function collapsing of everything i think my brain is collapsing so let me start by making the tile class i had used the tiles array to load the images so now i'm going to actually have an array called tile images now that i've done that i only need to load the blank and up tile the first tile can be the blank one with those edges the second one would be the up tile with those edges now what if i allow myself to create new tiles based on previous ones what if there were a function that returned a new tile which is one rotation two rotations or three rotations of another tile the rotate function needs to do two things rotate the image and rotate the edges so i make a blank canvas with the same width and height of the image set the image mode to center rotate by half of pi or 90 degrees times the number of rotations so one would just be one rotation let me store the width and height in separate variables which i think will make our lives a little bit better today i'm going to call this variable new image because i'm getting confused between this dot image which is that tiles image and a new image i have the new image technically it's not a p5 image it's just a p5 graphics object but those two things are going to function the same way so i think it's fine now i need to rotate the edges so each new edge is the previous edge plus the number of rotations or minus is it minus this edge was previously down here and the index values go zero one two three so the new edge is the previous edge minus one however if i'm edge zero minus one isn't negative one it's three it's gotta wrap around and get index three a way i can do that is let's create a variable to store the number of edges i can add that to the total so zero minus one is negative one plus the total number edges of four would be index three but if i'm two two minus one is one plus the total number of edges is four so i'd get five ah so all i then need to do is use the modulo operator and this should give me perfect wrap around always take the previous one but if the previous one is negative you're going to get the higher value and it's not one it's the number of rotations so now i can return a new tile with the new image and the new edges so before i go any further i just want to determine if this at least worked rotating these images the difference now is the image is a property of that tile object something is wrong my rotation is not working so i've made a sort of classic error in p5 here where i didn't think about the origin around which i was rotating so i've rotated the image off the canvas that i'm drawing it to i need to say new image translate to the center then do the rotation then draw the image at zero zero so if you zoom in you'll see that the tiling is a little bit of skew that's really just because when i made the images i didn't make them perfectly symmetrical so the rotation isn't perfect but i kind of actually like the way that it looks with it slightly askew but this is not relevant to the algorithm it's just a matter of designing the tile images and ultimately i'm going to use the tile images from here to see if i can create a more sophisticated pattern so now instead of having this big array that's just a mess of all these rules could i procedurally generate the rules by analyzing the tile objects that i'm creating and as long as i'm doing that why not put in the tile object itself lists of valid neighbors this is terrifying but i'm just going to delete all of this from the code now that i have tile objects looking down here would make sense for me to have a cell object i mean i have cell objects they've got a list of options as well as whether they're collapsed or not but i should make a class with a constructor to generate these these names are no longer relevant the list of options can just be the index values to the tiles array so what i want to pass in is the total amount of tiles there actually are then i can fill the array with if there are five options zero one two three four of course that could be done with some higher order functions like fill and map and from and have a ball doing that i actually just spent a little while doing it myself and it was very confusing and i didn't want to include it in this video but here's what it looks like loaded and created the tiles i built a cell for every spot on the grid and now i need to generate the adjacency rules based on the edges for every tile i'm gonna just write a function called analyze and give it all the tiles all the other tiles so the tile objects gonna have to figure this out let's call this the connection is edges index zero now if we look at all the tiles i mean we should check if a tile can connect to itself that is a valid thing to check so i'm looking at all the tiles regardless so if my connection up is a certain value i need to find all of the tiles that have that same connection pointing down which is index two and i'm sure there's a way that i could not do these as four different loops but i'm gonna do it that way right now and maybe this secondary variable is kind of unnecessary and this is tiled index i and this might actually be easier to read i don't the order of the tiles doesn't actually matter so let tile of tiles so if that particular tile down edge matches the tile that i am my edge which is this dot edges then it's a valid connection so now i just need to repeat this for right down and left oh and i don't need to do a separate loop it can all be in here so right is three is equal to one down is zero is equal to two and left is checking if this tile's edge at three is connected to the tile that it's looking at its edge at one now again there's probably a lot of redundancy here but this is just the way that i'm getting started here trying to recreate what i did originally in a bit more of a generic scalable fashion i think this order makes more sense we're loading the images rotating the ones we need to rotate and defining what all the edges are then we're analyzing all the tiles against each other to see what which tiles can go next to each other then we make a grid full of empty cells each cell could be any given tile to start so drawing doesn't change this however is the part that needs to change before i was looking at my rules array now i need to look at the adjacencies that are defined in the tile objects themselves so up looking at the cell up valid options starts as a blank array then i'll need to look at what are the possible options in up and then get the valid ones now are not rules but tiles dot down anything that i could place where i am has to be something that can be below all of the things that could be next to the tile above me is that the only thing i'm changing look at the tiles and look to the left then look to the tiles up no way it's as simple as that okay cell is not defined okay well that's an error i can fix include the cell file blank is not defined where did i have blank let me by the way change the dimensions to just four by four while we're sort of figuring this out ah so the options are when i'm assuming it could be anything let's use the fancy higher order array functionality thing here i need an array with the number of spots in it as the number of tiles there are i need to fill it with something to start so i'll just dip zero and then i can use the map function to map every value to its index so that's its current value which is zero its index is i if i've done my higher order array functions correctly it's an array that has with five tiles has the values zero one two three and four in them okay cannot read properties of undefined reading up well we can start 137 tiles option up what is going on here hi everybody i've been debugging this for a little bit and part of my debugging i said console logs a grid and i'm looking at the grid and the first time i get four cells because i made it two by two only one option left because that one's collapsed five five five and then suddenly look at this cell then rackety brickety brackety brackety those aren't cell objects because i did something really pretty terrible at the end instead of creating the new cell object for the next generation i'm just making an object literal which is not right so i need to say new sell and the options shouldn't this is when a new cell is made how about i could give it options i'm trying to think of an elegant way to design the constructor now so i just did a little testing in the console here that i could determine if a variable is an array by saying instance of array and i'll get true so i think what i can do here in this cell class is i can say if num is an instance of an array then this dot options equals that array it's no longer num it's the array i mean i don't know what to call that variable i'll still call it a num otherwise i'm filling an array with all of the options according to some total so let's just call this value to be a little bit more generic so these are the two different ways i can create a cell object and if i go back to sketch.js i should be able to say make a new cell out of those options oh that's better i see four cells and four cells i still got this error though something is going very haywire here i'm gonna have to do some more debugging oh please hold if tile zero is collapsed i should see one option there tile one should have three possibilities tile two should have two and not be collapsed and tile three should have all five possibilities still so cell number one which is the one directly to the right of the top left should have three options left and it has zero so the bug is there and cell number one is when i is one and j is zero so i have an index so i can debug some things if index is one let's check looking to the left so if index equals one let me look at the tile to the left the tile to the left is collapsed and it is tile index one so it's valid options should be all of the things that can go to the right of tile index one ah the error is not a logic one it is an apples checking against oranges problem the valid tiles are tile objects but my function that i wrote days ago at this point now in the check valid is checking index values against each other so if i go back to this analyze function i shouldn't be putting the actual tile objects in the arrays that are valid up right down and left i should be putting the index of that tile so i do need to have this a for loop with i in it because the index of the tile is what is indicating what's valid we did it people wait let's get rid of some of the debugging let me go back and make it 20 by 20. wave function collapse exactly what i had before but now and again again it's not always going to find a solution and i got to talk about how to deal with that but now i don't have to create a massive map of all of the tiles and their adjacencies all i need to do is load tile images and some numeric indicator for what's a valid connection of an edge then i can rotate tiles and infer all of the adjacencies this means i believe i can get this pcb generator going thank you to those who are watching live who sent me fixed tiles and the circuit board tiles i'm going to download those now and see if i can bring them into my sketch so i have the circuit tiles and i have my code i think i'm going to need to kind of draw my own version of these tiles on the whiteboard to enumerate all of the edges so there's a blank gray and a blank green tile let's start with those that's tile zero that's this is zero dot png these numbers by the way aren't really relevant although they will be because they'll be the indices into the tiles array i guess and one dot png so the blank one will have zeros as its connectors edges and the blank green i'm just going to say this is blank and this one is green it'll have ones okay what is two dot png kind of looks like this all this area is green so that's a one a one a one and now we need another thing this is a two and this is like gray so green is one and this is something new it doesn't match this because this is green three three one so i've worked all this out and there's only actually a few different kinds of sides there's a blank side zero a full green side one a light green connector which is two a light gray connector which is three that's what all of these are except for four dot png and five dot png these are not symmetrical meaning if i flip them i have a different tile which is different than how i'm rotating things so i think i need a whole other mechanism for tracking how these connect so for right now in this process of working this through i'm gonna do this without using these tiles so i have 13 tiles ordinarily i would just write a loop now to load them into the array based on their the number of the file but since i want to skip to i'm going to do it manually okay so you can see i'm loading them into an array of 11 tile images skipping 4 and five now i put in the connections zeros all zeros all ones one two one one one three one three i really want to try this without rotating any of them and see what happens images are in a directory called circuit oh oh i've never seen anything so beautiful in my life that's amazing that's promising so now i just need to do some rotations now looking at these images they don't all need to be rotated four times but i might as well because then i don't have to think about it so let index equals 11 i'm gonna skip obviously zero and one i'm gonna go through all of the tiles one through ten oh i'm not i shouldn't be in preload what am i doing i'm gonna go from 2 all the way to 10 and i'm going to say tiles.push tiles index i rotate 1 1 2 3 so less than 4. so that should go skipping the first two tiles which don't need to be rotated now there's a lot of extra rotations i don't think i need but starting with tile two going all the way down to tile 10 rotating them once twice and thrice oh i don't need this index because i can just push them into the array wow this is wild i guess the blank tile never shows up tile zero it only can connect to tile four let's i i'm so close i think i could get image four and image five in there no i can't one day later welcome to day three this time i'm finally going to complete the wave function collapse algorithm first i need to say a huge thank you to telemacho and garageball who overnight while i was sleeping added some github issues on the wavefunction collapse repository pointing to the keys to unlocking the asymmetrical tiles and placing them correctly that i was struggling with yesterday an incredible demonstration of the solution i'm about to attempt is oscar stahlberg's unity implementation of wave function collapse in it you can interactively start to select tiles and it will visually show to you which tiles are left you can also let it run and watch the process as it selects the tiles and the magic of wave function collapse unfolds over the screen the beautifully designed tiles of this demonstration are not symmetrical along the edges but each edge can be divided into three parts the left part the right part and the middle part and as long as brown matches with brown blue matches with blue half brown half light brown matches with half light brown half dark brown the process will work thanks to the magic of these colorful markers i have redrawn all of these tiles so i think i can make a key to enumerate all of the possible parts with each edge divided into three that could be on any tile symmetrical or not so this first tile which is all black is fully symmetrical along all the edges in all rotations and i think because i've numbered all the tiles it might be easier for me to use letters here so that we can really distinguish what's being matched with what so i'm going to call the black color a white which really is a dark green in the actual tiles i will call b now this side will be a a a a a a one color all around all the parts of the edges same for this but with b finally now with the image number two we will get something a little bit more interesting we've got b's all around these sides those are some very funny b's and then i've got a b here and a b here but now i need a third color for light green we'll call that c the blue color here is actually gray in the image files a new color we'll give that the letter d so now i have b b b b d b and so on and so forth now we've got something pretty interesting the asymmetrical tiles but this system makes them really easy to notate and i can go on and complete the rest how did i do i think i've got this right one mistake thank you live chat so now back to the code first thing i can turn this into a loop which is going to make all of our lives so much better don't you just feel so much more at ease and relaxed tile images ah no no i'm not relaxed at all in fact i'm totally panicking that would have been very unfortunate to find later but now nonetheless these tile objects still have to be created individually because i'm going to manually notate all of the letters for the edges and by the way there's a key term that i should be using when talking about all of these edges and that is the term socket you can think of each section of an edge as a socket each socket must connect to another socket of the same type for them to match up and by the way i encourage you to try having more than three sockets or fewer than three sockets so many possible things you could do if you we could get this working the one thing that's going to be really confusing is what is the order by which i write the letters for the sockets this side socket is bbb well this side socket is also bbb and i don't have to worry about what order because they're symmetrical but this one i really have to think about this side socket is a b b does it connect to itself well you might think it does right because what it wants to connect to is something that looks like this a matches up with a b matches up with b b matches up with b but if i took this side and put it here i would have to do that by rotating this all the way around and suddenly this side rotated around would look like this these don't match but this side if i were to take this side and bring it up here it would match but this says abb these are not the same while this one says abb and this one says abb those aren't the same orientation i need to make sure i'm notating everything in the same order which means in the clockwise order it's the way i've been thinking about this project all along up right down left up right down left so even though i most definitely want to draw it this way because it'll be way too confusing for me to write bba and not see that match up when i put it in the code i need to notate the sockets as abb bcb bba aaa then edges need to match up with other edges that are inverted so they lock together and i also should note that another way to approach this order would be north east south west which i could have been doing all along but somehow my brain is going up right down left so now as i prepare to enter the edges into the code looking right at the whiteboard for tile zero this is easy it's just going to be aaa in all four spots tile one all b's now with tile index two i've got the top as bbb but i need to make sure i read b c b in this order and b b b in this order oh but these sides are symmetrical so again it's only gonna matter when i get to four and five and here i am at index four abb that's the top bbb that's the right now for this one here even though i'm wired to read it from left to right i need to make sure i enter it from right to left the way that it would look if i had flipped it rotated it so this side were on the top bba and then the last edge is aaa from bottom to top you might be asking yourself isn't there a way to automate this i mean do you really have to enter it in manually one line of code at a time and the truth of the matter is there's probably a way we could look at the color values of the pixels along the edges and generate the sockets based on those color values but that's a project for another time i'm going to stick with doing it manually here let's do the rest of them sorry one error here with tyler x4 that's bcb so now that everything's in here what else needs to change certainly the way i'm checking if two edges are compatible if the sockets fit together that needs to change let's just run the code and see what happens there's bound to be an error somewhere amazingly i'm not getting an error but i'm also getting a pattern that isn't exactly what i'm looking for well now i got an error because it came up against the tile where it couldn't figure out what goes there and here now we're seeing a strange pattern that i don't even recognize but i do kind of love so what i'm doing currently in the code is checking if one side is equal to another side so can bbb go with bbb yes those sockets connect but back to here can abb go with abb no those don't connect but a b b could go with b b a remember this side is really b b a so all i need to do is instead of checking equality i need to check if one edge is equal to the reverse of another edge and i believe that happens in the checkvalid function no this isn't it it's all about how i generate the adjacency rules checkval is just checking to see based on the adjacency rules so i need to regenerate the adjacency rules which is in this analyze function and here i'm checking if tile dot edges ah here's where i'm checking if one edge is equal to another edge so let's write a function compare edge return a is equal to b is there a string function called reverse there's an array function called reverse so i think i need to write my own string function to reverse the string that's not too hard i could make it into an array i think split takes a string and puts it into an array then i can reverse the array and then join it back together i think that'll work and then now i can just say compare tile edges 2 with this dot edges 0 and that's called compare edge now i want to compare three and one zero and two and one and three all right are we ready is this going to work we're about to find out list list.reverse is not a function oh i've got to give it a empty character from which to split so just like i need to join them with an empty character to put it back into a string i need to split it with that empty character oh no there's a function in p5 called reverse op5 i love you so much you always have these global functions which confuse me so the reverse function in p5 actually does the work of reversing the array but it does say deprecated it will be removed in a future version of p5 because there already is an array.reverse function so that all makes sense and everything is right with the world again i just need to call this reverse string which is more clear anyway all right you've waited long enough let's see oh shoot assignment to a constant variable i made it constant let oh look at that oh it's so beautiful no but that's fine that's just the thing where it gets stuck i'm gonna put my random seed back in just to sort of track the error well that one didn't have an error but it is lovely i can't seem to find the random seed that will give me an error aha there we go we got an error so the error happens on line 136 so tiles option is undefined let's see what's in up dot options this really slows it down to console.log every like thing that it's looking at but we'll see ah there's a weird clue here the array isn't empty like there's no options left it's got one element but that element is undefined and there's only one place that i put manually one element into the array it's this sort of weird way that over here i pick from its options if there's no options left what i pick will be undefined and then place it in the array so i think i have to say if not any pick what do i do start over let's just say no loop and return see what that gives us so i think there's some optimization and cleanup i could do in the code and ultimately implementing backtracking going back and trying a different solution would make sense here but i'm just going to keep things simple and have it start over i'm going to write a function called start over in setup i create all the tile objects i put them into a big tiles array i analyze all the adjacency rules and then create a new grid i think i could just start over by creating a new grid so we'll call start over also in setup then create the new grid and start over so if we ever get down to a cell with no options we'll start over there we go so let's see how many times i have to run this before it fills i got one but the chat is rightfully pointing out something that i didn't consider which is that if not pick is causing a lot of false positives because one of the options it could legitimately pick is zero so i have to just actually say if pick is not equal to undefined just make sure it's not undefined then you can keep going or if it is undefined sorry if it is undefined you could keep going no if it is undefined start over if it's not undefined keep going i think we finally have it people let's run it one more time yeah now it's getting further along before it will reach that error there now it got the error and now it's going there we go i think this is our second attempt yay and we did it on the second attempt amazing now let's do something really exciting let's get rid of random seed so that it'll do it differently each time we run the canvas is 800 by 800. let's try upping the resolution to 40 by 40. my guess is it's going to run very slow because i haven't bothered to think about are there ways to optimize the performance but let's see what happens wave function collapse we have it everybody there is so much more to do here first of all i haven't even attempted the overlapping model i'm gonna wait until you're sometime in the future actually watching this this is a video on youtube so i can get a lot of comments and feedback because i'm sure there's lots of things that i've done in sort of strange and odd ways that i might want to think about and address before i move on to the next version of the algorithm which detects the tiles and adjacencies in a way based on doing a pixel analysis that's a little hand wavy but that's the general idea i also have left out a key element of the algorithm which is explained really nicely in this processing forum post from solid the process doesn't stop to the four direct neighbors of the collapsed cell and has to be extended recursively to the neighbors of the neighbors and so on until all constraints are propagated i'm kind of getting it to work anyway because i'm just doing a full pass through everything every time through draw but ultimately i could reduce the entropy by recursively propagating the cells as their options start to collapse now in truth this tile set that i'm using doesn't really need this because a tile when it's collapsed only affects its immediate neighbors and that doesn't really ripple out in the same way that it might in say sudoku but this is definitely something that i would want to add to the algorithm in a future version of this so give me your tips and thoughts about how to do that in the comments of course there's backtracking would love to add that and then but really this is what i'm here for this is why i made this video what possible tiles could you design and what patterns and beauty could you create by just using my code exactly as is not changing anything but just designing your own tiles creating your own key of sockets and just running it and letting the beauty follow i want to see this so badly not to mention this algorithm can be applied in 3d and whoa there are so many amazing implementations of wave function collapse in 3d youtube videos websites i'll try to link a whole bunch of them put them up on the screen oh there's just too many to mention so comment on the video go to the coding train website where there is a place that you can submit your version of this tag me on social media i want to see the world full of beautiful wave function collapse algorithmically generated images and stay tuned for the next coding challenge or sometime in the future when i tackle the overlapping model
