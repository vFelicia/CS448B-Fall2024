With timestamps:

00:00 - Hi, okay, this, this is the video. This is the one that...
00:05 - I don't know. Maybe you've been waiting for. Maybe not.
00:08 - This is the video where I want to talk about pixels. Pixels. The pixels. The pixels themselves. So let's think about this in
00:14 - context for a second.
00:15 - Something that we do a lot in our lives.
00:19 - This is the lives that we're stuck living. Is we draw lines to the screen. We say something like line, you know...
00:27 - 100, 50, 300, 250. Processing says: "AH!
00:33 - You have said that I should draw a line I see the coordinates you want
00:37 - me to draw the line to. I am gonna
00:38 - start here and I end over here and I draw a line there. The line appears on the screen but what's really going on here?
00:44 - The existence of this line didn't happen by magic. The line, the line is not something inherent to a
00:51 - computer or screen. There is an algorithm.
00:54 - Processing has an algorithm when it gets a two points it knows how to
00:59 - fill in all of the pixels between those two points to create the illusion of that line on the screen.
01:05 - I don't know if it's really a line or not but that's that's a
01:09 - metaphysical question. We don't have to answer
01:12 - This is something. This exists because
01:14 - we need to do this stuff all the time in order to draw lines and circles, rectangles and triangles and put images all the time.
01:19 - We don't want to have to figure out which pixels we need to set, which colors... Every single time
01:24 - we want to draw a shape. That's what these functions are doing for us. However there comes a time in our lives.
01:30 - When we might want to do that. We might want to say I don't.... These
01:35 - functions are not good enough for me. They... I have this idea for this kind of shape that doesn't exist
01:39 - anywhere in the world and I need to set all the pixels individually or another... Another scenario might be I took a picture.
01:46 - A picture's too dark. I wanna make it brighter. I open Photoshop and make it brighter. I save it.
01:51 - That's what Photoshop is for. It's for, you know, image Processing. Making, changing brightness...
01:56 - Contrast. Also color all sorts of things you can do to an image.
01:59 - But if there is something you want to do to an image that isn't available as part of the tools of
02:05 - Photoshop, you need to invent your own image Processing algorithm. The way to do that would be by
02:11 - reading the pixels and setting the pixels of an image one by one at a time with your own algorithm. With your own
02:17 - piece of software. This is what I want to examine how to do. In this
02:21 - video. And the next one and the next one. And I don't know if there's another one after that. In a few videos I want to look
02:26 - at what, what happens when you
02:29 - can, you know, actually just Individually set every pixel on the screen. What, what... there's nothing you couldn't draw in theory,
02:36 - if you have access to every single pixel on the screen. So that's what I want to look at. Now...
02:41 - There's a kind of quick and dirty way to do this in Processing. There are two functions get() and...
02:48 - set()
02:50 - and get() will retrieve...
02:52 - the color of a particular pixel. I want the color at this xy coordinate and I want to store that in a variable.
02:59 - Set() will set a particular pixel to a certain color. Now, these functions are useful and maybe actually lets
03:05 - demonstrate set() really quickly although in the end we're going to see is these aren't very efficient and when
03:10 - we want to actually do something to all of the pixels... 
03:14 - then we want to look at the pixel array itself. These are kind of
03:17 - helper functions for, you know, just the moment you know... Here's a scenario where you can... and I'll give this as an exercise where you might use get().
03:25 - This is kind of off a little tangent here but it's worth it for a second. Let's say you are working on a program...
03:32 - Where you have a map of the United States I wish I could think of a different country but
03:36 - I'm just gonna use the United States right now and
03:38 - I'm
03:40 - incapable of drawing. That's like the worst drawing of the United States ever but you know the states are all these misshapen strange-looking
03:47 - things. It's going to be how
03:48 - do you know when the user has clicked on a certain state? Which state that user has clicked
03:53 - on. What if you had a map of the United States where each state was colored with a
03:57 - highly specific color? If you just looked at the pixel underneath the mouse coordinates to see what color that
04:03 - was you could then know which state the user clicked on. So anyway this is a kind of cockamamie scenario that
04:09 - we're not looking at right now, but would be a great topic for a video but this is why you might want to just retrieve a
04:16 - single color of a single pixel.
04:18 - Let's go back and let's look at set for a second. So if I come over here and I have a
04:25 - Processing sketch already kind of going here here's a blank screen and...
04:31 - And what I want to do is I want to say, let me set the pixel 300, 200 to the color red.
04:40 - Let me run this and somewhere in there... Can we find it? Is there a...
04:48 - Pause for my... pause this video
04:51 - Okay, I'm back, I found the pixel. So, we can see right there that little pixel is red.
04:57 - We've set that one individual pixel red. So, you know, there's no reason why I couldn't do something like...
05:02 - I don't know, for int x equals 0; x is less than width; x plus plus.
05:09 - set x, 200 to red. Look I now have a line of all those pixels going right across the screen. So we can see
05:17 - how there's a function in Processing set() which says for this particular x for this particular y,
05:23 - stick this particular color in that location and this will actually work, and we could start to build this example out more and more but...
05:32 - set(), the a...
05:34 - There's a detail about set() which I will explain in a moment
05:38 - and we'll come back full circle, which makes calling the set() function very very very slow. So what
05:43 - we want to do is do this same exact idea, which is a bit simpler, albeit to see with the set() function
05:49 - using the Pixel Array. And what do I mean by the Pixel Array. So let's come back over here. So...
05:54 - Secretly and not really so secretly but Processing and...
05:57 - Is keeping track of for you, all the pixels in your window or as
06:02 - we're going to see in a moment all of the pixels in a PImage.
06:05 - It's keeping track of it in a data structure. That data structure is an array. 
06:14 - Just Processing has built in variables. A built-in variable that you were probably quite familiar with
06:18 - is mouseX. Whenever I say mouseX
06:20 - I get the x coordinate of the mouse. I don't have to declare it. It's just there. It's a variable I get it for free. 
06:26 - There's another variable I get for free.
06:28 - pixels
06:30 - Whenever I say pixels that
06:32 - variable holds all of the pixels, all of the colors on the screen but what is this data structure? I mean the window itself...
06:40 - You can think of as a grid.
06:43 - Right.. If we were zoomed way in every single pixel is a square...
06:48 - Rectangle. I don't  know. You decide. Uh-huh and each each one of them has a number.
06:54 - 0 1 2 3 4 5 6 7 8 9 10 11 12
07:01 - Etc, etc, etc. Each one of these is in an array. 
07:06 - The pixels are actually an array of integers or you can think of them as an array of colors.
07:12 - Intege... A color, the color data type is really just an integer. The integer that has the red, green and blue component.
07:18 - This pixel array is one long array
07:22 - of pixels.
07:25 - So if I wanted to set
07:27 - pixel number nine. I could say pixels
07:33 - index [9] equals color 255, 0, 0.
07:39 - This is just like the set function only I'm
07:43 - accessing the array and a particular index in the array which is a
07:48 - particular...
07:49 - sorry. A....
07:51 - particular pixel number nine referring to a particular pixel that happens to be on the screen. Blah, okay!
07:56 - Let's go back and see if we can implement that here.
08:00 - Oh i'm here. I'm here. Okay so let's comment this out and let's say, right, there's some pixel, right, pixels index 9.
08:08 - Equals color 255, 0, 0.
08:11 - This should work right? There's no reason why this is going to fail. Let's run this and look I got an error.
08:16 - What error did I get? NullPointerException. Null Pointer Exception. The Pixels were nulled. There are no pixels.
08:24 - So what's going on here? So something that set()
08:27 - did for us
08:28 - Is set()
08:29 - warned Processing in advance, by the way, I'm about to start looking at the pixels and this is something that you just have to do.
08:36 - Before you access that pixel array you've got to give Processing a warning that you're planning to do that so that it's not just sitting there empty.
08:42 - Processing is going to load those pixels into memory and give you access to them. And the way that
08:47 - we do that is by saying loadPixels(). So anytime we do an operation with pixels we need to first call loadPixels().
08:54 - By the way right now I'm speaking about pixels in this sort of general way.
08:59 - Pixels being...
09:00 - The pixels of the display window but soon
09:03 - we're going to start seeing things like image dot pixels or image dot loadPixels. So right now we're talking in generic terms
09:10 - about manipulating the pixels of the display window but later as
09:13 - we're going to see it's perhaps a bit more flexible and sometimes more powerful to work with
09:18 - PImages and manipulate those pixels which you then draw to the screen. So we'll see that in a little bit. So now that I've
09:24 - done this... This works. I actually, if we search I'm pretty sure we would not be able to find your red pixel because another thing you need
09:31 - to do; I don't see it in there. Another thing you need to do is after you're done with the pixels need to tell Processing:
09:36 - "I'm done with the pixels please update your display accordingly..." and the way to do that is with updatePixels(). So now
09:43 - we can see that I can look into that Pixel Array...
09:46 - Specify a particular pixel, give it a certain color and call updatePixels().
09:52 - Now...
09:53 - I'm not going to pause.
09:55 - There it is, there it is. There's that red pixel. Pixel number nine. Right up there is red.
10:00 - Beautiful. We have now set a pixel in the window. By the way...
10:04 - This should... 
10:07 - This should give you an idea right. Well pixel is an array it must have a length and why couldn't I write a loop
10:18 - Why couldn't I write a loop which says do something to every single pixel in the window.
10:27 - Now I have a fully red window.
10:29 - We just broke the algorithm for the background function essentially. Again why does the background function exist? Because it
10:35 - would be a lot of work to have to put this in our code every single time
10:38 - we want to fill the background. It's such a common task. There's a background function. But this here is us doing the background
10:46 - manually and if you think about this if I'm setting every pixel individually there's no reason why
10:51 - every pixel needs to have the same color. 
10:54 - You know random 255
10:57 - random
10:58 - 50, 200
11:01 - So now I'm going to set each pixel with some random color. So we can see I have this kind of purply bluey
11:07 - random set of colors. So this might actually be your first
11:11 - project here which is our first exercise to think about.
11:15 - You know, this isn't the most and I want to take this a few steps further. Actually you know, what I think
11:23 - But what might be a different way of thinking about this. You know the first thing that could come up with is just like I
11:28 - don't know, make some random colors but what if you wanted to
11:31 - have the colors from go get like progressively more and more blue as
11:35 - we went across the screen or all the colors closer to the center be more blue and closer to the edge
11:39 - were red. There are lots and lots of possibilities here. The truth of the matter is, and this is why this video can't end here, and
11:45 - has to keep going even though it's... we're about 12 minutes in; is that, we're missing a really key, key important piece of information.
11:53 - You can pause now and try
11:54 - to just put this in and try to manipulate this, but there's a real big problem.
11:58 - Like for example the exercise I just suggested was have the pixels nearer to the center....
12:03 - Be more red and the pixels to the edge be more blue.
12:07 - Well how do I know which pixel is which? I mean I have this just like numbers. Like this pixel over here is probably like
12:12 - pixel like 722,000.
12:13 - Like how do I know which one is which.
12:16 - I really want to say... I know that that... I know, I know about its x y but there's nothing, there's no x y here. So let's return
12:22 - back to our diagram over here and let's, let's... Let's think about something.
12:28 - This is the kind of key piece of information
12:31 - That you're going to see in just about every example we do from now until the end of whenever these videos end.
12:37 - This... Are the pixels are in this one dimensional array.
12:41 - Numerically indexed 0 1 2 3 4.....
12:45 - This... They...This list of pixels is
12:49 - arranged on the screen in a grid
12:50 - where the pixels count like this: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23...
12:58 - But we, whenever we work with pixels, we really want to think of them in terms of their x and in terms of their y.
13:05 - Their column number and their row number like:
13:08 - 0 1 2 3 4 5 and the row numbers 0 1 2 3 4 5
13:15 - So I made a 5 by 5 square this will be nice for making the math kind of work out very nicely but let's actually
13:23 - let's pretend that the y was 6.
13:26 - Just so we can prove that if I have an image that's 5 by 6...
13:31 - you can't see that - if I have an image that's 5 by 6 how do I figure out where is pixel 4
13:40 - comma 3. (4, 3). Now bear with me for a second let's count, I'm going to be way too long winded about this but lets count.
13:47 - 11 12 13 14 15 16 18 19 20 21 22 23 so this should be pixel
13:56 - 23
13:58 - It's pretty obvious to us that this is pixel 4...
14:03 - By the way I... in my head I just, did something wrong which I wonder if you're doing in your head as well.
14:07 - What's the width of this image? It's not... it's not five by six. I put that over here.
14:13 - I didn't do it through my head I wrote it out here and it was absolutely wrong.
14:16 - The index value is
14:17 - 0 1 2 3 4 5. 0 to 5 but the width is actually 6 and the height here is actually 7. So this image is
14:24 - a 6 by 7 image.
14:26 - This pixel is pixel number 4. The one below it is pixel number 10
14:31 - 4 plus the width 6 is 10. This pixel is actually 16 and then this pixel... I counted wrong.
14:38 - It should actually be
14:40 - 22. Oh boy this is such a disaster 17 18 19 20 21 22. I counted wrong. This Pixel is definitely
14:48 - 22. How did I get that?
14:50 - We can get... If we know the two-dimensional location of a pixel. It's x and it's y.
14:55 - We could get the one dimensional location into this array by saying x
15:00 - plus y times
15:03 - width.
15:06 - 4 is the x
15:09 - y is
15:11 - 3
15:13 - times the width which is 6 which is 4 plus 18. Which equals
15:21 - I got a different number, no, no that's right. 4 plus 18 is 22. Oh boy...
15:28 - My mind, my brain is melting. 4 plus 18 is 22. You know...
15:34 - Maybe I'll rerecord this video later but
15:38 - What's going on here. This is actually quite a crucial algorithm. This magic little formula you can see why it makes sense.
15:44 - Pixels here: 0 6 12 18. The pixels are internally stored as a long list but
15:51 - we want to think of them as a
15:53 - two-dimensional grid.
15:54 - An X Y grid. So if we're thinking them as an xy grid the moment that we need to do something to its color we use convert from
16:01 - that one dimensional index with this formula x plus y times width. If this is confusing to you
16:06 - I would suggest pausing this video draw a grid, number everything and number all the rows, number all the columns and try to
16:14 - try to get this formula to work for you. It'll, it'll, it'll make itself clear and otherwise
16:19 - you should e-mail me your complaints. I would love to hear them. Okay so let's go back over here.
16:24 - Now how do we apply that to this particular algorithm?
16:28 - Instead of looping through all the pixels from 0 to the length of the pixel array what I want to do is
16:34 - write an algorithm that loops through
16:37 - every single x value and
16:40 - loops through every single y value.
16:43 - Whoops and this is y plus plus and this should be x plus plus. Now I'm almost certain that
16:49 - there was another video earlier...
16:52 - Which looked at this idea of a nested loop.
16:54 - This is a kind of a difficult thing to get used to this idea of a nested loop. What I'm saying is:
17:00 - "For every single x. For, every, single, x. When I'm at the first x, go over every y. When
17:06 - I'm at the next x go through every y." Let's think about that over here. When I'm at
17:11 - the first, x equals 0. Let me go through every y.
17:14 - Now I'm at the next x equals 1. Let me go through every y.
17:18 - Then I'm at the next x. Let me go through every y. That algorithm of for every x look at every y, that will cover every single pixel on the screen.
17:27 - So this algorithm, if I were to say print x y.
17:30 - We're going to see in the console the coordinates of every single pixel on the screen but
17:35 - I don't want to do that. I want to say pixels x plus y times width. Right?
17:39 - Here I was able to say pixels index i because I was just counting through all the pixels. Now that I'm storing them by x&y
17:46 - Now... 
17:47 - I have to still look up at the array that one-dimensional index and this is my formula for it. That...
17:55 - This formula is now the formula I'm applying right here in the index of the array. So if I were to say this
18:06 - and I'm going to take a loadPixels() and put it down here and updatePixels() and put it down here and then
18:13 - I'm going to comment out this old way of doing it and save it. Whoops. Pixels
18:20 - 2... and...
18:22 - save it in here. I'll try to figure out where to put these so you guys can find them. Now I have an entire green
18:27 - window. Again I've rewritten the background function but now I have access
18:31 - to every single pixel's x y location. This is very powerful because
18:36 - what if I said y divided by 2 for example.
18:40 - Now you can see the Pixels get
18:43 - more and more green as I go down to the bottom and what if I set in the blue, like x divided by 2?
18:49 - Now that... Now we can start seeing these gradients of color because
18:52 - I can't arrange the colors I'm picking according to their x y values. Let's go ahead and do that distance idea.
19:02 - Let's say I want to get the distance between that particular x y coordinate and the center of the window.
19:10 - The center of the window being the width divided by 2 and the height divided by 2. What if I set the color...
19:16 - equal to that distance? Now look what I have. When that distance is small I have that black color. When that distance
19:23 - is big I have a white color.
19:25 - What if I did something random? What if I put this in the draw loop and instead of having it just be the center I
19:30 - set the pixels according to the distance from the actual mouse. So there's lots and lots of steps here. This core algorithm of
19:38 - looking through every x and every y and setting every pixel according to
19:44 - that x and y. This is the basis behind every single
19:48 - image processing algorithm. Image processing, computer vision, all the things
19:51 - we're going to look. All of the code is always going to have this in it. So this is worth taking some time to getting
19:55 - used to. I would say take this, download it, copy it, whatever makes help and then just try
20:01 - it in a lot of different ways. Use a sine function. Use perlin noise.
20:04 - Use Random.
20:06 - Anything you can think of as a way of coloring the Pixels. Give that a try and try to
20:10 - do as much as you can using those x and y values. One little improvement though I want to make to this is,
20:15 - this is a little bit awkward and I think sometimes
20:18 - it can be a little easier to just put that in a separate variable.
20:24 - So i'm going to take that formula x plus y times width and put it in a separate variable and
20:30 - just put that variable in here. I don't know...
20:32 - this to me just gives it a little bit, a little easier to read and work with if I'm kind of
20:37 - calculating that and storing it in a variable and actually if you look at a lot of the examples that are in Processing or
20:43 - certainly in the Learning Processing book if you're following along in that, I often use the variable named loc as in like location of pixels.
20:51 - Okay so this was a particularly long video and hopefully it was helpful.
20:56 - and...
21:00 - That's that. So in the next video I want to start... This is just kind of start looking at
21:06 - what is... What, right now
21:07 - we're just kind of making up pixels on the fly, but what if we actually read the pixels from an image. Manipulate those pixels
21:13 - and draw them to the screen. That's sort of the next piece that
21:16 - we will look at. Okay.
21:17 - But I'm going to stop this video and see you in the next one if I could find the mouse to stop recording.

Cleaned transcript:

Hi, okay, this, this is the video. This is the one that... I don't know. Maybe you've been waiting for. Maybe not. This is the video where I want to talk about pixels. Pixels. The pixels. The pixels themselves. So let's think about this in context for a second. Something that we do a lot in our lives. This is the lives that we're stuck living. Is we draw lines to the screen. We say something like line, you know... 100, 50, 300, 250. Processing says "AH! You have said that I should draw a line I see the coordinates you want me to draw the line to. I am gonna start here and I end over here and I draw a line there. The line appears on the screen but what's really going on here? The existence of this line didn't happen by magic. The line, the line is not something inherent to a computer or screen. There is an algorithm. Processing has an algorithm when it gets a two points it knows how to fill in all of the pixels between those two points to create the illusion of that line on the screen. I don't know if it's really a line or not but that's that's a metaphysical question. We don't have to answer This is something. This exists because we need to do this stuff all the time in order to draw lines and circles, rectangles and triangles and put images all the time. We don't want to have to figure out which pixels we need to set, which colors... Every single time we want to draw a shape. That's what these functions are doing for us. However there comes a time in our lives. When we might want to do that. We might want to say I don't.... These functions are not good enough for me. They... I have this idea for this kind of shape that doesn't exist anywhere in the world and I need to set all the pixels individually or another... Another scenario might be I took a picture. A picture's too dark. I wanna make it brighter. I open Photoshop and make it brighter. I save it. That's what Photoshop is for. It's for, you know, image Processing. Making, changing brightness... Contrast. Also color all sorts of things you can do to an image. But if there is something you want to do to an image that isn't available as part of the tools of Photoshop, you need to invent your own image Processing algorithm. The way to do that would be by reading the pixels and setting the pixels of an image one by one at a time with your own algorithm. With your own piece of software. This is what I want to examine how to do. In this video. And the next one and the next one. And I don't know if there's another one after that. In a few videos I want to look at what, what happens when you can, you know, actually just Individually set every pixel on the screen. What, what... there's nothing you couldn't draw in theory, if you have access to every single pixel on the screen. So that's what I want to look at. Now... There's a kind of quick and dirty way to do this in Processing. There are two functions get() and... set() and get() will retrieve... the color of a particular pixel. I want the color at this xy coordinate and I want to store that in a variable. Set() will set a particular pixel to a certain color. Now, these functions are useful and maybe actually lets demonstrate set() really quickly although in the end we're going to see is these aren't very efficient and when we want to actually do something to all of the pixels... then we want to look at the pixel array itself. These are kind of helper functions for, you know, just the moment you know... Here's a scenario where you can... and I'll give this as an exercise where you might use get(). This is kind of off a little tangent here but it's worth it for a second. Let's say you are working on a program... Where you have a map of the United States I wish I could think of a different country but I'm just gonna use the United States right now and I'm incapable of drawing. That's like the worst drawing of the United States ever but you know the states are all these misshapen strangelooking things. It's going to be how do you know when the user has clicked on a certain state? Which state that user has clicked on. What if you had a map of the United States where each state was colored with a highly specific color? If you just looked at the pixel underneath the mouse coordinates to see what color that was you could then know which state the user clicked on. So anyway this is a kind of cockamamie scenario that we're not looking at right now, but would be a great topic for a video but this is why you might want to just retrieve a single color of a single pixel. Let's go back and let's look at set for a second. So if I come over here and I have a Processing sketch already kind of going here here's a blank screen and... And what I want to do is I want to say, let me set the pixel 300, 200 to the color red. Let me run this and somewhere in there... Can we find it? Is there a... Pause for my... pause this video Okay, I'm back, I found the pixel. So, we can see right there that little pixel is red. We've set that one individual pixel red. So, you know, there's no reason why I couldn't do something like... I don't know, for int x equals 0; x is less than width; x plus plus. set x, 200 to red. Look I now have a line of all those pixels going right across the screen. So we can see how there's a function in Processing set() which says for this particular x for this particular y, stick this particular color in that location and this will actually work, and we could start to build this example out more and more but... set(), the a... There's a detail about set() which I will explain in a moment and we'll come back full circle, which makes calling the set() function very very very slow. So what we want to do is do this same exact idea, which is a bit simpler, albeit to see with the set() function using the Pixel Array. And what do I mean by the Pixel Array. So let's come back over here. So... Secretly and not really so secretly but Processing and... Is keeping track of for you, all the pixels in your window or as we're going to see in a moment all of the pixels in a PImage. It's keeping track of it in a data structure. That data structure is an array. Just Processing has built in variables. A builtin variable that you were probably quite familiar with is mouseX. Whenever I say mouseX I get the x coordinate of the mouse. I don't have to declare it. It's just there. It's a variable I get it for free. There's another variable I get for free. pixels Whenever I say pixels that variable holds all of the pixels, all of the colors on the screen but what is this data structure? I mean the window itself... You can think of as a grid. Right.. If we were zoomed way in every single pixel is a square... Rectangle. I don't know. You decide. Uhhuh and each each one of them has a number. 0 1 2 3 4 5 6 7 8 9 10 11 12 Etc, etc, etc. Each one of these is in an array. The pixels are actually an array of integers or you can think of them as an array of colors. Intege... A color, the color data type is really just an integer. The integer that has the red, green and blue component. This pixel array is one long array of pixels. So if I wanted to set pixel number nine. I could say pixels index [9] equals color 255, 0, 0. This is just like the set function only I'm accessing the array and a particular index in the array which is a particular... sorry. A.... particular pixel number nine referring to a particular pixel that happens to be on the screen. Blah, okay! Let's go back and see if we can implement that here. Oh i'm here. I'm here. Okay so let's comment this out and let's say, right, there's some pixel, right, pixels index 9. Equals color 255, 0, 0. This should work right? There's no reason why this is going to fail. Let's run this and look I got an error. What error did I get? NullPointerException. Null Pointer Exception. The Pixels were nulled. There are no pixels. So what's going on here? So something that set() did for us Is set() warned Processing in advance, by the way, I'm about to start looking at the pixels and this is something that you just have to do. Before you access that pixel array you've got to give Processing a warning that you're planning to do that so that it's not just sitting there empty. Processing is going to load those pixels into memory and give you access to them. And the way that we do that is by saying loadPixels(). So anytime we do an operation with pixels we need to first call loadPixels(). By the way right now I'm speaking about pixels in this sort of general way. Pixels being... The pixels of the display window but soon we're going to start seeing things like image dot pixels or image dot loadPixels. So right now we're talking in generic terms about manipulating the pixels of the display window but later as we're going to see it's perhaps a bit more flexible and sometimes more powerful to work with PImages and manipulate those pixels which you then draw to the screen. So we'll see that in a little bit. So now that I've done this... This works. I actually, if we search I'm pretty sure we would not be able to find your red pixel because another thing you need to do; I don't see it in there. Another thing you need to do is after you're done with the pixels need to tell Processing "I'm done with the pixels please update your display accordingly..." and the way to do that is with updatePixels(). So now we can see that I can look into that Pixel Array... Specify a particular pixel, give it a certain color and call updatePixels(). Now... I'm not going to pause. There it is, there it is. There's that red pixel. Pixel number nine. Right up there is red. Beautiful. We have now set a pixel in the window. By the way... This should... This should give you an idea right. Well pixel is an array it must have a length and why couldn't I write a loop Why couldn't I write a loop which says do something to every single pixel in the window. Now I have a fully red window. We just broke the algorithm for the background function essentially. Again why does the background function exist? Because it would be a lot of work to have to put this in our code every single time we want to fill the background. It's such a common task. There's a background function. But this here is us doing the background manually and if you think about this if I'm setting every pixel individually there's no reason why every pixel needs to have the same color. You know random 255 random 50, 200 So now I'm going to set each pixel with some random color. So we can see I have this kind of purply bluey random set of colors. So this might actually be your first project here which is our first exercise to think about. You know, this isn't the most and I want to take this a few steps further. Actually you know, what I think But what might be a different way of thinking about this. You know the first thing that could come up with is just like I don't know, make some random colors but what if you wanted to have the colors from go get like progressively more and more blue as we went across the screen or all the colors closer to the center be more blue and closer to the edge were red. There are lots and lots of possibilities here. The truth of the matter is, and this is why this video can't end here, and has to keep going even though it's... we're about 12 minutes in; is that, we're missing a really key, key important piece of information. You can pause now and try to just put this in and try to manipulate this, but there's a real big problem. Like for example the exercise I just suggested was have the pixels nearer to the center.... Be more red and the pixels to the edge be more blue. Well how do I know which pixel is which? I mean I have this just like numbers. Like this pixel over here is probably like pixel like 722,000. Like how do I know which one is which. I really want to say... I know that that... I know, I know about its x y but there's nothing, there's no x y here. So let's return back to our diagram over here and let's, let's... Let's think about something. This is the kind of key piece of information That you're going to see in just about every example we do from now until the end of whenever these videos end. This... Are the pixels are in this one dimensional array. Numerically indexed 0 1 2 3 4..... This... They...This list of pixels is arranged on the screen in a grid where the pixels count like this 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23... But we, whenever we work with pixels, we really want to think of them in terms of their x and in terms of their y. Their column number and their row number like 0 1 2 3 4 5 and the row numbers 0 1 2 3 4 5 So I made a 5 by 5 square this will be nice for making the math kind of work out very nicely but let's actually let's pretend that the y was 6. Just so we can prove that if I have an image that's 5 by 6... you can't see that if I have an image that's 5 by 6 how do I figure out where is pixel 4 comma 3. (4, 3). Now bear with me for a second let's count, I'm going to be way too long winded about this but lets count. 11 12 13 14 15 16 18 19 20 21 22 23 so this should be pixel 23 It's pretty obvious to us that this is pixel 4... By the way I... in my head I just, did something wrong which I wonder if you're doing in your head as well. What's the width of this image? It's not... it's not five by six. I put that over here. I didn't do it through my head I wrote it out here and it was absolutely wrong. The index value is 0 1 2 3 4 5. 0 to 5 but the width is actually 6 and the height here is actually 7. So this image is a 6 by 7 image. This pixel is pixel number 4. The one below it is pixel number 10 4 plus the width 6 is 10. This pixel is actually 16 and then this pixel... I counted wrong. It should actually be 22. Oh boy this is such a disaster 17 18 19 20 21 22. I counted wrong. This Pixel is definitely 22. How did I get that? We can get... If we know the twodimensional location of a pixel. It's x and it's y. We could get the one dimensional location into this array by saying x plus y times width. 4 is the x y is 3 times the width which is 6 which is 4 plus 18. Which equals I got a different number, no, no that's right. 4 plus 18 is 22. Oh boy... My mind, my brain is melting. 4 plus 18 is 22. You know... Maybe I'll rerecord this video later but What's going on here. This is actually quite a crucial algorithm. This magic little formula you can see why it makes sense. Pixels here 0 6 12 18. The pixels are internally stored as a long list but we want to think of them as a twodimensional grid. An X Y grid. So if we're thinking them as an xy grid the moment that we need to do something to its color we use convert from that one dimensional index with this formula x plus y times width. If this is confusing to you I would suggest pausing this video draw a grid, number everything and number all the rows, number all the columns and try to try to get this formula to work for you. It'll, it'll, it'll make itself clear and otherwise you should email me your complaints. I would love to hear them. Okay so let's go back over here. Now how do we apply that to this particular algorithm? Instead of looping through all the pixels from 0 to the length of the pixel array what I want to do is write an algorithm that loops through every single x value and loops through every single y value. Whoops and this is y plus plus and this should be x plus plus. Now I'm almost certain that there was another video earlier... Which looked at this idea of a nested loop. This is a kind of a difficult thing to get used to this idea of a nested loop. What I'm saying is "For every single x. For, every, single, x. When I'm at the first x, go over every y. When I'm at the next x go through every y." Let's think about that over here. When I'm at the first, x equals 0. Let me go through every y. Now I'm at the next x equals 1. Let me go through every y. Then I'm at the next x. Let me go through every y. That algorithm of for every x look at every y, that will cover every single pixel on the screen. So this algorithm, if I were to say print x y. We're going to see in the console the coordinates of every single pixel on the screen but I don't want to do that. I want to say pixels x plus y times width. Right? Here I was able to say pixels index i because I was just counting through all the pixels. Now that I'm storing them by x&y Now... I have to still look up at the array that onedimensional index and this is my formula for it. That... This formula is now the formula I'm applying right here in the index of the array. So if I were to say this and I'm going to take a loadPixels() and put it down here and updatePixels() and put it down here and then I'm going to comment out this old way of doing it and save it. Whoops. Pixels 2... and... save it in here. I'll try to figure out where to put these so you guys can find them. Now I have an entire green window. Again I've rewritten the background function but now I have access to every single pixel's x y location. This is very powerful because what if I said y divided by 2 for example. Now you can see the Pixels get more and more green as I go down to the bottom and what if I set in the blue, like x divided by 2? Now that... Now we can start seeing these gradients of color because I can't arrange the colors I'm picking according to their x y values. Let's go ahead and do that distance idea. Let's say I want to get the distance between that particular x y coordinate and the center of the window. The center of the window being the width divided by 2 and the height divided by 2. What if I set the color... equal to that distance? Now look what I have. When that distance is small I have that black color. When that distance is big I have a white color. What if I did something random? What if I put this in the draw loop and instead of having it just be the center I set the pixels according to the distance from the actual mouse. So there's lots and lots of steps here. This core algorithm of looking through every x and every y and setting every pixel according to that x and y. This is the basis behind every single image processing algorithm. Image processing, computer vision, all the things we're going to look. All of the code is always going to have this in it. So this is worth taking some time to getting used to. I would say take this, download it, copy it, whatever makes help and then just try it in a lot of different ways. Use a sine function. Use perlin noise. Use Random. Anything you can think of as a way of coloring the Pixels. Give that a try and try to do as much as you can using those x and y values. One little improvement though I want to make to this is, this is a little bit awkward and I think sometimes it can be a little easier to just put that in a separate variable. So i'm going to take that formula x plus y times width and put it in a separate variable and just put that variable in here. I don't know... this to me just gives it a little bit, a little easier to read and work with if I'm kind of calculating that and storing it in a variable and actually if you look at a lot of the examples that are in Processing or certainly in the Learning Processing book if you're following along in that, I often use the variable named loc as in like location of pixels. Okay so this was a particularly long video and hopefully it was helpful. and... That's that. So in the next video I want to start... This is just kind of start looking at what is... What, right now we're just kind of making up pixels on the fly, but what if we actually read the pixels from an image. Manipulate those pixels and draw them to the screen. That's sort of the next piece that we will look at. Okay. But I'm going to stop this video and see you in the next one if I could find the mouse to stop recording.
