With timestamps:

00:06 - that's right
00:07 - i'm here standing on platform 3.14 the
00:11 - pie train is rolling into the station
00:13 - full of delicious pies
00:14 - and i'm here to celebrate pie with me
00:19 - [Music]
00:22 - that you can eat
00:25 - my favorite treat circumference divided
00:28 - by diameter
00:33 - this year i am going to look at a
00:34 - technique for estimating the number of
00:37 - pi
00:37 - with random numbers this is a direct
00:39 - result of me
00:40 - re-watching one of my favorite internet
00:42 - videos from stand-up maths
00:44 - called generating pi from 1 000 random
00:47 - numbers
00:48 - now in that video matt parker the host
00:50 - of stand-up maths
00:51 - physically rolls dice picking a thousand
00:54 - numbers
00:55 - to estimate the value of pi i am going
00:58 - to write some code it'll probably take
00:59 - me actually
01:00 - longer than physically rolling dice but
01:02 - that's what i'm going to do however i'm
01:04 - going to give myself a little
01:05 - restriction
01:06 - i will not be using the random function
01:09 - in p5.js
01:10 - no rather i'm going to pick random
01:12 - numbers from my favorite book
01:14 - 1 million random digits and with 100 000
01:18 - normal deviants
01:19 - and see how close can i get to the
01:22 - number pi
01:23 - from all of the digits in that book so
01:25 - how's this all work
01:27 - let's say i pick two random integers
01:29 - call them a
01:30 - and b while in an ideal world i would
01:32 - pick them between one and infinity i
01:34 - need to establish some kind of range so
01:36 - that i can actually work with this stuff
01:38 - in code
01:38 - i will choose the upper bound of a
01:40 - hundred thousand
01:41 - because in the random numbers book the
01:44 - digits are grouped in groupings of five
01:46 - so between zero and ninety nine thousand
01:48 - nine hundred ninety nine
01:50 - i don't want to pick the number zero
01:51 - you'll see why in a second so i
01:53 - my range will be between one and one
01:56 - hundred thousand
01:57 - the probability that these two numbers
02:00 - are
02:01 - co prime is
02:05 - six divided by pi squared
02:08 - huh why is that that's crazy well this
02:11 - is one of the wonderful things about the
02:13 - number pi it shows up
02:15 - all over the place in mathematics and
02:17 - it's just delightful
02:19 - if you want to understand a bit more
02:21 - about the derivation
02:22 - and proof of this number this is where i
02:24 - would suggest you check out matt
02:25 - parker's video he goes through this
02:27 - in detail for me in this video what i
02:29 - want to focus on
02:30 - is this concept of coprime and how do i
02:33 - write some javascript code or really in
02:35 - any programming
02:36 - language to determine if two integers
02:38 - are
02:39 - co-prime what does it mean for two
02:41 - numbers to be co-prime in the first
02:42 - place
02:43 - let's say i pick two numbers 15 and 16.
02:46 - well for any number i could list all of
02:48 - the factors of that number
02:50 - what other integers that are small in
02:52 - that number divide into that number with
02:53 - a remainder of 0.
02:55 - with 15 i've got 5 3
02:58 - and 1. with 16 i've got
03:02 - 8 four two and one
03:05 - looking at these two numbers the only
03:07 - factor that they share
03:08 - is one if two numbers
03:12 - don't share any factors other than one
03:14 - they are
03:17 - co-prime another way to say co-prime
03:20 - is greatest common divisor
03:23 - so the greatest common divisor of 15
03:26 - and 16 is one that's the highest number
03:30 - that divides into both of them
03:32 - let's change the 16 now to 21.
03:37 - the factors of 21 are 7 3
03:40 - and 1. oh look at this they share a
03:43 - greatest common divisor
03:45 - of three i should not be erasing this
03:48 - with my fingers
03:50 - this means they are not co-prime and in
03:52 - fact matt parker calls this cofactor
03:56 - so if i do have a sequence of random
03:58 - numbers which i do
04:00 - if i could just look at pairs of those
04:02 - random numbers
04:04 - determine whether they're co prime or
04:06 - cofactor
04:07 - look at the ratio of co prime to
04:10 - cofactor
04:11 - solve for pi then i could estimate the
04:14 - value of pi
04:15 - which begs the question how do i
04:17 - determine if two integers are co-prime
04:20 - or not
04:20 - i've got some wonderful news for you
04:24 - there's a well-known algorithm known as
04:26 - euclid's algorithm
04:30 - to determine the greatest common divisor
04:32 - of two integers
04:35 - and you can implement that algorithm
04:37 - with recursion
04:43 - i can't wait to look at the youtube
04:44 - retention stats in this part of the
04:46 - video
04:48 - unfortunately something terrible has
04:50 - happened i have to erase this so i can
04:52 - have some room
04:53 - to explain the algorithm
04:56 - i'll provide links in the description
04:57 - where you can read up more on both the
04:59 - derivation of this probability as well
05:02 - as
05:02 - euclid's algorithm or the euclidean
05:03 - algorithm but i'm going to try to
05:05 - describe it to you
05:06 - in my own words here in this video the
05:08 - first thing i need to do is determine
05:10 - which number is larger and for the sake
05:12 - of
05:12 - this moment i'm just going to assume
05:14 - that a is greater than b
05:15 - in my code i can figure something out to
05:17 - determine which is the bigger number
05:19 - i then need to take a divided by b
05:23 - and determine what the remainder is
05:26 - i'll call that r if by the way this
05:29 - remainder
05:31 - is zero then those
05:34 - numbers are not co-prime if i take 15
05:37 - divided
05:38 - by 3 i'm going to get 5 remainder 0.
05:42 - 15 and 3 are obviously not co-prime
05:45 - because they both share the factor
05:46 - 3. oh i wasn't including the number
05:48 - itself in my earlier list of factors
05:50 - which clearly i should have
05:53 - if the remainder is one they're
05:55 - definitely co-prime
05:59 - take the numbers 15 and 16 again 16
06:02 - divided by 15 is
06:04 - one remainder one those two numbers are
06:07 - co prime what if my numbers however are
06:10 - say
06:11 - 22 and five if i take
06:15 - 22 divided by five i get four
06:18 - remainder 2.
06:21 - as i'm moving through this you're going
06:22 - to notice that i'm not bothering to
06:24 - write the 4 here
06:25 - it's because this division actually
06:26 - doesn't matter it's only the remainder
06:28 - that matters
06:29 - and the term the operator that you use
06:31 - in javascript for remainder of division
06:34 - is the percent sign is that modulo or
06:36 - modulus oh
06:38 - the comments
06:39 - [Music]
06:44 - i got it the percent sign is the
06:47 - modulo operator the two the result is
06:50 - the modulus
06:51 - of 22 modulo 5. will i remember this the
06:55 - next time i come to it in a video
06:57 - most definitely not i should also
06:59 - mention that i'm kind of mixing things
07:01 - up here
07:02 - i want to determine whether two numbers
07:04 - are co-prime by calculating the greatest
07:06 - common divisor and if the greatest
07:08 - common divisor is one then they are
07:11 - co-prime
07:12 - and so to be a bit more clear if a
07:14 - modulo
07:15 - b is remainder zero then that greatest
07:18 - common divisor
07:19 - is b itself so this should say
07:23 - that the gcd the greatest common divisor
07:26 - is
07:27 - b if it's not zero i need to keep
07:30 - going and the way that i keep going is
07:33 - by then
07:34 - taking b modulus that remainder
07:41 - and i could call this r zero and then
07:43 - call this
07:44 - r1 and so oh sorry call this r0
07:47 - b modulus r0 is r1 and i'm going to do
07:51 - this over and over continuously again so
07:53 - now r 0 modulus r1
07:57 - equals r2 and i keep going and going and
07:59 - going if ever
08:01 - this becomes zero then whatever
08:04 - the value is here is the greatest common
08:07 - divisor and by the way if that remainder
08:10 - is ever one
08:11 - any number modulus one is going to be i
08:14 - said it wrong any number modulo one
08:18 - [Music]
08:21 - the modulus of any number and one will
08:23 - be
08:24 - zero so you that in that case
08:28 - the greatest common divisor will be that
08:31 - number one
08:32 - i wonder if looking at um two example
08:35 - numbers will be helpful in explaining
08:37 - this because boy am i doing a terrible
08:38 - job
08:41 - let's try 93 and 10.
08:44 - 93 modulo 10
08:48 - is 9 remainder 3.
08:53 - that's not zero so keep going ten
08:58 - modulo three is
09:03 - three remainder one so that's not zero
09:07 - keep going three
09:10 - modulo one is zero hey that's zero
09:13 - this is now the greatest common divisor
09:16 - one guess what 93 and 10 co prime
09:21 - let's change this to 95
09:26 - 95 divided by 10 is 9 remainder 5. so 95
09:31 - modulo 10 is
09:32 - 5 10 modulo 5
09:36 - is oh wait a second zero so guess what
09:40 - the greatest common divisor is five
09:43 - these are cofactor
09:44 - 95 and 10 not co-prime
09:48 - i feel ready do you feel ready it's okay
09:49 - if you don't feel ready but i feel ready
09:51 - to go
09:52 - and write this algorithm in the code now
09:54 - here i am in the p5 web editor i'm going
09:57 - to write a new function
09:59 - i'm going to call it gcd for greatest
10:01 - common divisor
10:03 - i'm going to pass it two numbers a and b
10:07 - and i'm going to implement euclid's
10:09 - algorithm in that function
10:11 - the first thing that i want to do is
10:12 - figure out which is the bigger number
10:15 - by the way if the numbers are the same
10:17 - they're not co-prime
10:18 - because a modulo a would be zero
10:23 - and then the greatest common divisor
10:25 - would be itself
10:26 - okay got that so first i just need to
10:28 - determine is
10:30 - b greater than a if b is greater than a
10:33 - i just want to like swap those numbers
10:39 - i look forward to all your suggestions
10:40 - about how to handle this more elegantly
10:42 - but this now is keeping both numbers but
10:44 - always guaranteeing
10:46 - that a is greater than b the first thing
10:48 - i want to do is calculate
10:50 - the modulus of a modulo b
10:54 - i'm going to store that in a variable
10:56 - called r if r
10:57 - is 0 return what b
11:00 - that's the greatest common divisor
11:04 - otherwise what do i do well now
11:08 - i want to check b modulo the remainder
11:11 - but ultimately
11:12 - why am i what is that doing that's
11:14 - checking the greatest common divisor
11:16 - of b comma r this is where the recursion
11:20 - comes in
11:21 - return g c d of b
11:24 - comma r get rid of draw
11:28 - let's confirm that it's working
11:29 - correctly
11:32 - what were the numbers that i tried 93
11:34 - and 10
11:36 - and 95 and 10 so i should see in the
11:39 - console
11:40 - a greatest common divisor of one and of
11:43 - five it worked
11:47 - it's like very rare that i'll write
11:49 - something it actually worked the first
11:50 - time
11:51 - all right a little birdie just said
11:54 - something to me in my ear
11:56 - which is like i forgot that this sort of
11:58 - like fancy javascript
12:00 - destructuring thingymabobber allows you
12:02 - to swap two variables like this
12:06 - let's make sure it still works
12:09 - indeed it does we're good to go i guess
12:12 - if i really want to be sure that this
12:13 - works
12:14 - i better also check 10 comma 93
12:17 - and 10 comma 95.
12:21 - okay i'm really good to go here what's
12:23 - next so i need my random numbers i need
12:25 - those
12:26 - 100 000 pairs of random numbers between
12:28 - 1 and 100 000
12:29 - and i want to get them from the book
12:31 - that i don't actually have with me but
12:32 - that will
12:33 - somehow be appearing like as if i'm
12:35 - holding it oh look at that
12:36 - post-production effect there luckily for
12:38 - us you can download all the digits i'll
12:39 - put a link in the description where you
12:40 - can get them yourselves
12:41 - but i've already done that and i've put
12:43 - them into a file called
12:44 - milliondigits.txt
12:46 - it looks like this it has that full
12:48 - sequence and in p5 i can use the load
12:50 - strings function to get them
12:56 - a little oddity about load strings not
12:57 - that strange actually it loads
12:59 - everything into an array i just want the
13:01 - first element of that array which has
13:02 - all billion digits in it
13:05 - and then i want to split those up into
13:08 - chunks of
13:08 - five all right i'm looking through the
13:11 - string documentation to try to find a
13:13 - function that might work for me
13:16 - pad and repeat replay slice
13:21 - yeah all right all right maybe there's a
13:23 - better way to do this i'm going to try
13:24 - using slice which allows me to slice out
13:27 - a section of the string
13:28 - so let me make an array called randoms
13:31 - for all my random numbers while i have
13:34 - some digits left
13:37 - the number i want is
13:40 - a slice starting with index zero
13:44 - up until but not including index five
13:48 - zero one two three four that's five
13:50 - things
13:52 - and then digits is just
13:55 - the rest of it strings are immutable so
13:58 - this slice
13:58 - doesn't actually change the string
14:00 - digits so i'm pulling the slice out and
14:03 - then i'm slicing
14:04 - digits the beginning part off of the
14:06 - string digits
14:08 - add that number to the array and
14:12 - if i've done everything correctly i
14:14 - should have a array of 200 000
14:17 - numbers perfect 200 000. now actually
14:20 - those are not numbers i've created
14:23 - little string slices but i want to work
14:25 - with them as numbers if i'm going to be
14:26 - calculating the greatest common divisor
14:29 - so let's add
14:30 - a parseint of num and just to be sure
14:33 - i'm going to take a look at that full
14:34 - array itself
14:36 - you can see there is my random number
14:38 - sequence
14:39 - now i think it would be fun to see fun
14:42 - is relative here
14:44 - the estimation of the value pi
14:46 - converging
14:47 - as i go through that full list of
14:48 - numbers so i'm going to make use of the
14:50 - p5 draw loop
14:52 - and i need two values i need the coprime
14:56 - total
14:57 - our co-prime count and the total
15:01 - that's going to allow me to compute that
15:02 - probability of any two numbers being
15:05 - co-prime
15:06 - and then solve for an estimated value of
15:08 - pi
15:09 - just to sort of know that it's working
15:11 - i'm going to add no loop to do draw just
15:13 - once this time
15:14 - i'm going to have a global variable
15:15 - called index which is keeping track of
15:17 - where i
15:18 - am in the random sequence
15:22 - so a is random's
15:26 - index b is the next number
15:30 - random's index plus one
15:34 - and if a and b have a greatest common
15:36 - divisor of one
15:37 - increase the coprime count and always
15:39 - increase
15:40 - the total count and let me just console
15:44 - log everything so i can see if this
15:45 - works
15:49 - i love p5 so much it seems that you may
15:53 - have accidentally written randoms
15:55 - instead of random just letting you know
15:57 - maybe you wanted to use random no i
15:59 - didn't i wanted to use randoms but i
16:01 - forgot to make randoms a global variable
16:03 - and i probably shouldn't have called it
16:04 - randoms because it's very confusing
16:05 - because randoms is very similar to
16:06 - random so i really
16:08 - really appreciate you p5 error message
16:12 - i'm going to call it random sequence
16:13 - make it a global variable
16:17 - and try this one more time here are the
16:19 - two numbers i got
16:21 - 10 097 32 533
16:24 - their greatest common divisor is one
16:26 - therefore they are
16:27 - co-prime dare i take out this no loop
16:33 - i'm getting the same number over and
16:34 - over again i forgot that i need to
16:36 - increase the index
16:38 - so instead of increasing the index by 1
16:40 - i'm taking them as pairs so i'm going to
16:42 - go up by 2
16:45 - and if index equals
16:49 - the end of that array no loop
16:52 - console.log complete
16:57 - oh look i saw one that had 11. that was
16:59 - exciting so i
17:00 - it appears to be working you know i have
17:02 - to hope that all of my code and math is
17:04 - right
17:05 - but i'm seeing all the numbers coming
17:07 - out in pairs
17:08 - i'm seeing their greatest common divisor
17:11 - i think i'm good
17:12 - i'll wait just to see until it gets to
17:14 - the end so that i can see that it says
17:16 - complete or if i get an error message
17:23 - this seems to be taking an awfully long
17:24 - time i'm doing this a hundred thousand
17:27 - times
17:28 - a hundred thousand at 60 frames per
17:30 - second i don't know a lot of minutes oh
17:32 - this is going to take a while
17:34 - i'm not going to wait till the end i'm
17:36 - going to hit stop now i could do more
17:38 - than one per frame
17:39 - we'll get to that the next step though
17:42 - is
17:43 - that i need to figure out how to solve
17:46 - for pi
17:47 - so this is now a variable in my system
17:51 - the probability of the greatest common
17:53 - divisor of two integers a
17:55 - and b equaling one is six divided by
17:59 - pi squared let's say that this
18:01 - probability is x
18:03 - and in my code x is
18:06 - coprime count divided by total
18:11 - so coprime count divided by total
18:16 - equals 6 over pi squared and this is not
18:18 - pi squared actually it's my
18:20 - variable that i want to solve for it's
18:22 - my pi estimate i'll just call that p-i-e
18:24 - for pi
18:25 - estimate i might just have pi for lunch
18:28 - today
18:29 - and i could rewrite this thing to say pi
18:32 - squared
18:33 - equals 6 times the total
18:38 - divided by coprime count
18:42 - or pi the pi estimate is the square root
18:45 - of all of this i think i did that right
18:48 - let's add that into the code
18:52 - let pi for pi estimate
18:55 - square root of 6 times total
18:58 - divided by co prime count
19:01 - let's be really really safe here and add
19:03 - some extra parentheses although i don't
19:04 - think they're technically necessary
19:06 - let's get rid of this console log and
19:08 - let's just watch console log
19:10 - pi oh
19:13 - let's get in there come on 3.1 let's
19:16 - show me a 3.1
19:19 - yeah 3.1 can i get a 4
19:23 - can i get a four let's let's actually
19:25 - draw this into the canvas
19:33 - oop erasing the background might be nice
19:37 - and here we go
19:39 - let's also make a little progress bar so
19:42 - we can see how things are going
19:50 - i haven't tested this yet but i'm just
19:52 - drawing a rectangle that's the full
19:53 - width
19:54 - of the window and then drawing one
19:56 - that's the percentage along the way with
19:58 - a fill
20:02 - wow this is really really really slow
20:05 - let's do more than one pair per frame
20:08 - so that index increasing by two has got
20:10 - to be up here
20:13 - then i can do let's try five per frame
20:18 - and i should do this check here
20:22 - so if i get to the end no loop complete
20:25 - break out of the loop
20:29 - and let's do 500 per frame
20:35 - ooh maximum call stack size exceeded
20:39 - let's take a look at what a and b are it
20:41 - really shouldn't like the numbers can't
20:43 - be so big that it can't possibly do the
20:44 - recursion to find the greatest common
20:46 - divisor
20:49 - i'm going to console log them
20:54 - oh look there's a zero oh my goodness of
20:58 - course
21:00 - i said this earlier in the video let's
21:02 - think back to that time
21:06 - i don't want to pick the number zero
21:07 - you'll see why in a second so i
21:09 - my range will be between 1 and 100
21:13 - 000. the range has to be
21:16 - between one and a hundred thousand i
21:18 - can't use a zero in this algorithm you
21:20 - can't have a greatest common divisor
21:21 - with zero
21:22 - so i can fix that by just saying plus
21:25 - one
21:26 - and plus one and now let's run it
21:29 - and there we go can i get a four yes
21:33 - ah look at this there's my estimated
21:35 - value of pi
21:36 - with all a hundred thousand pairs of
21:38 - five digit numbers
21:40 - in the one million random digits book i
21:42 - would encourage you to try it different
21:44 - ways
21:45 - certainly i could start from a different
21:46 - place in the book i could look at
21:48 - every page of the book and see which
21:49 - page of the book has the closest
21:51 - approximation of pi but i have another
21:53 - thought experiment i would like to try
21:55 - what if instead of using those million
21:58 - random digits
21:59 - what if i used the digits of pi itself
22:04 - here's a text file with the first 1
22:06 - million digits of pi
22:08 - let's get rid of the 3 and the decimal
22:10 - place
22:11 - save that and upload it to my sketch
22:16 - now all i need to do is replace the file
22:18 - name from
22:19 - million digits to pi 1 million
22:23 - and let me comment out this console log
22:25 - i don't want to be doing that anymore
22:31 - and there we go i'm gonna stop here i'm
22:35 - very pleased with the fact that i have
22:37 - taken the digits of pi
22:38 - divided them into groups of five found
22:41 - out whether those groups of fives
22:43 - are co-prime or not and then use that
22:46 - ratio of co-prime to not co-prime
22:47 - to estimate the digits of pi itself
22:50 - thank you
22:51 - thank you acting thanksgiving
22:54 - i hope you enjoyed this pi day video i
22:56 - feel like there's a lot of things that
22:57 - you could do to improve on what i've
22:59 - done
22:59 - certainly you could try to make the code
23:01 - more efficient use more random numbers
23:03 - pick your random numbers from
23:04 - some type of like a quantum
23:07 - thermodynamic
23:08 - machine that's true randomness
23:11 - is that a thing i don't know also i
23:14 - think there's some visualization
23:15 - possibilities
23:16 - is there a way to visualize the process
23:18 - of euclid's algorithm
23:20 - looking on the wikipedia page you can
23:21 - see some nice diagrams there that might
23:23 - be a starting point
23:24 - i would love for you to make something
23:26 - please share it with me there's a link
23:27 - in the video description to the coding
23:29 - train website where you can add your
23:31 - twist onto this uh coding challenge and
23:34 - i will see you
23:34 - i'll hopefully see you on this internet
23:36 - thing before next pie day but i'll be
23:38 - back
23:38 - every year on the dot march 14th it's pi
23:42 - day
23:42 - i'm gonna go and have blueberry is my
23:46 - favorite kind of pie just putting that
23:47 - out there
23:48 - and i'll see you later i can't stop
23:50 - these videos i got to get on the train
23:52 - uh it was track 3.14228 apparently
24:10 - circumference divided by diameter day

Cleaned transcript:

that's right i'm here standing on platform 3.14 the pie train is rolling into the station full of delicious pies and i'm here to celebrate pie with me that you can eat my favorite treat circumference divided by diameter this year i am going to look at a technique for estimating the number of pi with random numbers this is a direct result of me rewatching one of my favorite internet videos from standup maths called generating pi from 1 000 random numbers now in that video matt parker the host of standup maths physically rolls dice picking a thousand numbers to estimate the value of pi i am going to write some code it'll probably take me actually longer than physically rolling dice but that's what i'm going to do however i'm going to give myself a little restriction i will not be using the random function in p5.js no rather i'm going to pick random numbers from my favorite book 1 million random digits and with 100 000 normal deviants and see how close can i get to the number pi from all of the digits in that book so how's this all work let's say i pick two random integers call them a and b while in an ideal world i would pick them between one and infinity i need to establish some kind of range so that i can actually work with this stuff in code i will choose the upper bound of a hundred thousand because in the random numbers book the digits are grouped in groupings of five so between zero and ninety nine thousand nine hundred ninety nine i don't want to pick the number zero you'll see why in a second so i my range will be between one and one hundred thousand the probability that these two numbers are co prime is six divided by pi squared huh why is that that's crazy well this is one of the wonderful things about the number pi it shows up all over the place in mathematics and it's just delightful if you want to understand a bit more about the derivation and proof of this number this is where i would suggest you check out matt parker's video he goes through this in detail for me in this video what i want to focus on is this concept of coprime and how do i write some javascript code or really in any programming language to determine if two integers are coprime what does it mean for two numbers to be coprime in the first place let's say i pick two numbers 15 and 16. well for any number i could list all of the factors of that number what other integers that are small in that number divide into that number with a remainder of 0. with 15 i've got 5 3 and 1. with 16 i've got 8 four two and one looking at these two numbers the only factor that they share is one if two numbers don't share any factors other than one they are coprime another way to say coprime is greatest common divisor so the greatest common divisor of 15 and 16 is one that's the highest number that divides into both of them let's change the 16 now to 21. the factors of 21 are 7 3 and 1. oh look at this they share a greatest common divisor of three i should not be erasing this with my fingers this means they are not coprime and in fact matt parker calls this cofactor so if i do have a sequence of random numbers which i do if i could just look at pairs of those random numbers determine whether they're co prime or cofactor look at the ratio of co prime to cofactor solve for pi then i could estimate the value of pi which begs the question how do i determine if two integers are coprime or not i've got some wonderful news for you there's a wellknown algorithm known as euclid's algorithm to determine the greatest common divisor of two integers and you can implement that algorithm with recursion i can't wait to look at the youtube retention stats in this part of the video unfortunately something terrible has happened i have to erase this so i can have some room to explain the algorithm i'll provide links in the description where you can read up more on both the derivation of this probability as well as euclid's algorithm or the euclidean algorithm but i'm going to try to describe it to you in my own words here in this video the first thing i need to do is determine which number is larger and for the sake of this moment i'm just going to assume that a is greater than b in my code i can figure something out to determine which is the bigger number i then need to take a divided by b and determine what the remainder is i'll call that r if by the way this remainder is zero then those numbers are not coprime if i take 15 divided by 3 i'm going to get 5 remainder 0. 15 and 3 are obviously not coprime because they both share the factor 3. oh i wasn't including the number itself in my earlier list of factors which clearly i should have if the remainder is one they're definitely coprime take the numbers 15 and 16 again 16 divided by 15 is one remainder one those two numbers are co prime what if my numbers however are say 22 and five if i take 22 divided by five i get four remainder 2. as i'm moving through this you're going to notice that i'm not bothering to write the 4 here it's because this division actually doesn't matter it's only the remainder that matters and the term the operator that you use in javascript for remainder of division is the percent sign is that modulo or modulus oh the comments i got it the percent sign is the modulo operator the two the result is the modulus of 22 modulo 5. will i remember this the next time i come to it in a video most definitely not i should also mention that i'm kind of mixing things up here i want to determine whether two numbers are coprime by calculating the greatest common divisor and if the greatest common divisor is one then they are coprime and so to be a bit more clear if a modulo b is remainder zero then that greatest common divisor is b itself so this should say that the gcd the greatest common divisor is b if it's not zero i need to keep going and the way that i keep going is by then taking b modulus that remainder and i could call this r zero and then call this r1 and so oh sorry call this r0 b modulus r0 is r1 and i'm going to do this over and over continuously again so now r 0 modulus r1 equals r2 and i keep going and going and going if ever this becomes zero then whatever the value is here is the greatest common divisor and by the way if that remainder is ever one any number modulus one is going to be i said it wrong any number modulo one the modulus of any number and one will be zero so you that in that case the greatest common divisor will be that number one i wonder if looking at um two example numbers will be helpful in explaining this because boy am i doing a terrible job let's try 93 and 10. 93 modulo 10 is 9 remainder 3. that's not zero so keep going ten modulo three is three remainder one so that's not zero keep going three modulo one is zero hey that's zero this is now the greatest common divisor one guess what 93 and 10 co prime let's change this to 95 95 divided by 10 is 9 remainder 5. so 95 modulo 10 is 5 10 modulo 5 is oh wait a second zero so guess what the greatest common divisor is five these are cofactor 95 and 10 not coprime i feel ready do you feel ready it's okay if you don't feel ready but i feel ready to go and write this algorithm in the code now here i am in the p5 web editor i'm going to write a new function i'm going to call it gcd for greatest common divisor i'm going to pass it two numbers a and b and i'm going to implement euclid's algorithm in that function the first thing that i want to do is figure out which is the bigger number by the way if the numbers are the same they're not coprime because a modulo a would be zero and then the greatest common divisor would be itself okay got that so first i just need to determine is b greater than a if b is greater than a i just want to like swap those numbers i look forward to all your suggestions about how to handle this more elegantly but this now is keeping both numbers but always guaranteeing that a is greater than b the first thing i want to do is calculate the modulus of a modulo b i'm going to store that in a variable called r if r is 0 return what b that's the greatest common divisor otherwise what do i do well now i want to check b modulo the remainder but ultimately why am i what is that doing that's checking the greatest common divisor of b comma r this is where the recursion comes in return g c d of b comma r get rid of draw let's confirm that it's working correctly what were the numbers that i tried 93 and 10 and 95 and 10 so i should see in the console a greatest common divisor of one and of five it worked it's like very rare that i'll write something it actually worked the first time all right a little birdie just said something to me in my ear which is like i forgot that this sort of like fancy javascript destructuring thingymabobber allows you to swap two variables like this let's make sure it still works indeed it does we're good to go i guess if i really want to be sure that this works i better also check 10 comma 93 and 10 comma 95. okay i'm really good to go here what's next so i need my random numbers i need those 100 000 pairs of random numbers between 1 and 100 000 and i want to get them from the book that i don't actually have with me but that will somehow be appearing like as if i'm holding it oh look at that postproduction effect there luckily for us you can download all the digits i'll put a link in the description where you can get them yourselves but i've already done that and i've put them into a file called milliondigits.txt it looks like this it has that full sequence and in p5 i can use the load strings function to get them a little oddity about load strings not that strange actually it loads everything into an array i just want the first element of that array which has all billion digits in it and then i want to split those up into chunks of five all right i'm looking through the string documentation to try to find a function that might work for me pad and repeat replay slice yeah all right all right maybe there's a better way to do this i'm going to try using slice which allows me to slice out a section of the string so let me make an array called randoms for all my random numbers while i have some digits left the number i want is a slice starting with index zero up until but not including index five zero one two three four that's five things and then digits is just the rest of it strings are immutable so this slice doesn't actually change the string digits so i'm pulling the slice out and then i'm slicing digits the beginning part off of the string digits add that number to the array and if i've done everything correctly i should have a array of 200 000 numbers perfect 200 000. now actually those are not numbers i've created little string slices but i want to work with them as numbers if i'm going to be calculating the greatest common divisor so let's add a parseint of num and just to be sure i'm going to take a look at that full array itself you can see there is my random number sequence now i think it would be fun to see fun is relative here the estimation of the value pi converging as i go through that full list of numbers so i'm going to make use of the p5 draw loop and i need two values i need the coprime total our coprime count and the total that's going to allow me to compute that probability of any two numbers being coprime and then solve for an estimated value of pi just to sort of know that it's working i'm going to add no loop to do draw just once this time i'm going to have a global variable called index which is keeping track of where i am in the random sequence so a is random's index b is the next number random's index plus one and if a and b have a greatest common divisor of one increase the coprime count and always increase the total count and let me just console log everything so i can see if this works i love p5 so much it seems that you may have accidentally written randoms instead of random just letting you know maybe you wanted to use random no i didn't i wanted to use randoms but i forgot to make randoms a global variable and i probably shouldn't have called it randoms because it's very confusing because randoms is very similar to random so i really really appreciate you p5 error message i'm going to call it random sequence make it a global variable and try this one more time here are the two numbers i got 10 097 32 533 their greatest common divisor is one therefore they are coprime dare i take out this no loop i'm getting the same number over and over again i forgot that i need to increase the index so instead of increasing the index by 1 i'm taking them as pairs so i'm going to go up by 2 and if index equals the end of that array no loop console.log complete oh look i saw one that had 11. that was exciting so i it appears to be working you know i have to hope that all of my code and math is right but i'm seeing all the numbers coming out in pairs i'm seeing their greatest common divisor i think i'm good i'll wait just to see until it gets to the end so that i can see that it says complete or if i get an error message this seems to be taking an awfully long time i'm doing this a hundred thousand times a hundred thousand at 60 frames per second i don't know a lot of minutes oh this is going to take a while i'm not going to wait till the end i'm going to hit stop now i could do more than one per frame we'll get to that the next step though is that i need to figure out how to solve for pi so this is now a variable in my system the probability of the greatest common divisor of two integers a and b equaling one is six divided by pi squared let's say that this probability is x and in my code x is coprime count divided by total so coprime count divided by total equals 6 over pi squared and this is not pi squared actually it's my variable that i want to solve for it's my pi estimate i'll just call that pie for pi estimate i might just have pi for lunch today and i could rewrite this thing to say pi squared equals 6 times the total divided by coprime count or pi the pi estimate is the square root of all of this i think i did that right let's add that into the code let pi for pi estimate square root of 6 times total divided by co prime count let's be really really safe here and add some extra parentheses although i don't think they're technically necessary let's get rid of this console log and let's just watch console log pi oh let's get in there come on 3.1 let's show me a 3.1 yeah 3.1 can i get a 4 can i get a four let's let's actually draw this into the canvas oop erasing the background might be nice and here we go let's also make a little progress bar so we can see how things are going i haven't tested this yet but i'm just drawing a rectangle that's the full width of the window and then drawing one that's the percentage along the way with a fill wow this is really really really slow let's do more than one pair per frame so that index increasing by two has got to be up here then i can do let's try five per frame and i should do this check here so if i get to the end no loop complete break out of the loop and let's do 500 per frame ooh maximum call stack size exceeded let's take a look at what a and b are it really shouldn't like the numbers can't be so big that it can't possibly do the recursion to find the greatest common divisor i'm going to console log them oh look there's a zero oh my goodness of course i said this earlier in the video let's think back to that time i don't want to pick the number zero you'll see why in a second so i my range will be between 1 and 100 000. the range has to be between one and a hundred thousand i can't use a zero in this algorithm you can't have a greatest common divisor with zero so i can fix that by just saying plus one and plus one and now let's run it and there we go can i get a four yes ah look at this there's my estimated value of pi with all a hundred thousand pairs of five digit numbers in the one million random digits book i would encourage you to try it different ways certainly i could start from a different place in the book i could look at every page of the book and see which page of the book has the closest approximation of pi but i have another thought experiment i would like to try what if instead of using those million random digits what if i used the digits of pi itself here's a text file with the first 1 million digits of pi let's get rid of the 3 and the decimal place save that and upload it to my sketch now all i need to do is replace the file name from million digits to pi 1 million and let me comment out this console log i don't want to be doing that anymore and there we go i'm gonna stop here i'm very pleased with the fact that i have taken the digits of pi divided them into groups of five found out whether those groups of fives are coprime or not and then use that ratio of coprime to not coprime to estimate the digits of pi itself thank you thank you acting thanksgiving i hope you enjoyed this pi day video i feel like there's a lot of things that you could do to improve on what i've done certainly you could try to make the code more efficient use more random numbers pick your random numbers from some type of like a quantum thermodynamic machine that's true randomness is that a thing i don't know also i think there's some visualization possibilities is there a way to visualize the process of euclid's algorithm looking on the wikipedia page you can see some nice diagrams there that might be a starting point i would love for you to make something please share it with me there's a link in the video description to the coding train website where you can add your twist onto this uh coding challenge and i will see you i'll hopefully see you on this internet thing before next pie day but i'll be back every year on the dot march 14th it's pi day i'm gonna go and have blueberry is my favorite kind of pie just putting that out there and i'll see you later i can't stop these videos i got to get on the train uh it was track 3.14228 apparently circumference divided by diameter day
