With timestamps:

00:01 - Hello welcome to a coding
training coding challenge.
00:05 - What does the coding
training bring us today?
00:10 - Forget about that.
00:11 - So what I'm going to do is this,
it's something called A Star.
00:13 - Is a pathfinding algorithm.
00:15 - I'm actually recording
this part of the video
00:17 - that you're watching
after I did the challenge,
00:19 - was a bit of a mess.
00:20 - I have to admit, you what you're
about to watch is quite a mess.
00:23 - It took me 2 and 1/2
hours to sort this out.
00:25 - I had a lot of bugs.
00:27 - But what are you going to
watch is a little bit shorter,
00:29 - some of it's edited out.
00:30 - If you want to watch the full
archive of the live stream,
00:32 - you can find a link to that
in this video's description.
00:35 - This is the final
result. What I'm
00:37 - using is an algorithm
to find the optimal path
00:39 - from the top left
corner of the screen,
00:41 - to the bottom right
corner of the screen
00:44 - going around some obstacles.
00:45 - And you can see here
this is that path.
00:47 - And there's a lot
of pieces to this.
00:48 - The video is going
to be in two parts.
00:50 - So the first part of the
video, the only thing that I'm
00:53 - going to do is look at how
to make the optimal path
00:56 - from the top left to the
bottom right with no obstacles,
00:59 - and not being allowed
to go diagonally.
01:01 - And then that video will finish.
01:03 - And the second part of
the video will show you
01:05 - how to add diagonals,
and how to add obstacles.
01:09 - And so enjoy,
watch, if you don't
01:12 - see the second half
published as part of my feed
01:16 - go check this video's
description to be a link to it.
01:19 - So enjoy all aboard the code
train, and coding train,
01:22 - or whatever it is, enjoy
this A star challenge.
01:26 - So let's dive in and make
the A star algorithm,
01:29 - or an implementation
of it in JavaScript.
01:32 - So first of all, what
is the A star algorithm?
01:34 - The A star algorithm
is a search algorithm,
01:36 - meaning there's some
space of possibilities
01:39 - and you want to search
through that space
01:41 - for a particular needle in
a Haystack, so to speak.
01:44 - Solution and afterwards solution
out of all possible solutions.
01:47 - And typically speaking, there
are a lot of search algorithms
01:50 - to be able to come back to
others A star is typically
01:53 - applied to a pathfinding
kind of search problem.
01:55 - So let's talk about what
I mean by pathfinding.
01:57 - So here's one scenario,
incidentally a scenario
02:02 - that A star can actually
be applied to is trains,
02:04 - like how to make an
optimal path of freight
02:08 - trains between a
whole bunch of cities
02:10 - to get stuff from
one city to another.
02:11 - So let's sort of imagine
driving of cars in cities.
02:15 - So if you have a
bunch of cities,
02:18 - and they're connected by
roads in some arbitrary way,
02:25 - not everything is
connected to everything.
02:27 - And you're starting
at city A, and you
02:29 - want to get to city B, what
is the optimal path to get
02:34 - there that's the shortest?
02:35 - So we could eyeball this
and well actually there's
02:38 - only really one path, but I'll
connect things a bit more,
02:41 - add some more cities.
02:45 - So you could see there's
more possibilities here
02:47 - like this would be, if I were
to start here and go like this,
02:51 - I'm going to get all
the way to city B,
02:52 - but I can see that
this would be shorter.
02:54 - So you could imagine an
algorithm for just trying out
02:58 - every possibility.
02:59 - You could use recursion
because recursion
03:01 - is this kind of like
self-referential function,
03:03 - because you're at one city
and you try all the roads out
03:06 - of that city and you
get to other cities,
03:08 - and for those cities you try all
the roads out of those cities,
03:10 - and for those cities you try all
the roads out of those cities,
03:12 - and eventually some of those
paths will make it to the end.
03:15 - And then you could keep track
of how long it took you,
03:17 - and which one was the fastest.
03:18 - You can kind of do a search
every single possibility.
03:23 - What I just described
to you is essentially
03:25 - what's known as
Dijkstra's algorithm.
03:27 - Dijkstra's is an algorithm that
looks at every possible path,
03:32 - and tries to find
the optimal one.
03:34 - It works and it will
find you the optimal one,
03:36 - but it's not super efficient.
03:37 - So A star because it
takes a long time.
03:40 - Like this didn't take
that long, but if they're
03:42 - like thousands of nodes it
takes a really long time.
03:44 - The A star algorithm is very
similar to Dijkstra's algorithm
03:47 - but it uses a concept
known as heuristics.
03:52 - I have no idea if I'm going
to be able to spell this,
03:54 - heuristics.
03:55 - Heuristics is like
a really fancy word,
03:57 - how you would use it
you sound like you
03:58 - know what you're doing.
04:00 - But it's really just
a word for describing-
04:03 - I would say one way to think
about as an educated guess.
04:06 - So instead of having to check
every single possible route,
04:12 - what if we could just
sort of make a guess.
04:14 - This route is probably
going to be the best,
04:16 - I kind of know if
I go backwards,
04:18 - it's going to take me longer
than if I go forwards.
04:20 - So I can skip checking
the possibility that
04:22 - goes backwards.
04:24 - So this kind of heuristic.
04:26 - This kind of educated
guessing allows
04:27 - you to skip checking a
lot of the possibilities,
04:30 - and makes the
algorithm much faster.
04:32 - And the algorithm is typically
written with a formula.
04:35 - This formula is
actually quite simple
04:37 - although any time you
write a formula it starts
04:38 - to be like, Oh my God, is this
really what we're doing today.
04:41 - But f of n equals
g of n plus h to n.
04:47 - So I figure what all
these things stand
04:49 - for the h stands for
heuristic, the g,
04:53 - I don't know what it
stands for maybe we'll
04:55 - look on the Wikipedia page
and see, but so f of n
05:00 - it's like a cost function.
05:02 - Cost being like for
each one of these nodes,
05:05 - how much does that node cost?
05:07 - In terms of our time
in getting from point A
05:10 - to point B, the path
we're trying to find.
05:12 - So if it takes, the g
is the known amount.
05:16 - Like this distance
for this node is g.
05:19 - If I then went to this node
next, the g for this node
05:24 - is this distance
plus that distance.
05:26 - That's the g.
05:27 - So the g is the
like actual I would
05:30 - say cost, the
time, the distance,
05:33 - from beginning to end.
05:38 - Now the h is how
long does it take
05:41 - to-- g being like
how long did it
05:43 - take me to get
from the beginning,
05:44 - h is like how long is it going
to take me to get to the end.
05:47 - So if I knew what g and h
were not as a heuristic but as
05:50 - an actual value for
every single node,
05:53 - I could see very quickly
what's the fastest path is.
05:56 - The idea is, I'm traversing
this tree, this node, this path,
06:00 - and I get to here, I
don't actually know.
06:02 - I know how long it
took me to get here,
06:04 - I don't know how long it's going
to take me to get to the end.
06:06 - But I could make an
educated guess, because I
06:08 - know where the end is.
06:10 - I know the end is over here,
I don't know how to get there,
06:13 - but I know where it is.
06:13 - And what's my educated guess?
06:16 - How about just the
actual distance
06:18 - between these two points.
06:19 - If there were no
roads I could just
06:20 - go up in my helicopter,
coding helicopter.
06:24 - That was really the
same ring to it.
06:26 - That the coding training
has a ring to it exactly,
06:28 - but anyway if I could
go up in my helicopter
06:29 - just fly straight there, it
would take this amount of time.
06:31 - And an important thing about
your heuristic, your educated
06:34 - guess, in A star
algorithm is you
06:36 - don't want it to
ever overestimate
06:39 - the amount of time.
06:40 - If it underestimates
it, you're OK and how
06:42 - the algorithm is going to work.
06:44 - If you overestimate it,
you could have a problem
06:46 - in not getting the
optimal answer at the end.
06:48 - And in this case, we
can see that there's
06:51 - no way to overestimate if I'm
using the actual distance.
06:54 - Because no matter what, even
if there's a road from here
06:57 - to there, that's
the actual distance.
06:59 - If there's a lot of other roads,
there's a lot of other roads.
07:01 - So that's the basic idea.
07:03 - For every single one of these
nodes, I want to figure out,
07:08 - I know how long it
took me to get there,
07:10 - and then I want to
guess how long it's
07:11 - going to take me to the end.
07:13 - So and the way this is going
to work is if I'm here,
07:16 - I'm going to look at all
of the possibilities,
07:19 - so I could go here, I could
go here, or I could go here.
07:22 - And what I'm going
to do is I'm going
07:24 - to look at what the value of how
long it took me to get there,
07:29 - and the guess of
how long it takes
07:31 - to the end of each one of these.
07:32 - And I can pretty much see
that this one is going to win.
07:36 - So I'm going to pick the
total cost of how long it took
07:39 - me to get there plus my guess
of how much more I have to go,
07:42 - that's the way I'm going to go.
07:43 - And you'll see it's
still going to leave
07:45 - the others as an option, it
might have to back up and check
07:48 - some of those other ones later,
but that will actually work.
07:52 - So let's look at actually
trying to implement
07:54 - this with some code right now.
07:55 - So I have a Wikipedia page open
to the A Star Search algorithm.
08:00 - And if I scroll down
something that's
08:03 - going to be helpful to
us is this pseudocode.
08:05 - So there's a lot of tutorials
you can probably find,
08:11 - examples of the
A star algorithm.
08:13 - I'm going to make my own.
08:14 - I'm going to kind of use this
as something to refer back
08:17 - to as we start to
program as a reminder,
08:20 - but I'll try to explain
things as I go as well.
08:22 - The thing that I need to talk
about, which I came over here
08:26 - unnecessarily is that
the system that I'm
08:29 - to build, I am not going
to build this node space
08:34 - type of map, it's going to
be a little bit different.
08:37 - Let's say this is my Canvas.
08:40 - And let's say what
I'm going to do
08:42 - is think about there
are cities in a grid.
08:45 - The Canvas is a big grid
of cities like this.
08:50 - And every single
city is connected
08:53 - to every city around it.
08:56 - Like this, I won't keep
drawing all those lines.
08:58 - So if I'm trying
to get to here, I
09:01 - might figure out
the optimal path
09:03 - you could imagine as something
like this or whatever.
09:05 - And then at some point
what am going to do
09:07 - is I'm going to add
obstacles, and see
09:09 - how the A star
algorithm can solve
09:10 - going around those obstacles.
09:12 - So this is a generic
way of finding a path
09:14 - through any given pixel space,
because pixel spaces are
09:17 - just grids.
09:18 - And we could do
things like then add
09:21 - a sort of steering agent
to follow the path,
09:23 - or that sort of thing.
09:24 - Or we could kind of create
a non-traditional grid
09:26 - of network map like this.
09:27 - But I think it's going to
be a classic implementation
09:30 - and demonstration is
using a system like this.
09:32 - And this is a full grid I just
didn't draw out all the pieces.
09:34 - So that's what I'm going to do.
09:36 - And we'll see how that goes.
09:38 - So coming back, the first
thing that I want to do
09:42 - is I want to have
a two dimensional
09:44 - array that can store information
for every spot in the grid.
09:50 - So let me go to my code,
and what I'm going to do
09:53 - is I'm going to create
a variable called grid.
09:56 - And I'm going to
use some Java syntax
09:59 - and you know what
I'm going to do too,
10:01 - is I'm going to say I want to
have some variables that say,
10:05 - let's start small,
there's going to be
10:06 - five columns and five rows.
10:09 - So the grid is 5 by 5.
10:13 - Two dimensional arrays are
sort of goofy in JavaScript.
10:16 - What I ultimately want to do is,
I want to say things like grid
10:21 - 0, grid index 0, index 3,
is like the first column
10:27 - and the fourth row.
10:29 - Counting starting from 0, zero
is number one, zero, one, two,
10:32 - three is the fourth one.
10:33 - So I want to be able to
refer to any spot in the grid
10:36 - by its column and row position.
10:38 - But the first thing I
would do is just make
10:41 - the an array itself with a
certain number of columns.
10:45 - So the array, is an array of
certain number of columns.
10:47 - Each column has an array
for all those spots
10:50 - that are in the rows.
10:51 - So what I will do here is I
would say for var i equals 0.
10:54 - i Is less than
columns i plus plus,
10:57 - and I would say grid index
i is a new array, rows.
11:03 - So this is really
making a 2D array,
11:08 - and if I then say
console dot log grid,
11:12 - we can see what I've got here.
11:14 - Where am I?
11:14 - This is where the
code is running,
11:16 - you can see what is a
two dimensional array
11:18 - and it's 5 by 5.
11:21 - But it's an array of five
arrays of five things in it.
11:26 - So that's the grid.
11:27 - Now what do I want to put in
the grid, this is a question.
11:30 - So now what I want to do
is every spot-- now here's
11:36 - the thing, remember this
algorithm that I'm working on,
11:38 - the idea is that
every single spot
11:41 - has a cost associated with it.
11:43 - How long did it
take to get there.
11:44 - And what's its
guess for how long
11:46 - it's going to take to the end.
11:47 - So I want to store
that information
11:49 - in each one of these spots.
11:50 - I want an object that
can know what's my.
11:52 - I'm a node, I'm a cell, I'm
in this grid, what's my cost?
11:56 - So coming back
over here I'm going
11:58 - to do another loop
that's going to go
12:00 - through every column
and every row.
12:06 - And I'm going to kind of do
this in an object oriented way,
12:08 - I should say that
a bunch of things
12:10 - I'm going to do
in this video, I'm
12:11 - doing for ease, readability,
and not necessarily
12:15 - for optimal efficiency.
12:17 - I'm definitely going to make
the most efficient version
12:19 - of this algorithm, and I'll talk
about some things maybe later
12:22 - at the end that will see
that being more efficient.
12:24 - But I want to make each
spot in the grid an object.
12:28 - I'm going to call it a spot.
12:32 - Let's call it a spot.
12:33 - I don't know what a good
name for this would be.
12:35 - So what I need is
like a constructor
12:37 - function to create an object.
12:40 - So every object will have a
f value, a g value, and an h
12:46 - value.
12:47 - So those are the things that
I'm going to count spot.
12:52 - Every spot I need to calculate
the g, the h, and the f value.
12:55 - You need to know for each
cell in the grid, what
12:57 - are those values?
12:58 - There are some other things
I'm going to want to know.
13:00 - We're going to have to add
a bunch of things actually,
13:02 - let's add things
as we need them.
13:05 - So that I've done that.
13:07 - So now I have a grid of spots,
and now what I need to do now--
13:11 - here's the thing, the A
star algorithm by definition
13:16 - is a loop.
13:17 - It's trying a lot
of possibilities
13:19 - until it gets to the
solution and then it's done.
13:22 - So what I want to do is have my
example demonstrate and animate
13:28 - the process.
13:28 - So I'm going to do
something a little bit
13:30 - different than probably
what's found in that Wikipedia
13:32 - pseudocode.
13:33 - I forgot to mention I'm using a
JavaScript framework called P5.
13:36 - And as P5 ask you to write
a set up function, which
13:39 - is kind of the beginning
and I make a Canvas,
13:41 - and draw is a function that
loops, it's an animation loop.
13:44 - What you do like normally with
like set request animation
13:47 - frame or something like
that with native JavaScript.
13:49 - So what I'm going to do is
I'm going to use the draw
13:51 - loop as the loop.
13:52 - So if I go back to
this particular page,
13:57 - we can see here
where is that loop.
13:59 - There's this loop here
while open set is not empty.
14:03 - So this is it doing this
thing to solve the problem.
14:07 - So here's the thing,
what's going on.
14:09 - Open set, close set.
14:11 - So this is a concept that's
part of the algorithm that's
14:13 - quite important.
14:15 - We have this idea of
an open set, which
14:20 - is an array, or
a map, or a list,
14:21 - or whatever the data structure
is that you're using,
14:24 - I'm going to just use an array.
14:25 - And we have this
idea of closed set.
14:29 - So the idea is that closed set
stores a list of all the nodes
14:35 - that have finished
being evaluated.
14:38 - So this is everything
that's done that you
14:39 - don't need to ever revisit.
14:41 - That's going to be closed set.
14:43 - Open set are nodes that
still need to be evaluated.
14:49 - We need to consider and evaluate
them they're not closed yet.
14:52 - The algorithm is finished
when open set is empty.
14:57 - There's nothing left
to be evaluated.
15:00 - Actually that's
not entirely right,
15:03 - so the algorithm is
finished, there's
15:05 - two ways the
algorithm can finish.
15:07 - One is I'm going to be
searching through nodes.
15:09 - And if I ever arrive
at the end I'm
15:11 - finished because I
arrived at the end,
15:13 - I found the optimal
path all the way there.
15:14 - That's the way this
algorithm is working.
15:16 - However, if I have nothing
left in open set to review,
15:20 - nothing left to look at,
and I haven't arrived
15:23 - at the end I also have to stop.
15:25 - That means that means
there's no solution.
15:28 - So it's possible we could
build a maze of obstacles
15:32 - with no way to get
to the actual end.
15:34 - And so if there's nothing
left to evaluate you
15:36 - haven't got the end it's also.
15:37 - So these closed set starts
as empty, open set starts
15:41 - with just one node.
15:43 - At the beginning the open set
has just the starting node.
15:49 - So let's go into my
code again, and let's
15:53 - create and make some of
these global variables
15:55 - just so we can kind of
look at them in the console
15:58 - if we need to or evaluate
them, closed set.
16:02 - So I'm going to create
two arrays, open set
16:08 - and closed set.
16:09 - And what I'm going to
do right here in Setup,
16:12 - is I'm going to say I'm going
to make a start and an end.
16:21 - And so a start is going
to be the top left.
16:26 - THE start node is grid at 0, 0.
16:30 - And the end node is grid at
columns minus 1 rows minus 1.
16:38 - So these could be picked
randomly or through a variety
16:40 - of other ideas.
16:41 - But the idea is that
I want to start here,
16:43 - and I want to get to there.
16:44 - That's I want to find the
path from the top left
16:46 - to the bottom right
of the window.
16:49 - So then what do I need to do?
16:51 - I need to say open
set, push, start.
16:56 - So we're starting with open set.
16:59 - I'm going to look,
that's the thing
17:00 - I'm going to iterate through and
check every possibility there.
17:06 - And so let's look
at the algorithm.
17:09 - We're going to talk about came
from in a second, g score we're
17:13 - going to talk
about that, f score
17:15 - these are a bunch of things.
17:16 - But here's really
where I need to start.
17:19 - I need to say while
open set is not empty,
17:22 - as long as there are
spots to be evaluated,
17:25 - let me start
evaluating those spots.
17:28 - So the thing is I don't
need a while loop remember,
17:31 - I'm going to use the draw loop.
17:32 - So the draw is already
looping I'm just going to say,
17:34 - if open set is not empty--
17:38 - the way I'll say that
is if open set dot
17:45 - length is greater than zero,
great, we can keep going,
17:52 - otherwise no solution.
17:55 - I say no solution.
17:57 - There's nothing left and haven't
gone there's no solution.
18:00 - Now what I also want to do just
because I want to debug this
18:02 - as we're going, is I
want to write something
18:08 - where I draw all the
spots in the grid,
18:11 - and maybe I debug in some ways.
18:13 - This will be good for debugging.
18:14 - So I'm going to write
another double loop.
18:17 - This is a long
problem by the way,
18:18 - this is going to be a
kind of a long video,
18:19 - you're still watching?
18:23 - This could be like
multiple parts
18:25 - but maybe I should do
multiple part videos.
18:27 - I don't know.
18:29 - Grid i, j, and I'm
going to do show.
18:33 - So I'm going to
write a function.
18:35 - Each spot is going to be
a function to show itself.
18:38 - And what I'm going to
do is, I'm going to say,
18:43 - this dot show equals function.
18:46 - So how can the spot show itself
it doesn't know where it is.
18:49 - So I'm going to give each
spot an x, in each spot a y.
18:57 - So when I create each spot I'm
going to pass in the i and j.
19:03 - So each spot knows where it is.
19:06 - This is going to become
important later actually.
19:08 - And then in the
show function, I can
19:10 - draw a rectangle
at this dot x, this
19:13 - dot y but here's the thing.
19:16 - I have a sort of
scaling issue, which
19:18 - is that if my
window is 400 by 400
19:20 - but I only have 10 by
10 columns and rows
19:22 - and you figure out
how wide each cell is.
19:25 - So I can do that with
some global variables.
19:28 - I'll just make a
variable w and h.
19:32 - And what I'll do is say that
w equals the width divided
19:37 - by columns, and the number
of columns or if it's 400
19:41 - and I have 10 columns, each
spot is 40 pixels wide.
19:45 - H is height divided by rows.
19:48 - This is pretty good.
19:50 - And so then I want
to just multiply
19:51 - by that w, multiplied
by that h, and then
19:55 - have it with in height.
19:56 - I probably need one
variable to be honest
19:58 - because I'm making everything
a square but whatever.
20:00 - Let's say fill 255, stroke
zero, and let's run this again,
20:06 - we can see there's my grid.
20:08 - Maybe what I should do is
I'm getting ridiculous here
20:11 - as I should make everything
like one pixel left,
20:14 - so I can see the full
grid but whatever.
20:16 - So you get the idea.
20:17 - There's the grid.
20:19 - Good call.
20:20 - Good job.
20:22 - So what I want to do is I also
want to do some debugging,
20:26 - so what I'm going
to do actually let's
20:28 - make this show
function get a color,
20:31 - and forget about the stroke.
20:36 - I could keep the
stroke but no stroke.
20:41 - So what I'm going
to do is whenever
20:42 - I call the show function,
I'm going to use a color.
20:46 - So in my debugging I could say
I want everything to be white.
20:51 - But I also want to look
at the closed list.
21:01 - And I also want to look at
the closed lists and open set,
21:05 - closed set, open set,
whatever, I can't
21:07 - remember what these are called.
21:09 - I'm going to say closed
set index i dot show
21:12 - and I'll make these green, are
closed will be red I guess.
21:16 - Somebody will come up with
more beautiful and interesting
21:19 - colors and nicer design
choices, and open set
21:25 - will be green for open.
21:31 - And so now if we do this,
no stoke is not defined.
21:36 - No hey no stoke man.
21:39 - That does not make
any sense, no stoke.
21:43 - There we go.
21:44 - So we can see things
are looking up here.
21:46 - Now I can see that's my open
set, nothing is closed yet.
21:49 - So I want to have this because
I want to be able to debug it
21:53 - as it's going.
21:53 - I need to draw stuff to see
how the algorithm is working
21:56 - plus this is going to open
a lot of interesting visual
21:58 - possibilities for you guys.
22:03 - So let's keep going.
22:03 - Now what do we do?
22:05 - We've got to start thinking
about this algorithm.
22:08 - So let's go back to the
Wikipedia pseudocode.
22:13 - The idea here is
current should be
22:17 - the node in the open set
that has the lowest f.
22:22 - So in other words,
I want to evaluate,
22:26 - here I am, I want to evaluate
all the open set possibilities
22:31 - and what has the lowest f.
22:32 - What's going to be the best
thing getting me to the end.
22:35 - So how do we find
what something f is,
22:38 - and which has the lowest f.
22:40 - So first thing I
can do is I can say
22:42 - for var equals 0 i is less
than open set dot length i
22:49 - plus plus.
22:51 - So I'm going to say of
our lowest index equals 0.
22:55 - So I'm going to assume
in the open set--
22:58 - there has to be something
in the open set,
23:00 - I'm going to assume that the
lowest one is the first one.
23:03 - The winner, the record keeper,
I could say winner, index,
23:06 - or whatever, I don't know
what to call it, lowest index.
23:08 - It probably has a variable
name in the pseudocode.
23:12 - So what I'm going
to do now is I need
23:13 - to say if open set dot index
i dot f is less than open set
23:24 - lowest index dot f.
23:27 - Lowest in this is such a long--
23:29 - let's just call it winner.
23:32 - Winner dot f if it's less
than then the winner is i.
23:38 - so we're looking to see if we
have which one is the lowest.
23:42 - That's good that's an
easy algorithm, loop
23:44 - through everything, find
the one that's the winner.
23:47 - What do we do next?
23:48 - So first thing we have to
say, if the winner is the end
23:52 - we're done.
23:54 - So let's add that in right here.
23:57 - If open set winner
equals end, remember
24:02 - end is a variable that's
holding on to that last spot,
24:05 - then console dot log DONE.
24:10 - So that's where we're done.
24:12 - So we start with the open
set, we look at all the
24:15 - what all the things in
the open set, what's best,
24:18 - if the one that's best
is actually the end,
24:21 - then we're great,
then we're done.
24:23 - Now the next thing
is, whichever one
24:29 - we found current is the node in
the open set having the lowest
24:33 - score.
24:33 - So you know what I should do?
24:34 - I should say var current
equals and this is really
24:37 - winning index, I'm going
to say open set winner.
24:50 - So if current-- and, boy,
I have lots of typos here.
24:53 - Remember if you want
to test it something
24:55 - is equals in JavaScript
you use double equals.
24:57 - If you really want to test,
if you really want to be sure
24:59 - use the triple equals.
25:01 - So if current is
the end we're done.
25:03 - Otherwise what do I want to do?
25:05 - I want to add close
set, push current,
25:13 - and then I want to say
open set remove current.
25:16 - This is not any
actual real code.
25:18 - So here is one of
the tricky things.
25:20 - What I want to do is, there
is a function in JavaScript
25:24 - to add a particular object
to an array, that's push.
25:29 - There is no function
in JavaScript
25:30 - is just arbitrarily say, hey,
this thing if it's in the array
25:33 - remove it.
25:34 - So and this is where I'm going
to not do things so optimally,
25:37 - but what I'm going to do is
I need to find that object
25:40 - and remove it.
25:40 - And I'm just going to write a
function, remove from array,
25:44 - open set current.
25:47 - So I'm going to write
my own function,
25:49 - I'm going to stick it
just at the top here.
25:52 - Function remove from array
and function array element,
25:58 - and then what I need to do is I
need to loop through the array,
26:01 - but I want to loop through it
backwards to say i in a second.
26:05 - i is the length of the array,
length of the array minus 1
26:09 - will be starting at the end
going all the way down to zero,
26:12 - and if the array index i equals
elt, then array splice i, 1.
26:20 - So what is that?
26:20 - I just really quickly
wrote a function
26:22 - that loops through the array,
since if it has that element,
26:25 - splice being a function to
delete a particular element add
26:27 - an index from the
array, and only want
26:29 - to delete that one array.
26:31 - I'm sure somebody can tell
me a better way to do it.
26:37 - But then it will
work for right now.
26:38 - Maybe I'll come back
and optimize that later.
26:42 - But why do I go
through it backwards?
26:44 - The reason why I go
through it backwards
26:45 - is if I'm going through
the array forwards,
26:47 - and I delete something, then
all the elements come back
26:49 - and I'm moving forwards
I could skip an array,
26:51 - so skipping elements.
26:52 - So I want to go
through it backwards.
26:54 - So we want to remove it.
27:01 - Remove from array,
current from open set,
27:04 - current add to closed set.
27:06 - So now what do we do?
27:07 - If I go back to the
algorithm, I need
27:15 - to figure out what should
I add to the open set.
27:19 - What new nodes do
I need to evaluate.
27:21 - And if we think about
this, if I have just
27:24 - gone if I started here,
if this is the grid.
27:29 - We try to fill out a
little more of this.
27:32 - Just so it doesn't
look so empty.
27:34 - If this is the grid, what I want
to do I've just evaluated this.
27:37 - It's my best node coz
I only had one choice.
27:39 - That just went into closed set.
27:42 - It came out of open set.
27:44 - Now I need to
figure out what are
27:45 - some nodes I need
to check next, it's
27:47 - anything that's neighboring
that particular node.
27:50 - This one, this one, or this
one, as long as they are nodes
27:53 - we've already checked
or finished with before.
27:57 - So how do I get the neighbors?
27:59 - So I need some way--
28:01 - I'm in wrong keyboard,
I need some way
28:03 - of figuring out what are all
of the neighbors of current.
28:08 - Guess what, I think a
nice way of doing this.
28:12 - One way of doing this would be
to add a function in the let's
28:22 - add an array.
28:25 - So let's have each spot
keep track of its neighbors.
28:28 - And let's add a function
called add neighbors.
28:34 - What I'm going to do
is do things like,
28:37 - so add neighbors from
a particular grid,
28:40 - just pass it in.
28:42 - And so what I'm
going to do is I'm
28:43 - going to say this dot neighbors
push, grid, this dot i plus 1.
28:56 - I'm going to do
something silly just
28:57 - to make it a little
more readable.
28:59 - Say var i equals this dot
i, var j equals this dot j,
29:04 - I might need those out.
29:06 - I'm losing my train
of thought here.
29:08 - But this is fine.
29:09 - i plus 1, j.
29:11 - So there's four neighbors.
29:16 - i plus 1, j, i minus 1 j,
i, j plus 1, i j minus 1.
29:25 - So these are the four neighbors.
29:27 - I want to add those.
29:30 - I want each as they emerge,
but there's an issue,
29:33 - what if i is on the edge.
29:37 - So you know there's so
many nice and probably
29:40 - concise and strange and
optimal ways of writing this,
29:43 - but I'm going to do something
really simple which just says,
29:46 - as long as i is less
than columns minus 1,
29:52 - then I can add that neighbor.
29:55 - As long as i is
greater than 0, then
30:00 - it's OK to add this neighbor.
30:03 - And then as long as j is less
than rows minus 1, very tedious
30:07 - the other way of doing this
I can add that neighbor as
30:10 - long as j is greater than 0.
30:13 - And you know what, I
called these x and y.
30:16 - So this is one of these
things about programming.
30:19 - You got to keep
track of your stuff,
30:20 - and I'm not doing
a very good job
30:21 - of naming things in such a way
that making it easy on myself.
30:24 - I was calling it i and j,
and then I call it x and y.
30:27 - So maybe I'll change
these to i and j,
30:33 - because it's not really the
x and y, the x and the y
30:36 - is really the location
this start i times.
30:39 - So I think this is
going to be better.
30:42 - And then if j is greater than
0 at this particular neighbor.
30:46 - So here now I can add
all the neighbors.
30:49 - So this is a function
for any given spot
30:51 - to add neighbors that
are in a particular grid.
30:54 - Where do I do that?
30:55 - Well you might think--
30:56 - I kind of want to do it here.
30:57 - But I have a feeling this is
going to cause a big problem.
31:00 - The reason why I
can't do it here,
31:05 - is because this is where
I'm making all the spots,
31:08 - and I can't add the
neighbors while making
31:10 - the spots because I want to make
the spot that's next to it yet.
31:13 - So this is very inefficient
I'm sure I could come up
31:15 - with a different
way of doing this.
31:17 - But I'm just going to add
a completely other loop.
31:19 - Just to do this again.
31:21 - And say add neighbors.
31:23 - So I want to make all the
spots, loop through everything
31:25 - and have everything
at its own neighbors.
31:27 - So now just let's
refresh this and see
31:31 - I don't have any errors.
31:33 - Oh I know what the error is.
31:35 - I wrote it in such a
way that it to pass
31:37 - and because maybe you
want to add neighbors
31:39 - from a different grid and
some other life that you have.
31:42 - I could just use it
as a global variable.
31:44 - Great now I'm going
to look at grid,
31:46 - and we can see that each
spot has an f, g, and h, j,
31:51 - and a list of neighbors,
and the neighbors--
31:55 - something's wrong here.
31:56 - Oh look at this, look at this
comma in a totally nonsensical
32:00 - location.
32:03 - That's not right at all.
32:04 - A lot of you are screaming
at the computer I'm sure.
32:07 - Hopefully you were just
saying in a nice way
32:09 - like, excuse me I might like to
point out your small but subtle
32:14 - error there.
32:16 - Why debugging is good.
32:17 - Let's look at this again.
32:19 - Let's look at this, and
let's look at this spot,
32:23 - and let's look at its neighbors.
32:24 - It's got three neighbors.
32:26 - And where is it?
32:27 - It's like the
location 0 comma 1.
32:30 - So let's go back to
the Wikipedia page.
32:33 - For each neighbor of current.
32:36 - So we want to see what to do
about all the neighbors we're
32:40 - going to add to the open set.
32:41 - But before we put
them in the open set
32:43 - we need to evaluate them.
32:44 - So first let's say for
each neighbor of current.
32:47 - So what I'm going to do
is, I'm going to go here,
32:51 - and where are we in the
algorithm, sorry right here.
32:56 - So I want to get all the
neighbors current dot
32:59 - neighbors.
32:59 - I'm just going to put
this in a variable
33:00 - so I don't have to say current
dot neighbors all the time.
33:02 - Var neighbors equals
current dot neighbors.
33:04 - I'm going to use a for loop
to check every neighbor.
33:07 - For var i equals 0, i
is less than neighbors
33:09 - dot length, i plus plus.
33:15 - So this is every
neighbor and then
33:16 - I'm just going to say neighbor
equals neighbors index i.
33:21 - So this is me checking
every neighbor.
33:23 - Now what do I need to do
for every single neighbor.
33:26 - Well the first
thing I need to do
33:27 - is that neighbor, if I'm
moving to that neighbor,
33:31 - the g should increase by 1.
33:34 - I started here, it makes
sense that g would be 0 here.
33:40 - The amount of time
it takes me to get
33:42 - to this spot at the beginning
from the beginning is 0.
33:45 - So if these are the
neighbors, actually these
33:48 - are the only two neighbors.
33:50 - I'm not doing diagonals.
33:51 - So I don't know why
circle that I just
33:52 - realized I'll add diagonals
later I can see what that does.
33:55 - But so I can either go
here, or I could go here.
33:58 - And the g for each one
of these should be 1.
34:01 - So another way of
saying it should be 1,
34:03 - it's whatever it was
previously connected to plus 1.
34:07 - Because if it takes me like
10 steps to get to here,
34:10 - and then I'm going here,
then this would be 11 steps.
34:13 - So the first thing
I want to do is
34:15 - I want to say neighbor dot g
equals current dot g plus 1.
34:27 - Except I don't entirely
want to do this.
34:29 - So let's go back and
look at the algorithm.
34:31 - There's a couple of
things I need to check.
34:33 - First of all, what if that
neighbor is in the closed set?
34:36 - If the neighbor is
in the closed set,
34:39 - then I don't want
to evaluate it.
34:41 - Because by that definition it's
something that's done already.
34:44 - I don't need to revisit
it, I've already
34:46 - visited there through
some other optimal path.
34:49 - So let's add that in.
34:51 - So what I need to
do is first say,
34:55 - now how do I say if an
object is part of an object.
34:58 - So this is, again,
where I would want to do
35:00 - some type of efficient search.
35:03 - This is a search algorithm,
but a search within a search
35:05 - to figure out if
something is in a list.
35:07 - So I want to make that more
efficient somehow here.
35:09 - Because I want to say, so as
long as closed set does not
35:16 - include the neighbor, then
I can change its g value.
35:24 - Although can I really?
35:26 - So let's look at
the algorithm here.
35:29 - Sorry back here.
35:31 - So you'll notice
in the algorithm
35:37 - it says the tentative gscore.
35:40 - The reason why I actually don't
want to just automatically give
35:43 - it a new gscore, is
I might have gotten
35:45 - to that if it's not
in the closed set,
35:47 - it still could be something
that's been evaluated already,
35:51 - and I might have gotten to it in
a bit more of an efficient way.
35:54 - So I need to check some things.
35:55 - Because if it's in the open set
already but it's a neighbor,
35:58 - I might have gotten to
it with a lower gscore
36:00 - and I want to keep
that lower gscore.
36:02 - So what we're
going to do is say,
36:04 - I'm going to actually say var,
I'm going to call it tempG.
36:07 - So I want to keep track
of what the G would be,
36:10 - and you'll notice in
the algorithm that
36:11 - says current plus distance
between current and neighbor,
36:15 - so in a more generic version
of this algorithm where
36:18 - the nodes might have different
distances between each other.
36:21 - I would have to evaluate that.
36:22 - But the way that I've
done this over here.
36:24 - But you can see
this pretty well.
36:25 - Is that everything
has a distance of one.
36:28 - So I'm going to add one, now.
36:30 - Now what I need to do
is I need to figure out,
36:33 - is this something
that's actually already
36:35 - in the open list.
36:36 - So does the open set
include that neighbor.
36:45 - So I want to check
is it something
36:47 - I've evaluated before,
because if it's
36:49 - something I've evaluated
before I want to figure out
36:51 - is this a better g.
36:53 - Wherever kind of like way
that I'm checking right now,
36:56 - have I gotten there
more efficiently.
36:59 - So if tempG less
than neighbor dot g.
37:05 - If that's the case, then
I've got a better g.
37:09 - So now I can be that new g.
37:11 - I want to be the new g
that's lower than my old g.
37:14 - Old g.
37:16 - So if we go back
I get that right,
37:18 - so right if the tentative
score is greater than gscore
37:23 - don't do anything.
37:24 - Just kind of doing it in the
algorithms, the pseudocode
37:27 - describe it a little
different way.
37:29 - But so then, if
it's not in there,
37:34 - if it's not in the
open list then great.
37:37 - Neighbor dot g should
have that score,
37:40 - and open set, push
that neighbor.
37:45 - So all of these things they're
either already in the open set,
37:48 - and if they're already
in the open set of things
37:50 - to be evaluated
still, I should see
37:52 - if I've gotten there faster
than maybe I did previously.
37:54 - And if they're not
in the open set then,
37:56 - I've gotten there and
add it to the open set.
37:59 - So once I've done all
of this, and we've
38:02 - got to check to make sure
I'm still within the right
38:05 - if statement.
38:06 - I'm still within
this if statement
38:10 - of if it's a neighbor that's
not in the closed set,
38:12 - as long as it's something--
and now we can see is here's
38:15 - what I need to do.
38:17 - What I need to do is figure
out, what it's gscore
38:24 - and what's it's fscore,
that's interesting.
38:30 - So what I'm going
to do here is--
38:32 - so I need to figure
out what is fscore.
38:34 - It's time for the heuristic.
38:35 - Are you guys excited?
38:36 - You've watched I don't a
really long video so far,
38:39 - and I'm only now arriving
at the point where you need
38:41 - to calculate the heuristic.
38:43 - So I'm going to
say neighbor dot h,
38:47 - the heuristic is the
heuristic, I just
38:51 - want to use that
word that sounds
38:52 - so fancy, between the
neighbor and the end.
38:57 - So here's where I now need
to make an educated guess.
39:01 - How long can I guess
that it's going
39:04 - to take me to get to the end.
39:06 - So there are a lot of
different kinds of heuristics.
39:08 - And they'll give you
different results.
39:10 - But the heuristic I'm
going to use just right
39:12 - now is just the raw
Euclidean distance.
39:14 - I'm going to change it
later, because you're
39:16 - going to see I will get
slightly different results.
39:18 - But I'm just going to say,
what's the raw of distance?
39:21 - So I know that that's
always going to be
39:23 - less than what it actually is.
39:25 - But it's a good educated guess.
39:27 - So coming back here I
need to write a function.
39:30 - And I'm zoomed in.
39:32 - I'm going to write a function
at the top, function heuristic
39:37 - and between points
A and B. So I want
39:40 - to say var d equals the
distance and distance
39:44 - is a p5 function between a dot
i a dot j, b dot i, b dot j.
39:51 - So that's just do what's
known as Euclidean distance
39:53 - it uses the Pythagorean
theorem, just
39:55 - like how long is the line
between those two points.
39:58 - And then return D. So
that's the heuristic.
40:01 - So if I come back now
into my algorithm.
40:06 - The h-- I have a run this
is why I don't recommend,
40:09 - usually I like to
run the code a lot
40:10 - in between every direction
on the errors but here we go.
40:14 - That neighbors h is the
distance between A and the end.
40:19 - And then that neighbor's
f, it's g plus it's h.
40:28 - So the whole point
of this, is to know
40:30 - how long did it
take for me to get
40:31 - there, what's my
guess for how long
40:33 - it's going to take
to get to the end,
40:35 - add those two things
together, and that's
40:37 - the sort of score of
this particular node.
40:39 - And once I've done
that what do I do?
40:45 - I need to add that
to the open set,
40:47 - I don't see that
anywhere in here.
40:49 - I did that already.
40:50 - Open set add neighbor.
40:54 - I did add that here.
40:55 - So it's either already in there
and I'm updating its values,
40:57 - or it's not in there
and I'm updating it.
41:00 - So there's a little
bit of something
41:01 - like this doesn't
need to happen again,
41:03 - if I'm not updating the g
because the heuristic is never
41:05 - going to change.
41:06 - But it's fine it'll work anyway.
41:09 - So now that that's good,
I think we're good.
41:14 - Came from, so I'll
get to that later.
41:16 - We're going to need
that came from thing.
41:18 - So let's just run
this see what happens.
41:21 - Well, it made it to
the end, hold on OK.
41:28 - So let's make a bigger grid.
41:32 - Did that really work.
41:37 - Yeah oh that's just
doesn't look right to me.
41:40 - OK well, I think there's
a bug in my code, which
41:44 - I'm going to have
to find definitely,
41:46 - but I can't be 100%
sure I sort of missed
41:48 - a key part of this, which
I really would like to add.
41:51 - So if I go back to
the algorithm here,
41:54 - you'll notice this
now this pseudo
41:56 - code is written with a
particular kind of style.
42:00 - I don't want to
get too far in to.
42:02 - But you can see that,
these are like these maps.
42:04 - Like this is a map of all
the g scores for every spot,
42:07 - this is all the f
scores for every spot.
42:09 - I've done it differently,
in a different way
42:11 - I have this two dimensional
array of all these spot objects
42:14 - each of those have properties.
42:15 - But one of the properties
that each spot needs,
42:18 - is to keep track of
where it came from.
42:21 - Like as I'm going through
this, what was the node that
42:25 - was previous to it.
42:25 - And you think of
that as like a parent
42:27 - node, or the previous
node because eventually
42:29 - once I get to the
end and it's done,
42:32 - I want to be able to
trace back and find
42:35 - what that optimal path was.
42:37 - So what I need to
do here is add--
42:40 - where am I?
42:41 - What I need to do in the
code is I need to say,
42:48 - neighbor dot previous
equals current.
42:53 - So I want to just use previous,
I could say came from,
42:57 - or parent but may say previous.
42:59 - Where this neighbor
came from is current.
43:02 - And so you know what I
might do up here just
43:04 - to be clear about this, as I say
this previous equals undefined.
43:09 - That's unnecessary because by
definition will be undefined,
43:12 - or null, or whatever, but I
just want to have that in there.
43:15 - So what I'm going to do
then is when it finishes,
43:21 - this is where it finishes.
43:22 - Wherever the open
sets, whenever the best
43:29 - the item in the open set,
the spot in the open set,
43:32 - with the highest fscore, the
gscore and the hscore combined,
43:37 - the lowest that is the best one.
43:39 - If that happens to be
the end, then I'm done.
43:42 - So now what I need to do
is I need to find the path,
43:45 - and the way that I'm
going to do that,
43:47 - is I'm going to make this a
global variable just again so I
43:50 - can kind of evaluate this stuff.
43:52 - I'm going to say the path.
43:57 - And so what I want to do when
I find the path, where so much
44:01 - code it would be nice
to organize this better.
44:03 - Is I'm going to say
path is a new array,
44:07 - and I'm going to
say var, I don't
44:10 - think I can mess anything
up by messing with current,
44:12 - but I just say temp equals
current, because at the end.
44:16 - And as long as temp has a
previous, as long as there
44:22 - exists a previous
what I should do
44:25 - and then I should also say path
dot push temp, path dot push,
44:33 - temp dot previous, and then
temp equals temp previous.
44:38 - So this is an algorithm I
kind of do this in my head
44:40 - here a little bit.
44:41 - I think I need to
explain this right.
44:43 - What I'm doing is I'm
starting with an empty list,
44:45 - and I'm going to put
the end in the list.
44:47 - And then the end is connected
to the one before it,
44:50 - so that goes in the list.
44:51 - And that was connected
the one before it,
44:52 - so that one goes in the list.
44:54 - So as long as there
is a one before it,
44:55 - put the one before it and now
the thing that I'm checking
44:58 - is the one that was before it.
44:59 - So this is a nice
little algorithm
45:01 - to sort of backtrack
over that path.
45:03 - And then what I should be
able to do is when I'm done,
45:09 - I should be able to say if you
know where I want to draw this.
45:14 - I'm going to do this down here.
45:18 - I'm scrolling around
like a crazy person.
45:20 - I'm just going to initialize the
path as an empty array up here.
45:23 - So I want to say, as
long as I know I can say,
45:27 - I want to loop through
the path, and I
45:32 - want to say path index i dot
show with a color, 0, 0, 255.
45:39 - So again I'm not being
far from about the colors.
45:41 - The closed set are red,
the open set are green,
45:45 - and the path is blue.
45:47 - So let's see what happens here.
45:54 - Oh you know what, I should
evaluate that path always.
45:58 - Why not?
45:59 - To see what the current path is.
46:00 - It's only going to do it
when it gets to the end.
46:03 - It makes sense, that
makes sense as the path.
46:06 - I think.
46:07 - I got to check, I feel like
there's a bug in the code.
46:11 - So one thing as I'm just
realizing is I can be done,
46:14 - and I can say like no
loop to stop the looping.
46:18 - But there's no reason
why I shouldn't just
46:22 - evaluate what the current
path is like every frame.
46:25 - And I can actually just
do that right here.
46:30 - So let's do that.
46:32 - Well, what am I getting.
46:36 - So I think things
are actually working
46:37 - and maybe we're going to see
some improvements if I add
46:41 - a few more things to
the code, and also
46:44 - kind of add some obstacles.
46:45 - So let's just keep
going with this.
46:48 - So what I'm going
to do, a couple
46:50 - of things I want to
do, first of all this
46:52 - really isn't a good heuristic.
46:54 - Where's my heuristic
function, here it is.
46:56 - Using the Euclidean
distance, which is actually
46:59 - just kind of measuring
that distance,
47:01 - isn't really accurate
when I can only
47:03 - make steps that aren't
diagonal like this.
47:05 - So there's actually
a distance that's
47:07 - called a Manhattan distance
or taxicab distance, which
47:10 - is just measuring the difference
in x and the difference in y.
47:13 - So let me put that
heuristic in which I think
47:16 - will give us some results
that look a bit more like what
47:18 - we might expect.
47:20 - So I'm going to put
that into that's
47:22 - the absolute value of the
difference between the i values
47:31 - of the x values, plus
the absolute value
47:35 - of the difference between
the j or the y values.
47:40 - So I can run this
now, and we're going
47:42 - to see we can see it trying
to solve this problem.
47:45 - The funny thing
is, the reason why
47:47 - it's covering this
whole space is because
47:51 - in a way like the top
and the bottom are
47:54 - equivalent in distance so it
ends up checking everywhere,
47:57 - but we'll be able to
see here that if I
47:59 - were to just change the end
spot for example to where
48:03 - do I set the end.
48:04 - The end spot to
like the fourth row.
48:08 - Then actually what it's
doing is it's optimally
48:10 - finding that path very quickly.
48:12 - It doesn't have to
check every possibility
48:13 - because what are we doing, we're
using the A star algorithm.
48:16 - So there's a couple of things
that I want to add to this.
48:18 - Number one, let's
add some obstacles.
48:21 - So obstacles are
really going to help us
48:23 - understand how this is working.
48:25 - And number two, let's think
about adding diagonals as well,
48:30 - and how that works
if we add diagonals.

Cleaned transcript:

Hello welcome to a coding training coding challenge. What does the coding training bring us today? Forget about that. So what I'm going to do is this, it's something called A Star. Is a pathfinding algorithm. I'm actually recording this part of the video that you're watching after I did the challenge, was a bit of a mess. I have to admit, you what you're about to watch is quite a mess. It took me 2 and 1/2 hours to sort this out. I had a lot of bugs. But what are you going to watch is a little bit shorter, some of it's edited out. If you want to watch the full archive of the live stream, you can find a link to that in this video's description. This is the final result. What I'm using is an algorithm to find the optimal path from the top left corner of the screen, to the bottom right corner of the screen going around some obstacles. And you can see here this is that path. And there's a lot of pieces to this. The video is going to be in two parts. So the first part of the video, the only thing that I'm going to do is look at how to make the optimal path from the top left to the bottom right with no obstacles, and not being allowed to go diagonally. And then that video will finish. And the second part of the video will show you how to add diagonals, and how to add obstacles. And so enjoy, watch, if you don't see the second half published as part of my feed go check this video's description to be a link to it. So enjoy all aboard the code train, and coding train, or whatever it is, enjoy this A star challenge. So let's dive in and make the A star algorithm, or an implementation of it in JavaScript. So first of all, what is the A star algorithm? The A star algorithm is a search algorithm, meaning there's some space of possibilities and you want to search through that space for a particular needle in a Haystack, so to speak. Solution and afterwards solution out of all possible solutions. And typically speaking, there are a lot of search algorithms to be able to come back to others A star is typically applied to a pathfinding kind of search problem. So let's talk about what I mean by pathfinding. So here's one scenario, incidentally a scenario that A star can actually be applied to is trains, like how to make an optimal path of freight trains between a whole bunch of cities to get stuff from one city to another. So let's sort of imagine driving of cars in cities. So if you have a bunch of cities, and they're connected by roads in some arbitrary way, not everything is connected to everything. And you're starting at city A, and you want to get to city B, what is the optimal path to get there that's the shortest? So we could eyeball this and well actually there's only really one path, but I'll connect things a bit more, add some more cities. So you could see there's more possibilities here like this would be, if I were to start here and go like this, I'm going to get all the way to city B, but I can see that this would be shorter. So you could imagine an algorithm for just trying out every possibility. You could use recursion because recursion is this kind of like selfreferential function, because you're at one city and you try all the roads out of that city and you get to other cities, and for those cities you try all the roads out of those cities, and for those cities you try all the roads out of those cities, and eventually some of those paths will make it to the end. And then you could keep track of how long it took you, and which one was the fastest. You can kind of do a search every single possibility. What I just described to you is essentially what's known as Dijkstra's algorithm. Dijkstra's is an algorithm that looks at every possible path, and tries to find the optimal one. It works and it will find you the optimal one, but it's not super efficient. So A star because it takes a long time. Like this didn't take that long, but if they're like thousands of nodes it takes a really long time. The A star algorithm is very similar to Dijkstra's algorithm but it uses a concept known as heuristics. I have no idea if I'm going to be able to spell this, heuristics. Heuristics is like a really fancy word, how you would use it you sound like you know what you're doing. But it's really just a word for describing I would say one way to think about as an educated guess. So instead of having to check every single possible route, what if we could just sort of make a guess. This route is probably going to be the best, I kind of know if I go backwards, it's going to take me longer than if I go forwards. So I can skip checking the possibility that goes backwards. So this kind of heuristic. This kind of educated guessing allows you to skip checking a lot of the possibilities, and makes the algorithm much faster. And the algorithm is typically written with a formula. This formula is actually quite simple although any time you write a formula it starts to be like, Oh my God, is this really what we're doing today. But f of n equals g of n plus h to n. So I figure what all these things stand for the h stands for heuristic, the g, I don't know what it stands for maybe we'll look on the Wikipedia page and see, but so f of n it's like a cost function. Cost being like for each one of these nodes, how much does that node cost? In terms of our time in getting from point A to point B, the path we're trying to find. So if it takes, the g is the known amount. Like this distance for this node is g. If I then went to this node next, the g for this node is this distance plus that distance. That's the g. So the g is the like actual I would say cost, the time, the distance, from beginning to end. Now the h is how long does it take to g being like how long did it take me to get from the beginning, h is like how long is it going to take me to get to the end. So if I knew what g and h were not as a heuristic but as an actual value for every single node, I could see very quickly what's the fastest path is. The idea is, I'm traversing this tree, this node, this path, and I get to here, I don't actually know. I know how long it took me to get here, I don't know how long it's going to take me to get to the end. But I could make an educated guess, because I know where the end is. I know the end is over here, I don't know how to get there, but I know where it is. And what's my educated guess? How about just the actual distance between these two points. If there were no roads I could just go up in my helicopter, coding helicopter. That was really the same ring to it. That the coding training has a ring to it exactly, but anyway if I could go up in my helicopter just fly straight there, it would take this amount of time. And an important thing about your heuristic, your educated guess, in A star algorithm is you don't want it to ever overestimate the amount of time. If it underestimates it, you're OK and how the algorithm is going to work. If you overestimate it, you could have a problem in not getting the optimal answer at the end. And in this case, we can see that there's no way to overestimate if I'm using the actual distance. Because no matter what, even if there's a road from here to there, that's the actual distance. If there's a lot of other roads, there's a lot of other roads. So that's the basic idea. For every single one of these nodes, I want to figure out, I know how long it took me to get there, and then I want to guess how long it's going to take me to the end. So and the way this is going to work is if I'm here, I'm going to look at all of the possibilities, so I could go here, I could go here, or I could go here. And what I'm going to do is I'm going to look at what the value of how long it took me to get there, and the guess of how long it takes to the end of each one of these. And I can pretty much see that this one is going to win. So I'm going to pick the total cost of how long it took me to get there plus my guess of how much more I have to go, that's the way I'm going to go. And you'll see it's still going to leave the others as an option, it might have to back up and check some of those other ones later, but that will actually work. So let's look at actually trying to implement this with some code right now. So I have a Wikipedia page open to the A Star Search algorithm. And if I scroll down something that's going to be helpful to us is this pseudocode. So there's a lot of tutorials you can probably find, examples of the A star algorithm. I'm going to make my own. I'm going to kind of use this as something to refer back to as we start to program as a reminder, but I'll try to explain things as I go as well. The thing that I need to talk about, which I came over here unnecessarily is that the system that I'm to build, I am not going to build this node space type of map, it's going to be a little bit different. Let's say this is my Canvas. And let's say what I'm going to do is think about there are cities in a grid. The Canvas is a big grid of cities like this. And every single city is connected to every city around it. Like this, I won't keep drawing all those lines. So if I'm trying to get to here, I might figure out the optimal path you could imagine as something like this or whatever. And then at some point what am going to do is I'm going to add obstacles, and see how the A star algorithm can solve going around those obstacles. So this is a generic way of finding a path through any given pixel space, because pixel spaces are just grids. And we could do things like then add a sort of steering agent to follow the path, or that sort of thing. Or we could kind of create a nontraditional grid of network map like this. But I think it's going to be a classic implementation and demonstration is using a system like this. And this is a full grid I just didn't draw out all the pieces. So that's what I'm going to do. And we'll see how that goes. So coming back, the first thing that I want to do is I want to have a two dimensional array that can store information for every spot in the grid. So let me go to my code, and what I'm going to do is I'm going to create a variable called grid. And I'm going to use some Java syntax and you know what I'm going to do too, is I'm going to say I want to have some variables that say, let's start small, there's going to be five columns and five rows. So the grid is 5 by 5. Two dimensional arrays are sort of goofy in JavaScript. What I ultimately want to do is, I want to say things like grid 0, grid index 0, index 3, is like the first column and the fourth row. Counting starting from 0, zero is number one, zero, one, two, three is the fourth one. So I want to be able to refer to any spot in the grid by its column and row position. But the first thing I would do is just make the an array itself with a certain number of columns. So the array, is an array of certain number of columns. Each column has an array for all those spots that are in the rows. So what I will do here is I would say for var i equals 0. i Is less than columns i plus plus, and I would say grid index i is a new array, rows. So this is really making a 2D array, and if I then say console dot log grid, we can see what I've got here. Where am I? This is where the code is running, you can see what is a two dimensional array and it's 5 by 5. But it's an array of five arrays of five things in it. So that's the grid. Now what do I want to put in the grid, this is a question. So now what I want to do is every spot now here's the thing, remember this algorithm that I'm working on, the idea is that every single spot has a cost associated with it. How long did it take to get there. And what's its guess for how long it's going to take to the end. So I want to store that information in each one of these spots. I want an object that can know what's my. I'm a node, I'm a cell, I'm in this grid, what's my cost? So coming back over here I'm going to do another loop that's going to go through every column and every row. And I'm going to kind of do this in an object oriented way, I should say that a bunch of things I'm going to do in this video, I'm doing for ease, readability, and not necessarily for optimal efficiency. I'm definitely going to make the most efficient version of this algorithm, and I'll talk about some things maybe later at the end that will see that being more efficient. But I want to make each spot in the grid an object. I'm going to call it a spot. Let's call it a spot. I don't know what a good name for this would be. So what I need is like a constructor function to create an object. So every object will have a f value, a g value, and an h value. So those are the things that I'm going to count spot. Every spot I need to calculate the g, the h, and the f value. You need to know for each cell in the grid, what are those values? There are some other things I'm going to want to know. We're going to have to add a bunch of things actually, let's add things as we need them. So that I've done that. So now I have a grid of spots, and now what I need to do now here's the thing, the A star algorithm by definition is a loop. It's trying a lot of possibilities until it gets to the solution and then it's done. So what I want to do is have my example demonstrate and animate the process. So I'm going to do something a little bit different than probably what's found in that Wikipedia pseudocode. I forgot to mention I'm using a JavaScript framework called P5. And as P5 ask you to write a set up function, which is kind of the beginning and I make a Canvas, and draw is a function that loops, it's an animation loop. What you do like normally with like set request animation frame or something like that with native JavaScript. So what I'm going to do is I'm going to use the draw loop as the loop. So if I go back to this particular page, we can see here where is that loop. There's this loop here while open set is not empty. So this is it doing this thing to solve the problem. So here's the thing, what's going on. Open set, close set. So this is a concept that's part of the algorithm that's quite important. We have this idea of an open set, which is an array, or a map, or a list, or whatever the data structure is that you're using, I'm going to just use an array. And we have this idea of closed set. So the idea is that closed set stores a list of all the nodes that have finished being evaluated. So this is everything that's done that you don't need to ever revisit. That's going to be closed set. Open set are nodes that still need to be evaluated. We need to consider and evaluate them they're not closed yet. The algorithm is finished when open set is empty. There's nothing left to be evaluated. Actually that's not entirely right, so the algorithm is finished, there's two ways the algorithm can finish. One is I'm going to be searching through nodes. And if I ever arrive at the end I'm finished because I arrived at the end, I found the optimal path all the way there. That's the way this algorithm is working. However, if I have nothing left in open set to review, nothing left to look at, and I haven't arrived at the end I also have to stop. That means that means there's no solution. So it's possible we could build a maze of obstacles with no way to get to the actual end. And so if there's nothing left to evaluate you haven't got the end it's also. So these closed set starts as empty, open set starts with just one node. At the beginning the open set has just the starting node. So let's go into my code again, and let's create and make some of these global variables just so we can kind of look at them in the console if we need to or evaluate them, closed set. So I'm going to create two arrays, open set and closed set. And what I'm going to do right here in Setup, is I'm going to say I'm going to make a start and an end. And so a start is going to be the top left. THE start node is grid at 0, 0. And the end node is grid at columns minus 1 rows minus 1. So these could be picked randomly or through a variety of other ideas. But the idea is that I want to start here, and I want to get to there. That's I want to find the path from the top left to the bottom right of the window. So then what do I need to do? I need to say open set, push, start. So we're starting with open set. I'm going to look, that's the thing I'm going to iterate through and check every possibility there. And so let's look at the algorithm. We're going to talk about came from in a second, g score we're going to talk about that, f score these are a bunch of things. But here's really where I need to start. I need to say while open set is not empty, as long as there are spots to be evaluated, let me start evaluating those spots. So the thing is I don't need a while loop remember, I'm going to use the draw loop. So the draw is already looping I'm just going to say, if open set is not empty the way I'll say that is if open set dot length is greater than zero, great, we can keep going, otherwise no solution. I say no solution. There's nothing left and haven't gone there's no solution. Now what I also want to do just because I want to debug this as we're going, is I want to write something where I draw all the spots in the grid, and maybe I debug in some ways. This will be good for debugging. So I'm going to write another double loop. This is a long problem by the way, this is going to be a kind of a long video, you're still watching? This could be like multiple parts but maybe I should do multiple part videos. I don't know. Grid i, j, and I'm going to do show. So I'm going to write a function. Each spot is going to be a function to show itself. And what I'm going to do is, I'm going to say, this dot show equals function. So how can the spot show itself it doesn't know where it is. So I'm going to give each spot an x, in each spot a y. So when I create each spot I'm going to pass in the i and j. So each spot knows where it is. This is going to become important later actually. And then in the show function, I can draw a rectangle at this dot x, this dot y but here's the thing. I have a sort of scaling issue, which is that if my window is 400 by 400 but I only have 10 by 10 columns and rows and you figure out how wide each cell is. So I can do that with some global variables. I'll just make a variable w and h. And what I'll do is say that w equals the width divided by columns, and the number of columns or if it's 400 and I have 10 columns, each spot is 40 pixels wide. H is height divided by rows. This is pretty good. And so then I want to just multiply by that w, multiplied by that h, and then have it with in height. I probably need one variable to be honest because I'm making everything a square but whatever. Let's say fill 255, stroke zero, and let's run this again, we can see there's my grid. Maybe what I should do is I'm getting ridiculous here as I should make everything like one pixel left, so I can see the full grid but whatever. So you get the idea. There's the grid. Good call. Good job. So what I want to do is I also want to do some debugging, so what I'm going to do actually let's make this show function get a color, and forget about the stroke. I could keep the stroke but no stroke. So what I'm going to do is whenever I call the show function, I'm going to use a color. So in my debugging I could say I want everything to be white. But I also want to look at the closed list. And I also want to look at the closed lists and open set, closed set, open set, whatever, I can't remember what these are called. I'm going to say closed set index i dot show and I'll make these green, are closed will be red I guess. Somebody will come up with more beautiful and interesting colors and nicer design choices, and open set will be green for open. And so now if we do this, no stoke is not defined. No hey no stoke man. That does not make any sense, no stoke. There we go. So we can see things are looking up here. Now I can see that's my open set, nothing is closed yet. So I want to have this because I want to be able to debug it as it's going. I need to draw stuff to see how the algorithm is working plus this is going to open a lot of interesting visual possibilities for you guys. So let's keep going. Now what do we do? We've got to start thinking about this algorithm. So let's go back to the Wikipedia pseudocode. The idea here is current should be the node in the open set that has the lowest f. So in other words, I want to evaluate, here I am, I want to evaluate all the open set possibilities and what has the lowest f. What's going to be the best thing getting me to the end. So how do we find what something f is, and which has the lowest f. So first thing I can do is I can say for var equals 0 i is less than open set dot length i plus plus. So I'm going to say of our lowest index equals 0. So I'm going to assume in the open set there has to be something in the open set, I'm going to assume that the lowest one is the first one. The winner, the record keeper, I could say winner, index, or whatever, I don't know what to call it, lowest index. It probably has a variable name in the pseudocode. So what I'm going to do now is I need to say if open set dot index i dot f is less than open set lowest index dot f. Lowest in this is such a long let's just call it winner. Winner dot f if it's less than then the winner is i. so we're looking to see if we have which one is the lowest. That's good that's an easy algorithm, loop through everything, find the one that's the winner. What do we do next? So first thing we have to say, if the winner is the end we're done. So let's add that in right here. If open set winner equals end, remember end is a variable that's holding on to that last spot, then console dot log DONE. So that's where we're done. So we start with the open set, we look at all the what all the things in the open set, what's best, if the one that's best is actually the end, then we're great, then we're done. Now the next thing is, whichever one we found current is the node in the open set having the lowest score. So you know what I should do? I should say var current equals and this is really winning index, I'm going to say open set winner. So if current and, boy, I have lots of typos here. Remember if you want to test it something is equals in JavaScript you use double equals. If you really want to test, if you really want to be sure use the triple equals. So if current is the end we're done. Otherwise what do I want to do? I want to add close set, push current, and then I want to say open set remove current. This is not any actual real code. So here is one of the tricky things. What I want to do is, there is a function in JavaScript to add a particular object to an array, that's push. There is no function in JavaScript is just arbitrarily say, hey, this thing if it's in the array remove it. So and this is where I'm going to not do things so optimally, but what I'm going to do is I need to find that object and remove it. And I'm just going to write a function, remove from array, open set current. So I'm going to write my own function, I'm going to stick it just at the top here. Function remove from array and function array element, and then what I need to do is I need to loop through the array, but I want to loop through it backwards to say i in a second. i is the length of the array, length of the array minus 1 will be starting at the end going all the way down to zero, and if the array index i equals elt, then array splice i, 1. So what is that? I just really quickly wrote a function that loops through the array, since if it has that element, splice being a function to delete a particular element add an index from the array, and only want to delete that one array. I'm sure somebody can tell me a better way to do it. But then it will work for right now. Maybe I'll come back and optimize that later. But why do I go through it backwards? The reason why I go through it backwards is if I'm going through the array forwards, and I delete something, then all the elements come back and I'm moving forwards I could skip an array, so skipping elements. So I want to go through it backwards. So we want to remove it. Remove from array, current from open set, current add to closed set. So now what do we do? If I go back to the algorithm, I need to figure out what should I add to the open set. What new nodes do I need to evaluate. And if we think about this, if I have just gone if I started here, if this is the grid. We try to fill out a little more of this. Just so it doesn't look so empty. If this is the grid, what I want to do I've just evaluated this. It's my best node coz I only had one choice. That just went into closed set. It came out of open set. Now I need to figure out what are some nodes I need to check next, it's anything that's neighboring that particular node. This one, this one, or this one, as long as they are nodes we've already checked or finished with before. So how do I get the neighbors? So I need some way I'm in wrong keyboard, I need some way of figuring out what are all of the neighbors of current. Guess what, I think a nice way of doing this. One way of doing this would be to add a function in the let's add an array. So let's have each spot keep track of its neighbors. And let's add a function called add neighbors. What I'm going to do is do things like, so add neighbors from a particular grid, just pass it in. And so what I'm going to do is I'm going to say this dot neighbors push, grid, this dot i plus 1. I'm going to do something silly just to make it a little more readable. Say var i equals this dot i, var j equals this dot j, I might need those out. I'm losing my train of thought here. But this is fine. i plus 1, j. So there's four neighbors. i plus 1, j, i minus 1 j, i, j plus 1, i j minus 1. So these are the four neighbors. I want to add those. I want each as they emerge, but there's an issue, what if i is on the edge. So you know there's so many nice and probably concise and strange and optimal ways of writing this, but I'm going to do something really simple which just says, as long as i is less than columns minus 1, then I can add that neighbor. As long as i is greater than 0, then it's OK to add this neighbor. And then as long as j is less than rows minus 1, very tedious the other way of doing this I can add that neighbor as long as j is greater than 0. And you know what, I called these x and y. So this is one of these things about programming. You got to keep track of your stuff, and I'm not doing a very good job of naming things in such a way that making it easy on myself. I was calling it i and j, and then I call it x and y. So maybe I'll change these to i and j, because it's not really the x and y, the x and the y is really the location this start i times. So I think this is going to be better. And then if j is greater than 0 at this particular neighbor. So here now I can add all the neighbors. So this is a function for any given spot to add neighbors that are in a particular grid. Where do I do that? Well you might think I kind of want to do it here. But I have a feeling this is going to cause a big problem. The reason why I can't do it here, is because this is where I'm making all the spots, and I can't add the neighbors while making the spots because I want to make the spot that's next to it yet. So this is very inefficient I'm sure I could come up with a different way of doing this. But I'm just going to add a completely other loop. Just to do this again. And say add neighbors. So I want to make all the spots, loop through everything and have everything at its own neighbors. So now just let's refresh this and see I don't have any errors. Oh I know what the error is. I wrote it in such a way that it to pass and because maybe you want to add neighbors from a different grid and some other life that you have. I could just use it as a global variable. Great now I'm going to look at grid, and we can see that each spot has an f, g, and h, j, and a list of neighbors, and the neighbors something's wrong here. Oh look at this, look at this comma in a totally nonsensical location. That's not right at all. A lot of you are screaming at the computer I'm sure. Hopefully you were just saying in a nice way like, excuse me I might like to point out your small but subtle error there. Why debugging is good. Let's look at this again. Let's look at this, and let's look at this spot, and let's look at its neighbors. It's got three neighbors. And where is it? It's like the location 0 comma 1. So let's go back to the Wikipedia page. For each neighbor of current. So we want to see what to do about all the neighbors we're going to add to the open set. But before we put them in the open set we need to evaluate them. So first let's say for each neighbor of current. So what I'm going to do is, I'm going to go here, and where are we in the algorithm, sorry right here. So I want to get all the neighbors current dot neighbors. I'm just going to put this in a variable so I don't have to say current dot neighbors all the time. Var neighbors equals current dot neighbors. I'm going to use a for loop to check every neighbor. For var i equals 0, i is less than neighbors dot length, i plus plus. So this is every neighbor and then I'm just going to say neighbor equals neighbors index i. So this is me checking every neighbor. Now what do I need to do for every single neighbor. Well the first thing I need to do is that neighbor, if I'm moving to that neighbor, the g should increase by 1. I started here, it makes sense that g would be 0 here. The amount of time it takes me to get to this spot at the beginning from the beginning is 0. So if these are the neighbors, actually these are the only two neighbors. I'm not doing diagonals. So I don't know why circle that I just realized I'll add diagonals later I can see what that does. But so I can either go here, or I could go here. And the g for each one of these should be 1. So another way of saying it should be 1, it's whatever it was previously connected to plus 1. Because if it takes me like 10 steps to get to here, and then I'm going here, then this would be 11 steps. So the first thing I want to do is I want to say neighbor dot g equals current dot g plus 1. Except I don't entirely want to do this. So let's go back and look at the algorithm. There's a couple of things I need to check. First of all, what if that neighbor is in the closed set? If the neighbor is in the closed set, then I don't want to evaluate it. Because by that definition it's something that's done already. I don't need to revisit it, I've already visited there through some other optimal path. So let's add that in. So what I need to do is first say, now how do I say if an object is part of an object. So this is, again, where I would want to do some type of efficient search. This is a search algorithm, but a search within a search to figure out if something is in a list. So I want to make that more efficient somehow here. Because I want to say, so as long as closed set does not include the neighbor, then I can change its g value. Although can I really? So let's look at the algorithm here. Sorry back here. So you'll notice in the algorithm it says the tentative gscore. The reason why I actually don't want to just automatically give it a new gscore, is I might have gotten to that if it's not in the closed set, it still could be something that's been evaluated already, and I might have gotten to it in a bit more of an efficient way. So I need to check some things. Because if it's in the open set already but it's a neighbor, I might have gotten to it with a lower gscore and I want to keep that lower gscore. So what we're going to do is say, I'm going to actually say var, I'm going to call it tempG. So I want to keep track of what the G would be, and you'll notice in the algorithm that says current plus distance between current and neighbor, so in a more generic version of this algorithm where the nodes might have different distances between each other. I would have to evaluate that. But the way that I've done this over here. But you can see this pretty well. Is that everything has a distance of one. So I'm going to add one, now. Now what I need to do is I need to figure out, is this something that's actually already in the open list. So does the open set include that neighbor. So I want to check is it something I've evaluated before, because if it's something I've evaluated before I want to figure out is this a better g. Wherever kind of like way that I'm checking right now, have I gotten there more efficiently. So if tempG less than neighbor dot g. If that's the case, then I've got a better g. So now I can be that new g. I want to be the new g that's lower than my old g. Old g. So if we go back I get that right, so right if the tentative score is greater than gscore don't do anything. Just kind of doing it in the algorithms, the pseudocode describe it a little different way. But so then, if it's not in there, if it's not in the open list then great. Neighbor dot g should have that score, and open set, push that neighbor. So all of these things they're either already in the open set, and if they're already in the open set of things to be evaluated still, I should see if I've gotten there faster than maybe I did previously. And if they're not in the open set then, I've gotten there and add it to the open set. So once I've done all of this, and we've got to check to make sure I'm still within the right if statement. I'm still within this if statement of if it's a neighbor that's not in the closed set, as long as it's something and now we can see is here's what I need to do. What I need to do is figure out, what it's gscore and what's it's fscore, that's interesting. So what I'm going to do here is so I need to figure out what is fscore. It's time for the heuristic. Are you guys excited? You've watched I don't a really long video so far, and I'm only now arriving at the point where you need to calculate the heuristic. So I'm going to say neighbor dot h, the heuristic is the heuristic, I just want to use that word that sounds so fancy, between the neighbor and the end. So here's where I now need to make an educated guess. How long can I guess that it's going to take me to get to the end. So there are a lot of different kinds of heuristics. And they'll give you different results. But the heuristic I'm going to use just right now is just the raw Euclidean distance. I'm going to change it later, because you're going to see I will get slightly different results. But I'm just going to say, what's the raw of distance? So I know that that's always going to be less than what it actually is. But it's a good educated guess. So coming back here I need to write a function. And I'm zoomed in. I'm going to write a function at the top, function heuristic and between points A and B. So I want to say var d equals the distance and distance is a p5 function between a dot i a dot j, b dot i, b dot j. So that's just do what's known as Euclidean distance it uses the Pythagorean theorem, just like how long is the line between those two points. And then return D. So that's the heuristic. So if I come back now into my algorithm. The h I have a run this is why I don't recommend, usually I like to run the code a lot in between every direction on the errors but here we go. That neighbors h is the distance between A and the end. And then that neighbor's f, it's g plus it's h. So the whole point of this, is to know how long did it take for me to get there, what's my guess for how long it's going to take to get to the end, add those two things together, and that's the sort of score of this particular node. And once I've done that what do I do? I need to add that to the open set, I don't see that anywhere in here. I did that already. Open set add neighbor. I did add that here. So it's either already in there and I'm updating its values, or it's not in there and I'm updating it. So there's a little bit of something like this doesn't need to happen again, if I'm not updating the g because the heuristic is never going to change. But it's fine it'll work anyway. So now that that's good, I think we're good. Came from, so I'll get to that later. We're going to need that came from thing. So let's just run this see what happens. Well, it made it to the end, hold on OK. So let's make a bigger grid. Did that really work. Yeah oh that's just doesn't look right to me. OK well, I think there's a bug in my code, which I'm going to have to find definitely, but I can't be 100% sure I sort of missed a key part of this, which I really would like to add. So if I go back to the algorithm here, you'll notice this now this pseudo code is written with a particular kind of style. I don't want to get too far in to. But you can see that, these are like these maps. Like this is a map of all the g scores for every spot, this is all the f scores for every spot. I've done it differently, in a different way I have this two dimensional array of all these spot objects each of those have properties. But one of the properties that each spot needs, is to keep track of where it came from. Like as I'm going through this, what was the node that was previous to it. And you think of that as like a parent node, or the previous node because eventually once I get to the end and it's done, I want to be able to trace back and find what that optimal path was. So what I need to do here is add where am I? What I need to do in the code is I need to say, neighbor dot previous equals current. So I want to just use previous, I could say came from, or parent but may say previous. Where this neighbor came from is current. And so you know what I might do up here just to be clear about this, as I say this previous equals undefined. That's unnecessary because by definition will be undefined, or null, or whatever, but I just want to have that in there. So what I'm going to do then is when it finishes, this is where it finishes. Wherever the open sets, whenever the best the item in the open set, the spot in the open set, with the highest fscore, the gscore and the hscore combined, the lowest that is the best one. If that happens to be the end, then I'm done. So now what I need to do is I need to find the path, and the way that I'm going to do that, is I'm going to make this a global variable just again so I can kind of evaluate this stuff. I'm going to say the path. And so what I want to do when I find the path, where so much code it would be nice to organize this better. Is I'm going to say path is a new array, and I'm going to say var, I don't think I can mess anything up by messing with current, but I just say temp equals current, because at the end. And as long as temp has a previous, as long as there exists a previous what I should do and then I should also say path dot push temp, path dot push, temp dot previous, and then temp equals temp previous. So this is an algorithm I kind of do this in my head here a little bit. I think I need to explain this right. What I'm doing is I'm starting with an empty list, and I'm going to put the end in the list. And then the end is connected to the one before it, so that goes in the list. And that was connected the one before it, so that one goes in the list. So as long as there is a one before it, put the one before it and now the thing that I'm checking is the one that was before it. So this is a nice little algorithm to sort of backtrack over that path. And then what I should be able to do is when I'm done, I should be able to say if you know where I want to draw this. I'm going to do this down here. I'm scrolling around like a crazy person. I'm just going to initialize the path as an empty array up here. So I want to say, as long as I know I can say, I want to loop through the path, and I want to say path index i dot show with a color, 0, 0, 255. So again I'm not being far from about the colors. The closed set are red, the open set are green, and the path is blue. So let's see what happens here. Oh you know what, I should evaluate that path always. Why not? To see what the current path is. It's only going to do it when it gets to the end. It makes sense, that makes sense as the path. I think. I got to check, I feel like there's a bug in the code. So one thing as I'm just realizing is I can be done, and I can say like no loop to stop the looping. But there's no reason why I shouldn't just evaluate what the current path is like every frame. And I can actually just do that right here. So let's do that. Well, what am I getting. So I think things are actually working and maybe we're going to see some improvements if I add a few more things to the code, and also kind of add some obstacles. So let's just keep going with this. So what I'm going to do, a couple of things I want to do, first of all this really isn't a good heuristic. Where's my heuristic function, here it is. Using the Euclidean distance, which is actually just kind of measuring that distance, isn't really accurate when I can only make steps that aren't diagonal like this. So there's actually a distance that's called a Manhattan distance or taxicab distance, which is just measuring the difference in x and the difference in y. So let me put that heuristic in which I think will give us some results that look a bit more like what we might expect. So I'm going to put that into that's the absolute value of the difference between the i values of the x values, plus the absolute value of the difference between the j or the y values. So I can run this now, and we're going to see we can see it trying to solve this problem. The funny thing is, the reason why it's covering this whole space is because in a way like the top and the bottom are equivalent in distance so it ends up checking everywhere, but we'll be able to see here that if I were to just change the end spot for example to where do I set the end. The end spot to like the fourth row. Then actually what it's doing is it's optimally finding that path very quickly. It doesn't have to check every possibility because what are we doing, we're using the A star algorithm. So there's a couple of things that I want to add to this. Number one, let's add some obstacles. So obstacles are really going to help us understand how this is working. And number two, let's think about adding diagonals as well, and how that works if we add diagonals.
