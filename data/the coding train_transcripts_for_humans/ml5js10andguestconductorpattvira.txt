With timestamps:

00:06 - Welcome to a very special
episode of The Coding Train
00:10 - with our guest today, Patt Vira.
00:13 - Patt has an incredible number--
00:15 - over 100, at least,
already in the last year--
00:18 - of tutorials and videos
about p5.js creative coding.
00:22 - So if you like the
coding train, you're
00:25 - going to like Patt's channel.
00:27 - I hope so.
00:28 - So we're here today to do
a special collaboration.
00:31 - Patt happens to be in
New York for ITP Camp.
00:35 - ITP is the program where
I teach during the year.
00:37 - They run a month-long
program in June for Camp.
00:40 - And I just so happened
that yesterday,
00:43 - I taught a quick
workshop at ITP Camp
00:46 - on the ML5 library, which
also just yesterday had a 1.0
00:51 - release.
00:51 - So what we're going to do
in this video is introduce
00:54 - to you the new release
of the ML5 library,
00:58 - show you the new ML5 website.
01:00 - I'm going to give you a
quick walkthrough of how
01:02 - to code some stuff in ML5.
01:04 - And then Patt's going to make it
much more visually interesting
01:07 - and exciting.
01:08 - All right, so what is ml5.js?
01:11 - The ML5 project started in
2017 when researchers at Google
01:18 - were developing deeplearn.js.
01:20 - And we asked the question,
could deeplearn.js,
01:24 - which was a library to
run machine learning
01:26 - models in the browser, could
we run those models with p5.js?
01:31 - deeplearn.js later
became TensorFlow.js.
01:34 - And the ML5 project has had
many years of development
01:38 - with different models and
tutorials and examples.
01:41 - But in the last year, a group
of us at NYU in New York
01:46 - and at NYU Shanghai have been
working on updating the library
01:49 - to use a bunch of refreshed,
new models for pose tracking,
01:54 - as well as some new
functions for training
01:57 - a neural network, all of which
I explore in a lot of detail
02:01 - in chapters 10 and 11 of my
new Nature of Code Book, which
02:04 - think I've probably
mentioned way
02:06 - too many times on this channel.
02:07 - So let's take a look
at the ML5 website,
02:10 - and I can show you what some
of the new features are.
02:13 - This is the new ml5.js website.
02:15 - I encourage you to take
a look at the About page
02:18 - so you can learn all about all
of the wonderful people who
02:21 - are contributing and
building this library.
02:23 - The Getting Started
page is probably
02:26 - where you want to begin, just to
find a quick walk through of how
02:30 - to get started with the
library and the p5.js editor.
02:34 - Under the Reference,
you will see here,
02:36 - on the left, all of the
machine learning models that
02:40 - are currently supported in ML5.
02:42 - There is a model for tracking
body pose, for hand--
02:46 - key points on your hand,
key points on your face.
02:49 - That's what we're going to
use for this tutorial today.
02:52 - There's an image classifier, a
sound classifier, a sentiment
02:55 - analysis model, as
well as a module
02:58 - for training your
own neural network.
03:01 - So I think I'm going to
go to the BodyPose page.
03:03 - Each model page includes
a description, a demo--
03:07 - let's run this demo here.
03:09 - I'm going to allow
it to use the camera.
03:11 - So I'm going to just
awkwardly stand up.
03:14 - So the BodyPose model,
you can see, captures
03:16 - 17 key points on the body--
03:19 - eyes, nose, hands, shoulders,
hips, knees, and toes.
03:24 - And this is actually--
this particular model
03:26 - that it's running
is called MoveNet.
03:28 - One of the wonderful
things about on the website
03:30 - is you can run the demo
here, but you can also click
03:33 - to just look at the example.
03:35 - And you can see the example
code here in the P5 editor
03:38 - and start playing
around with it yourself.
03:40 - More examples are linked below
as well as a step-by-step guide.
03:44 - And then, all the
way down on the page,
03:46 - there's more details about
the specific properties
03:49 - and functions for more detailed
documentation of everything
03:53 - you could do with
the BodyPose model.
03:55 - I also just want to
quickly highlight
03:57 - that the new ML5 has a body
segmentation model in it that
04:01 - will give you a colored
pixel map of every pixel
04:05 - and which part of your
body it's associated with.
04:08 - In a minute, I'm
going to show you
04:10 - how to import the new ML5
library and write code with it.
04:14 - But just in case
you happen to be
04:16 - a current user of the
previous versions of ML5,
04:19 - there's a lot of
models and functions
04:22 - that you still would have to
access by using version 12.2.
04:28 - So let's get started using ML5.
04:30 - I've got a completely
blank p5.js sketch.
04:34 - Now, normally, if I'm
working on a project that
04:37 - uses the ML5
library, I'm probably
04:39 - just going to click on one of
the examples which will already
04:41 - have the library imported.
04:42 - But I'm going to show
you here, step-by-step,
04:44 - if you're starting from
a blank p5.js sketch,
04:47 - how to import the ML5 library.
04:49 - If I click on the Getting
Started page and scroll down,
04:52 - there's some instructions
of how to do it here.
04:55 - But this is what
I'm looking for.
04:56 - I'm looking for this
script tag to where
05:00 - the ML5 library is hosted.
05:02 - And you'll notice this @1
because we're using version 1.0
05:06 - of ML5.
05:07 - I'm going to copy
this to the clipboard.
05:09 - I'm going to go back
to the index.html file
05:14 - in the p5.js sketch.
05:16 - You can see how the p5.js
libraries are being referenced
05:19 - here through script tags.
05:20 - And I can now just add by
pasting in the ML5 library.
05:25 - One thing I'll note
is that you want
05:28 - to make sure that you're using
the most recent version of P5.
05:32 - I'm going to show
you in a minute
05:33 - how some features in the
newest P5 work really well
05:37 - with the ML5 library.
05:38 - The next thing I'm going to
do, which is not related to ML5
05:41 - specifically, is
I'm going to open up
05:44 - a connection to the
webcam on this laptop
05:46 - and see that in the p5.js canvas
and create a variable called
05:51 - video.
05:52 - In Setup, I'm going
to call createCapture.
05:57 - And we can see
here already there
05:59 - am that is the DOM element
floating on the page separate
06:04 - from the canvas.
06:04 - Now could leave it there.
06:06 - But what I want to do eventually
is draw over top of the video.
06:10 - So in order to do that,
what I'm going to do
06:12 - is actually call video.hide
so you don't see it anymore.
06:15 - I'm going to change the
size of the canvas to 640
06:18 - by 480, which is the
size of the video,
06:21 - and then draw the video on the
canvas with the image function.
06:26 - I'm going to show
you something that's
06:27 - in the new version of P5 that
is incredibly exciting to me.
06:32 - Now I'm holding up my hand.
06:34 - This is my right
hand, but it's showing
06:36 - on the left side of the canvas
because it is not mirrored.
06:40 - And if you've ever watched
any of my other videos
06:43 - where I try to mirror
the video, I've
06:45 - got to look up
translate and scale
06:47 - and use a negative number
and all sorts of stuff.
06:50 - But the new P5, I can
actually add an option
06:53 - to the createCapture function
with a property called
06:57 - flipped and set it to true.
06:58 - Let's see what happens.
07:01 - I have a syntax error.
07:03 - I'm missing a comma.
07:05 - Look at that.
07:06 - And now, as I hold
up my left hand,
07:08 - it's on the left
side of the canvas.
07:10 - The video is mirrored,
which is incredibly
07:13 - useful for any kind of
interactive application
07:16 - where you want people to see
themselves reflected on a screen
07:18 - and interact with it.
07:19 - It's much more intuitive if that
video is flipped horizontally.
07:23 - All right, so that's it.
07:24 - We have the video.
07:25 - Now is the time to
incorporate ML5.
07:29 - All of the models,
whether you want
07:30 - to look for key points on the
full body, key points on a hand,
07:33 - or key points on the face,
they all work the same way.
07:37 - The first step is to
create a variable that
07:39 - will hold onto that particular
machine learning model.
07:42 - And I'm going to call
that variable faceMesh
07:44 - because we're going to
use the FaceMesh model.
07:48 - I'm going to navigate
over to the FaceMesh page
07:51 - on the documentation.
07:53 - Let's run the quick
start just to see
07:55 - what the example looks like.
07:56 - And you can see
all of the points
07:58 - that it's tracking on the face.
07:59 - Now you might be
wondering, wait a second,
08:02 - where does this even come from?
08:04 - The models that are available
in ML5 are not magic.
08:07 - There's not some magic system
that knows how to find your face
08:11 - and put key points all over it.
08:13 - The FaceMesh model--
and, in fact,
08:15 - all of the pose
detection models in ML5--
08:18 - come from the
TensorFlow project.
08:20 - And you can find
documentation around
08:22 - what are these models,
who trained them,
08:25 - what data sets they were used to
train on the TensorFlow website
08:28 - itself.
08:29 - And this is a really
important question to ask.
08:31 - If you are working with
a machine learning model,
08:33 - it's very helpful
for you to think
08:35 - about who owns this model,
who trained this model,
08:39 - and what data was used.
08:40 - That will really inform
whatever decisions
08:42 - you want to make about how
you want to use that model
08:44 - and in what context it's
going to work well for.
08:47 - In particular, when you're
tracking somebody's face,
08:50 - it's really important to be
thoughtful about these kinds
08:52 - of questions.
08:53 - Back to the documentation-- the
next thing that I want to do
08:56 - is load the model itself.
08:59 - I'm going to add
the preload function
09:01 - and say faceMesh
equals ml5.faceMesh,
09:06 - and let's see what happens.
09:08 - So every function
that you call in ML5
09:11 - is namespaced under
the variable name ml5.
09:16 - And, in fact, in setup, if I
say console.log(ml5.version),
09:20 - we'll see that version 1.0.1
is logged into the console.
09:25 - The next thing that I need to do
is somehow connect this FaceMesh
09:30 - model with the video.
09:33 - The way that I do that is with
a function called detect--
09:37 - and, in fact, in this
case, detectStart--
09:42 - start video.
09:45 - I've loaded the model, and I've
called the detectStart function,
09:48 - which will trigger the model
to continuously analyze
09:52 - the image from the video.
09:54 - Now there is also a function
called just detect then
09:57 - you can use if you
want to analyze
09:59 - a single image one time only.
10:01 - But with detectStart,
what I need to do--
10:04 - and you can see this
in the error message
10:06 - here-- is I need to add
a callback function.
10:09 - So the model returns
the results of what
10:13 - it finds in the
video asynchronously,
10:15 - meaning that after it's analyzed
the image, when the data is
10:19 - ready, it will
execute a function
10:21 - and pass the results
into that function.
10:23 - So I'm going to make up a name
of a function, call it gotFaces.
10:28 - I'm going to define
that function,
10:31 - and I need to give it an
argument which will hold
10:35 - the data, the results of
the machine learning model,
10:38 - and let's just see what's in
there-- console.log(results).
10:43 - One object-- so I'm
just one person.
10:46 - I have one face.
10:47 - So that's why we're
just seeing one object.
10:49 - But this model, presumably,
if a second person--
10:52 - do you want to prove
if this is true, Patt?
10:55 - Let's see if this is true.
10:56 - If you come here--
10:57 - I think you need to--
10:58 - Change the maxFaces?
11:00 - Right.
11:00 - This is important.
11:01 - But actually, the
FaceMesh model,
11:04 - I can also give it options.
11:06 - So I'm going to allow it to have
a maximum of five faces now.
11:10 - Yes, now we have two faces.
11:11 - There we go.
11:12 - All right, thank you
for that demonstration.
11:14 - But it's actually going to
be kind of convenient to work
11:16 - with it with just one face.
11:18 - So I'm going to take out--
11:19 - I'm going to put maxFaces
back to one right now.
11:22 - Here's another aspect
that's very important
11:24 - that I want to emphasize.
11:26 - Even though the model is being
loaded from the cloud, when you
11:30 - call ML5 FaceMesh, the model--
11:34 - a giant file with a
lot of numbers in it,
11:36 - basically-- is being downloaded
from one of Google's TensorFlow
11:40 - servers.
11:41 - That model itself is actually
executing in the browser.
11:45 - So the images that are
being seen from the camera
11:48 - and being sent to
the model are all
11:50 - happening on-device
inside your web browser.
11:53 - This is very important
and quite different
11:55 - than if you were using another
cloud-based service, where
11:59 - you're actually
sending your data,
12:00 - sending your images
to another server
12:02 - to be processed through a
model and then sent back.
12:05 - Everything is happening
on-device here.
12:07 - So the next step
that I need to do
12:10 - is I want to be able to draw
where those points on my face
12:14 - are on top of the Canvas.
12:16 - So I have the model, I have
the video, I have the results,
12:22 - but I don't have the results
inside of the draw loop.
12:25 - So to do that, I'm going to
create a global variable.
12:28 - I'm going to call it faces.
12:29 - I'm going to initialize
it with an empty array.
12:32 - So when the sketch
starts, it will
12:34 - assume it's detected no faces.
12:37 - And then I'm simply going to
pass that array, those results,
12:43 - into that faces variable.
12:45 - So now, inside of
the draw loop, I
12:47 - can access the global
variable faces.
12:50 - But before I do that,
let's actually go and add--
12:54 - I'm going to add the
mousePressed function.
12:56 - And in here, I'm going
to console.log the faces
12:59 - so we can just take
a look at what's
13:01 - inside the actual
object that holds
13:03 - all the results from the model.
13:05 - So let me make the
console a bit bigger.
13:07 - And I think it's
detecting my face.
13:09 - I'm going to click the
mouse, and there we go.
13:12 - Now I can start to look
inside of this object.
13:15 - So, first of all, it's an array
that holds one object, a face,
13:20 - and then all of
these properties.
13:22 - You could look at the
ML5 Reference page, which
13:25 - will have all the
documentation in terms
13:27 - of these properties
of the results object,
13:30 - as well as a diagram that shows
where all the points on the face
13:33 - are and what order in
the array they are.
13:35 - But, for now, one way we
can just figure it out
13:38 - is by poking through this
object in the console.
13:40 - You'll notice there's
a keypoints object.
13:42 - That is an array
with all 468 points.
13:46 - But one of the
things that ML5 does
13:49 - is it takes that raw
array of all the points
13:51 - and divides it into
parts and gives you a bit
13:53 - more information.
13:54 - So let's focus on
the lips for right
13:56 - now because I think
Patt's project is
13:57 - going to have to do with
opening and closing your mouth.
14:00 - So if I unpack
the lips object, I
14:01 - can see there's an x, a y,
a width, a height, center
14:05 - x, center y, as well as
an array of keypoints,
14:07 - and only 42 key points.
14:09 - So let's first see if we can
draw just the bounding box
14:13 - of your mouth.
14:14 - I have to remember I'm going
into faces, index 0, dot lips,
14:18 - dot x, y-- width, height.
14:20 - And I can do that
right here in draw.
14:23 - The first thing, though,
is I should probably
14:25 - check to make sure that it's
detected at least one face.
14:28 - I can use an if statement and
say if faces.length is greater
14:31 - than 0, then let the
face equal faces index 0.
14:35 - Let's just put it in
a separate variable.
14:37 - And then let's draw a rectangle
at face.x, face.y, face.width,
14:44 - face.height, stroke
weight of 4, no fill,
14:49 - and let's give it a nice, I
don't know, blue-ish, pinkish--
14:54 - I don't know, pick a
random color out of a hat.
14:56 - And let's see what we get.
14:59 - OK, I've made a mistake.
15:00 - Oh, I forgot dot lips.
15:02 - So there is no--
15:04 - that's interesting.
15:05 - Let's go back, and let's
look at the object.
15:08 - So I've made a mistake here.
15:09 - I went straight
for assuming there
15:11 - is some-- there is a box which
has the full bounding box
15:14 - of the face.
15:15 - But I'm looking for the
lips, so I forgot dot lips.
15:18 - So it might actually
be nice for me
15:19 - to say let lips equals
faces index 0 dot lips
15:24 - since that's what
I'm using here.
15:25 - And then I can change
face to lips here.
15:28 - And these should
be the properties.
15:30 - OK, let's see if it works now.
15:33 - There we go.
15:34 - Uh-oh, what happened?
15:35 - So one of the unfortunate
but beautiful things
15:39 - that's happening is that I
mirrored the P5 video, which
15:44 - is only mirroring the
way that it's displayed
15:47 - and not actually mirroring
the data that's being
15:49 - passed to the ML5 library.
15:52 - But guess what-- remember how
I was able to add a property
15:55 - called maxFaces to
FaceMesh, and there's
15:57 - lots of other properties
you could add,
15:59 - which are all on
the reference page?
16:01 - I can also add the
flipped property.
16:05 - And now look at that.
16:07 - And I don't know what I did.
16:09 - I thought I did no fill, but--
16:12 - oh, I typed fill here.
16:13 - OK, that was meant to be stroke.
16:15 - I wanted it to be see-through.
16:17 - There we go.
16:18 - So now you see that
this bounding box
16:20 - is tracking my mouth.
16:23 - If I wanted to look at the
specific points on the mouth,
16:28 - then I could actually dig
into not just the x/y width
16:31 - and height, but the key
points array itself.
16:35 - So I'm going to do a for of loop
to look at every point-- well,
16:39 - I shouldn't use the
variable name "point"
16:41 - because point is an
actual P5 function.
16:45 - So let's call it lipPoint.
16:48 - That's a weird name,
and I'll keep it.
16:50 - Let lipPoint of lips.keypoints--
16:52 - I think that's
what it's called--
16:54 - and then I can
just do a little--
16:57 - let's do a stroke weight of 2.
17:00 - And we'll make a green
color to differentiate it.
17:06 - And I'm going to
say make a point.
17:09 - That's why-- of
lipPoint.x and lipPoint.y.
17:15 - So I've got an error.
17:17 - Let's take a look--
lip.keypoints is not iterable.
17:20 - Let's go look again at
that object to see maybe
17:25 - where I went wrong.
17:28 - Oh, keypoints with
a lowercase p--
17:30 - I capitalized the p,
which is incorrect.
17:33 - If I had bothered to
look at the reference,
17:35 - I wouldn't have had that issue.
17:36 - So let's lowercase this p.
17:39 - And I think now--
17:40 - there we go.
17:41 - So you can see, in addition
to the bounding box,
17:44 - we now have the contours
of the actual lips itself
17:48 - that are being detected.
17:49 - And I could pick
specific points to track.
17:52 - I could use those to draw
other colors or shapes.
17:56 - I could give myself
a really bright shade
17:57 - of lipstick or something.
17:59 - I'm sure you're watching
this-- could come up
18:01 - with many more creative ideas.
18:03 - And, obviously, in addition
to simply just the lips
18:07 - part of the face, I could also
use the left eye, eyebrow,
18:11 - right eye, as well as the face
oval for all the other points.
18:15 - So that's the basic how-to to
load the model, open a video,
18:21 - pass the video to the
model, get the result,
18:24 - and then analyze the result
object and draw based on it.
18:27 - But what kinds of
creative projects
18:29 - might you be able
to make with that?
18:31 - Well, I'm going to turn it over
to Patt to see what she can do.
18:34 - What I want to do is I'm going
to step away from the sketch
18:37 - that Dan just made
and create another one
18:40 - to show you how to make the
kinetic topography sketch,
18:43 - and then we'll
combine it at the end.
18:46 - So we're going to start by
declaring a few variables.
18:49 - The first one is center.
18:51 - And center is going
to be a vector.
18:54 - And a vector is an object that
can hold two to three values.
18:57 - And I'm going to use it to hold
the x and y values of my center
19:02 - coordinates.
19:02 - So center will be
equals to createVector.
19:05 - And this is a method
within the vector class
19:08 - that allows us to
create a vector.
19:11 - And I'm going to give it in
the middle of the canvas.
19:13 - So let's do width divided by
2 and height divided by 2.
19:19 - And then another variable
that I want to create
19:21 - is going to be called
pos, for position,
19:24 - and I'm going to set
it as a vector as well.
19:27 - And let's give it at--
19:29 - how about 300 by 300.
19:31 - So it's going to be
at the bottom right
19:33 - corner of the sketch.
19:34 - Now inside draw, I'm going to
draw the positions of the center
19:39 - and the position vectors
using an ellipse function.
19:42 - And the ellipse function takes
in a total of four arguments.
19:45 - The first two are going to
be the x and y-coordinates
19:47 - of the center of the circle.
19:50 - So let's do center.x, center.y.
19:53 - And this is how you can
access the x and y-coordinates
19:56 - of the vector.
19:58 - And then let's give
it a size of 10 by 10,
20:01 - and I'm going to give
it a color black.
20:04 - So nothing's new here.
20:06 - We have a circle in the
middle of the canvas.
20:08 - Let's do one more,
give it a color red,
20:11 - and ellipse of pos.x,
pos.y, 10 by 10.
20:19 - So now what I want
to do next is that I
20:21 - want to move this red circle
in the direction of where it
20:27 - is from this black circle here.
20:29 - So we have to do a few things.
20:30 - The first thing we
need to do is that we
20:32 - need to figure out what is the
direction between these two.
20:36 - So first, we're going to find
the angle between the black dot
20:40 - and the red dot here.
20:42 - We're going to be
using trigonometry,
20:44 - and I think that has many
videos on this already.
20:48 - But, essentially,
we're going to find
20:49 - that the distance between the
x-coordinates of these two
20:52 - points and the y-coordinates
of these two points.
20:55 - And then we're going to use the
inverse tangent formula to find
20:58 - the angle between the two.
21:00 - So instead of just putting
everything inside draw,
21:02 - I'm going to create
another function.
21:05 - And let's call it calcAngle.
21:08 - And the parameters for these
are going to be center and pos.
21:13 - So it's going to be the two
vectors that we have right here.
21:18 - And then I'm going
to now define x
21:23 - to be equals to
center.x minus pos.x,
21:27 - and then y to be equals
to center.y minus pos.y.
21:31 - And then angle will be equals
to inverse tangent, which
21:36 - is a tan of y divided by x.
21:42 - Now we're going to return angle.
21:45 - And we're going to be doing
this in the radians mode.
21:48 - But I'm going to change it to
degrees first because it's more
21:53 - intuitive for me to understand.
21:55 - So we're going to change it by
using the function angleMode,
21:58 - change it to degrees,
and then, inside
22:02 - draw, I'm going to call
the function calcAngle
22:07 - and put in the two
points, center and pos,
22:09 - and then we're going to
print out the result, which
22:11 - should be the angle.
22:14 - And, as you can
see here, what we
22:16 - have here is the angle
45, which is what we want.
22:20 - So where the x-axis here is 0.
22:23 - If you go clockwise,
you get 45 degrees.
22:26 - It works when we're
in quadrant 1.
22:28 - So I'm going to call this
quadrant 1, 2, 3, and 4.
22:32 - Let's try a different point.
22:35 - So what if I put
in 100, comma, 300.
22:40 - So now it is in the
second quadrant,
22:43 - but the return value
is negative 45.
22:46 - But what we want is
actually 180 minus 45.
22:51 - So we are going to be writing
a few conditional statements.
22:54 - So let's start
with the first one.
22:55 - So if pos.x is greater than or
equals to center.x and pos.y
23:02 - is greater than or
equals to center.y.
23:06 - In the case where it is
in the first quadrant,
23:09 - then we'll just return angle.
23:11 - But else if pos.x is greater or
equal to center.x and pos.y is
23:20 - less than or equal to center.y,
which is the case that you are
23:24 - seeing right here, what we're
going to return is actually--
23:27 - it's going to be, what, 180
minus absolute value of angle.
23:33 - So if we do this and I click
Run, what did I do wrong?
23:38 - Oh, so it actually is less
than or equals to center.x
23:42 - And then this is more than
or equals to center.y.
23:46 - Now we get 135 degrees.
23:49 - Now I need to do two
more cases, which
23:52 - is when we're in the third
quadrant, which is here.
23:55 - So let's do 100 by 100.
23:58 - Now it's going to be else
if pos.x is less than
24:02 - or equal to center.x
and pos.y is less than
24:06 - or equals to center.y.
24:09 - So if I just return angle,
what we get would be 45.
24:14 - But what we want is 180 plus 45.
24:20 - And then, for the last case,
which would be 300, comma, 100--
24:27 - yes.
24:28 - What we want is else if pos.x
is greater or equal to center.x
24:34 - and pos.y is less than or equal
to center.y, then return angle.
24:43 - And what we have
here is negative 45.
24:46 - But what we want is actually 360
minus absolute value of angle.
24:54 - So we get 315 degrees.
24:56 - And actually, we also want to
do this as greater than but not
25:01 - equals to for the first case.
25:03 - So that none of these
conditional statements overlap.
25:08 - And I'm going to actually
delete the angle mode here
25:11 - because I want to be
using radians right now.
25:15 - So now that we
get the angle, now
25:18 - we want to get the direction
between these two points.
25:20 - And we can actually use a
method within the vector
25:23 - class called from angle.
25:25 - So we can do that easily,
and I'm going to do it
25:28 - inside a function.
25:30 - So let's do function--
25:32 - how about calcDir for direction?
25:36 - Actually, let's do Vel because
it's going to be a velocity.
25:39 - So velocity is
speed and direction
25:42 - at which this red circle
is going to be traveling.
25:46 - And then we're going to need
two parameters, the same ones,
25:49 - center and post.
25:51 - And then how about I declare
a variable called vel?
25:55 - And to call the P5 vector method
from angle, all we need to do
26:00 - is put in P5.Vector.fromAngle.
26:04 - And we want to put in the
angle that is returned
26:08 - from the calcAngle function.
26:10 - So how about I also create a
variable called angle, and then
26:15 - let's call this function
calcAngle with two arguments,
26:21 - center and pos.
26:22 - And then we just put
in angle in here.
26:25 - And let's return--
actually, let's draw a line.
26:30 - We're going to draw a line
between center.x center.y,
26:34 - center.x plus vel.x and
center.y plus vel.y.
26:43 - I want to draw a line
between these two points.
26:46 - And inside draw, I'm
going to call calcVel.
26:50 - All right, let's delete this.
26:52 - We don't need this.
26:53 - So calcVel, and it will
be center, comma, pos.
27:02 - There's no error, but we
don't see anything right now.
27:04 - Why is that?
27:06 - Let's print what vel is.
27:08 - And as you can see here, it's
an object with three values
27:13 - x, y, and z, but we only
have two values, x and y.
27:16 - And you can see that the
values are less than 1.
27:19 - So the magnitude is very small.
27:21 - So what we want to do is
we want to actually set
27:24 - a magnitude that is greater
than what it is right now.
27:27 - So we can do vel.setMag,
and this is also
27:32 - a method within a vector class.
27:34 - How about we set it to 100?
27:36 - Uh-oh-- oh, I changed
it to the radians mode,
27:40 - but I didn't change these
values, so 180 will be pi.
27:45 - This will be pi, and
then 360 will be 2 pi.
27:51 - And now we have this line that
almost there, but not yet--
27:55 - not there yet.
27:56 - And that is because the
distance between the black dot
27:59 - and the red dot is
actually greater than 100.
28:03 - But how do we figure out
what is that distance?
28:06 - We can do that easily using a
function called dist, D-I-S-T,
28:10 - which allows us to find
distance between two points.
28:14 - And we need to put in
four arguments, the x
28:17 - and y-coordinates
of the two points.
28:18 - So center.x, center.y,
and pos.x and pos.y.
28:25 - And then we want to put
in distance in here.
28:30 - So now that we find the
direction between these two
28:33 - points, now how do
we move the red dots?
28:36 - So let's come inside
the draw function.
28:38 - And now I'm going to actually
set this function here
28:43 - to a variable called vel.
28:45 - And then, instead
of actually drawing
28:49 - the ellipse using the x
and y-coordinates of pos.x
28:52 - and pos.y, what I'm
actually going to do
28:54 - is that I'm going to use
a translate function,
28:57 - and I'm going to
translate the origin
28:59 - point from the top
left corner here
29:01 - to the point where the dot is.
29:04 - So let's do pos.x
and pos.y, and then
29:09 - now, inside the ellipse
function, I can just do 0,
29:12 - comma, 0.
29:13 - Click Run.
29:14 - You should see the exact same
thing, but the line is gone.
29:18 - And that is because vel
was not defined earlier.
29:24 - So now I want to
move the red dot.
29:28 - I want to move it in
an oscillating motion.
29:30 - An oscillating motion is
a back-and-forth motion
29:33 - between a center point.
29:34 - And that center
point is going to be
29:36 - the point where it is right
now, which is the position--
29:39 - pos.x and pos.y.
29:40 - And I want to move
it back and forth,
29:42 - and I can use a sine
or cosine function.
29:46 - So the equation will be
how I define this variable
29:49 - as oscillation or osc.
29:52 - And we're going to use--
29:54 - let's use a sine function.
29:56 - And then, inside
the sine function,
29:57 - I'm going to put in 2
pi times angle here.
30:01 - And then, what we want is
that inside here, we're
30:05 - going to translate it by
vel.x, which is a vector,
30:09 - times osc, and then
vel.y times osc.
30:17 - Let's click Run.
30:20 - Angle is not defined.
30:21 - OK, let's define angle.
30:23 - Let angle equals to 0.
30:27 - 18-- oh, I forgot to return.
30:31 - So inside here, we also need
to return the vel vector.
30:38 - OK, perfect.
30:40 - But it's not moving because
we have not incremented
30:44 - the variable angle yet.
30:45 - So how about we
increment it by 0.005?
30:53 - All right, so now,
as you can see,
30:55 - it's oscillating
around this point here.
30:58 - The original position
where pos.x and pos.y was.
31:02 - So let's just try to change
it to something else.
31:05 - Let's do 150 by 150.
31:09 - So, as you can see
here also, the closer
31:13 - it is to the black dot here,
the smaller the magnitude
31:17 - at which it is oscillating
or the amplitude.
31:20 - Perfect-- now, what
I'm going to do
31:24 - is let's change from
a circle to a letter.
31:28 - And I'm going to comment
out this ellipse,
31:31 - and we're going to be using
a function called text,
31:35 - which takes in three arguments.
31:37 - The first one is a string of
text that we want to draw.
31:40 - I'm going to just
draw a letter A,
31:42 - and then we're going to put in
the x and y-coordinates as 0, 0.
31:49 - Yay.
31:51 - Now what I want to do is
I want to align the text
31:55 - to be at the center for
both x and y direction.
32:01 - All right, so now
it's at the center.
32:03 - And we can also set the
size of this string of text,
32:07 - and we can do it using
the function text size.
32:10 - But actually, what
I'm going to do
32:12 - is I'm going to use a
function called scale.
32:14 - And I'm going to--
32:16 - how about we scale
it by, let's say, 3.
32:19 - So that's really big.
32:21 - Let's do 2.
32:23 - Now that we have
this code ready,
32:25 - why don't we put
it inside a class
32:27 - before we make a bunch of them?
32:28 - So I'm going to come to this
arrow here, click the plus sign,
32:31 - and then click Create File.
32:33 - I'm going to call
this file letter.js.
32:37 - And then before we
start writing a class,
32:39 - make sure you go to index.html
and integrate this file
32:43 - into the whole program.
32:45 - So all you need to do is copy
and paste this line of code,
32:49 - change the name here to the name
of your new file-- in my case,
32:52 - letter.js-- and now we're ready.
32:56 - All right, so inside
the letter class,
32:58 - let's start with the word class.
32:59 - Let's call it letter.
33:01 - And then we're going to
write a constructor function.
33:04 - So what do we want to put
in the constructor function?
33:07 - Let's start by going back here.
33:10 - I'm going to keep center
as a global variable.
33:13 - And so is angle.
33:15 - So this angle is actually
different from the angle
33:18 - in the calcAngle here.
33:20 - Actually, I'm going to
change the name here to theta
33:23 - so that we're not confused
that they're different.
33:26 - So the angle variable
that is global
33:29 - is the variable for moving
the oscillating motion.
33:35 - And then, now what
we need to do is
33:38 - we want pos here to be part
of the constructor function.
33:42 - So this.pos will be
equal to createVector,
33:46 - and the parameter
will be x, comma, y.
33:49 - And then I'm going to write
a method called display,
33:54 - and then we're going
to put all of this
33:57 - here inside the display method.
34:03 - And then don't forget this dot.
34:04 - So this dot-- before I change
all this dot here, let's
34:08 - put these two functions,
calcAngle and calcVel,
34:12 - inside the class as well.
34:16 - And when you put the
functions inside the class,
34:20 - you don't need the
word function anymore.
34:23 - So we can delete that--
34:24 - and here, also.
34:28 - And then, now, it's time
to put in all the this dot.
34:31 - So center is a global variable,
so we don't need that.
34:34 - We are calling the calcVel
method inside the class,
34:37 - so we need this dot as well.
34:39 - We're going to put
this dot OSC and go,
34:42 - here is the global variable,
this dot post this dot Vel,
34:46 - this.osc--
34:48 - a lot of this dot here.
34:50 - That's it for here.
34:52 - And then, under here, we
don't need this inside.
34:56 - Put in this dot,
this dot, and then
34:59 - this dot, this dot, this dot,
this dot, this dot here, here,
35:07 - and here.
35:08 - We don't need this
inside the calcVel.
35:11 - We need this.calcAngle because
we're calling the method.
35:14 - And then we don't need
the parameter here.
35:17 - This will be this.vel.
35:19 - I'm going to call this
as this.distance as well,
35:22 - and this.pos,
this.vel, this.vel.
35:28 - And we don't need
the return function
35:29 - because it's already
part of this.vel variable
35:35 - inside this class.
35:36 - I hope this is all good.
35:38 - Why don't we just
start by creating
35:39 - this one object just to make
sure that the class is working?
35:43 - So I'm going to call
this variable l.
35:46 - And l is going to be
a new letter object.
35:49 - And we need two arguments, which
is the x and y coordinates.
35:53 - And I'm going to put
it as 150 by 150, just
35:57 - like what we have here.
36:00 - Then, in here, we're
going to call the display
36:03 - method-- so l.display.
36:08 - Uh-oh, it seems like I forgot
this dot for one of them.
36:13 - And actually, Dan has a song.
36:17 - OK, one more thing
that I missed--
36:21 - 9.
36:24 - I don't think I need to
set this.vel to this.
36:27 - So we can just call
this method here.
36:31 - All right, so now we
have the same thing
36:34 - but now inside a class.
36:35 - Now we're ready to make a
bunch of letters inside a grid.
36:39 - So I'm going to
start by creating
36:40 - an array called letters.
36:43 - And then we're going to create a
few more variables, cols, rows,
36:47 - and size.
36:49 - And I'm going to set
size to 20, actually.
36:52 - And then, inside
the setup function,
36:54 - first, what I'm
going to do is I'm
36:56 - going to calculate
cols and rows here,
36:59 - which will be determined based
on width divided by size,
37:03 - and rows will be
height divided by size.
37:07 - And now we're going to store
the objects inside a 2D array
37:10 - letters.
37:11 - And I'm going to use
a nested for loop.
37:14 - So let i equal to 0, i less
than cols, i plus plus,
37:18 - and then same thing for the j.
37:21 - So let j equals to 0, j less
than rows, and j plus plus.
37:26 - Now to create a 2D array
inside the outer loop here,
37:31 - we're going to populate this
letter array with a lot of empty
37:35 - arrays.
37:35 - And then, inside here, it's
going to be letters of i
37:40 - and j is going to be
new letter object.
37:43 - But what I'm going to put here
as the x and y arguments--
37:47 - what we need is x will be equals
to i times size, because it's
37:52 - going to be spaced out
by equidistance of size,
37:56 - and then let y equal
to j times size.
38:00 - And I'm going to
put x and y here.
38:02 - Now that we create
letter objects,
38:04 - we just need to display them
using the nested for loop.
38:07 - So I'm just going to copy this
down here, delete this, delete
38:13 - this, and just call
the display method.
38:23 - Whoa, what's going on here?
38:26 - I forgot something
important when
38:27 - you use any type of
transformation functions,
38:31 - which are the two main
functions, push and pop.
38:33 - So whenever you use
transformation functions,
38:35 - you need to think
about whether you
38:37 - want to save the transformation
and then return back
38:40 - to the default mode before you
call the next transformation
38:44 - functions, which is
the case right now.
38:46 - So inside the display method
here, we call translate,
38:50 - and we call scale.
38:51 - To use the push and pop
function, what you want
38:53 - is that you want to put it
before the transformation
38:56 - functions.
38:57 - And so it is going to save
the translate position
38:59 - here and then the scale.
39:01 - And then, afterwards,
we're going to put in pop.
39:04 - So it's going to return
back to the original default
39:07 - settings, which is when
the origin point is
39:10 - at the top left
corner of the canvas
39:12 - before you call the next
transformation functions.
39:15 - So if you do this, it
should fix the issue.
39:19 - Whoa-- it's pretty cool.
39:22 - All right, I'm going to delete
or comment out these lines.
39:27 - We don't need them right now.
39:33 - So as you can see,
all the letters
39:35 - are going from whatever
the amplitude is down
39:39 - to the 0 point.
39:40 - But what if I want it to
travel at a shorter distance?
39:45 - What I can do is actually I can
just multiply this magnitude
39:49 - here by a certain scale.
39:51 - Let's do-- how about 0.3?
39:54 - So you can see that it moves
a little bit at a shorter
39:58 - distance, basically.
39:59 - Instead of putting or
hardcoding this number,
40:02 - I'm going to actually set a
variable-- this.scl, for scale,
40:07 - and put it here.
40:09 - So we can just
change it as we want.
40:14 - And then let's go
back to sketch,
40:16 - and then I'm going to put in
0.3 in the constructor function
40:21 - here.
40:22 - Now what I want to do is I'm
going to comment out this angle.
40:27 - And, as you can see,
it's not in the center.
40:30 - Actually, I need to
fix this a little bit.
40:31 - So instead of just i times
size and j times size,
40:34 - I want to also add my size
divided by 2 for both of them.
40:40 - Perfect.
40:41 - Next, we are going to
actually now draw a rectangle.
40:47 - I just want to draw a
grid so that you can see.
40:49 - So i times size, j times
size, and then size, size--
40:56 - wow, OK.
40:57 - We also want no fill.
41:01 - And how about we scale down the
letter to just 1.2, maybe, here.
41:08 - So let's do 1.2 so it's smaller.
41:12 - I want to get that
feeling of, like, a wave.
41:17 - And we can do that by
actually add a little bit
41:20 - to the simple harmonic
motion equation.
41:23 - So we can add some
shifting and go here.
41:28 - So let's call it this.shift.
41:31 - And, actually, let us try it.
41:33 - If I shift it by--
41:35 - because this is in radians
mode, so if I shift it by 0.4,
41:40 - you can see that everything
is shifted a little bit.
41:44 - So what I want to
do is that I want
41:45 - to shift it based on its
distance from the center point.
41:50 - So I'm going to define
this as this.shift.
41:54 - And this.shift will be
mapped based on the distance.
42:00 - And between the value--
42:01 - how about I just do 0 to 1,000.
42:04 - And I know for this
particular sketch,
42:06 - the canvas size is 400 by 400.
42:08 - So, actually, the distance is
not up to 1,000, but that's OK.
42:12 - You can change or play
around with these values
42:14 - to get the look
that you want later.
42:16 - But I'm going to map it to
the values 10, comma, 0.
42:21 - Let's see what happens.
42:23 - It looks a little bit wavy here.
42:25 - I don't know if you can tell,
but why don't we first move it
42:30 - and to see what happens.
42:34 - Ta-da.
42:36 - That looks really cool.
42:37 - And I can actually stop
here, but I'm not going to.
42:40 - I'm going to make it a
little bit more interesting.
42:43 - And what we can do is
how about we also change
42:47 - the size of the letter A here.
42:49 - And we can do it in
a very similar way
42:52 - by using the oscillating motion.
42:54 - So we're going to actually
create another variable.
42:57 - Let's call it this dot--
43:00 - how about fontS.
43:02 - And we're going to set
it to be equals to--
43:05 - I want it to also
oscillating back and forth.
43:09 - So this.fontS is going to be
mapped to this oscillating
43:14 - motion, which is this.osc, which
will go between negative 1 and 1
43:21 - because the magnitude is just 1.
43:24 - And I want to map it to the
values of-- how about 0.5?
43:29 - Actually, let's
do 0, comma, 1.5.
43:33 - And you can play around
with these values as well.
43:36 - And we need to make sure that
we put this.fontS in here.
43:40 - Let's see.
43:44 - Wow, OK, so because
I put in 0, you
43:48 - can see that there is a point at
which the letters just go away.
43:52 - So you can actually-- if you
don't want that, you can do,
43:55 - let's say, 0.3 maybe.
43:59 - And, actually, another
interesting thing
44:01 - that I want to show is what
if we do this.fontS and set
44:06 - it equals to this.osc, which
oscillates between negative 1
44:09 - and 1.
44:11 - Do you see that?
44:12 - The letter actually flipped,
which is an interesting look.
44:15 - So play around and
see what you like.
44:18 - I'm going to keep it as this.
44:20 - And then, now what
I want to do is--
44:24 - because we're going
to be putting it back
44:27 - with the video part, I'm going
to set the canvas size to 640
44:32 - by 480.
44:33 - And then I'm going to set
the background to black.
44:37 - And, also, we don't need
the rectangle anymore.
44:41 - And then how about
we set the color
44:44 - of the ellipse in the middle or
the center as the color white,
44:49 - and then we're going to
set the font to white.
44:57 - There.
45:00 - All right.
45:01 - So the next thing--
what we can do
45:03 - is also what if
we move the center
45:05 - based on where the mouse is?
45:07 - So inside draw,
all we need to do
45:09 - is actually just set center.x to
be equals to mouseX and center.y
45:16 - to be equals to mouseY.
45:21 - There you go.
45:25 - And remember that
a variable scale--
45:27 - that controls how much
each of the letters travel.
45:31 - I'm going to play around
with that variable
45:33 - as well inside here.
45:35 - So how about I write a
conditional statement
45:37 - that says if mouseIsPressed--
45:41 - and mouseIsPressed
is a blunt variable
45:43 - that returns true when the
mouse is pressed and returns
45:46 - false when it is not--
45:47 - we're going to change
letters of i and j.scl--
45:52 - the scale-- to 1 when the
mouse is pressed or else,
45:57 - then we're going
to set it to 0.3.
46:03 - And I have a typo
here and then here.
46:09 - Let's try that.
46:11 - So the mouse is not pressed.
46:13 - The mouse is pressed.
46:15 - The mouse is not pressed.
46:16 - The mouse is pressed.
46:21 - One last thing that I want to
do, just to add a little bit
46:24 - more complexity to this--
46:26 - so instead of just sending
it right back to 0.3,
46:29 - when you release
the mouse, I'm going
46:31 - to write another
conditional statement that
46:33 - says if letters of i and
j.scl is more than 0.3,
46:40 - then I want to slowly
reduce it by 0.01.
46:46 - Then else here--
we're going to set it
46:48 - to this, just to
keep it a little bit
46:53 - of a nicer transition.
46:55 - I don't know if you
can really notice.
47:00 - Anyway, this part is all good.
47:03 - Now we're going to put
everything back together.
47:07 - All right, so when
you were not looking,
47:08 - I have already put
Dan's code with mine.
47:11 - I didn't change anything at all.
47:13 - We just combined
the two together.
47:14 - And, as you can see,
this is not the effect
47:16 - that we're looking for.
47:18 - So let's just edit
this a little bit.
47:20 - So first, I'm going
to hide the video.
47:22 - Actually, we don't
need it at all.
47:24 - And then, what we want is that
the face is already detected.
47:30 - I want to-- actually, instead
of just using the lips,
47:33 - I'm going to get
all the keypoints
47:35 - for the whole entire face.
47:37 - So let's define a
few more variables.
47:41 - So I'm going to actually
comment out Dan's code here,
47:45 - and I'm going to define
a variable called face.
47:48 - And let's set it equals
to faces with index 0
47:51 - because we're only
detecting one face.
47:53 - Then, I'm going to set another
variable called keypoints,
47:56 - and it's going to
be just face-- which
48:00 - is faces of 0-- dot keypoints.
48:04 - And then we're going to loop
through the entire thing.
48:07 - So i is equal to 0 to i
less than keypoints.length,
48:11 - i plus plus.
48:13 - And I want to draw
all the points out.
48:15 - So we're going to use
an ellipse function, put
48:18 - in the x and y-coordinates
of all the points.
48:22 - So keypoints of i.x
and keypoints of i.y.
48:28 - And let's set the size to be 2.
48:32 - And then let's fill it
with the color white.
48:36 - Let's try that.
48:38 - Can you see that?
48:39 - You see my face in the back
there because the circle
48:44 - is kind of small, a
little bit hard to see,
48:47 - but you can see that there
are so many points on my face.
48:51 - So, next, instead of using
lips, what I'm going to use
48:54 - is that I'm actually
going to pull out
48:56 - a specific point
on the mouth here.
49:00 - And I actually happen to
know what are those values.
49:04 - So let mouthTop equals to
keypoints with the index of 13.
49:11 - And let mouseBottom to be
equals to keypoints of index 14.
49:18 - And then let's just
draw these points out.
49:21 - So mouthTop.x, mouthTop.y--
let's do 10 by 10.
49:28 - Same thing for the bottom.
49:32 - And then let's color it white.
49:37 - Oops-- keypoints.
49:42 - You see the point on
my lips, on my mouth?
49:46 - Perfect.
49:47 - Now what I want, actually,
is the center point
49:51 - between these two points.
49:52 - And I'm going to define
some variables up here.
49:57 - I want to define mouthX, mouthY,
and mouthW for the width.
50:05 - And down here, what
I'm going to do
50:09 - is I'm going to calculate mouthX
to be equals to mouthTop.x
50:16 - plus mouthBottom.x divided by
2, and same logic for mouthY.
50:29 - And then let's just draw
out a circle for this point.
50:36 - mouthX, mouthY, 10 by 10--
50:41 - and we can draw it.
50:42 - We can put this back as well.
50:45 - And you can see, there's
the middle point there.
50:49 - And why am I doing this?
50:51 - I want to actually control
this instead of with the mouse
50:56 - location, but with
our mouth location.
51:00 - So now what we're going
to do is I'm going
51:03 - to comment out these 2 again.
51:05 - And then, instead of
sending center.x to be this,
51:09 - it's going to be
mouthX and mouthY.
51:17 - So you can see that
it's tracking the face.
51:22 - But if I open the mouth,
it doesn't do anything yet.
51:26 - But let's make it do something.
51:29 - So how about we set mouthW to
be equals to-- the calculation
51:34 - would be mouthBottom.y
minus mouthBottom.x.
51:42 - And I'm going to print this
out so you can see the value.
51:45 - So mouthW-- oh, it's
negative because it
51:51 - should be top minus bottom.
51:55 - Well, I did this wrong.
51:58 - It's mouthBottom.y
minus mouthTop.y.
52:07 - See, as I opened my mouth,
the value increases.
52:11 - So we can just set a threshold
at which we want to call this.
52:15 - So how about when I open my
mouth, it goes up to, like,
52:20 - 40-50 here, so we can just do--
52:23 - what did we just do 40?
52:24 - And where are we
going to put it--
52:25 - we're going to put it in
this conditional statement.
52:28 - Instead of mouseIsPressed,
we're going to do if mouth of W
52:33 - is greater than 45, maybe.
52:37 - Let's run.
52:41 - And there you go.
52:42 - So we're going to bring Dan
back so that he can play around
52:47 - with this sketch.
52:50 - Whoa.
52:55 - I love how you're drawing
all the points of the face,
52:57 - like, very subtly there.
53:00 - And then that's
the center point.
53:04 - Ah, OK, my mouth
didn't open as wide.
53:07 - [LAUGHTER]
53:08 - I just decreased this.
53:09 - Let's do 30.
53:16 - That is really fun.
53:18 - I wanted to check how--
53:21 - one thing I was curious about--
53:23 - I'm just looking
at your code here.
53:25 - So, ah, I see-- so you
pick specific points,
53:28 - and then you found
the top and the bottom
53:32 - and then average them.
53:34 - So it's interesting--
I'd be curious to see
53:37 - if we use the lips object,
which analyzes the lips
53:40 - and, in theory, finds
the center, if that's
53:43 - the same point or
a different point.
53:45 - But it's good to
see this technique.
53:49 - It'd be interesting to think
about what other kinds of text
53:52 - you could put in here.
53:53 - It's all the letter
A, but you could
53:54 - imagine this being like
a poem or it somehow
53:57 - is changing as you're
interacting with it.
53:59 - It's also maybe
something to consider
54:00 - as adding the lerp function
because, sometimes,
54:03 - the points that come for
the model-- it's actually
54:05 - quite smooth, but it's
a little bit jittery.
54:07 - And the lerp
function is something
54:09 - that anybody who's
watching could
54:10 - try to add for some smoothing.
54:13 - Amazing.
54:14 - Thanks, everybody, for watching.
54:16 - Thank you, Patt, so much for
demonstrating this project.
54:19 - Hopefully, you've gotten
both now a nice introduction
54:23 - to the new ml5.js library, and
I hope you try that out, as well
54:27 - as seeing how you could take a
creative computational design,
54:32 - which there are many,
many to choose from,
54:34 - from all of Patt's videos that
encourage you to go and check
54:37 - out and see how you
might combine them
54:39 - with interactivity from
the FaceMesh model,
54:42 - but you can also try
HandPose or BodyPose.
54:45 - And this video will be included
on the Coding Train website
54:49 - with the Passenger
Showcase page.
54:51 - So if you make something based
on this video, please share it.
54:55 - Don't forget to check out
Patt's channel and subscribe.
54:59 - And I'll see you next
time on The Coding Train.

Cleaned transcript:

Welcome to a very special episode of The Coding Train with our guest today, Patt Vira. Patt has an incredible number over 100, at least, already in the last year of tutorials and videos about p5.js creative coding. So if you like the coding train, you're going to like Patt's channel. I hope so. So we're here today to do a special collaboration. Patt happens to be in New York for ITP Camp. ITP is the program where I teach during the year. They run a monthlong program in June for Camp. And I just so happened that yesterday, I taught a quick workshop at ITP Camp on the ML5 library, which also just yesterday had a 1.0 release. So what we're going to do in this video is introduce to you the new release of the ML5 library, show you the new ML5 website. I'm going to give you a quick walkthrough of how to code some stuff in ML5. And then Patt's going to make it much more visually interesting and exciting. All right, so what is ml5.js? The ML5 project started in 2017 when researchers at Google were developing deeplearn.js. And we asked the question, could deeplearn.js, which was a library to run machine learning models in the browser, could we run those models with p5.js? deeplearn.js later became TensorFlow.js. And the ML5 project has had many years of development with different models and tutorials and examples. But in the last year, a group of us at NYU in New York and at NYU Shanghai have been working on updating the library to use a bunch of refreshed, new models for pose tracking, as well as some new functions for training a neural network, all of which I explore in a lot of detail in chapters 10 and 11 of my new Nature of Code Book, which think I've probably mentioned way too many times on this channel. So let's take a look at the ML5 website, and I can show you what some of the new features are. This is the new ml5.js website. I encourage you to take a look at the About page so you can learn all about all of the wonderful people who are contributing and building this library. The Getting Started page is probably where you want to begin, just to find a quick walk through of how to get started with the library and the p5.js editor. Under the Reference, you will see here, on the left, all of the machine learning models that are currently supported in ML5. There is a model for tracking body pose, for hand key points on your hand, key points on your face. That's what we're going to use for this tutorial today. There's an image classifier, a sound classifier, a sentiment analysis model, as well as a module for training your own neural network. So I think I'm going to go to the BodyPose page. Each model page includes a description, a demo let's run this demo here. I'm going to allow it to use the camera. So I'm going to just awkwardly stand up. So the BodyPose model, you can see, captures 17 key points on the body eyes, nose, hands, shoulders, hips, knees, and toes. And this is actually this particular model that it's running is called MoveNet. One of the wonderful things about on the website is you can run the demo here, but you can also click to just look at the example. And you can see the example code here in the P5 editor and start playing around with it yourself. More examples are linked below as well as a stepbystep guide. And then, all the way down on the page, there's more details about the specific properties and functions for more detailed documentation of everything you could do with the BodyPose model. I also just want to quickly highlight that the new ML5 has a body segmentation model in it that will give you a colored pixel map of every pixel and which part of your body it's associated with. In a minute, I'm going to show you how to import the new ML5 library and write code with it. But just in case you happen to be a current user of the previous versions of ML5, there's a lot of models and functions that you still would have to access by using version 12.2. So let's get started using ML5. I've got a completely blank p5.js sketch. Now, normally, if I'm working on a project that uses the ML5 library, I'm probably just going to click on one of the examples which will already have the library imported. But I'm going to show you here, stepbystep, if you're starting from a blank p5.js sketch, how to import the ML5 library. If I click on the Getting Started page and scroll down, there's some instructions of how to do it here. But this is what I'm looking for. I'm looking for this script tag to where the ML5 library is hosted. And you'll notice this @1 because we're using version 1.0 of ML5. I'm going to copy this to the clipboard. I'm going to go back to the index.html file in the p5.js sketch. You can see how the p5.js libraries are being referenced here through script tags. And I can now just add by pasting in the ML5 library. One thing I'll note is that you want to make sure that you're using the most recent version of P5. I'm going to show you in a minute how some features in the newest P5 work really well with the ML5 library. The next thing I'm going to do, which is not related to ML5 specifically, is I'm going to open up a connection to the webcam on this laptop and see that in the p5.js canvas and create a variable called video. In Setup, I'm going to call createCapture. And we can see here already there am that is the DOM element floating on the page separate from the canvas. Now could leave it there. But what I want to do eventually is draw over top of the video. So in order to do that, what I'm going to do is actually call video.hide so you don't see it anymore. I'm going to change the size of the canvas to 640 by 480, which is the size of the video, and then draw the video on the canvas with the image function. I'm going to show you something that's in the new version of P5 that is incredibly exciting to me. Now I'm holding up my hand. This is my right hand, but it's showing on the left side of the canvas because it is not mirrored. And if you've ever watched any of my other videos where I try to mirror the video, I've got to look up translate and scale and use a negative number and all sorts of stuff. But the new P5, I can actually add an option to the createCapture function with a property called flipped and set it to true. Let's see what happens. I have a syntax error. I'm missing a comma. Look at that. And now, as I hold up my left hand, it's on the left side of the canvas. The video is mirrored, which is incredibly useful for any kind of interactive application where you want people to see themselves reflected on a screen and interact with it. It's much more intuitive if that video is flipped horizontally. All right, so that's it. We have the video. Now is the time to incorporate ML5. All of the models, whether you want to look for key points on the full body, key points on a hand, or key points on the face, they all work the same way. The first step is to create a variable that will hold onto that particular machine learning model. And I'm going to call that variable faceMesh because we're going to use the FaceMesh model. I'm going to navigate over to the FaceMesh page on the documentation. Let's run the quick start just to see what the example looks like. And you can see all of the points that it's tracking on the face. Now you might be wondering, wait a second, where does this even come from? The models that are available in ML5 are not magic. There's not some magic system that knows how to find your face and put key points all over it. The FaceMesh model and, in fact, all of the pose detection models in ML5 come from the TensorFlow project. And you can find documentation around what are these models, who trained them, what data sets they were used to train on the TensorFlow website itself. And this is a really important question to ask. If you are working with a machine learning model, it's very helpful for you to think about who owns this model, who trained this model, and what data was used. That will really inform whatever decisions you want to make about how you want to use that model and in what context it's going to work well for. In particular, when you're tracking somebody's face, it's really important to be thoughtful about these kinds of questions. Back to the documentation the next thing that I want to do is load the model itself. I'm going to add the preload function and say faceMesh equals ml5.faceMesh, and let's see what happens. So every function that you call in ML5 is namespaced under the variable name ml5. And, in fact, in setup, if I say console.log(ml5.version), we'll see that version 1.0.1 is logged into the console. The next thing that I need to do is somehow connect this FaceMesh model with the video. The way that I do that is with a function called detect and, in fact, in this case, detectStart start video. I've loaded the model, and I've called the detectStart function, which will trigger the model to continuously analyze the image from the video. Now there is also a function called just detect then you can use if you want to analyze a single image one time only. But with detectStart, what I need to do and you can see this in the error message here is I need to add a callback function. So the model returns the results of what it finds in the video asynchronously, meaning that after it's analyzed the image, when the data is ready, it will execute a function and pass the results into that function. So I'm going to make up a name of a function, call it gotFaces. I'm going to define that function, and I need to give it an argument which will hold the data, the results of the machine learning model, and let's just see what's in there console.log(results). One object so I'm just one person. I have one face. So that's why we're just seeing one object. But this model, presumably, if a second person do you want to prove if this is true, Patt? Let's see if this is true. If you come here I think you need to Change the maxFaces? Right. This is important. But actually, the FaceMesh model, I can also give it options. So I'm going to allow it to have a maximum of five faces now. Yes, now we have two faces. There we go. All right, thank you for that demonstration. But it's actually going to be kind of convenient to work with it with just one face. So I'm going to take out I'm going to put maxFaces back to one right now. Here's another aspect that's very important that I want to emphasize. Even though the model is being loaded from the cloud, when you call ML5 FaceMesh, the model a giant file with a lot of numbers in it, basically is being downloaded from one of Google's TensorFlow servers. That model itself is actually executing in the browser. So the images that are being seen from the camera and being sent to the model are all happening ondevice inside your web browser. This is very important and quite different than if you were using another cloudbased service, where you're actually sending your data, sending your images to another server to be processed through a model and then sent back. Everything is happening ondevice here. So the next step that I need to do is I want to be able to draw where those points on my face are on top of the Canvas. So I have the model, I have the video, I have the results, but I don't have the results inside of the draw loop. So to do that, I'm going to create a global variable. I'm going to call it faces. I'm going to initialize it with an empty array. So when the sketch starts, it will assume it's detected no faces. And then I'm simply going to pass that array, those results, into that faces variable. So now, inside of the draw loop, I can access the global variable faces. But before I do that, let's actually go and add I'm going to add the mousePressed function. And in here, I'm going to console.log the faces so we can just take a look at what's inside the actual object that holds all the results from the model. So let me make the console a bit bigger. And I think it's detecting my face. I'm going to click the mouse, and there we go. Now I can start to look inside of this object. So, first of all, it's an array that holds one object, a face, and then all of these properties. You could look at the ML5 Reference page, which will have all the documentation in terms of these properties of the results object, as well as a diagram that shows where all the points on the face are and what order in the array they are. But, for now, one way we can just figure it out is by poking through this object in the console. You'll notice there's a keypoints object. That is an array with all 468 points. But one of the things that ML5 does is it takes that raw array of all the points and divides it into parts and gives you a bit more information. So let's focus on the lips for right now because I think Patt's project is going to have to do with opening and closing your mouth. So if I unpack the lips object, I can see there's an x, a y, a width, a height, center x, center y, as well as an array of keypoints, and only 42 key points. So let's first see if we can draw just the bounding box of your mouth. I have to remember I'm going into faces, index 0, dot lips, dot x, y width, height. And I can do that right here in draw. The first thing, though, is I should probably check to make sure that it's detected at least one face. I can use an if statement and say if faces.length is greater than 0, then let the face equal faces index 0. Let's just put it in a separate variable. And then let's draw a rectangle at face.x, face.y, face.width, face.height, stroke weight of 4, no fill, and let's give it a nice, I don't know, blueish, pinkish I don't know, pick a random color out of a hat. And let's see what we get. OK, I've made a mistake. Oh, I forgot dot lips. So there is no that's interesting. Let's go back, and let's look at the object. So I've made a mistake here. I went straight for assuming there is some there is a box which has the full bounding box of the face. But I'm looking for the lips, so I forgot dot lips. So it might actually be nice for me to say let lips equals faces index 0 dot lips since that's what I'm using here. And then I can change face to lips here. And these should be the properties. OK, let's see if it works now. There we go. Uhoh, what happened? So one of the unfortunate but beautiful things that's happening is that I mirrored the P5 video, which is only mirroring the way that it's displayed and not actually mirroring the data that's being passed to the ML5 library. But guess what remember how I was able to add a property called maxFaces to FaceMesh, and there's lots of other properties you could add, which are all on the reference page? I can also add the flipped property. And now look at that. And I don't know what I did. I thought I did no fill, but oh, I typed fill here. OK, that was meant to be stroke. I wanted it to be seethrough. There we go. So now you see that this bounding box is tracking my mouth. If I wanted to look at the specific points on the mouth, then I could actually dig into not just the x/y width and height, but the key points array itself. So I'm going to do a for of loop to look at every point well, I shouldn't use the variable name "point" because point is an actual P5 function. So let's call it lipPoint. That's a weird name, and I'll keep it. Let lipPoint of lips.keypoints I think that's what it's called and then I can just do a little let's do a stroke weight of 2. And we'll make a green color to differentiate it. And I'm going to say make a point. That's why of lipPoint.x and lipPoint.y. So I've got an error. Let's take a look lip.keypoints is not iterable. Let's go look again at that object to see maybe where I went wrong. Oh, keypoints with a lowercase p I capitalized the p, which is incorrect. If I had bothered to look at the reference, I wouldn't have had that issue. So let's lowercase this p. And I think now there we go. So you can see, in addition to the bounding box, we now have the contours of the actual lips itself that are being detected. And I could pick specific points to track. I could use those to draw other colors or shapes. I could give myself a really bright shade of lipstick or something. I'm sure you're watching this could come up with many more creative ideas. And, obviously, in addition to simply just the lips part of the face, I could also use the left eye, eyebrow, right eye, as well as the face oval for all the other points. So that's the basic howto to load the model, open a video, pass the video to the model, get the result, and then analyze the result object and draw based on it. But what kinds of creative projects might you be able to make with that? Well, I'm going to turn it over to Patt to see what she can do. What I want to do is I'm going to step away from the sketch that Dan just made and create another one to show you how to make the kinetic topography sketch, and then we'll combine it at the end. So we're going to start by declaring a few variables. The first one is center. And center is going to be a vector. And a vector is an object that can hold two to three values. And I'm going to use it to hold the x and y values of my center coordinates. So center will be equals to createVector. And this is a method within the vector class that allows us to create a vector. And I'm going to give it in the middle of the canvas. So let's do width divided by 2 and height divided by 2. And then another variable that I want to create is going to be called pos, for position, and I'm going to set it as a vector as well. And let's give it at how about 300 by 300. So it's going to be at the bottom right corner of the sketch. Now inside draw, I'm going to draw the positions of the center and the position vectors using an ellipse function. And the ellipse function takes in a total of four arguments. The first two are going to be the x and ycoordinates of the center of the circle. So let's do center.x, center.y. And this is how you can access the x and ycoordinates of the vector. And then let's give it a size of 10 by 10, and I'm going to give it a color black. So nothing's new here. We have a circle in the middle of the canvas. Let's do one more, give it a color red, and ellipse of pos.x, pos.y, 10 by 10. So now what I want to do next is that I want to move this red circle in the direction of where it is from this black circle here. So we have to do a few things. The first thing we need to do is that we need to figure out what is the direction between these two. So first, we're going to find the angle between the black dot and the red dot here. We're going to be using trigonometry, and I think that has many videos on this already. But, essentially, we're going to find that the distance between the xcoordinates of these two points and the ycoordinates of these two points. And then we're going to use the inverse tangent formula to find the angle between the two. So instead of just putting everything inside draw, I'm going to create another function. And let's call it calcAngle. And the parameters for these are going to be center and pos. So it's going to be the two vectors that we have right here. And then I'm going to now define x to be equals to center.x minus pos.x, and then y to be equals to center.y minus pos.y. And then angle will be equals to inverse tangent, which is a tan of y divided by x. Now we're going to return angle. And we're going to be doing this in the radians mode. But I'm going to change it to degrees first because it's more intuitive for me to understand. So we're going to change it by using the function angleMode, change it to degrees, and then, inside draw, I'm going to call the function calcAngle and put in the two points, center and pos, and then we're going to print out the result, which should be the angle. And, as you can see here, what we have here is the angle 45, which is what we want. So where the xaxis here is 0. If you go clockwise, you get 45 degrees. It works when we're in quadrant 1. So I'm going to call this quadrant 1, 2, 3, and 4. Let's try a different point. So what if I put in 100, comma, 300. So now it is in the second quadrant, but the return value is negative 45. But what we want is actually 180 minus 45. So we are going to be writing a few conditional statements. So let's start with the first one. So if pos.x is greater than or equals to center.x and pos.y is greater than or equals to center.y. In the case where it is in the first quadrant, then we'll just return angle. But else if pos.x is greater or equal to center.x and pos.y is less than or equal to center.y, which is the case that you are seeing right here, what we're going to return is actually it's going to be, what, 180 minus absolute value of angle. So if we do this and I click Run, what did I do wrong? Oh, so it actually is less than or equals to center.x And then this is more than or equals to center.y. Now we get 135 degrees. Now I need to do two more cases, which is when we're in the third quadrant, which is here. So let's do 100 by 100. Now it's going to be else if pos.x is less than or equal to center.x and pos.y is less than or equals to center.y. So if I just return angle, what we get would be 45. But what we want is 180 plus 45. And then, for the last case, which would be 300, comma, 100 yes. What we want is else if pos.x is greater or equal to center.x and pos.y is less than or equal to center.y, then return angle. And what we have here is negative 45. But what we want is actually 360 minus absolute value of angle. So we get 315 degrees. And actually, we also want to do this as greater than but not equals to for the first case. So that none of these conditional statements overlap. And I'm going to actually delete the angle mode here because I want to be using radians right now. So now that we get the angle, now we want to get the direction between these two points. And we can actually use a method within the vector class called from angle. So we can do that easily, and I'm going to do it inside a function. So let's do function how about calcDir for direction? Actually, let's do Vel because it's going to be a velocity. So velocity is speed and direction at which this red circle is going to be traveling. And then we're going to need two parameters, the same ones, center and post. And then how about I declare a variable called vel? And to call the P5 vector method from angle, all we need to do is put in P5.Vector.fromAngle. And we want to put in the angle that is returned from the calcAngle function. So how about I also create a variable called angle, and then let's call this function calcAngle with two arguments, center and pos. And then we just put in angle in here. And let's return actually, let's draw a line. We're going to draw a line between center.x center.y, center.x plus vel.x and center.y plus vel.y. I want to draw a line between these two points. And inside draw, I'm going to call calcVel. All right, let's delete this. We don't need this. So calcVel, and it will be center, comma, pos. There's no error, but we don't see anything right now. Why is that? Let's print what vel is. And as you can see here, it's an object with three values x, y, and z, but we only have two values, x and y. And you can see that the values are less than 1. So the magnitude is very small. So what we want to do is we want to actually set a magnitude that is greater than what it is right now. So we can do vel.setMag, and this is also a method within a vector class. How about we set it to 100? Uhoh oh, I changed it to the radians mode, but I didn't change these values, so 180 will be pi. This will be pi, and then 360 will be 2 pi. And now we have this line that almost there, but not yet not there yet. And that is because the distance between the black dot and the red dot is actually greater than 100. But how do we figure out what is that distance? We can do that easily using a function called dist, DIST, which allows us to find distance between two points. And we need to put in four arguments, the x and ycoordinates of the two points. So center.x, center.y, and pos.x and pos.y. And then we want to put in distance in here. So now that we find the direction between these two points, now how do we move the red dots? So let's come inside the draw function. And now I'm going to actually set this function here to a variable called vel. And then, instead of actually drawing the ellipse using the x and ycoordinates of pos.x and pos.y, what I'm actually going to do is that I'm going to use a translate function, and I'm going to translate the origin point from the top left corner here to the point where the dot is. So let's do pos.x and pos.y, and then now, inside the ellipse function, I can just do 0, comma, 0. Click Run. You should see the exact same thing, but the line is gone. And that is because vel was not defined earlier. So now I want to move the red dot. I want to move it in an oscillating motion. An oscillating motion is a backandforth motion between a center point. And that center point is going to be the point where it is right now, which is the position pos.x and pos.y. And I want to move it back and forth, and I can use a sine or cosine function. So the equation will be how I define this variable as oscillation or osc. And we're going to use let's use a sine function. And then, inside the sine function, I'm going to put in 2 pi times angle here. And then, what we want is that inside here, we're going to translate it by vel.x, which is a vector, times osc, and then vel.y times osc. Let's click Run. Angle is not defined. OK, let's define angle. Let angle equals to 0. 18 oh, I forgot to return. So inside here, we also need to return the vel vector. OK, perfect. But it's not moving because we have not incremented the variable angle yet. So how about we increment it by 0.005? All right, so now, as you can see, it's oscillating around this point here. The original position where pos.x and pos.y was. So let's just try to change it to something else. Let's do 150 by 150. So, as you can see here also, the closer it is to the black dot here, the smaller the magnitude at which it is oscillating or the amplitude. Perfect now, what I'm going to do is let's change from a circle to a letter. And I'm going to comment out this ellipse, and we're going to be using a function called text, which takes in three arguments. The first one is a string of text that we want to draw. I'm going to just draw a letter A, and then we're going to put in the x and ycoordinates as 0, 0. Yay. Now what I want to do is I want to align the text to be at the center for both x and y direction. All right, so now it's at the center. And we can also set the size of this string of text, and we can do it using the function text size. But actually, what I'm going to do is I'm going to use a function called scale. And I'm going to how about we scale it by, let's say, 3. So that's really big. Let's do 2. Now that we have this code ready, why don't we put it inside a class before we make a bunch of them? So I'm going to come to this arrow here, click the plus sign, and then click Create File. I'm going to call this file letter.js. And then before we start writing a class, make sure you go to index.html and integrate this file into the whole program. So all you need to do is copy and paste this line of code, change the name here to the name of your new file in my case, letter.js and now we're ready. All right, so inside the letter class, let's start with the word class. Let's call it letter. And then we're going to write a constructor function. So what do we want to put in the constructor function? Let's start by going back here. I'm going to keep center as a global variable. And so is angle. So this angle is actually different from the angle in the calcAngle here. Actually, I'm going to change the name here to theta so that we're not confused that they're different. So the angle variable that is global is the variable for moving the oscillating motion. And then, now what we need to do is we want pos here to be part of the constructor function. So this.pos will be equal to createVector, and the parameter will be x, comma, y. And then I'm going to write a method called display, and then we're going to put all of this here inside the display method. And then don't forget this dot. So this dot before I change all this dot here, let's put these two functions, calcAngle and calcVel, inside the class as well. And when you put the functions inside the class, you don't need the word function anymore. So we can delete that and here, also. And then, now, it's time to put in all the this dot. So center is a global variable, so we don't need that. We are calling the calcVel method inside the class, so we need this dot as well. We're going to put this dot OSC and go, here is the global variable, this dot post this dot Vel, this.osc a lot of this dot here. That's it for here. And then, under here, we don't need this inside. Put in this dot, this dot, and then this dot, this dot, this dot, this dot, this dot here, here, and here. We don't need this inside the calcVel. We need this.calcAngle because we're calling the method. And then we don't need the parameter here. This will be this.vel. I'm going to call this as this.distance as well, and this.pos, this.vel, this.vel. And we don't need the return function because it's already part of this.vel variable inside this class. I hope this is all good. Why don't we just start by creating this one object just to make sure that the class is working? So I'm going to call this variable l. And l is going to be a new letter object. And we need two arguments, which is the x and y coordinates. And I'm going to put it as 150 by 150, just like what we have here. Then, in here, we're going to call the display method so l.display. Uhoh, it seems like I forgot this dot for one of them. And actually, Dan has a song. OK, one more thing that I missed 9. I don't think I need to set this.vel to this. So we can just call this method here. All right, so now we have the same thing but now inside a class. Now we're ready to make a bunch of letters inside a grid. So I'm going to start by creating an array called letters. And then we're going to create a few more variables, cols, rows, and size. And I'm going to set size to 20, actually. And then, inside the setup function, first, what I'm going to do is I'm going to calculate cols and rows here, which will be determined based on width divided by size, and rows will be height divided by size. And now we're going to store the objects inside a 2D array letters. And I'm going to use a nested for loop. So let i equal to 0, i less than cols, i plus plus, and then same thing for the j. So let j equals to 0, j less than rows, and j plus plus. Now to create a 2D array inside the outer loop here, we're going to populate this letter array with a lot of empty arrays. And then, inside here, it's going to be letters of i and j is going to be new letter object. But what I'm going to put here as the x and y arguments what we need is x will be equals to i times size, because it's going to be spaced out by equidistance of size, and then let y equal to j times size. And I'm going to put x and y here. Now that we create letter objects, we just need to display them using the nested for loop. So I'm just going to copy this down here, delete this, delete this, and just call the display method. Whoa, what's going on here? I forgot something important when you use any type of transformation functions, which are the two main functions, push and pop. So whenever you use transformation functions, you need to think about whether you want to save the transformation and then return back to the default mode before you call the next transformation functions, which is the case right now. So inside the display method here, we call translate, and we call scale. To use the push and pop function, what you want is that you want to put it before the transformation functions. And so it is going to save the translate position here and then the scale. And then, afterwards, we're going to put in pop. So it's going to return back to the original default settings, which is when the origin point is at the top left corner of the canvas before you call the next transformation functions. So if you do this, it should fix the issue. Whoa it's pretty cool. All right, I'm going to delete or comment out these lines. We don't need them right now. So as you can see, all the letters are going from whatever the amplitude is down to the 0 point. But what if I want it to travel at a shorter distance? What I can do is actually I can just multiply this magnitude here by a certain scale. Let's do how about 0.3? So you can see that it moves a little bit at a shorter distance, basically. Instead of putting or hardcoding this number, I'm going to actually set a variable this.scl, for scale, and put it here. So we can just change it as we want. And then let's go back to sketch, and then I'm going to put in 0.3 in the constructor function here. Now what I want to do is I'm going to comment out this angle. And, as you can see, it's not in the center. Actually, I need to fix this a little bit. So instead of just i times size and j times size, I want to also add my size divided by 2 for both of them. Perfect. Next, we are going to actually now draw a rectangle. I just want to draw a grid so that you can see. So i times size, j times size, and then size, size wow, OK. We also want no fill. And how about we scale down the letter to just 1.2, maybe, here. So let's do 1.2 so it's smaller. I want to get that feeling of, like, a wave. And we can do that by actually add a little bit to the simple harmonic motion equation. So we can add some shifting and go here. So let's call it this.shift. And, actually, let us try it. If I shift it by because this is in radians mode, so if I shift it by 0.4, you can see that everything is shifted a little bit. So what I want to do is that I want to shift it based on its distance from the center point. So I'm going to define this as this.shift. And this.shift will be mapped based on the distance. And between the value how about I just do 0 to 1,000. And I know for this particular sketch, the canvas size is 400 by 400. So, actually, the distance is not up to 1,000, but that's OK. You can change or play around with these values to get the look that you want later. But I'm going to map it to the values 10, comma, 0. Let's see what happens. It looks a little bit wavy here. I don't know if you can tell, but why don't we first move it and to see what happens. Tada. That looks really cool. And I can actually stop here, but I'm not going to. I'm going to make it a little bit more interesting. And what we can do is how about we also change the size of the letter A here. And we can do it in a very similar way by using the oscillating motion. So we're going to actually create another variable. Let's call it this dot how about fontS. And we're going to set it to be equals to I want it to also oscillating back and forth. So this.fontS is going to be mapped to this oscillating motion, which is this.osc, which will go between negative 1 and 1 because the magnitude is just 1. And I want to map it to the values of how about 0.5? Actually, let's do 0, comma, 1.5. And you can play around with these values as well. And we need to make sure that we put this.fontS in here. Let's see. Wow, OK, so because I put in 0, you can see that there is a point at which the letters just go away. So you can actually if you don't want that, you can do, let's say, 0.3 maybe. And, actually, another interesting thing that I want to show is what if we do this.fontS and set it equals to this.osc, which oscillates between negative 1 and 1. Do you see that? The letter actually flipped, which is an interesting look. So play around and see what you like. I'm going to keep it as this. And then, now what I want to do is because we're going to be putting it back with the video part, I'm going to set the canvas size to 640 by 480. And then I'm going to set the background to black. And, also, we don't need the rectangle anymore. And then how about we set the color of the ellipse in the middle or the center as the color white, and then we're going to set the font to white. There. All right. So the next thing what we can do is also what if we move the center based on where the mouse is? So inside draw, all we need to do is actually just set center.x to be equals to mouseX and center.y to be equals to mouseY. There you go. And remember that a variable scale that controls how much each of the letters travel. I'm going to play around with that variable as well inside here. So how about I write a conditional statement that says if mouseIsPressed and mouseIsPressed is a blunt variable that returns true when the mouse is pressed and returns false when it is not we're going to change letters of i and j.scl the scale to 1 when the mouse is pressed or else, then we're going to set it to 0.3. And I have a typo here and then here. Let's try that. So the mouse is not pressed. The mouse is pressed. The mouse is not pressed. The mouse is pressed. One last thing that I want to do, just to add a little bit more complexity to this so instead of just sending it right back to 0.3, when you release the mouse, I'm going to write another conditional statement that says if letters of i and j.scl is more than 0.3, then I want to slowly reduce it by 0.01. Then else here we're going to set it to this, just to keep it a little bit of a nicer transition. I don't know if you can really notice. Anyway, this part is all good. Now we're going to put everything back together. All right, so when you were not looking, I have already put Dan's code with mine. I didn't change anything at all. We just combined the two together. And, as you can see, this is not the effect that we're looking for. So let's just edit this a little bit. So first, I'm going to hide the video. Actually, we don't need it at all. And then, what we want is that the face is already detected. I want to actually, instead of just using the lips, I'm going to get all the keypoints for the whole entire face. So let's define a few more variables. So I'm going to actually comment out Dan's code here, and I'm going to define a variable called face. And let's set it equals to faces with index 0 because we're only detecting one face. Then, I'm going to set another variable called keypoints, and it's going to be just face which is faces of 0 dot keypoints. And then we're going to loop through the entire thing. So i is equal to 0 to i less than keypoints.length, i plus plus. And I want to draw all the points out. So we're going to use an ellipse function, put in the x and ycoordinates of all the points. So keypoints of i.x and keypoints of i.y. And let's set the size to be 2. And then let's fill it with the color white. Let's try that. Can you see that? You see my face in the back there because the circle is kind of small, a little bit hard to see, but you can see that there are so many points on my face. So, next, instead of using lips, what I'm going to use is that I'm actually going to pull out a specific point on the mouth here. And I actually happen to know what are those values. So let mouthTop equals to keypoints with the index of 13. And let mouseBottom to be equals to keypoints of index 14. And then let's just draw these points out. So mouthTop.x, mouthTop.y let's do 10 by 10. Same thing for the bottom. And then let's color it white. Oops keypoints. You see the point on my lips, on my mouth? Perfect. Now what I want, actually, is the center point between these two points. And I'm going to define some variables up here. I want to define mouthX, mouthY, and mouthW for the width. And down here, what I'm going to do is I'm going to calculate mouthX to be equals to mouthTop.x plus mouthBottom.x divided by 2, and same logic for mouthY. And then let's just draw out a circle for this point. mouthX, mouthY, 10 by 10 and we can draw it. We can put this back as well. And you can see, there's the middle point there. And why am I doing this? I want to actually control this instead of with the mouse location, but with our mouth location. So now what we're going to do is I'm going to comment out these 2 again. And then, instead of sending center.x to be this, it's going to be mouthX and mouthY. So you can see that it's tracking the face. But if I open the mouth, it doesn't do anything yet. But let's make it do something. So how about we set mouthW to be equals to the calculation would be mouthBottom.y minus mouthBottom.x. And I'm going to print this out so you can see the value. So mouthW oh, it's negative because it should be top minus bottom. Well, I did this wrong. It's mouthBottom.y minus mouthTop.y. See, as I opened my mouth, the value increases. So we can just set a threshold at which we want to call this. So how about when I open my mouth, it goes up to, like, 4050 here, so we can just do what did we just do 40? And where are we going to put it we're going to put it in this conditional statement. Instead of mouseIsPressed, we're going to do if mouth of W is greater than 45, maybe. Let's run. And there you go. So we're going to bring Dan back so that he can play around with this sketch. Whoa. I love how you're drawing all the points of the face, like, very subtly there. And then that's the center point. Ah, OK, my mouth didn't open as wide. [LAUGHTER] I just decreased this. Let's do 30. That is really fun. I wanted to check how one thing I was curious about I'm just looking at your code here. So, ah, I see so you pick specific points, and then you found the top and the bottom and then average them. So it's interesting I'd be curious to see if we use the lips object, which analyzes the lips and, in theory, finds the center, if that's the same point or a different point. But it's good to see this technique. It'd be interesting to think about what other kinds of text you could put in here. It's all the letter A, but you could imagine this being like a poem or it somehow is changing as you're interacting with it. It's also maybe something to consider as adding the lerp function because, sometimes, the points that come for the model it's actually quite smooth, but it's a little bit jittery. And the lerp function is something that anybody who's watching could try to add for some smoothing. Amazing. Thanks, everybody, for watching. Thank you, Patt, so much for demonstrating this project. Hopefully, you've gotten both now a nice introduction to the new ml5.js library, and I hope you try that out, as well as seeing how you could take a creative computational design, which there are many, many to choose from, from all of Patt's videos that encourage you to go and check out and see how you might combine them with interactivity from the FaceMesh model, but you can also try HandPose or BodyPose. And this video will be included on the Coding Train website with the Passenger Showcase page. So if you make something based on this video, please share it. Don't forget to check out Patt's channel and subscribe. And I'll see you next time on The Coding Train.
