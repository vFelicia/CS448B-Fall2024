With timestamps:

00:00 - [BELL RINGING]
00:01 - Hello, and welcome
back to part 2
00:04 - of building your own
Processing library in Java.
00:06 - Look, I'm working with Eclipse!
00:09 - I love eclipse!
00:09 - All of you will complain
that I'm using Eclipse,
00:11 - and I don't care.
00:12 - I love Eclipse.
00:14 - It's one of the first
places I learned to program,
00:16 - so it has a special
place in my heart.
00:18 - So what I did in
the previous part--
00:19 - you're probably going to
want to go back to watch it
00:22 - if you're here and you didn't--
00:24 - was set up the
development environment,
00:26 - so install Eclipse, make sure
I have Processing installed,
00:30 - setup all the paths, the
build paths, the project,
00:32 - the template, the cloning,
all of that stuff.
00:35 - So what I am here right now, I
successfully built the library.
00:39 - So it shows up now in
Processing under Import Library.
00:43 - And, remember, I'm choosing
OpenSimplexNoise as the topic.
00:46 - It's very arbitrary, but
I want to build something
00:48 - that's actually useful and can
be published as a real library.
00:51 - But the library is here,
but if I click this,
00:54 - it automatically adds
the import statement,
00:57 - which you can see is
just template.library.*.
01:00 - So in this video, what I want
to do is code the library itself
01:06 - and make one example
that uses it.
01:09 - Probably the hardest
part of making a library
01:11 - is being thoughtful
about the design
01:13 - of the library API itself,
how you make the examples,
01:17 - as well as documenting it.
01:19 - So that's more of a
broader topic related
01:22 - to how to maintain and publish
an open-source library,
01:27 - but I'm going to mostly focus
on the technical details
01:30 - of building the thing.
01:32 - And maybe towards the end, I
can circle back and talk more
01:34 - about those key important
concepts and topics
01:38 - to having a healthy
open-source project.
01:42 - So first thing
that I want to do,
01:44 - if I want to
customize this, it I
01:45 - should say something
like "import
01:47 - shiffman.opensimplexnoise,"
or something like that.
01:49 - I mean, I don't think that's
what I'm going to call it.
01:51 - I'm going to go back to Eclipse.
01:53 - I'm going to go over here, and
I'm looking for under Source.
01:56 - And so, look, this is
what's known as a package,
01:58 - template.library.
02:00 - And so, because the package
name in the template
02:04 - is just "template.library,"
that's what the import was,
02:06 - template.library.
02:07 - So I'm going to
right-click on this,
02:09 - I'm going to go to
Refactor, and click Rename.
02:13 - And then I'm going
to come here, and I
02:15 - got to pick a name for it.
02:17 - Let's call it
"algorithms.noise."
02:22 - Ultimately, I think
what could be exciting
02:24 - about this library
is to implement
02:26 - a bunch of different noise
algorithms, OpenSimplex
02:29 - noise, fractal noise,
gradient noise, Worley noise.
02:32 - So many different kinds
of noise algorithms
02:34 - could be in here that would
be additions and enhancements
02:37 - to the built-in, original
Perlin noise algorithm that's
02:41 - in Processing itself.
02:42 - So that'll be my name.
02:44 - I'm going to click
OK, excellent.
02:47 - Now I want to go into
the source code, which
02:49 - is called "HelloLibrary."
02:51 - So I am going to
rename this also
02:55 - by going to Refactor, Rename.
02:57 - And I'm going to name that--
02:59 - let's call this particular
Java class "OpenSimplexNoise."
03:05 - And I'm going to do Finish.
03:08 - OK, great.
03:09 - I'm going to go over
here, and there we go.
03:11 - Let's try rebuilding
the library.
03:12 - We don't need to rebuild
it at every single stage,
03:15 - but let's just rebuild it to
see if what I did at least
03:18 - shows up with the proper
naming conventions.
03:20 - So I go to Window,
Show View, Ant.
03:23 - Click here, and do Ant Build.
03:26 - BUILD SUCCESSFUL is
what you're looking for.
03:30 - Go back to Processing,
Sketch, Import Library,
03:34 - OpenSimplexNoise.
03:36 - There we go!
03:38 - Interestingly, it's giving
me an error message.
03:40 - Let's try restarting Processing
and see what happens.
03:43 - All right, I
restarted Processing,
03:45 - and the error message went away.
03:47 - So certain things
that you change,
03:49 - if you're changing
the package name,
03:51 - even though the
new library files
03:53 - are being built and brought
over into Processing,
03:55 - Processing has loaded what
it thought all the package
03:58 - names were when it started
up, so you have to restart.
04:00 - So I don't think with
every single change
04:02 - you make while you're
building the library you're
04:04 - going to have to
restart Processing,
04:05 - but that certainly
is something you'll
04:06 - have to do from time to time.
04:08 - One of the things
I like to do when
04:10 - designing an open-source
library is actually
04:12 - write the example
first in the way
04:14 - that I imagine that it might be.
04:16 - So even though I
haven't built any
04:17 - of the functionality
of the library itself,
04:20 - what I want to do is I want
to take a simple processing
04:25 - Perlin noise example
that uses just
04:28 - the built-in original Perlin
noise from the 1980s algorithm,
04:31 - and then change that example
to use OpenSimplex noise.
04:35 - So if I go to
Examples, under Basics,
04:39 - under Math, let's
just take Noise1D,
04:44 - and let's look at this example.
04:46 - This Noise1D example is
mapping the x location
04:50 - of this circle it's
drawing to the noise
04:53 - implementation in Processing.
04:55 - So I'm going to
grab all this code,
05:00 - copy it, close this out,
and paste it in here.
05:05 - And I'm going to
imagine what I might do.
05:07 - So I might do something
like, OpenSimplexNoise noise.
05:14 - And then I'm going to say "noise
is a new OpenSimplexNoise."
05:20 - So presumably the idea
is that OpenSimplexNoise
05:22 - would be an object inside of
the package algorithms.noise.
05:26 - Maybe I want to name
that just "OpenSimplex,"
05:29 - because by definition
it's noise.
05:30 - Who knows, but I want to
create a new instance of it.
05:34 - Maybe, optionally,
there could be
05:36 - a seed that goes in
here, because I could
05:38 - be randomly seeding the noise.
05:41 - And then, what I
would do is, say--
05:45 - (CHUCKLING) and so let me
call it something different
05:48 - for it to be less confusion.
05:49 - Let me call it "osnoise"
for OpenSimplexNoise.
05:54 - And then, probably what
I would want to do is say
05:56 - "osnoise.value," pass
it this X offset.
06:02 - And, actually, that's it!
06:03 - Because, really,
this is such a like--
06:05 - even though the OpenSimplexNoise
algorithm is quite complex,
06:08 - I just want one function that
gives me the noise value back.
06:11 - And I'll call that value-- or,
I could have called it "noise."
06:14 - I don't know what to call it.
06:15 - But, again, these types of
naming an API design decisions,
06:19 - while incredibly important, I'm
going to maybe tackle later,
06:23 - and through user
testing and discussion,
06:25 - and are less crucial right now
in terms of the nuts and bolts
06:28 - of how to build your library.
06:29 - How to think about making
an open-source library,
06:33 - it's so important!
06:34 - But right now I can
just pick something.
06:36 - Let's pick value.
06:37 - Let me go back to
the library code.
06:40 - And I'm going to
add a function now.
06:42 - I'm going to add a function
called "public value."
06:46 - And it's going to receive an
argument, like X offset, xoff.
06:53 - And I'm going to say
"return negative 5."
06:58 - So I just want to
test out this idea.
07:00 - I want to add a
function called--
07:03 - oh!
07:04 - This should be
"public float value."
07:09 - Because it's a Java function
that returns a float.
07:12 - It receives a float.
07:13 - So, again, this is not the
OpenSimplexNoise (CHUCKLING)
07:16 - algorithm, but I am just
going to have it return
07:19 - negative 5 to see if it works.
07:22 - And let's actually just
give it the number 50.
07:26 - Well, actually, noise should
return a value between 0 and 1
07:30 - or, in this case, maybe
between negative 1 and 1.
07:34 - So let's actually
make it negative 0.5.
07:36 - And, in Java, if I
want it to be a float,
07:40 - I've actually got to add
that f to indicate float.
07:43 - So, once again, I am going
to build the library.
07:48 - The library is rebuilt.
Let's go back to the code.
07:52 - Oh, wait, I'm getting an error.
07:55 - "The constructor
OpenSimplexNoise noise
07:57 - is undefined."
07:58 - Why am I getting that error?
08:01 - Because I have a constructor
OpenSimplexNoise--
08:05 - oh!
08:06 - It needs this thing,
PApplet theParent.
08:10 - Ah-ha!
08:11 - What this is and how this
works, PApplet theParent,
08:16 - is probably something I
should tackle or address
08:18 - in maybe a third part or a
fourth part to this series
08:21 - because I don't
think that I need it
08:24 - for this particular
OpenSimplexNoise library.
08:27 - But this is a way of having
the library know something
08:31 - and communicate to or execute
functions in the user's sketch
08:35 - itself.
08:35 - It's not something I initially
need for OpenSimplexNoise,
08:38 - but let me just keep it
in here for right now.
08:40 - I'll decide later
if I can remove it.
08:42 - But there's-- this is not a
flaw of the library design.
08:46 - It's now a flaw of my code
where I need to say "this."
08:51 - The keyword "this" in Java
refers to "this class,"
08:55 - and your Processing
sketch is actually
08:57 - a class that's just hidden
from you when you're
08:59 - working in Processing itself.
09:00 - So now let me run this.
09:03 - And we could see
the negative 320.
09:05 - Why is it negative 320?
09:08 - Because I'm multiplying
it by width.
09:10 - So that's right, width is 640.
09:13 - The only noise value
I ever get back
09:15 - is negative 0.5,
multiplied by width is 320.
09:18 - So now we're
building the library
09:19 - and we added our own function
to a particular class
09:22 - in the library itself.
09:24 - The next step is let's actually
put in the OpenSimplexNoise
09:27 - algorithm.
09:28 - Here is the r-- it's raw source
code for Kurt Spencer's 2014
09:33 - implementation of
OpenSimplexNoise in Java.
09:36 - Now, there's a little
bit of an unfortunate
09:37 - thing, which this class is
also named "OpenSimplexNoise."
09:41 - Again, here I am back
to this naming thing.
09:43 - Everything is quite
difficult, but let's--
09:45 - let me first just bring
this into Eclipse.
09:47 - So there's a variety of
ways I could do that,
09:49 - but I'm just going
to copy paste it.
09:50 - So I'm going to make-- here,
I'm going to create a new class.
09:57 - And I'm going to call
it "OpenSimplexNoiseKS,"
10:03 - the KS for Kurt Spencer's.
10:05 - I want to keep that
implementation entirely intact.
10:10 - So I'm going to hit Finish.
10:12 - I am going to paste it in, and
then I am going to hit Save.
10:22 - And then, I need to
change this to KS.
10:27 - I need to add the
package declaration.
10:33 - And then, I need to
find other things.
10:34 - Like, this should be
KS, this should be KS,
10:38 - this should be KS,
this should be KS.
10:42 - There we go.
10:43 - Now that I have the
OpenSimplexNoise original
10:47 - implementation from Kurt
Spencer as a separate class
10:50 - here in my library, I
have a decision to make.
10:52 - Ultimately, what I want
is for that functionality
10:54 - to appear in my
OpenSimplexNoise class.
10:58 - And so I could extend the
OpenSimplexNoiseKS class,
11:01 - that would be known
as inheritance.
11:03 - Or I could really just wrap it
by making an object in here,
11:07 - like OpenSimplexNoiseKS
generator that
11:12 - is an instance of Kurt
Spencer's OpenSimplexNoise
11:18 - implementation.
11:19 - And this is referred
to as composition,
11:21 - maybe like wrapping another
class as an instance
11:25 - inside of a class.
11:26 - So the reason why I want to
do this is I'm trying to--
11:30 - I'm not trying to expose
the full implementation
11:33 - and just add a few window
dressing things to it.
11:36 - Although, that would
be a legitimate way
11:38 - of designing this library.
11:39 - But I'd rather do it this
way just to really hide that,
11:43 - but have my own set of
functions that make use
11:47 - of the implementation there.
11:49 - So I'm going to do that here.
11:50 - And then, so in
the constructor, I
11:54 - need to create a generator
equals new OpenSimplexNoiseKS.
12:01 - And then, in this
value function--
12:03 - and I don't need this
say hello function.
12:08 - The welcome function
is maybe nice to have.
12:10 - This set-- I'm going to
get rid of the set variable
12:13 - and get variables.
12:14 - Those are all just
template functions.
12:18 - But what I want to
do now is, instead
12:19 - of returning to some
arbitrary number,
12:21 - I want to return the generator.
12:23 - And the function inside
of the OpenSimplexNoise
12:27 - is called "eval."
12:29 - So maybe I'm actually
going to call this "noise."
12:32 - And the function's
called "eval."
12:34 - So I'm going to pass
X offset to eval.
12:39 - (CHUCKLING) The
thing is, the eval--
12:41 - the OpenSimplexNoise
implementation
12:43 - doesn't allow for one dimension.
12:45 - But for me to get
one dimension, I
12:47 - could always just pass as
the second argument a zero.
12:51 - So why do I have an error here?
12:54 - Let's look at what
this error might be.
12:56 - "Cannot convert from
double to float."
12:59 - Oh, right!
13:00 - Because OpenSimplexNoise
implementation
13:04 - is all done with doubles, but
processing and simplification
13:08 - only works with floats.
13:09 - So here's where I can now
change this to be a float.
13:13 - And there we go.
13:14 - So now I have
essentially wrapped
13:17 - the general-- the eval function,
which works in two dimensions,
13:21 - to work in one dimension
with floating-point numbers.
13:25 - And now, if I rebuild the
library, go back to Processing,
13:30 - and I'm going to run this.
13:34 - Oh, and it's called "noise" now.
13:36 - I renamed it from
"value" to "noise."
13:40 - So this circle is
disappearing off the screen
13:42 - because I'm getting
negative numbers.
13:44 - The built-in noise
implementation and processing
13:46 - always gives you a
value between 0 and 1,
13:49 - where as this OpenSimplexNoise
implementation gives you
13:51 - a value between
negative 1 and 1.
13:53 - So there's probably
some advantages
13:54 - for me keeping that range
between negative 1 and 1.
13:57 - But if I want to make
the case that what
13:59 - I want people to
be able to use this
14:00 - for is to have their current
Processing code just work out
14:05 - of the box by changing it to the
OpenSimplexNoise function, then
14:09 - maybe what I should do is,
here, I should actually say--
14:16 - I'm going to say--
14:17 - I'm going to just call a remap.
14:19 - I'm going to make a function
called "remap," private float--
14:24 - or, double remap, double val.
14:31 - And what I'm doing is I'm saying
"return val plus 1 times 0.5,"
14:41 - right?
14:42 - Because a value between
negative 1 and 1
14:44 - would shift between
0 and 2, divided by 2
14:47 - would shift between 0 and 1.
14:48 - So I'm going to do that.
14:50 - So I could rebuild
and test this,
14:52 - but I'm pretty sure that
correction will work.
14:54 - Let's now add functions
for 2D, 3D, and 4D noise
14:59 - to make sure those work as well.
15:01 - So I'm going to do this.
15:06 - (CHUCKLING) I'm just going
to do this a few more times.
15:09 - Then, I'm going
to add a Y offset.
15:14 - I'm going to add a Y
offset and a Z offset.
15:19 - And then, I'm going to add
a Y offset, a Z offset,
15:23 - and a U offset.
15:26 - And so this would be xoff, yoff.
15:32 - And, again, I could
refactor this to probably
15:34 - have them call each
other, but I think this
15:36 - will work fairly well for me.
15:39 - And then, here.
15:42 - So now we have 1D,
2D, 3D, and 4D noise.
15:51 - And I also should add
a constructor, which
15:54 - allows me to pass in a seed.
15:58 - So I'm going to say "int seed."
16:01 - And I'm going to pass that
seed to OpenSimplexNoise.
16:04 - And with no seed, maybe
I'll change it to just
16:06 - call the other constructor
"this" with theParent
16:13 - and a System.currentTimeMillis.
16:19 - So I'll use that as the seed.
16:22 - Ah, so I have an error here.
16:25 - Whoops.
16:26 - Oh, it's because
currentTime.Millis
16:28 - is a long data type.
16:31 - So maybe I'll
change this to long.
16:32 - I think that's probably
OK, because you can always
16:34 - give it an integer.
16:36 - And so there we go.
16:38 - So now I have two constructors.
16:40 - If I just say "OpenSimplexNoise
this," it'll pick a random seed
16:44 - or I can give it
a specific seed,
16:46 - and it'll generate
with that seed.
16:48 - So now I'm done [CLAPS]
with the basic functionality
16:50 - of this library that
I wanted to build.
16:52 - So let's go back
and build it again.
16:55 - So people who are watching
this live right now in the chat
16:58 - are rightfully complaining about
my redundant duplicated code
17:02 - here.
17:03 - At a minimum, let me refactor
this to just have the first 1D
17:07 - noise function.
17:08 - Just return this.noise
X offset, 0.
17:19 - I do think that the
implementations, as you
17:22 - get to higher dimensions,
run more slowly.
17:25 - So I don't actually want to call
those with fixed dimensions,
17:28 - but I only want to do
that for the first one.
17:30 - So, again, I'm
sure there's a way
17:32 - to optimize or refactor that.
17:33 - It'll come later in the
building this library,
17:35 - but I just want
to get it to work.
17:36 - Let me rebuild the
library one more time.
17:39 - Go back to Processing,
and run it.
17:46 - There we go.
17:46 - The same exact example, but
now with OpenSimplexNoise.
17:53 - I'm going to hit Save.
17:54 - And I'm actually going to now
make this one of the examples.
18:00 - Whoops.
18:01 - So I'm going to call
this, "OpenSimplex--
18:03 - "OSNoise1D."
18:07 - And then, I'm also going to
save this as "OSNoise2D."
18:13 - Let's also go and grab Noise2D.
18:18 - And we're going to
Sketch, Import Library,
18:23 - OpenSimplexNoise for Processing.
18:25 - I'm going to make a
OpenSimplexNoise noise
18:32 - instance.
18:33 - I going to say "noise equals new
OpenSimplexNoise noise this."
18:41 - Then, here I'm going
to say "noise.--
18:46 - oh, let's call this "OSNoise."
18:50 - And I'm going to
say, osnoise noise.
18:53 - And let's run this.
18:55 - Look, the same exact example,
but with OpenSimplexNoise!
19:00 - Change this to regular
noise and run it.
19:04 - It looks like this.
19:05 - Change this to "improved."
19:07 - What I would say is
improved OpenSimplexNoise,
19:10 - and it looks like this.
19:11 - So that's another example.
19:13 - And so now, you'll see,
by the way, in Eclipse,
19:16 - you can see that the
examples are showing up here.
19:18 - And I can get rid of
this hello example
19:20 - because I don't need that.
19:22 - I finally have a fully
functioning, working version
19:25 - of the library
with two examples.
19:28 - Here's the thing.
19:29 - There's a lot more
work for me to do.
19:31 - I haven't added
anything in the code
19:33 - comments that will help generate
documentation for the library.
19:37 - I haven't published
a library in a way
19:40 - that it would show up here under
Import Library, Add Library
19:44 - in this actual list here.
19:46 - This is a way of publishing
it to the Processing
19:48 - list of libraries itself.
19:50 - But this is a good
stopping point,
19:52 - because now I'm at a point
where you, the viewer,
19:55 - could actually use this library.
19:57 - So I will come back
and do a third video
20:00 - about cleaning up and
finalizing and publishing
20:03 - the library in a
more public way.
20:05 - But right now what I'm going
to ask of you, the viewer,
20:07 - is two things.
20:09 - Number one, go and download
and try this library yourself.
20:12 - So I'm going to
compress this folder
20:17 - and make a file called
"OpenSimplexNoise
20:19 - for noise Processing.zip."
20:21 - And I will add a link
to the GitHub repo.
20:26 - Here is the GitHub
repo for the library.
20:28 - If you go here, the link to this
is in the video's description.
20:30 - By the time you're
watching this,
20:32 - there will be more information
in this README about how
20:34 - to get your hands
on this zip file
20:37 - and manually install it to
your Processing download.
20:40 - So you can test the library.
20:42 - You can give me feedback by
filing an issue here on GitHub.
20:47 - No issues have been filed yet.
20:48 - And you could also contribute
to the functionality
20:51 - of this and documentation
of this library.
20:53 - So if you have
some time and would
20:55 - like to work out
filling out this JSDoc,
21:00 - information inside the
source code itself.
21:02 - If you really don't
like the way (CHUCKLING)
21:04 - I've written these
four noise functions
21:06 - and want to refactor
that, we can
21:08 - think about and have a
discussion about the API design
21:11 - decisions.
21:12 - And after I let that
cook for a little while,
21:15 - I'll come back and
do a third video
21:17 - to show you these updates, what
kinds of changes I've made,
21:20 - and how to take that final
last step to creating a website
21:24 - and publishing your Processing
library to a website,
21:27 - and having it appear in the
Processing contributions
21:30 - manager itself.
21:31 - All right, [CLAPS] I hope
this has been helpful to you.
21:33 - I look forward to seeing
this project grow.
21:35 - We can add some other
noise algorithms to it.
21:37 - There's going to be a
lot of fun in creating
21:39 - this open-source project
as a Coding Train community
21:41 - and adding it to
Processing itself.
21:43 - Thanks for watching, and
I'll see you sometime soon
21:46 - in the third part to the series.
21:47 - Goodbye!
21:48 - [TRAIN FLUTE SOUND]
21:49 - [THEME MUSIC]

Cleaned transcript:

[BELL RINGING] Hello, and welcome back to part 2 of building your own Processing library in Java. Look, I'm working with Eclipse! I love eclipse! All of you will complain that I'm using Eclipse, and I don't care. I love Eclipse. It's one of the first places I learned to program, so it has a special place in my heart. So what I did in the previous part you're probably going to want to go back to watch it if you're here and you didn't was set up the development environment, so install Eclipse, make sure I have Processing installed, setup all the paths, the build paths, the project, the template, the cloning, all of that stuff. So what I am here right now, I successfully built the library. So it shows up now in Processing under Import Library. And, remember, I'm choosing OpenSimplexNoise as the topic. It's very arbitrary, but I want to build something that's actually useful and can be published as a real library. But the library is here, but if I click this, it automatically adds the import statement, which you can see is just template.library.*. So in this video, what I want to do is code the library itself and make one example that uses it. Probably the hardest part of making a library is being thoughtful about the design of the library API itself, how you make the examples, as well as documenting it. So that's more of a broader topic related to how to maintain and publish an opensource library, but I'm going to mostly focus on the technical details of building the thing. And maybe towards the end, I can circle back and talk more about those key important concepts and topics to having a healthy opensource project. So first thing that I want to do, if I want to customize this, it I should say something like "import shiffman.opensimplexnoise," or something like that. I mean, I don't think that's what I'm going to call it. I'm going to go back to Eclipse. I'm going to go over here, and I'm looking for under Source. And so, look, this is what's known as a package, template.library. And so, because the package name in the template is just "template.library," that's what the import was, template.library. So I'm going to rightclick on this, I'm going to go to Refactor, and click Rename. And then I'm going to come here, and I got to pick a name for it. Let's call it "algorithms.noise." Ultimately, I think what could be exciting about this library is to implement a bunch of different noise algorithms, OpenSimplex noise, fractal noise, gradient noise, Worley noise. So many different kinds of noise algorithms could be in here that would be additions and enhancements to the builtin, original Perlin noise algorithm that's in Processing itself. So that'll be my name. I'm going to click OK, excellent. Now I want to go into the source code, which is called "HelloLibrary." So I am going to rename this also by going to Refactor, Rename. And I'm going to name that let's call this particular Java class "OpenSimplexNoise." And I'm going to do Finish. OK, great. I'm going to go over here, and there we go. Let's try rebuilding the library. We don't need to rebuild it at every single stage, but let's just rebuild it to see if what I did at least shows up with the proper naming conventions. So I go to Window, Show View, Ant. Click here, and do Ant Build. BUILD SUCCESSFUL is what you're looking for. Go back to Processing, Sketch, Import Library, OpenSimplexNoise. There we go! Interestingly, it's giving me an error message. Let's try restarting Processing and see what happens. All right, I restarted Processing, and the error message went away. So certain things that you change, if you're changing the package name, even though the new library files are being built and brought over into Processing, Processing has loaded what it thought all the package names were when it started up, so you have to restart. So I don't think with every single change you make while you're building the library you're going to have to restart Processing, but that certainly is something you'll have to do from time to time. One of the things I like to do when designing an opensource library is actually write the example first in the way that I imagine that it might be. So even though I haven't built any of the functionality of the library itself, what I want to do is I want to take a simple processing Perlin noise example that uses just the builtin original Perlin noise from the 1980s algorithm, and then change that example to use OpenSimplex noise. So if I go to Examples, under Basics, under Math, let's just take Noise1D, and let's look at this example. This Noise1D example is mapping the x location of this circle it's drawing to the noise implementation in Processing. So I'm going to grab all this code, copy it, close this out, and paste it in here. And I'm going to imagine what I might do. So I might do something like, OpenSimplexNoise noise. And then I'm going to say "noise is a new OpenSimplexNoise." So presumably the idea is that OpenSimplexNoise would be an object inside of the package algorithms.noise. Maybe I want to name that just "OpenSimplex," because by definition it's noise. Who knows, but I want to create a new instance of it. Maybe, optionally, there could be a seed that goes in here, because I could be randomly seeding the noise. And then, what I would do is, say (CHUCKLING) and so let me call it something different for it to be less confusion. Let me call it "osnoise" for OpenSimplexNoise. And then, probably what I would want to do is say "osnoise.value," pass it this X offset. And, actually, that's it! Because, really, this is such a like even though the OpenSimplexNoise algorithm is quite complex, I just want one function that gives me the noise value back. And I'll call that value or, I could have called it "noise." I don't know what to call it. But, again, these types of naming an API design decisions, while incredibly important, I'm going to maybe tackle later, and through user testing and discussion, and are less crucial right now in terms of the nuts and bolts of how to build your library. How to think about making an opensource library, it's so important! But right now I can just pick something. Let's pick value. Let me go back to the library code. And I'm going to add a function now. I'm going to add a function called "public value." And it's going to receive an argument, like X offset, xoff. And I'm going to say "return negative 5." So I just want to test out this idea. I want to add a function called oh! This should be "public float value." Because it's a Java function that returns a float. It receives a float. So, again, this is not the OpenSimplexNoise (CHUCKLING) algorithm, but I am just going to have it return negative 5 to see if it works. And let's actually just give it the number 50. Well, actually, noise should return a value between 0 and 1 or, in this case, maybe between negative 1 and 1. So let's actually make it negative 0.5. And, in Java, if I want it to be a float, I've actually got to add that f to indicate float. So, once again, I am going to build the library. The library is rebuilt. Let's go back to the code. Oh, wait, I'm getting an error. "The constructor OpenSimplexNoise noise is undefined." Why am I getting that error? Because I have a constructor OpenSimplexNoise oh! It needs this thing, PApplet theParent. Ahha! What this is and how this works, PApplet theParent, is probably something I should tackle or address in maybe a third part or a fourth part to this series because I don't think that I need it for this particular OpenSimplexNoise library. But this is a way of having the library know something and communicate to or execute functions in the user's sketch itself. It's not something I initially need for OpenSimplexNoise, but let me just keep it in here for right now. I'll decide later if I can remove it. But there's this is not a flaw of the library design. It's now a flaw of my code where I need to say "this." The keyword "this" in Java refers to "this class," and your Processing sketch is actually a class that's just hidden from you when you're working in Processing itself. So now let me run this. And we could see the negative 320. Why is it negative 320? Because I'm multiplying it by width. So that's right, width is 640. The only noise value I ever get back is negative 0.5, multiplied by width is 320. So now we're building the library and we added our own function to a particular class in the library itself. The next step is let's actually put in the OpenSimplexNoise algorithm. Here is the r it's raw source code for Kurt Spencer's 2014 implementation of OpenSimplexNoise in Java. Now, there's a little bit of an unfortunate thing, which this class is also named "OpenSimplexNoise." Again, here I am back to this naming thing. Everything is quite difficult, but let's let me first just bring this into Eclipse. So there's a variety of ways I could do that, but I'm just going to copy paste it. So I'm going to make here, I'm going to create a new class. And I'm going to call it "OpenSimplexNoiseKS," the KS for Kurt Spencer's. I want to keep that implementation entirely intact. So I'm going to hit Finish. I am going to paste it in, and then I am going to hit Save. And then, I need to change this to KS. I need to add the package declaration. And then, I need to find other things. Like, this should be KS, this should be KS, this should be KS, this should be KS. There we go. Now that I have the OpenSimplexNoise original implementation from Kurt Spencer as a separate class here in my library, I have a decision to make. Ultimately, what I want is for that functionality to appear in my OpenSimplexNoise class. And so I could extend the OpenSimplexNoiseKS class, that would be known as inheritance. Or I could really just wrap it by making an object in here, like OpenSimplexNoiseKS generator that is an instance of Kurt Spencer's OpenSimplexNoise implementation. And this is referred to as composition, maybe like wrapping another class as an instance inside of a class. So the reason why I want to do this is I'm trying to I'm not trying to expose the full implementation and just add a few window dressing things to it. Although, that would be a legitimate way of designing this library. But I'd rather do it this way just to really hide that, but have my own set of functions that make use of the implementation there. So I'm going to do that here. And then, so in the constructor, I need to create a generator equals new OpenSimplexNoiseKS. And then, in this value function and I don't need this say hello function. The welcome function is maybe nice to have. This set I'm going to get rid of the set variable and get variables. Those are all just template functions. But what I want to do now is, instead of returning to some arbitrary number, I want to return the generator. And the function inside of the OpenSimplexNoise is called "eval." So maybe I'm actually going to call this "noise." And the function's called "eval." So I'm going to pass X offset to eval. (CHUCKLING) The thing is, the eval the OpenSimplexNoise implementation doesn't allow for one dimension. But for me to get one dimension, I could always just pass as the second argument a zero. So why do I have an error here? Let's look at what this error might be. "Cannot convert from double to float." Oh, right! Because OpenSimplexNoise implementation is all done with doubles, but processing and simplification only works with floats. So here's where I can now change this to be a float. And there we go. So now I have essentially wrapped the general the eval function, which works in two dimensions, to work in one dimension with floatingpoint numbers. And now, if I rebuild the library, go back to Processing, and I'm going to run this. Oh, and it's called "noise" now. I renamed it from "value" to "noise." So this circle is disappearing off the screen because I'm getting negative numbers. The builtin noise implementation and processing always gives you a value between 0 and 1, where as this OpenSimplexNoise implementation gives you a value between negative 1 and 1. So there's probably some advantages for me keeping that range between negative 1 and 1. But if I want to make the case that what I want people to be able to use this for is to have their current Processing code just work out of the box by changing it to the OpenSimplexNoise function, then maybe what I should do is, here, I should actually say I'm going to say I'm going to just call a remap. I'm going to make a function called "remap," private float or, double remap, double val. And what I'm doing is I'm saying "return val plus 1 times 0.5," right? Because a value between negative 1 and 1 would shift between 0 and 2, divided by 2 would shift between 0 and 1. So I'm going to do that. So I could rebuild and test this, but I'm pretty sure that correction will work. Let's now add functions for 2D, 3D, and 4D noise to make sure those work as well. So I'm going to do this. (CHUCKLING) I'm just going to do this a few more times. Then, I'm going to add a Y offset. I'm going to add a Y offset and a Z offset. And then, I'm going to add a Y offset, a Z offset, and a U offset. And so this would be xoff, yoff. And, again, I could refactor this to probably have them call each other, but I think this will work fairly well for me. And then, here. So now we have 1D, 2D, 3D, and 4D noise. And I also should add a constructor, which allows me to pass in a seed. So I'm going to say "int seed." And I'm going to pass that seed to OpenSimplexNoise. And with no seed, maybe I'll change it to just call the other constructor "this" with theParent and a System.currentTimeMillis. So I'll use that as the seed. Ah, so I have an error here. Whoops. Oh, it's because currentTime.Millis is a long data type. So maybe I'll change this to long. I think that's probably OK, because you can always give it an integer. And so there we go. So now I have two constructors. If I just say "OpenSimplexNoise this," it'll pick a random seed or I can give it a specific seed, and it'll generate with that seed. So now I'm done [CLAPS] with the basic functionality of this library that I wanted to build. So let's go back and build it again. So people who are watching this live right now in the chat are rightfully complaining about my redundant duplicated code here. At a minimum, let me refactor this to just have the first 1D noise function. Just return this.noise X offset, 0. I do think that the implementations, as you get to higher dimensions, run more slowly. So I don't actually want to call those with fixed dimensions, but I only want to do that for the first one. So, again, I'm sure there's a way to optimize or refactor that. It'll come later in the building this library, but I just want to get it to work. Let me rebuild the library one more time. Go back to Processing, and run it. There we go. The same exact example, but now with OpenSimplexNoise. I'm going to hit Save. And I'm actually going to now make this one of the examples. Whoops. So I'm going to call this, "OpenSimplex "OSNoise1D." And then, I'm also going to save this as "OSNoise2D." Let's also go and grab Noise2D. And we're going to Sketch, Import Library, OpenSimplexNoise for Processing. I'm going to make a OpenSimplexNoise noise instance. I going to say "noise equals new OpenSimplexNoise noise this." Then, here I'm going to say "noise. oh, let's call this "OSNoise." And I'm going to say, osnoise noise. And let's run this. Look, the same exact example, but with OpenSimplexNoise! Change this to regular noise and run it. It looks like this. Change this to "improved." What I would say is improved OpenSimplexNoise, and it looks like this. So that's another example. And so now, you'll see, by the way, in Eclipse, you can see that the examples are showing up here. And I can get rid of this hello example because I don't need that. I finally have a fully functioning, working version of the library with two examples. Here's the thing. There's a lot more work for me to do. I haven't added anything in the code comments that will help generate documentation for the library. I haven't published a library in a way that it would show up here under Import Library, Add Library in this actual list here. This is a way of publishing it to the Processing list of libraries itself. But this is a good stopping point, because now I'm at a point where you, the viewer, could actually use this library. So I will come back and do a third video about cleaning up and finalizing and publishing the library in a more public way. But right now what I'm going to ask of you, the viewer, is two things. Number one, go and download and try this library yourself. So I'm going to compress this folder and make a file called "OpenSimplexNoise for noise Processing.zip." And I will add a link to the GitHub repo. Here is the GitHub repo for the library. If you go here, the link to this is in the video's description. By the time you're watching this, there will be more information in this README about how to get your hands on this zip file and manually install it to your Processing download. So you can test the library. You can give me feedback by filing an issue here on GitHub. No issues have been filed yet. And you could also contribute to the functionality of this and documentation of this library. So if you have some time and would like to work out filling out this JSDoc, information inside the source code itself. If you really don't like the way (CHUCKLING) I've written these four noise functions and want to refactor that, we can think about and have a discussion about the API design decisions. And after I let that cook for a little while, I'll come back and do a third video to show you these updates, what kinds of changes I've made, and how to take that final last step to creating a website and publishing your Processing library to a website, and having it appear in the Processing contributions manager itself. All right, [CLAPS] I hope this has been helpful to you. I look forward to seeing this project grow. We can add some other noise algorithms to it. There's going to be a lot of fun in creating this opensource project as a Coding Train community and adding it to Processing itself. Thanks for watching, and I'll see you sometime soon in the third part to the series. Goodbye! [TRAIN FLUTE SOUND] [THEME MUSIC]
