With timestamps:

00:00 - (bell dings)
00:01 - - Hello, and welcome
to a Coding Challenge.
00:02 - Woof! (gasps)
00:04 - If you can't tell, I'm really
excited about this one,
00:06 - so I found this GIF the
other day by Etienne Jacob,
00:12 - Etienne Jacob with my
American pronunciation,
00:14 - and look at it.
00:15 - It might look familiar to you.
00:16 - It looks like that heart curve
00:18 - that I made in a Coding
Challenge previously.
00:19 - Now, I can't say for sure
whether this GIF was made
00:22 - based on my heart curve Coding Challenge,
00:24 - but I can say for sure
that the work of Etienne
00:27 - is amazing, and phenomenal,
and uses a special technique,
00:31 - one that I have recently
rediscovered in a dream.
00:34 - It came to me in a dream, (giggles)
00:35 - and yet it's been on the
Internet at least since 2017,
00:38 - if not before that,
00:39 - so what's going on here that's
so fabulous and exciting
00:41 - is this chaotic scene,
00:44 - this scene of randomness
and smoky heart beauty
00:48 - is actually a perfect GIF loop.
00:51 - How is it that the end
matches the beginning?
00:54 - And this is something I talked about
00:55 - in my previous Coding Challenge, GIF loop,
00:58 - where we looked at, ah-kay, well,
00:59 - we can move something across the window.
01:01 - We can rotate something, and
as long as the last frame
01:04 - matches up with the
first frame it will loop,
01:05 - but if it's all random and
chaotic, how do you do that,
01:08 - and so there is a
technique for doing this.
01:11 - Golan Levin actually also
has an example bit of code
01:14 - which describes this in more detail,
01:16 - which I will show you later in this video,
01:19 - but mostly what I want
to do is highlight to you
01:21 - this blog post from Necessary Disorder,
01:24 - Etienne, from November 15th, 2017,
01:28 - which explains this technique
of creating GIFs like this.
01:31 - Here's another one!
01:33 - How could this even possibly work?
01:35 - And so to begin this discussion,
01:37 - I mean, hopefully we're
going to get to lots,
01:39 - I mean, I could probably
make videos on this topic
01:41 - for the rest of my life, (giggles)
01:44 - but to begin this topic
01:45 - I'm going to return to a
previous Coding Challenge.
01:48 - You may remember me from Coding Challenges
01:50 - such as Coding Challenge
number 36, blobby.
01:54 - It's when I used to wear T-shirts
01:56 - with this other logo on them
during my Coding Challenges,
01:59 - so what is the issue with blobby,
02:01 - so I'm actually, even though I
could just pull up that code,
02:04 - I'm going to (fingers snap)
speed-code blobby again.
02:06 - You're going to see, watch,
02:07 - this is like two Coding Challenges in one,
02:10 - so I'm going to what I'm going
to do is I'm just going to say,
02:15 - let a equal zero,
02:18 - a is less than TW0_PI,
02:21 - and what I'm going to do is
02:22 - I'm going to use my
polar-to-cartesian coordinate
02:24 - ♪ Song ♪
02:25 - and I'm going to say let x equal
02:28 - r times cosine of that angle.
02:31 - Let y equal r times sine of that angle,
02:34 - and then I'm going to
make up some value of r.
02:39 - r is going to be 100.
02:41 - I'm going to translate to
the center of the window,
02:45 - and then I am going to say beginShape.
02:49 - I am going to say endShape,
and I'm going to set a vertex,
02:54 - vertex at x, y, and I'm going to say,
02:58 - and I spelled TWO_PI with a zero,
03:00 - which is really complaining.
03:02 - I mean, I'm just saying,
stroke 255, and noFill,
03:07 - and there we go.
03:08 - Look, I just wrote the
code for drawing a circle
03:11 - because this is a for loop,
03:12 - I'm going to go through
all these different angles.
03:14 - I'm going to calculate.
03:15 - I'm going to increment the angle.
03:16 - I'm going to keep the radius constant,
03:19 - and I'm going to set all the
vertices x, y of the circle.
03:21 - Now, if r is random,
03:23 - and this is basically
what I did in blobby,
03:24 - if I say random 50 to
100, look what we've got.
03:28 - We've got this kind of like
crazy, flickering thing,
03:31 - and that's almost, that's kind
of interesting unto itself,
03:33 - and I could make this
a little more evident
03:35 - by making the time step,
03:37 - not the time step, the delta
angle, the amount of angle,
03:41 - the amount of vertices I'm drawing, fewer.
03:44 - I could make sure it connects
at the end by saying CLOSE,
03:47 - and I could also, just
for right now, say noLoop
03:51 - so we only get one of them,
03:52 - so each time I run this sketch
03:54 - I'm going to get a new random pattern.
03:56 - Now, here's the thing.
03:57 - This actually looks like
it's a nice, closed loop
03:59 - because it's all random.
04:00 - It doesn't matter if the last vertex
04:02 - doesn't match up with the first vertex,
04:04 - and I, it would be somewhat smart of me
04:07 - to be more thoughtful about
what this delta angle is,
04:10 - like maybe it should be something
04:11 - that divides perfectly into TWO_PI,
04:13 - or the radians equivalent of 360 degrees,
04:16 - but again, I'm not going
to worry about that.
04:17 - What I'm going to do is
04:19 - I'm now going to add Perlin noise to this.
04:21 - Now, if you've never heard
of Perlin noise before,
04:23 - I will refer you to a playlist
04:24 - where I talk about what Perlin
noise is, and how it works,
04:27 - and a whole bunch of other
videos (giggles) related to this,
04:30 - so go and watch those now if you want,
04:32 - or I also link to some
articles about Perlin noise,
04:34 - but I'm going to assume
knowledge of Perlin noise
04:36 - for the purpose of this Coding Challenge,
04:39 - so right now, what I'm going to do is
04:40 - I'm going to say let t equal zero,
04:43 - so I'm going to use t as my offset
04:45 - through the one-dimensional
Perlin noise space.
04:47 - I'm going to change that to
x offset in a little bit,
04:49 - but let's just keep it at t right now.
04:51 - Then I'm going to say r is noise
04:56 - of t times 100,
04:59 - so interestingly enough, let me,
05:01 - we get a different size circle
every time I run the sketch
05:06 - because we're getting a new,
05:08 - randomly seeded set of
Perlin noise values, (sighs)
05:13 - and I'm never moving
through that time space,
05:16 - so each vertex is exactly the same,
05:17 - so what I want to do
now is say, in the loop,
05:22 - t plus equal some amount of delta,
05:25 - so you now you can see look at this,
05:26 - ew, the amount is changing,
but it doesn't match up,
05:30 - so first of all, let me
clean this up a little bit
05:32 - by saying map, let me
use the map function,
05:34 - which I think will make
things a little simpler.
05:37 - Perlin noise always has a
range between zero and one,
05:39 - and let's say I want that range
05:40 - to go between like 100 and 200 now,
05:43 - so we can see, look at that.
05:44 - Now, there's just this
little every time I run it
05:47 - you can see that the
last Perlin noise value
05:50 - doesn't match the first one.
05:51 - This is the problem.
05:52 - This is getting at this idea
of a perfect Perlin noise loop,
05:56 - and let's also have delta t,
05:59 - the way I move through
the Perlin noise space.
06:02 - Siri, what should delta t be?
06:06 - (crickets chirping)
06:10 - (computer boops)
06:11 - Let me change that to this
06:12 - and you could see even if I move t faster,
06:15 - and I get this kind of
smoother blobby-like shape,
06:18 - it always has this artifact:
the last and by the way,
06:21 - if I took off this close,
this will be more evident.
06:24 - Why, right?
06:25 - The last vertex doesn't
match up with the first one.
06:29 - This is the problem,
06:30 - so I have my title of
this video right here,
06:33 - Perlin Noise Loops.
06:36 - Perlin noise,
06:37 - if we're talking about
one-dimensional Perlin noise,
06:40 - Perlin noise values in
a one-dimensional space,
06:44 - with this being the t-axis, the time axis,
06:47 - although really I should
call this x offset,
06:50 - 'cause it's like the x offset.
06:52 - This is maybe a graph of those values,
06:55 - and if I'm arbitrarily going
06:56 - from zero to some fixed endpoint
06:59 - as I get to the end of that circle,
07:01 - whatever value I get here,
which may be, let's say,
07:03 - if this is between like zero and one,
07:05 - maybe this is 0.3,
07:08 - and this is like 0.621, right?
07:11 - They don't match up.
07:12 - If I were to take this and
twist it around into a circle,
07:16 - they don't match up.
07:18 - There is another way
07:19 - to look at a space of Perlin noise values.
07:22 - This is a way of looking
at it in one dimension.
07:24 - Let's now look at it in two dimensions,
07:28 - so instead of having a sort
of one-dimensional graph
07:32 - of Perlin noise values,
07:34 - I present to you
07:36 - a grid of Perlin noise values.
07:39 - The idea is each one of
these represents some value
07:42 - between zero and one.
07:43 - Now, in this two-dimensional space,
07:46 - each one of these values represents,
07:48 - uh, is also a number between zero and one,
07:50 - so I might have like 0.2
here, 0.3 here, and 0.31 here,
07:54 - and 0.26 here, and 0.19 here, right?
07:56 - Every single space has a value.
07:58 - Now, here, in one dimension,
08:00 - any number in one-dimensional space
08:02 - is quite similar to its neighbors,
08:05 - and it only has two neighbors:
08:06 - a neighbor on the left and
a neighbor on the right,
08:08 - or a neighbor after and a neighbor before.
08:10 - Here, each value has how many neighbors?
08:13 - One, two, three, four,
five, six, seven, eight.
08:15 - It has neighbors above,
and neighbors below,
08:18 - and neighbors to the right,
and neighbors diagonally down,
08:20 - so the idea here is that
08:23 - what if I could walk around
08:27 - through a two-dimensional
Perlin noise to get space
08:30 - to get random values and always
end up back where I started?
08:35 - And why not just walk in a circular path?
08:37 - I mean, that's kind of what
I'm programming anyway,
08:40 - so why not just do that?
08:41 - What if I were to start here
08:42 - and get this Perlin noise
value, then this one,
08:45 - then this one, then
this one, then this one,
08:46 - then this one, then this one,
then this one, then this one,
08:48 - then this one, then
this one, then this one,
08:50 - then this one?
08:51 - I would have one, two,
three, four, five, six,
08:54 - seven, eight, nine, 10, 11, 12,
08:57 - 13 random numbers,
09:00 - and the last one is going to
match up with the first one
09:03 - if I keep going,
09:04 - so I could get those random
numbers over and over again,
09:06 - and if the amount of
numbers there is so vast,
09:09 - it's going to appear
09:10 - like it is a continuous
sequence of total randomness,
09:13 - smoothed with Perlin noise,
09:14 - so this is the theory,
09:15 - so let's now go and apply this theory
09:18 - to this particular blobby shape,
09:21 - so before I get back to the blobby code,
09:23 - what I have here is a processing sketch
09:25 - that is visualizing Perlin noise
in a two-dimensional space,
09:28 - so this a pretty sort of
like classic visualization
09:31 - of 2-D Perlin noise as
this cloudy like texture,
09:35 - and this is literally
(giggles) exactly this,
09:39 - where each number,
09:40 - each random Perlin noise value
in the two-dimensional space,
09:44 - is represented as a pixel
09:45 - with a brightness value
between zero and 255,
09:48 - and when you look at that you
get this cloud-like pattern
09:52 - because the color seamlessly,
smoothly moves between white,
09:56 - to black, to gray, to
black, to gray, to white,
09:59 - so the idea here is what
is what I want to do
10:02 - is walk around this space and
pull those numeric values,
10:07 - but map them to something
else besides a pixel value,
10:09 - and walking around in a circle
10:11 - is a nice way to create a loop,
10:12 - but you don't necessarily
10:14 - have to have that be in the circle.
10:16 - All right, so let's go
back to the blobby code.
10:17 - Now, there's a (giggles) a
bit confusing about this,
10:20 - because in addition
10:21 - to the walking around
the Perlin noise space
10:23 - in a circular path,
10:24 - I also happen to be walking
around the 2-D canvas
10:27 - in circular path to draw
this circular shape,
10:31 - so I'm kind of using the same idea,
10:33 - but with two different points of view,
10:36 - and hopefully that is something
that makes sense to you.
10:39 - Hmm, okay, so what I
want to change this is
10:43 - I no longer want to have t.
10:46 - What I want to have is x offset
10:49 - and a y offset,
10:51 - and I want to get the Perlin
noise at x offset, y offset,
10:56 - so this is now what I had before if the,
10:59 - if the x offset and the y offset,
11:01 - right, basically, if what I'm doing is
11:04 - I'm asking for what is the
Perlin noise value at this spot
11:10 - it's going to give me some random value,
11:12 - and then it's going to make
that the radius of the circle,
11:15 - the blob shape, as it
goes all the way around,
11:17 - so I want to start moving,
11:18 - but I actually don't want to start here.
11:19 - I want to start over here, so
I have to deal with the fact
11:24 - that I need to find this point
11:25 - if zero, zero's in the top-left,
11:26 - 'cause I can't have negative values
11:28 - in the Perlin noise space,
11:29 - so this is a little bit
of a tricky piece of this,
11:31 - but I want to use that same
11:33 - polar two-cartesian-coordinate formula,
11:35 - or I want to say x offset
equals cosine of that angle,
11:39 - y offset equals sine of that angle.
11:41 - Now, look at this.
11:43 - I've kind of got something,
but it's weirdly symmetrical,
11:47 - and the reason is this exactly
what I just alluded to.
11:50 - These x offset and y offset values
11:53 - are going between negative one and one,
11:55 - and so in fact I'm trying to
look at Perlin noise values
12:00 - over here, right, and
these, this doesn't exist.
12:03 - The Perlin noise space is all positive,
12:05 - so there's actually a very
simple solution to this,
12:08 - which is just to add one,
12:10 - and let me add the CLOSE back in,
12:13 - and let's run this a bunch of times,
12:15 - and we can see, there we go,
12:16 - we have this nice random blobby shape
12:19 - where the end matches the beginning.
12:21 - Now, I want to do, let's
do some more stuff here.
12:24 - All right, so first of all,
12:29 - what happened to that like incrementer?
12:31 - What happened to t plus equal 0.01?
12:34 - Now I have x offset and y offset.
12:36 - Why aren't I saying x
offset plus equal one,
12:39 - 0.1 y offset plus equal one, one,
12:41 - well, actually, the incrementer is this.
12:44 - It is the 0.1 here.
12:46 - It's cosine of the angle,
12:48 - and in truth (giggles) I could (gasps)
12:51 - have a separate variable
12:53 - from the one that's
incrementing in the loop,
12:56 - 'cause I could move through,
12:58 - but I need to go all the way to TWO_PI,
13:00 - so that I don't want to do.
13:00 - I think a way for me to vary
this in a more flexible way
13:04 - is actually to use the map function,
13:05 - so if I map cosine of a,
13:08 - which goes between negative one and one,
13:10 - and then map that to a
range between zero and two,
13:15 - we have, and this is sine,
13:19 - we have exactly what I had
before, and I can keep,
13:23 - I can keep rewriting the sketch,
13:25 - and I'm getting a new
version of the shape,
13:27 - but interestingly enough, what happens?
13:30 - This is really now something
that I should make a parameter,
13:33 - so for example, what if I were to say let,
13:36 - I'm going to make this a global variable,
13:38 - let, I'm going to call
this noiseMax equal two,
13:43 - and I'm going to put this here,
13:46 - and watch what happens
if I make this five,
13:48 - versus 10, versus 120,
13:52 - versus 0.1,
13:54 - and look at this, 0.3, 0.5, look at this.
13:58 - This is really kind of interesting.
14:01 - With just a little bit of noise,
14:03 - I have what appears almost
like a perfect circle,
14:06 - but it kind of looks like
a human being like me
14:10 - with faults, I have lots of faults,
14:12 - drew that circle.
14:14 - It's got some slight so Perlin noise
14:16 - can actually be used as a nice way,
14:17 - with a little subtle Perlin noise,
14:19 - of making some perfect shape,
14:21 - like a letterform, or
a circle, or a square,
14:23 - have a little bit of wiggle to it
14:25 - that makes it seem more hand-drawn,
14:27 - so that's a nice thing to see.
14:28 - The other thing we could see
here very quickly is like,
14:31 - it would make sense for
me to create a slider.
14:36 - I'm going to say,
14:37 - and this I'm using the p5
dom library to do this,
14:39 - which is a really quick way.
14:40 - I'm going to create a
slider which has a range
14:42 - between like 0.1 and 10,
14:45 - and I'm going to start it at,
14:47 - actually let's make it
between zero and 10,
14:49 - and I'm going to start it at zero,
14:52 - so I have the slider here now,
14:53 - and then I want noiseMax to equal,
14:58 - noiseMax to equal
slider.value, so watch this.
15:04 - Okay, that didn't work. (giggles)
15:06 - Oh, I have noLoop in here.
15:07 - No wonder.
15:08 - Take out the noLoop,
and now let me slide it.
15:12 - Oh, we need to make that,
15:13 - so first of all I need to
give myself smaller time steps
15:16 - when moving the slider, so let's do this.
15:20 - Oh, look at that.
15:21 - Look how it kind of like unfurls,
15:23 - because it's the same noise space;
15:25 - I'm just stretching or shrinking it.
15:28 - That is a really
15:29 - imagine now if I oscillated
that like along a sine wave,
15:32 - so another thing that I
could demonstrate to you
15:34 - is interesting, like a
always starts at zero,
15:38 - 'cause I'm going from zero to TWO_PI,
15:40 - but if I am walking around
the path of a circle,
15:43 - there's no reason why I
couldn't start over here
15:45 - and then go around, or start
over here and then go around,
15:47 - and why not vary that?
15:48 - That would be like the phase.
15:50 - You go back to my Fourier,
all of this stuff,
15:52 - it's so crazily interrelated it's amazing,
15:55 - but if you go back to my
Fourier transform videos,
15:58 - where we created these orbiting epicycles,
16:00 - we had this concept of phase,
16:01 - which is where does that orbit start,
16:04 - so let me show you another thing here.
16:07 - Okay, what I'm going to do is show you
16:11 - so let me make a variable called phase,
16:13 - and we have that be zero.
16:15 - I'm going to have cosine
of angle plus phase,
16:18 - sine of angle plus phase,
16:20 - what do you think's going to
happen if I increment phase?
16:25 - Well, it looks like the shape is rotating.
16:27 - I mean, it is rotating,
or it's not rotating.
16:29 - I mean, visually it's rotating,
16:30 - but I'm actually just starting
16:32 - at a different point in the noise space.
16:34 - Interestingly enough, like,
16:36 - and if I make that much smaller,
you'll actually see that,
16:39 - like smaller than the
amount of vertices I have,
16:41 - you start to see a wiggle
between them, so interest,
16:44 - like I could make this 0.2,
16:45 - and that's going to be even more apparent.
16:48 - Like, look at that crazy weird wiggle
16:51 - as those vertices adjust their spot,
16:54 - and then I want to show you
something even crazier, I think,
16:57 - like let me put it back.
16:58 - Let me sync it so this is
like a nice perfect rotation.
17:02 - What if I only apply the phase
17:04 - to the x offset or the y
offset, like different phases?
17:09 - That is really, oh, it's kind of too fast,
17:11 - so let me do like this.
17:14 - Like, this is really weird.
17:16 - You can sort of see
17:17 - it's almost like there's something
crawling around the edge.
17:20 - (screams in mock horror)
17:20 - There's so much weirdness stuff going on,
17:22 - so anyway you see the sort of
like exciting possibilities
17:27 - of thinking about Perlin noise values
17:30 - as one-dimensional,
17:31 - values that might pull over time
17:33 - in a sort of one-dimensional fashion,
17:36 - but actually pull them
from the path of a circle
17:39 - in the two-dimensional Perlin noise space.
17:42 - Now, what I happen to be doing in this
17:43 - is taking a very literal
approach. (giggles)
17:45 - I'm taking those Perlin noise path values
17:48 - walking around a circle,
17:50 - and applying them to like the distance
17:52 - from the center of a circle over,
17:55 - as I'm drawing it, so it's very like,
17:57 - it's a very literal sort
of like visualization
17:59 - of Perlin noise values in a circle
18:01 - to the edge points of a circle,
18:02 - but if you start to think of other ways
18:06 - you could apply those values,
18:08 - the creative possibilities explode,
18:11 - and so in other words, if
this is what I started with,
18:15 - I have Perlin noise at the beginning.
18:19 - Sorry, I have Perlin noise
values in one-dimensional space,
18:22 - but they don't loop,
18:23 - why not take those looping values here,
18:27 - along the path of a circle,
18:28 - and then unfurl them
18:29 - back into the sort of
one-dimensional line,
18:33 - and then use those
18:34 - to apply to any value in any visualization
18:37 - to make a perfect GIF loop.
18:38 - That's the idea, so I'm going
to just put that out there.
18:41 - I'm putting this out into the universe.
18:42 - I mean, I didn't put
it out in the universe.
18:43 - Lots of other people, Etienne, and Golan,
18:45 - and many others I'm sure
I'm forgetting to reference,
18:47 - have done this for years,
so give that a try.
18:52 - In the next video I'm going to
come back and actually do that,
18:54 - so I'm going to see if
I can take this idea
18:57 - and just apply it to something.
18:58 - Probably won't be that
visually interesting,
19:00 - but this will hopefully
give you lots of ideas
19:02 - of what you might make.
19:04 - Let's add one more thing to this.
19:05 - I think I can.
19:06 - This video's not too long so far.
19:08 - All right, let's add one
more thing, so first of all
19:09 - let me take out this idea
of phase for a second.
19:12 - Just going to comment that out
and put it back to what it was,
19:15 - which is just this,
19:17 - so every time I run it I get
a new Perlin noise space,
19:21 - and incidentally,
19:22 - the only reason why I'm getting
a new Perlin noise space
19:24 - is because p5, behind the scenes,
19:28 - will seed Perlin noise with
a random seed each time,
19:32 - but I could actually control it.
19:33 - If I were to say noiseSeed,
19:37 - and pick some arbitrary seed value,
19:38 - and random number seeds is
maybe a topic for another video.
19:41 - Every time I run this
19:43 - I'm going to get exactly
the same shape each time,
19:45 - so anyway, just pointing that out,
19:46 - but there is something else.
19:48 - There is another way I could animate this,
19:49 - and it has to do with
three-dimensional Perlin noise,
19:53 - and Perlin noise can exist
in any n-dimensional space.
19:56 - In p5 and in processing,
19:57 - I think the functions that give it to you
20:00 - just support one, two,
and three dimensions,
20:01 - but let's talk about
20:02 - how you might use three dimensions here,
20:04 - so for example, if this is my
visualization of Perlin noise
20:08 - in two-dimensional
space, that cloudy image,
20:13 - well, I could make sort of
like a cloudy set of cubes
20:16 - in three-dimensional space,
20:17 - but another way of thinking about it is
20:19 - have that third dimension
be slices of an animation,
20:22 - so I could show you the Perlin noise space
20:27 - over time
20:28 - while incrementing a z-value, a z offset,
20:31 - and show you Perlin noise
for a z offset equals zero,
20:34 - then z offset equals
0.1, then 0.2, then 0.3,
20:37 - and so that actually, all
of those will have numbers.
20:41 - Each one of these numbers is now
20:42 - has all of its neighbors to up, and down,
20:46 - and left, and right, and
forward, and backward,
20:48 - are similar random values,
20:50 - so this is actually a really
easy thing for me to add.
20:52 - I just need one more global
variable called z offset,
20:56 - and this needs to be global
20:57 - 'cause I'm not resetting it
back every time through draw.
21:01 - Each time through draw
I'm incrementing it,
21:03 - and I can just add zoff right there
21:07 - to the Perlin noise function,
21:09 - and then I can say zoff plus
equal some amount, like 0.1,
21:12 - and you can see we get this wiggle.
21:14 - I can make it 0.01,
21:15 - and I'm going to move through
the Perlin noise space
21:17 - much more slowly,
21:19 - and once again we could see, like,
21:20 - there's all sorts of
things I could do here,
21:22 - like this could be 0.3,
and this could be 0.1.
21:26 - There's so many parameters
that you can explore here.
21:29 - I think we've made, actually,
a super-interesting shape
21:32 - for like a crazy animated
game version of Asteroids,
21:35 - like you can imagine having Perlin noise
21:37 - jiggling, oscillating, looping, noisy,
21:40 - polar Asteroids.
21:42 - That's a thing you should make,
21:43 - so anyway, so I hope you find
some variations for this,
21:47 - and I look forward to
seeing what you make,
21:49 - and stay tuned for the next video.
21:51 - (bell dings)
21:52 - (playful music)
21:59 - (bell dings)

Cleaned transcript:

(bell dings) Hello, and welcome to a Coding Challenge. Woof! (gasps) If you can't tell, I'm really excited about this one, so I found this GIF the other day by Etienne Jacob, Etienne Jacob with my American pronunciation, and look at it. It might look familiar to you. It looks like that heart curve that I made in a Coding Challenge previously. Now, I can't say for sure whether this GIF was made based on my heart curve Coding Challenge, but I can say for sure that the work of Etienne is amazing, and phenomenal, and uses a special technique, one that I have recently rediscovered in a dream. It came to me in a dream, (giggles) and yet it's been on the Internet at least since 2017, if not before that, so what's going on here that's so fabulous and exciting is this chaotic scene, this scene of randomness and smoky heart beauty is actually a perfect GIF loop. How is it that the end matches the beginning? And this is something I talked about in my previous Coding Challenge, GIF loop, where we looked at, ahkay, well, we can move something across the window. We can rotate something, and as long as the last frame matches up with the first frame it will loop, but if it's all random and chaotic, how do you do that, and so there is a technique for doing this. Golan Levin actually also has an example bit of code which describes this in more detail, which I will show you later in this video, but mostly what I want to do is highlight to you this blog post from Necessary Disorder, Etienne, from November 15th, 2017, which explains this technique of creating GIFs like this. Here's another one! How could this even possibly work? And so to begin this discussion, I mean, hopefully we're going to get to lots, I mean, I could probably make videos on this topic for the rest of my life, (giggles) but to begin this topic I'm going to return to a previous Coding Challenge. You may remember me from Coding Challenges such as Coding Challenge number 36, blobby. It's when I used to wear Tshirts with this other logo on them during my Coding Challenges, so what is the issue with blobby, so I'm actually, even though I could just pull up that code, I'm going to (fingers snap) speedcode blobby again. You're going to see, watch, this is like two Coding Challenges in one, so I'm going to what I'm going to do is I'm just going to say, let a equal zero, a is less than TW0_PI, and what I'm going to do is I'm going to use my polartocartesian coordinate ♪ Song ♪ and I'm going to say let x equal r times cosine of that angle. Let y equal r times sine of that angle, and then I'm going to make up some value of r. r is going to be 100. I'm going to translate to the center of the window, and then I am going to say beginShape. I am going to say endShape, and I'm going to set a vertex, vertex at x, y, and I'm going to say, and I spelled TWO_PI with a zero, which is really complaining. I mean, I'm just saying, stroke 255, and noFill, and there we go. Look, I just wrote the code for drawing a circle because this is a for loop, I'm going to go through all these different angles. I'm going to calculate. I'm going to increment the angle. I'm going to keep the radius constant, and I'm going to set all the vertices x, y of the circle. Now, if r is random, and this is basically what I did in blobby, if I say random 50 to 100, look what we've got. We've got this kind of like crazy, flickering thing, and that's almost, that's kind of interesting unto itself, and I could make this a little more evident by making the time step, not the time step, the delta angle, the amount of angle, the amount of vertices I'm drawing, fewer. I could make sure it connects at the end by saying CLOSE, and I could also, just for right now, say noLoop so we only get one of them, so each time I run this sketch I'm going to get a new random pattern. Now, here's the thing. This actually looks like it's a nice, closed loop because it's all random. It doesn't matter if the last vertex doesn't match up with the first vertex, and I, it would be somewhat smart of me to be more thoughtful about what this delta angle is, like maybe it should be something that divides perfectly into TWO_PI, or the radians equivalent of 360 degrees, but again, I'm not going to worry about that. What I'm going to do is I'm now going to add Perlin noise to this. Now, if you've never heard of Perlin noise before, I will refer you to a playlist where I talk about what Perlin noise is, and how it works, and a whole bunch of other videos (giggles) related to this, so go and watch those now if you want, or I also link to some articles about Perlin noise, but I'm going to assume knowledge of Perlin noise for the purpose of this Coding Challenge, so right now, what I'm going to do is I'm going to say let t equal zero, so I'm going to use t as my offset through the onedimensional Perlin noise space. I'm going to change that to x offset in a little bit, but let's just keep it at t right now. Then I'm going to say r is noise of t times 100, so interestingly enough, let me, we get a different size circle every time I run the sketch because we're getting a new, randomly seeded set of Perlin noise values, (sighs) and I'm never moving through that time space, so each vertex is exactly the same, so what I want to do now is say, in the loop, t plus equal some amount of delta, so you now you can see look at this, ew, the amount is changing, but it doesn't match up, so first of all, let me clean this up a little bit by saying map, let me use the map function, which I think will make things a little simpler. Perlin noise always has a range between zero and one, and let's say I want that range to go between like 100 and 200 now, so we can see, look at that. Now, there's just this little every time I run it you can see that the last Perlin noise value doesn't match the first one. This is the problem. This is getting at this idea of a perfect Perlin noise loop, and let's also have delta t, the way I move through the Perlin noise space. Siri, what should delta t be? (crickets chirping) (computer boops) Let me change that to this and you could see even if I move t faster, and I get this kind of smoother blobbylike shape, it always has this artifact the last and by the way, if I took off this close, this will be more evident. Why, right? The last vertex doesn't match up with the first one. This is the problem, so I have my title of this video right here, Perlin Noise Loops. Perlin noise, if we're talking about onedimensional Perlin noise, Perlin noise values in a onedimensional space, with this being the taxis, the time axis, although really I should call this x offset, 'cause it's like the x offset. This is maybe a graph of those values, and if I'm arbitrarily going from zero to some fixed endpoint as I get to the end of that circle, whatever value I get here, which may be, let's say, if this is between like zero and one, maybe this is 0.3, and this is like 0.621, right? They don't match up. If I were to take this and twist it around into a circle, they don't match up. There is another way to look at a space of Perlin noise values. This is a way of looking at it in one dimension. Let's now look at it in two dimensions, so instead of having a sort of onedimensional graph of Perlin noise values, I present to you a grid of Perlin noise values. The idea is each one of these represents some value between zero and one. Now, in this twodimensional space, each one of these values represents, uh, is also a number between zero and one, so I might have like 0.2 here, 0.3 here, and 0.31 here, and 0.26 here, and 0.19 here, right? Every single space has a value. Now, here, in one dimension, any number in onedimensional space is quite similar to its neighbors, and it only has two neighbors a neighbor on the left and a neighbor on the right, or a neighbor after and a neighbor before. Here, each value has how many neighbors? One, two, three, four, five, six, seven, eight. It has neighbors above, and neighbors below, and neighbors to the right, and neighbors diagonally down, so the idea here is that what if I could walk around through a twodimensional Perlin noise to get space to get random values and always end up back where I started? And why not just walk in a circular path? I mean, that's kind of what I'm programming anyway, so why not just do that? What if I were to start here and get this Perlin noise value, then this one, then this one, then this one, then this one, then this one, then this one, then this one, then this one, then this one, then this one, then this one, then this one? I would have one, two, three, four, five, six, seven, eight, nine, 10, 11, 12, 13 random numbers, and the last one is going to match up with the first one if I keep going, so I could get those random numbers over and over again, and if the amount of numbers there is so vast, it's going to appear like it is a continuous sequence of total randomness, smoothed with Perlin noise, so this is the theory, so let's now go and apply this theory to this particular blobby shape, so before I get back to the blobby code, what I have here is a processing sketch that is visualizing Perlin noise in a twodimensional space, so this a pretty sort of like classic visualization of 2D Perlin noise as this cloudy like texture, and this is literally (giggles) exactly this, where each number, each random Perlin noise value in the twodimensional space, is represented as a pixel with a brightness value between zero and 255, and when you look at that you get this cloudlike pattern because the color seamlessly, smoothly moves between white, to black, to gray, to black, to gray, to white, so the idea here is what is what I want to do is walk around this space and pull those numeric values, but map them to something else besides a pixel value, and walking around in a circle is a nice way to create a loop, but you don't necessarily have to have that be in the circle. All right, so let's go back to the blobby code. Now, there's a (giggles) a bit confusing about this, because in addition to the walking around the Perlin noise space in a circular path, I also happen to be walking around the 2D canvas in circular path to draw this circular shape, so I'm kind of using the same idea, but with two different points of view, and hopefully that is something that makes sense to you. Hmm, okay, so what I want to change this is I no longer want to have t. What I want to have is x offset and a y offset, and I want to get the Perlin noise at x offset, y offset, so this is now what I had before if the, if the x offset and the y offset, right, basically, if what I'm doing is I'm asking for what is the Perlin noise value at this spot it's going to give me some random value, and then it's going to make that the radius of the circle, the blob shape, as it goes all the way around, so I want to start moving, but I actually don't want to start here. I want to start over here, so I have to deal with the fact that I need to find this point if zero, zero's in the topleft, 'cause I can't have negative values in the Perlin noise space, so this is a little bit of a tricky piece of this, but I want to use that same polar twocartesiancoordinate formula, or I want to say x offset equals cosine of that angle, y offset equals sine of that angle. Now, look at this. I've kind of got something, but it's weirdly symmetrical, and the reason is this exactly what I just alluded to. These x offset and y offset values are going between negative one and one, and so in fact I'm trying to look at Perlin noise values over here, right, and these, this doesn't exist. The Perlin noise space is all positive, so there's actually a very simple solution to this, which is just to add one, and let me add the CLOSE back in, and let's run this a bunch of times, and we can see, there we go, we have this nice random blobby shape where the end matches the beginning. Now, I want to do, let's do some more stuff here. All right, so first of all, what happened to that like incrementer? What happened to t plus equal 0.01? Now I have x offset and y offset. Why aren't I saying x offset plus equal one, 0.1 y offset plus equal one, one, well, actually, the incrementer is this. It is the 0.1 here. It's cosine of the angle, and in truth (giggles) I could (gasps) have a separate variable from the one that's incrementing in the loop, 'cause I could move through, but I need to go all the way to TWO_PI, so that I don't want to do. I think a way for me to vary this in a more flexible way is actually to use the map function, so if I map cosine of a, which goes between negative one and one, and then map that to a range between zero and two, we have, and this is sine, we have exactly what I had before, and I can keep, I can keep rewriting the sketch, and I'm getting a new version of the shape, but interestingly enough, what happens? This is really now something that I should make a parameter, so for example, what if I were to say let, I'm going to make this a global variable, let, I'm going to call this noiseMax equal two, and I'm going to put this here, and watch what happens if I make this five, versus 10, versus 120, versus 0.1, and look at this, 0.3, 0.5, look at this. This is really kind of interesting. With just a little bit of noise, I have what appears almost like a perfect circle, but it kind of looks like a human being like me with faults, I have lots of faults, drew that circle. It's got some slight so Perlin noise can actually be used as a nice way, with a little subtle Perlin noise, of making some perfect shape, like a letterform, or a circle, or a square, have a little bit of wiggle to it that makes it seem more handdrawn, so that's a nice thing to see. The other thing we could see here very quickly is like, it would make sense for me to create a slider. I'm going to say, and this I'm using the p5 dom library to do this, which is a really quick way. I'm going to create a slider which has a range between like 0.1 and 10, and I'm going to start it at, actually let's make it between zero and 10, and I'm going to start it at zero, so I have the slider here now, and then I want noiseMax to equal, noiseMax to equal slider.value, so watch this. Okay, that didn't work. (giggles) Oh, I have noLoop in here. No wonder. Take out the noLoop, and now let me slide it. Oh, we need to make that, so first of all I need to give myself smaller time steps when moving the slider, so let's do this. Oh, look at that. Look how it kind of like unfurls, because it's the same noise space; I'm just stretching or shrinking it. That is a really imagine now if I oscillated that like along a sine wave, so another thing that I could demonstrate to you is interesting, like a always starts at zero, 'cause I'm going from zero to TWO_PI, but if I am walking around the path of a circle, there's no reason why I couldn't start over here and then go around, or start over here and then go around, and why not vary that? That would be like the phase. You go back to my Fourier, all of this stuff, it's so crazily interrelated it's amazing, but if you go back to my Fourier transform videos, where we created these orbiting epicycles, we had this concept of phase, which is where does that orbit start, so let me show you another thing here. Okay, what I'm going to do is show you so let me make a variable called phase, and we have that be zero. I'm going to have cosine of angle plus phase, sine of angle plus phase, what do you think's going to happen if I increment phase? Well, it looks like the shape is rotating. I mean, it is rotating, or it's not rotating. I mean, visually it's rotating, but I'm actually just starting at a different point in the noise space. Interestingly enough, like, and if I make that much smaller, you'll actually see that, like smaller than the amount of vertices I have, you start to see a wiggle between them, so interest, like I could make this 0.2, and that's going to be even more apparent. Like, look at that crazy weird wiggle as those vertices adjust their spot, and then I want to show you something even crazier, I think, like let me put it back. Let me sync it so this is like a nice perfect rotation. What if I only apply the phase to the x offset or the y offset, like different phases? That is really, oh, it's kind of too fast, so let me do like this. Like, this is really weird. You can sort of see it's almost like there's something crawling around the edge. (screams in mock horror) There's so much weirdness stuff going on, so anyway you see the sort of like exciting possibilities of thinking about Perlin noise values as onedimensional, values that might pull over time in a sort of onedimensional fashion, but actually pull them from the path of a circle in the twodimensional Perlin noise space. Now, what I happen to be doing in this is taking a very literal approach. (giggles) I'm taking those Perlin noise path values walking around a circle, and applying them to like the distance from the center of a circle over, as I'm drawing it, so it's very like, it's a very literal sort of like visualization of Perlin noise values in a circle to the edge points of a circle, but if you start to think of other ways you could apply those values, the creative possibilities explode, and so in other words, if this is what I started with, I have Perlin noise at the beginning. Sorry, I have Perlin noise values in onedimensional space, but they don't loop, why not take those looping values here, along the path of a circle, and then unfurl them back into the sort of onedimensional line, and then use those to apply to any value in any visualization to make a perfect GIF loop. That's the idea, so I'm going to just put that out there. I'm putting this out into the universe. I mean, I didn't put it out in the universe. Lots of other people, Etienne, and Golan, and many others I'm sure I'm forgetting to reference, have done this for years, so give that a try. In the next video I'm going to come back and actually do that, so I'm going to see if I can take this idea and just apply it to something. Probably won't be that visually interesting, but this will hopefully give you lots of ideas of what you might make. Let's add one more thing to this. I think I can. This video's not too long so far. All right, let's add one more thing, so first of all let me take out this idea of phase for a second. Just going to comment that out and put it back to what it was, which is just this, so every time I run it I get a new Perlin noise space, and incidentally, the only reason why I'm getting a new Perlin noise space is because p5, behind the scenes, will seed Perlin noise with a random seed each time, but I could actually control it. If I were to say noiseSeed, and pick some arbitrary seed value, and random number seeds is maybe a topic for another video. Every time I run this I'm going to get exactly the same shape each time, so anyway, just pointing that out, but there is something else. There is another way I could animate this, and it has to do with threedimensional Perlin noise, and Perlin noise can exist in any ndimensional space. In p5 and in processing, I think the functions that give it to you just support one, two, and three dimensions, but let's talk about how you might use three dimensions here, so for example, if this is my visualization of Perlin noise in twodimensional space, that cloudy image, well, I could make sort of like a cloudy set of cubes in threedimensional space, but another way of thinking about it is have that third dimension be slices of an animation, so I could show you the Perlin noise space over time while incrementing a zvalue, a z offset, and show you Perlin noise for a z offset equals zero, then z offset equals 0.1, then 0.2, then 0.3, and so that actually, all of those will have numbers. Each one of these numbers is now has all of its neighbors to up, and down, and left, and right, and forward, and backward, are similar random values, so this is actually a really easy thing for me to add. I just need one more global variable called z offset, and this needs to be global 'cause I'm not resetting it back every time through draw. Each time through draw I'm incrementing it, and I can just add zoff right there to the Perlin noise function, and then I can say zoff plus equal some amount, like 0.1, and you can see we get this wiggle. I can make it 0.01, and I'm going to move through the Perlin noise space much more slowly, and once again we could see, like, there's all sorts of things I could do here, like this could be 0.3, and this could be 0.1. There's so many parameters that you can explore here. I think we've made, actually, a superinteresting shape for like a crazy animated game version of Asteroids, like you can imagine having Perlin noise jiggling, oscillating, looping, noisy, polar Asteroids. That's a thing you should make, so anyway, so I hope you find some variations for this, and I look forward to seeing what you make, and stay tuned for the next video. (bell dings) (playful music) (bell dings)
