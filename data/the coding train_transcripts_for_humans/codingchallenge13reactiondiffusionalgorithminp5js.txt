With timestamps:

00:00 - hello and welcome to another coding
00:02 - challenge uh in this coding challenge I
00:04 - am going to look at the reaction
00:06 - diffusion algorithm so I have a version
00:08 - of it running right over there that is a
00:10 - processing sketch that is implemented
00:12 - the reaction diffusion algorithm I'm
00:13 - going to implement it in JavaScript uh
00:16 - do it from scratch in this video and you
00:17 - can see that this allows you to create
00:19 - this interesting kind of Labyrinthian uh
00:22 - uh visual in your canvas now there's a
00:24 - lot of different ways that you can apply
00:26 - colors and get different qualities to
00:28 - the image but I'm going to look at the
00:29 - sort of core classic reaction diffusion
00:32 - algorithm using the gray Scott model I
00:34 - will include some links below to
00:36 - reference Pages the one that I will
00:38 - build the code based on is right here in
00:40 - the browser the Carl Sims a Carl Sims
00:42 - tutorial page um and so the idea here is
00:45 - that I'm going to just sort of look at
00:46 - the drop dead simple classic algorithm
00:49 - black and white pixels only and then
00:51 - hopefully you after watching this and
00:52 - using the code might come up some other
00:54 - creative uses and applications of it so
00:57 - let's try to understand first what this
00:58 - algorithm actually is and so I'm going
01:00 - to close this window out and look at
01:01 - this diagram so the idea of reaction
01:03 - diffusion is kind of like you have your
01:06 - screen and you're about to pour some
01:07 - chemicals into it and those chemicals
01:09 - are going to react and there's going to
01:10 - be a lot of chemical a and then less of
01:12 - chemical B and they're going to react
01:13 - and diffuse and that sort of thing and
01:15 - then based on the how those chemicals
01:18 - are arranged in the screen in this sort
01:20 - of like dish petri dish of your canvas
01:23 - I'm going to we're going to set a color
01:24 - so if there's a lot of chemical a we're
01:26 - going to make the pixel black if there's
01:27 - no chemical a we're going to make the
01:29 - pixel white and kind of everywhere in
01:30 - between so that's the idea here now
01:33 - there are a lot of different um kind of
01:35 - key pieces here and let's just look at
01:36 - this quick diagram here thank you again
01:38 - Carl Sims for providing the diagrams for
01:40 - this video um chemical a so um the way
01:44 - it's going to work is the canvas is
01:45 - going to be filled with chemical B and
01:47 - then we're going to start to pour
01:49 - chemical a into the canvas the reaction
01:52 - aspect is chemical A and B reacting and
01:55 - maybe a is turning into B and the sort
01:57 - of diffusion in this way is that
01:59 - chemical is also going to get kind of
02:00 - like removed uh from it so there are
02:04 - some there are some key constants in the
02:05 - system that are numbers that you're
02:07 - going to see in the code one is the feed
02:08 - rate which is how fast are we pouring in
02:11 - chemical a and then another is called
02:13 - the kill rate I wish there was a nicer
02:14 - name for that but that's what it's
02:15 - called which is how what is the rate
02:18 - that chemical B is being removed so this
02:20 - is the idea now um so and you can see
02:25 - here what we're going to do is each each
02:27 - cell is going to have a certain amount
02:28 - of chemical a and of chemical B and
02:31 - those values are going to have a range
02:32 - between zero and one uh one being a lot
02:35 - of chemical a zero being none and then
02:38 - that amount is going to be used to set
02:39 - the color for a pixel and so you can see
02:41 - here uh how this how this kind of works
02:44 - we're going to do all this in code now
02:46 - how look at this now we have this like
02:49 - terrifyingly scary looking formula but
02:52 - we can tackle this formula I'm going to
02:54 - right here I'm here with you to tackle
02:56 - this complicated looking formula so
02:58 - let's put putting that aside let's kind
03:00 - of make a quick diagram so the way that
03:03 - I'm going to build this in code is I'm
03:05 - going to have a two-dimensional array
03:08 - meaning I'm going to have a data
03:10 - structure that's going to keep track of
03:13 - uh each spot in that data structure is
03:15 - going to keep track of an individual
03:16 - cell call that a cell each cell is going
03:20 - to have an amount of chemical a and an
03:22 - amount of chemical B so what I need to
03:26 - do is understand uh if if there moments
03:30 - in time there are Generations This
03:31 - Moment In Time next moment in time so
03:33 - Moment In Time a0 moment in time b0 what
03:36 - I need to understand is how do I get the
03:39 - amount of a for Moment In Time One based
03:42 - on some function of the amount of a and
03:45 - the amount of B at time zero so this is
03:48 - what we're looking at and in fact over
03:50 - here that's what this formula is showing
03:52 - you the new value of a equals all this
03:54 - stuff based on the previous value of a
03:56 - and b and some other constants so this
03:58 - is what we need to do there's a bit more
04:00 - to it than this so you know I could say
04:03 - like oh A1 equals the average of a0 plus
04:07 - b 0 you know divided by two this could
04:09 - be our formula this would be a lot
04:10 - easier to implement so that formula is
04:12 - just like this but a lot more comp
04:15 - complicated so now but there the reason
04:17 - why there's more to it than this is
04:19 - because we have this scenario here of an
04:21 - individual cell we have to apply
04:23 - something called a
04:26 - convolution you're going to see I'm
04:27 - going to show you in a moment it says a
04:28 - convolution of a 3X3
04:32 - Matrix all this scary sounding stuff so
04:35 - here is a 3X3 Matrix and this is a given
04:39 - cell and what I want to know is what is
04:42 - this
04:43 - cell's new values of A and B based on
04:47 - its previous value of a and b but not
04:50 - just it I need to know also based on its
04:53 - neighbors so these chemicals are
04:57 - reacting and combining in a given also
05:00 - with what are the chemicals next to it
05:02 - so the a convolution means take every
05:05 - single one of these cells and multiply
05:08 - it by some weight so if I were blurring
05:11 - an image for example I could use a blur
05:14 - as a blur meaning the average of a
05:16 - convolu of of a of a 3X3 Matrix of
05:19 - pixels so the new pixel color is going
05:21 - to be an average one nth of this color
05:23 - plus 1 nth of this color plus 1 nth of
05:24 - this color plus 1 nth of this color so I
05:26 - take all of the colors and multiply them
05:27 - by 1 nth add them all together I have
05:29 - the new color but we have a different um
05:32 - convolution here and it's described in
05:35 - in the diffusion uh in the reaction
05:37 - diffusion algorithm so this is the basic
05:39 - idea I need a two-dimensional array each
05:41 - spot is going to have a certain amount
05:43 - of a and a certain amount of B I need to
05:45 - have a formula that for each cycle each
05:47 - frame through draw I get a new value of
05:49 - a and a new value of B and then a new
05:51 - value of a and a new value of B and the
05:52 - math formula is going to be something
05:54 - like this but more complicated because
05:56 - it's also going to involve all the
05:57 - neighbors so let's start setting this up
05:59 - now now hopefully this is the basic idea
06:00 - let's start setting it up to program it
06:02 - okay so now I'm back over
06:04 - here uh I am back over here ah oh was I
06:07 - not over there the whole time I think I
06:09 - was over there the whole time hopefully
06:10 - this was right uh somebody in the chat
06:12 - tell me was I in the on the Whiteboard
06:14 - while I was showing that um okay so if I
06:17 - go back to I have this blank uh code
06:19 - here um and uh I'm going to go to my uh
06:24 - canvas here and this is my canvas so the
06:26 - first thing I need to do is create okay
06:28 - I was good the first thing I need to do
06:30 - is create my uh two-dimensional array to
06:34 - store all the amount the the amount of
06:37 - chemicals in each spot in the in the
06:39 - grid okay so two-dimensional arrays in
06:42 - JavaScript are kind of a funny thing uh
06:44 - not funny haha funny a little bit weird
06:47 - because um arrays in JavaScript there's
06:49 - just so many different ways you can make
06:51 - them but ultimately what a
06:52 - two-dimensional array is and let me kind
06:53 - of describe this to you briefly I'm
06:55 - going to make an array called grid and
06:58 - you could imagine like what if I did
06:59 - this um I'm going to write something
07:01 - like
07:05 - this I'm just going to kind of type
07:07 - something out for a second just to
07:08 - explain
07:14 - this this my friends you are my friends
07:17 - indeed is a two-dimensional
07:21 - array I I kind of space it out like a
07:24 - grid but really what it is is just an
07:26 - array of arrays to see how it's an array
07:28 - open Square bracket n square bracket and
07:30 - then it's three arrays inside of it but
07:33 - I could but so really a two-dimensional
07:35 - array in programming is just an array of
07:37 - arrays so what I need is one array to
07:41 - keep an array for here for here for here
07:43 - for here right so I need the first array
07:45 - to be the first row the second array to
07:46 - be the second row the third array to be
07:48 - the third row that sort of thing but I
07:50 - I'm not going to type it out manually
07:51 - for 3x3 I could type it out manually
07:53 - what I need to do is kind of um is
07:57 - actually make it um uh make it in code
08:01 - okay everything's going to be fine so
08:02 - I'm going to create that variable and
08:03 - I'm going to do it I'm going to use a
08:05 - particular style I'm going to do it
08:07 - different I'm going to do it different
08:08 - so what I'm going to do is I'm first
08:10 - just going to say grid is an array it's
08:12 - an empty array and what I need to do is
08:15 - I need to Loop x equals 0 x is less than
08:18 - the width of this canvas and let me Zoom
08:20 - back out x++ so for every
08:23 - X and for every y
08:30 - right for every X ah stop oh I can't
08:36 - ah I'm waiting for my auto format that's
08:39 - not here um for every x what I need to
08:42 - do is say grid index X is an array so I
08:47 - start with this array and then I say hey
08:49 - let's make an array and
08:51 - then what am I going to put here grid
08:55 - XY equals now what do I what do I need
08:58 - in each spot in the grid now if I were
09:00 - just if I only had a single chemical if
09:03 - I only had a single chemical I was just
09:04 - putting a single number in each one of
09:05 - these but I have two chemicals I have an
09:07 - A and A B so let's actually I think this
09:08 - is a place where I could just make a
09:10 - literal JavaScript object and say a is
09:13 - you know there's zero of a and there is
09:15 - a zero of B so uh and you know I don't
09:19 - think I need to be so long-winded about
09:20 - it this is such a simple object I'm
09:22 - going to do
09:23 - this so I make each spot in the grid
09:27 - each spot in the grid for every in every
09:29 - y there's an A and A B with zero of each
09:32 - chemical and I'm going to need to change
09:33 - that eventually but we're going to start
09:34 - there so this is good I now have my grid
09:38 - yay now here's the thing in order to
09:42 - make this work right the whole this
09:44 - whole this whole all built on this idea
09:46 - of I need to get the Next Generation
09:49 - amount of a so I can't be me if if this
09:54 - grid is the snapshot of all the
09:56 - chemicals in a current generation I need
09:58 - a complete completely separate
10:00 - grid to start filling in the new
10:05 - values because if I were to use the same
10:08 - grid if I start overwriting the values
10:10 - in that grid while I'm checking other
10:11 - values neighbors everything's going to
10:13 - get all messed up so what I should do is
10:16 - I'm also going to create a variable here
10:17 - called
10:20 - Next and I'm going to be kind of silly
10:22 - about it and I'm just going to make two
10:23 - of
10:26 - these and I'm going to say
10:30 - next so I now have two two-dimensional
10:33 - arrays and I think I just want to
10:35 - briefly
10:36 - mention that um I could have done this
10:41 - so grid is going to be the current and
10:43 - then next is going to be the next one so
10:45 - I could have done this by also using new
10:48 - array in JavaScript to create a sort of
10:50 - fixed size but I know my array should
10:52 - have a width and height as kind of the
10:53 - number of uh columns and rows okay so
10:55 - now we're in good shape so what I could
10:58 - do what I want to do is just sort of see
11:01 - that the basic idea of this is working
11:04 - so what I need to do is draw a color a
11:08 - pixel color in the window based on each
11:11 - value in that grid so by the way we're
11:13 - going to need this double nested Loop
11:15 - like a zillion
11:16 - times so I'm going to just copy paste
11:19 - that down here and one one thing I'm
11:21 - going to do at the very end is I'm going
11:22 - to say load
11:24 - pixels and then I'm going to uh say
11:28 - update
11:29 - pixels and what I'm going to do is I'm
11:32 - going to uh create a
11:36 - color let's just make sure I'm going to
11:38 - just make a nice you know pinkish
11:40 - purplish color just to make sure this is
11:43 - working and I'm going to say pixels
11:44 - index oh boy so guess what everybody I
11:48 - have a whole video that goes through the
11:49 - pixel array I should link to that from
11:50 - here the pixel array in Java in P5 JS in
11:53 - the JavaScript canvas is a pixel array
11:56 - that has four spots for every pixel
11:59 - so I need to figure out and it's
12:01 - onedimensional so I go through the
12:03 - derivation of this formula but I'm going
12:06 - to say pix equals x + y time
12:12 - width Time 4 and then I'm going to say
12:14 - pixels pix
12:17 - plus 0 equals uh 255 and I'm going to
12:22 - this I don't need and I'm going to say
12:24 - zero and I'm going to say 100 and then
12:27 - and this is uh one
12:29 - one two and three so what I've done here
12:32 - is I'm using a formula to find the right
12:35 - spot in that array for every single
12:36 - Pixel every width every column in every
12:38 - row and then I'm saying make its red 255
12:41 - make its green zero make its blue 100
12:43 - make its Alpha 255 so I just want to see
12:46 - that this runs okay great so I filled it
12:49 - with a color so I do have a way of
12:51 - setting every pixel color now what I
12:53 - want is for these colors to be based on
12:56 - the grid so I'm going to say grid X
13:00 - comma y. a and I'm going to say grid X
13:06 - y.b so um so I'm going to do the red and
13:09 - the blue as coming from the
13:10 - two-dimensional array itself and we
13:12 - should see all black but if I give
13:14 - everything a
13:16 - uh random
13:21 - amount we should see uh okay so what am
13:24 - I missing here so I gave the grid a
13:27 - random amount of a and a random amount
13:29 - of of
13:30 - B and uh what's missing oh I I did
13:36 - random between zero and one so I what I
13:38 - want to do is multiply these by 255
13:40 - there's there's lots of ways I could use
13:41 - color mode or get around this but I'm
13:43 - just going to multiply that by 255 oh
13:45 - and I'm gonna have to say floor because
13:46 - it has to be an integer I
13:49 - bet uh okay so I probably could have
13:51 - done a better job at this but there we
13:52 - go so you can see that this is working I
13:55 - have a mechanism by which based on the
13:57 - amount of chemicals I get pixel color
14:00 - this is the core thing that we need so
14:02 - now all we need to do is say like okay
14:05 - let's put this formula
14:07 - in great so let's unpack this formula
14:10 - right because right now and and actually
14:11 - before we even do that let's let's
14:13 - actually just get the structure going so
14:16 - before I put the formula in let's do
14:18 - something let's put this nested Loop in
14:23 - again and what I want to say is now I
14:28 - need to use this next right
14:32 - next index XY equals and let me just do
14:36 - something like I'm going to make up a
14:38 - formula this isn't the actual reaction
14:39 - diffusion formula but what I'm going to
14:42 - do is where's the camera where's the
14:44 - screen I'm losing my mind I'm going to
14:46 - say grid X comma so
14:49 - next. a equals grid xy. a you know times
14:55 - 0.2
14:57 - and next next the the next
15:01 - B is the grids B * 1.2 so I'm going to
15:07 - do that so this is this again this isn't
15:08 - the correct formula we're going to have
15:11 - to actually put in the reaction
15:12 - diffusion formula but I'm showing this
15:14 - is the structure by which I say the next
15:17 - generation will be that so now if I run
15:20 - this again me come back to
15:22 - here well it doesn't seem to be
15:24 - animating or changing why so it's not
15:27 - animating or changing because I'm still
15:29 - drawing it based on grid so maybe what I
15:31 - actually want to do is draw the next
15:36 - one and I did get something strange
15:39 - happening here so it looks different and
15:41 - let's actually
15:43 - um not let it go over the values go over
15:46 - me so you can see that it is actually
15:49 - doing something like the values are
15:51 - different
15:53 - but importantly here I don't see
15:55 - anything animating so one of the major
15:57 - things that we need here is and let's
15:59 - think about is something called a swap
16:01 - are you with me are you still paying
16:03 - attention I would understand if you
16:05 - weren't okay so I need a
16:08 - swap
16:09 - so this is a very common technique in
16:12 - seller automata systems and other types
16:14 - of Generation by generation systems what
16:16 - I have here is I have oops wrong side of
16:19 - this marker what I have here is I have a
16:22 - two dimensional array called grid and
16:25 - then I have one called next
16:31 - so grid is all my starting values then
16:34 - next is calculated and then next is
16:37 - drawn to the
16:38 - window well what should next should then
16:42 - become grid again so I can get a new
16:44 - next and draw that to the window so what
16:47 - I need to do is swap them what I need to
16:49 - do is say let me put next back into grid
16:53 - and then I have a new blank one to write
16:54 - on and I could just pull grid over there
16:56 - CU it's the old one I don't need it
16:58 - anymore so if I if I want to have this
17:00 - continuous generation I have the old and
17:01 - the new so new gets calculated then new
17:05 - becomes old and I could just use that
17:06 - old one that I had to be the next new
17:08 - one and then new becomes old then then
17:10 - new gets calculated new becomes old
17:11 - again so I need to have a swap so I'm
17:13 - actually going to write this as a
17:14 - separate function so at the end of every
17:17 - oops after I draw I'm going to call a
17:20 - function called Swap and I'm going to
17:22 - write that down can you see this I'm
17:24 - going to write this down oh somewhere
17:25 - down here so I'm going to write a
17:27 - function and called Swap and so what's
17:31 - going on here next I want grid to be
17:35 - next and I want next to be grid I want
17:38 - grid to be next and I want next to be
17:40 - grid I want to swap them oh but this is
17:42 - no good if grid is next and then next
17:45 - equals grid well then next is next
17:46 - because grid is next we've got a problem
17:49 - here so in a swap what I need to do is I
17:52 - need to have a temporary variable that
17:54 - keeps track of the old grid so now grid
17:57 - can become next and next can become that
18:00 - old grid temp so this is a very simple
18:02 - swapping algorithm to swap the values of
18:04 - two variables um and that'll do the
18:07 - trick for me so now if I swap them this
18:09 - will get applied over and over again so
18:11 - let's let's do 0. n and 08 just so we
18:13 - see something happening here and you can
18:15 - see it it went down to zero very quickly
18:19 - um and I could um you know I could say
18:21 - 0.95 and I could try doing
18:23 - 1.01 so you can see it's going towards
18:26 - it's going to go towards blue eventually
18:28 - so we can see we have the system going
18:29 - on again this isn't this is the like
18:32 - shiffman rainbow reaction diffusion
18:35 - algorithm which isn't very interesting
18:36 - at all so we have the guts here we have
18:39 - the foundation we have the
18:40 - two-dimensional array each spot holds
18:42 - the amount of each chemical the screen
18:44 - is colored based on those chemicals and
18:46 - I have some formula to calculate the new
18:48 - chemical value based on the old chemical
18:50 - value so I don't know how long I've been
18:51 - doing this for but we're so close now
18:53 - all I need to do is actually go and get
18:56 - that scary formula uh from that web page
18:59 - and stick it in the code and we're done
19:01 - so let's go take a look at that this is
19:02 - going to be a bit more difficult than I
19:04 - might have imagined but let's see how it
19:06 - let's see how it goes so now we're back
19:08 - to here so let's look at all of these
19:11 - things okay a the difference of the new
19:14 - a equals what a so let's start putting
19:17 - this in uh so this we can do difference
19:19 - of a equals new a so I'm going to go
19:22 - back and um I'm going to probably need a
19:25 - lot more space here so um and I'm just
19:28 - going to do a for a second the new a
19:31 - right equals
19:33 - what the old
19:37 - a now I'm going to go back to this
19:39 - formula
19:41 - plus plus now what da what is da
19:46 - oh I can't operate the computer
19:48 - sometimes I went back by accident da is
19:50 - a diffusion rate so where are those here
19:53 - we go these are some typical values so
19:55 - this is by the way is something that
19:57 - you're going to after you watch this
19:58 - video and use example you're going to
19:59 - want to like play around with these
20:00 - values yourself or go look up other
20:02 - values the different values will produce
20:03 - different kind of results so diffusion
20:05 - rate of a is one so I'm going to in my
20:08 - code I'm going to make these uh Global
20:09 - variables da equals 1 let's see what
20:13 - else we got uh DB equals
20:16 - .5 diffusion rate for B the feed feed is
20:20 - how fast are you feeding in chemical a
20:22 - is
20:23 - 055 I'm going to call that feed just to
20:27 - because F can mean other stuff in
20:28 - programming
20:30 - 0.055 was that it yep and K is
20:34 - 0.062 uh VAR k equal
20:37 - 0.062 that's that's sort of the the the
20:40 - kill rate how how fast is a b being
20:42 - removed um so these are the values that
20:45 - I'm going to need in that particular
20:46 - formula so now I can go back here and
20:48 - say uh plus the diffusion rate of a
20:54 - times upside down triangle PL 2D
20:58 - function okay so let's let's make that
21:00 - something temporarily that we're going
21:02 - to deal with in a little bit so I'm just
21:04 - going to say right now I'm going to say
21:08 - la I'm GNA make that a function La a
21:12 - we're going to deal with that
21:14 - later and uh times
21:18 - a times and you know what I should do to
21:21 - make this shorter I think something that
21:22 - can make things a little easier is I can
21:24 - say a
21:25 - equals grid X Y A so that way I don't
21:29 - have to every time I need that a value I
21:30 - can just put a time a
21:33 - times uh uh oh no
21:37 - minus minus what a * b^
21:42 - 2ar uh so a * B * B and I'm going to I
21:48 - need a variable for a boy this is a lot
21:50 - of typing here guess you could fast
21:52 - forward now or put this on two times
21:54 - speed if you're watching this still uh I
21:57 - kind of want to like put this on multip
21:59 - lines also just so you can see it so uh
22:03 - whoops no this should be here I'm going
22:05 - to do each piece of this formula on a
22:07 - different
22:08 - line uh I don't know if this is making
22:10 - it uh um
22:14 - minus a * B * so we have a * the
22:18 - diffusion of a plus this lla thing I
22:19 - have to get to time a minus a * B * B
22:23 - and then now we have plus the feed
22:27 - multiply by 1 - A so plus the feed
22:34 - multiplied 1 - A did I get that right
22:38 - plus the feed multipli by 1 minus a and
22:41 - I'm going to put parentheses around
22:43 - these things I think I'm sure it's right
22:46 - anyway but this I think will help us a
22:49 - plus d a that doesn't seem right A Plus
22:51 - da times llas so I I so I'm going to um
22:55 - just to be consistent here I'm going to
22:57 - move this down here
23:00 - and uh I think I now have all the
23:02 - components of that formula a plus da *
23:05 - LL time a minus a * B * B plus feed *
23:10 - 1us a does that look right somebody
23:13 - watching this in the live stream will
23:14 - correct me I think I've gotten this
23:16 - right um and we will uh yeah da llas
23:21 - times a okay so hopefully I got this
23:23 - right I have to do the same thing for B
23:25 - why not just do it right now that we're
23:27 - here so B is B plus uh the the diffusion
23:33 - rate for
23:35 - B and I'm going to make a llas b
23:37 - function which is a little bit silly
23:39 - what I'm doing here but I'm going to do
23:40 - it anyway um uh times
23:43 - B and then it is plus ab^
23:47 - 2 plus ab^ 2
23:53 - minus uh
23:55 - minus k + f time B
23:59 - K plus feed
24:02 - times B okay we're in good shape here
24:08 - I'll put parentheses around this just to
24:10 - be consistent so I think I now have um
24:14 - so I think I now have these formulas now
24:16 - I I did miss a crucial
24:18 - point if you come back to this you'll
24:20 - see delta T delta T is the change in
24:24 - time for each iteration what does that
24:27 - mean
24:28 - well the way the world works is that
24:31 - Time Marches forward on and on and on
24:34 - the way that computer programs and
24:36 - animation programs work is Time Marches
24:39 - forward in time steps lock step and how
24:43 - and we're doing this calculation in this
24:44 - sort of like stop calculate wait stop
24:47 - calculate wait stop calculate so we can
24:49 - sort of scale the amount of time that's
24:52 - passing scale the calculation according
24:54 - to I'm going to leave that as one and
24:55 - basically my time scale is going to be
24:57 - the 60 frame per second that I hope that
25:00 - the um that the uh algorithm uh that I
25:04 - hope that the animation plays out at but
25:05 - you can really sort of change the
25:07 - quality of what you're getting and the
25:08 - degree of accuracy that you're getting
25:09 - by having a smaller time step so you
25:11 - might try 0.1 01 0.5 and see what you
25:13 - get but I'm going to kind of just leave
25:15 - that out for right now for the for the
25:16 - case of Simplicity Okay so we've done
25:19 - everything now except for this Lan thing
25:22 - and so I'm realizing by the way that
25:24 - this is lassi and a this is not multiply
25:27 - by a this this is the lloan a thing so
25:30 - one thing I can do is get rid of this
25:31 - times a and this times B um so what is
25:35 - that this is the convolution so this is
25:38 - this particular thing what I need to do
25:40 - in the llas function is look at the
25:43 - every single amount of a in all of the
25:46 - neighbors I need to multiply a weight
25:50 - and then add them all together to get
25:51 - the new value that's the lassan function
25:54 - the convolution so if we go back here
25:56 - let's go back to this page and here it
26:00 - says um the leian is performed with a
26:04 - three now there's different ways you
26:05 - could do this but this says with a 3X3
26:07 - convolution with a center weight of Nega
26:10 - one adjacent neighbors 02 and diagonals
26:14 - 05 this means the following so I need to
26:17 - in this
26:20 - function look at every single cell and
26:23 - apply a weight 0.5.2
26:28 - 5 2 point uh this is the center one Nega
26:32 - 1 and then 2 05 2 05 the diagonals get a
26:38 - weight of 05 the adjacents get a weight
26:41 - of 0. 2 and the center gets a weight of
26:42 - negative 1 we're trying to determine the
26:45 - difference between that Center cell and
26:48 - its neighbors and you notice it's in a
26:50 - way these have higher weights because
26:51 - it's like the adjacent ones are closer
26:53 - to it than the diagonals so those
26:55 - chemicals are going to play a larger
26:56 - role in the reaction you could try
26:58 - messing around with different values now
26:59 - there are all sorts of fancy ways I
27:01 - could write another nested Loop and kind
27:03 - of use some sort of other
27:05 - two-dimensional array to keep track of
27:06 - the weights I probably should do that
27:08 - but I'm going to be a little bit lazy
27:10 - right now and just do this in a very
27:11 - hard-coded manual way so let's look at
27:14 - how I might do that um so if I come back
27:17 - here first of all let's just write um so
27:20 - down here I'm going to need a function
27:22 - called llas a and I'm also going to need
27:25 - a function called llas B and I'm just
27:28 - going to do something right now I'm
27:30 - going to just say they return the value
27:31 - one which is obviously like wildly incor
27:33 - oh boy I'm not here uh so I need to add
27:35 - these two functions sorry I lost I
27:37 - didn't get back here I need to add these
27:38 - two functions and I'm just for right now
27:40 - for Simplicity to make sure my code runs
27:42 - just say that they return the number one
27:44 - so that this should do something and I
27:47 - should get something um and I should get
27:49 - something so let's run this and you can
27:52 - see okay so something's working and you
27:54 - can almost even like see it oops see it
27:56 - like Flicker and do something weird
27:58 - interesting for a second so that's good
28:00 - the other thing I want to change by the
28:01 - way and I'll deal with this later though
28:03 - let's leave that now okay
28:05 - so but now I need to actually do the
28:07 - correct llas function so what I think
28:09 - I'll do is pass into
28:12 - llas the function the current X and
28:16 - Y and then I'm going to do the entire
28:18 - calculation in that function and I need
28:21 - to do it with the grid right so what I
28:23 - need to do is say something like the sum
28:26 - for a is zero and then what I need to do
28:29 - is say sum a plus equal okay what's the
28:33 - center the center is grid X Y times that
28:39 - weight1 so I need to do this like nine
28:42 - times for all nine neighbers 2 3 4 5 6
28:46 - 7even 8 nine so the adjacent ones are
28:49 - all multiplied by 0 2 so adjacent to the
28:51 - left is x minus one adjacent to the
28:54 - right is+ one so these get multiplied by
28:57 - 02
28:59 - then uh above and below is y + 1 and Yus
29:03 - one those get multiplied by 0.2 0.2 now
29:07 - I need to do all the diagonals again
29:08 - this is like a kind of terrible manual
29:10 - way of doing it but it's and I could do
29:12 - this in a loop in a much nicer way but I
29:14 - think this is good for figuring it out
29:16 - uh minus one minus one
29:19 - 0.05 that's up into the
29:23 - left + one minus
29:26 - one and I just need this same same value
29:29 - for each one of these uh uh okay then I
29:33 - need uh I need plus one + one and then
29:38 - minus one minus one does that seem right
29:41 - to you did I get oh no no no no I
29:42 - already did minus one minus one plus one
29:45 - so I have oh boy I've been doing this
29:46 - for a half an hour that's that's not
29:48 - good um okay look this is turning out to
29:51 - be a very long video I should have done
29:52 - it in multiple Parts but it's too late
29:53 - now okay so uh minus oneus minus minus
29:57 - plusus plus plus minus plus that's all
29:59 - four so I think I've gotten this right
30:02 - and then I just need to return and I
30:05 - need to get those X Y values as
30:07 - arguments and then I need to return that
30:09 - sum
30:11 - a uh and
30:14 - then oh and I'm not returning that whole
30:17 - object I'm not adding that I'm adding
30:19 - the a amount for each one of these and
30:22 - you know so I could do this in a more
30:23 - clever way by also having a B1 function
30:25 - to add these objects together so now
30:28 - it's going to do the and I could even
30:30 - like do a function that knows whether
30:31 - it's doing lla or a or b but again I'm
30:34 - just going to do this completely the
30:35 - totally manual way and we can do another
30:38 - video I'm gonna I can make this just a
30:40 - few lines of code and I'm just going to
30:42 - be sitting here come on Sublime it's try
30:45 - it's trying to be way too smart for me I
30:47 - just want to I don't want you to give me
30:49 - suggestions sometimes I want suggestions
30:51 - sometimes I don't want suggestions and
30:53 - this is silly now that I called it this
30:55 - but I did so I'm going to go I'm going
30:57 - to go all the way through with
31:00 - it okay so now we should we've got these
31:03 - lass functions I'm doing the convolution
31:05 - for every X and Y adding up all the
31:07 - neighbors and the
31:08 - weights so that should go right into
31:10 - this formula and honestly I think we
31:13 - might be done I'm going be shocked if
31:15 - this actually works we're gonna have to
31:16 - debug what we missed but let's run it I
31:18 - I I know this's kind of okay so sketch
31:21 - ah great I love what just happened here
31:24 - so what just happened here cannot read
31:26 - property zero of UND Define so I have I
31:29 - I could kind of try to figure out what's
31:31 - going on let's look at sketch. JS line
31:33 - 65 um so down here there's an issue
31:37 - here's the issue xus one when is xus one
31:41 - going to be a completely invalid spot in
31:43 - the Grid it's a completely invalid spot
31:46 - if x is zero because there's no negative
31:48 - one so I could do some sort of
31:50 - wraparound thing or whatever but I think
31:51 - what would be easiest here would just be
31:53 - to say hey you know what for this
31:55 - calculation I'm not going to do the edge
31:57 - pixels I'm going to start at one and I'm
31:59 - going to go to width minus one and
32:01 - height minus one so I'm actually going
32:02 - to ignore the edge pixel so I don't have
32:04 - that issue so that should fix that now
32:06 - I'm going to run it and look at this
32:08 - something kind of crazy happened so I
32:10 - think I've got the algorithm going here
32:13 - I'm a little worried I have a mistake
32:14 - but the most mostly the problem right
32:16 - now is that I haven't really seated this
32:19 - this in a way that makes sense so I
32:22 - think the traditional way these are done
32:23 - let's look here is right I'm giving the
32:26 - grid all random values is what I think
32:28 - would make sense would be to fill it
32:32 - with B right I want to fill the grid
32:35 - with B let's run
32:37 - this it's blue and it uh or it kind of
32:41 - turned red that's interesting that's not
32:43 - what I expected to happen but I'm going
32:45 - to just leave that that and then what I
32:46 - want to do is I want to give one
32:48 - spot like I'm going to say I'm going to
32:51 - override that I'm going to say like uh
32:53 - 100
32:56 - 100 a actually has a b out of a in it so
33:00 - I fill the grid with b and no a and then
33:03 - I give one spot I I pour in a little a
33:05 - in that one
33:07 - spot why am I getting this that's so
33:09 - interesting that I'm getting this weird
33:10 - Square thing so I must have messed
33:12 - something
33:17 - up hello I'm back I don't know where I
33:20 - would that's G to get edited somehow um
33:22 - so here's the issue I just I I wanted to
33:25 - add like a little bit of B like I filled
33:27 - the whole thing with a actually switched
33:28 - that from when I was maybe last in this
33:29 - video so I filled the whole thing with a
33:31 - and then I want to add a little bit of B
33:33 - but that's not going to work just like a
33:34 - one little droplet of be on one pixel
33:37 - not going to get enough reaction
33:38 - diffusion to make anything happen I
33:40 - actually need to give it a block a block
33:42 - of like I need to pour a lot more in so
33:44 - I need like a little area of so what I
33:46 - think I'm going to do is I'm going to
33:48 - say uh for I'm going to use I here just
33:50 - to use a different like IAL 100 I is
33:52 - less than 10 I ++ no I is less than
33:56 - 110 I Plus Plus+ now how you seed the
33:59 - system is like super interesting and I'm
34:01 - doing this not in a very interesting way
34:03 - but I'm going to use
34:05 - J uh
34:07 - j++ and what I'm going to do is I'm
34:10 - going to take a whole
34:14 - area and give it some B like a little 10
34:17 - by10 pixel area so every pixel from
34:20 - between 100 to 110 is going to get some
34:22 - B right every pixel is going to start
34:24 - with a lot of a and no B and then this
34:27 - little 10x1 areas can to start with the
34:29 - and what I'm actually going to do is
34:30 - just for a second comment this out so
34:33 - let's just see what this looks like now
34:36 - why am I I'm getting this crazy
34:37 - flickering you can't see that actually
34:40 - interestingly enough I don't think the
34:41 - flickering is showing up because I've
34:43 - done something wrong with my
34:45 - rendering but you can see though that oh
34:48 - whoa oh now you're seeing interest I
34:50 - don't know what you're actually seeing
34:51 - on the stream um oh boy this is a really
34:56 - this was a much harder one than I
34:57 - imagined but I'm going to put this back
34:58 - in I got to figure out what the
35:00 - flickering is there why the flickering
35:02 - is
35:03 - happening okay so you can see this is
35:05 - now finally working um I'm getting a
35:08 - weird flickering around the edges oh oh
35:11 - I know what the problem is I know what
35:13 - the problem
35:16 - is because I'm not updating the edges
35:19 - the edges need to make sure they're
35:20 - seated with the original amount of
35:23 - stuff there we go finally we're good so
35:26 - it took me a little while there but but
35:27 - the issue was that I needed to place an
35:30 - area of of pixels um in order to to to
35:34 - seat it with some chemical B so uh this
35:37 - was this was much this would have been
35:38 - good this would have benefited from this
35:40 - will benefit from a second run like I
35:41 - could just do this whole thing again and
35:43 - probably get through it a lot faster
35:44 - with less hiccups but hopefully this
35:47 - helped you you can see now I now have
35:49 - the reaction diffusion simulation you
35:51 - can see this is one little area of
35:53 - pixels um and you know what happens if
35:55 - you give it like like a circular area of
35:58 - pixels or start stuff with like random
36:00 - values what kind of patterns might you
36:02 - get and you can see the reaction
36:03 - diffusion algorithm is kind of
36:05 - blossoming into this nice little flower
36:06 - we can let it run for a little bit I'm
36:08 - curious about the frame rate I it's
36:10 - JavaScript is handling this pretty well
36:12 - is is only 200x200 pixels um so it isn't
36:17 - um it isn't a tremendous amount of
36:19 - pixels for it to work with but so you
36:21 - might run into some serious performance
36:23 - issues if you do this in the browser
36:25 - it's going to run a lot faster in
36:26 - processing of course I'm sure there's
36:28 - like fancy Shader web gel ways of doing
36:30 - this super super fast but um I think
36:33 - this kind of wraps up this tutorial so
36:35 - to recap just now that we've kind of
36:37 - like just want to use this last few
36:38 - minutes to kind of recap what I've got
36:41 - is uh here we started out with uh in the
36:47 - code I'm just going to walk through all
36:48 - the pieces of the code now there is the
36:49 - grid which stores the amount of A and B
36:52 - chemicals across every pixel there are
36:55 - all these constants which are associated
36:57 - with gray Scott inter implementation so
37:00 - there's a an amount of diffusion for a
37:01 - an amount of diffusion for B there's a
37:03 - feed rate and a kill rate so you can
37:04 - look up different values for those like
37:06 - known values that produce different
37:08 - patterns you can also just play with
37:09 - those yourself then I have to create
37:12 - these two-dimensional arrays I need a
37:14 - current and a next because I got to
37:16 - calculate the Next Generation and then
37:17 - use the current as the Next Generation
37:19 - then use it as the next I've got this
37:20 - cycling going on and I'm starting and
37:22 - filling it each spot with all chemical a
37:25 - and no B then I start a little area of
37:29 - pixels the 10 x10 area of pixels to put
37:31 - some chemical B in and this is another
37:33 - place where you wanting to play with
37:35 - this code you should try something
37:36 - different like what if you fill in
37:38 - around the Contours of a silhouette and
37:40 - you start getting this like silhouetted
37:42 - person reaction diffusion pattern then
37:45 - in draw I do a bunch of things number
37:47 - one is I just actually Implement that
37:50 - reaction diffusion formula I need to
37:52 - calculate the next amount of A and B
37:54 - based on the current amount of a the
37:55 - diffusion rate the feed the kill all of
37:58 - that stuff as well as this sum of all of
38:01 - the neighbors so the sum of all the
38:02 - neighbors happens in these lass
38:04 - functions and that is lower down in the
38:07 - code again I would suggest and I'd be
38:09 - happy to do this and post this at some
38:11 - point if someone else to remind me
38:12 - modified version I could condense this
38:14 - into one function and I could also make
38:15 - this happen in a loop but I think this
38:17 - really shows exactly what's happening
38:19 - and these weights again are defined by
38:21 - The Sims uh page you could use you could
38:24 - wait things you could have a 5x5 Matrix
38:25 - you could do different things there so
38:27 - that's calculating all those next values
38:30 - and then here the only thing that's
38:31 - happening here is I'm Now setting every
38:34 - single Pixel in the window a color based
38:36 - on the amount of a and the amount of B
38:38 - and I'm just using black and white so
38:40 - it's up to you I think I could go back
38:41 - you could say well the amount of a could
38:43 - be the amount of blue the amount of B
38:44 - could be amount of the green you could
38:45 - create Rainbow cycling colors somebody
38:47 - make a rainbow reaction diffusion thing
38:50 - um there's a lot of possibilities there
38:52 - for how you can play with this but this
38:53 - is all of the code I think this is
38:55 - probably a 40 to 45 minute video I'm
38:57 - assuming at this point um and so uh
39:00 - please play with this uh send me your
39:02 - feedback send me your comments and um
39:05 - let me know how it goes thanks for
39:07 - watching

Cleaned transcript:

hello and welcome to another coding challenge uh in this coding challenge I am going to look at the reaction diffusion algorithm so I have a version of it running right over there that is a processing sketch that is implemented the reaction diffusion algorithm I'm going to implement it in JavaScript uh do it from scratch in this video and you can see that this allows you to create this interesting kind of Labyrinthian uh uh visual in your canvas now there's a lot of different ways that you can apply colors and get different qualities to the image but I'm going to look at the sort of core classic reaction diffusion algorithm using the gray Scott model I will include some links below to reference Pages the one that I will build the code based on is right here in the browser the Carl Sims a Carl Sims tutorial page um and so the idea here is that I'm going to just sort of look at the drop dead simple classic algorithm black and white pixels only and then hopefully you after watching this and using the code might come up some other creative uses and applications of it so let's try to understand first what this algorithm actually is and so I'm going to close this window out and look at this diagram so the idea of reaction diffusion is kind of like you have your screen and you're about to pour some chemicals into it and those chemicals are going to react and there's going to be a lot of chemical a and then less of chemical B and they're going to react and diffuse and that sort of thing and then based on the how those chemicals are arranged in the screen in this sort of like dish petri dish of your canvas I'm going to we're going to set a color so if there's a lot of chemical a we're going to make the pixel black if there's no chemical a we're going to make the pixel white and kind of everywhere in between so that's the idea here now there are a lot of different um kind of key pieces here and let's just look at this quick diagram here thank you again Carl Sims for providing the diagrams for this video um chemical a so um the way it's going to work is the canvas is going to be filled with chemical B and then we're going to start to pour chemical a into the canvas the reaction aspect is chemical A and B reacting and maybe a is turning into B and the sort of diffusion in this way is that chemical is also going to get kind of like removed uh from it so there are some there are some key constants in the system that are numbers that you're going to see in the code one is the feed rate which is how fast are we pouring in chemical a and then another is called the kill rate I wish there was a nicer name for that but that's what it's called which is how what is the rate that chemical B is being removed so this is the idea now um so and you can see here what we're going to do is each each cell is going to have a certain amount of chemical a and of chemical B and those values are going to have a range between zero and one uh one being a lot of chemical a zero being none and then that amount is going to be used to set the color for a pixel and so you can see here uh how this how this kind of works we're going to do all this in code now how look at this now we have this like terrifyingly scary looking formula but we can tackle this formula I'm going to right here I'm here with you to tackle this complicated looking formula so let's put putting that aside let's kind of make a quick diagram so the way that I'm going to build this in code is I'm going to have a twodimensional array meaning I'm going to have a data structure that's going to keep track of uh each spot in that data structure is going to keep track of an individual cell call that a cell each cell is going to have an amount of chemical a and an amount of chemical B so what I need to do is understand uh if if there moments in time there are Generations This Moment In Time next moment in time so Moment In Time a0 moment in time b0 what I need to understand is how do I get the amount of a for Moment In Time One based on some function of the amount of a and the amount of B at time zero so this is what we're looking at and in fact over here that's what this formula is showing you the new value of a equals all this stuff based on the previous value of a and b and some other constants so this is what we need to do there's a bit more to it than this so you know I could say like oh A1 equals the average of a0 plus b 0 you know divided by two this could be our formula this would be a lot easier to implement so that formula is just like this but a lot more comp complicated so now but there the reason why there's more to it than this is because we have this scenario here of an individual cell we have to apply something called a convolution you're going to see I'm going to show you in a moment it says a convolution of a 3X3 Matrix all this scary sounding stuff so here is a 3X3 Matrix and this is a given cell and what I want to know is what is this cell's new values of A and B based on its previous value of a and b but not just it I need to know also based on its neighbors so these chemicals are reacting and combining in a given also with what are the chemicals next to it so the a convolution means take every single one of these cells and multiply it by some weight so if I were blurring an image for example I could use a blur as a blur meaning the average of a convolu of of a of a 3X3 Matrix of pixels so the new pixel color is going to be an average one nth of this color plus 1 nth of this color plus 1 nth of this color plus 1 nth of this color so I take all of the colors and multiply them by 1 nth add them all together I have the new color but we have a different um convolution here and it's described in in the diffusion uh in the reaction diffusion algorithm so this is the basic idea I need a twodimensional array each spot is going to have a certain amount of a and a certain amount of B I need to have a formula that for each cycle each frame through draw I get a new value of a and a new value of B and then a new value of a and a new value of B and the math formula is going to be something like this but more complicated because it's also going to involve all the neighbors so let's start setting this up now now hopefully this is the basic idea let's start setting it up to program it okay so now I'm back over here uh I am back over here ah oh was I not over there the whole time I think I was over there the whole time hopefully this was right uh somebody in the chat tell me was I in the on the Whiteboard while I was showing that um okay so if I go back to I have this blank uh code here um and uh I'm going to go to my uh canvas here and this is my canvas so the first thing I need to do is create okay I was good the first thing I need to do is create my uh twodimensional array to store all the amount the the amount of chemicals in each spot in the in the grid okay so twodimensional arrays in JavaScript are kind of a funny thing uh not funny haha funny a little bit weird because um arrays in JavaScript there's just so many different ways you can make them but ultimately what a twodimensional array is and let me kind of describe this to you briefly I'm going to make an array called grid and you could imagine like what if I did this um I'm going to write something like this I'm just going to kind of type something out for a second just to explain this this my friends you are my friends indeed is a twodimensional array I I kind of space it out like a grid but really what it is is just an array of arrays to see how it's an array open Square bracket n square bracket and then it's three arrays inside of it but I could but so really a twodimensional array in programming is just an array of arrays so what I need is one array to keep an array for here for here for here for here right so I need the first array to be the first row the second array to be the second row the third array to be the third row that sort of thing but I I'm not going to type it out manually for 3x3 I could type it out manually what I need to do is kind of um is actually make it um uh make it in code okay everything's going to be fine so I'm going to create that variable and I'm going to do it I'm going to use a particular style I'm going to do it different I'm going to do it different so what I'm going to do is I'm first just going to say grid is an array it's an empty array and what I need to do is I need to Loop x equals 0 x is less than the width of this canvas and let me Zoom back out x++ so for every X and for every y right for every X ah stop oh I can't ah I'm waiting for my auto format that's not here um for every x what I need to do is say grid index X is an array so I start with this array and then I say hey let's make an array and then what am I going to put here grid XY equals now what do I what do I need in each spot in the grid now if I were just if I only had a single chemical if I only had a single chemical I was just putting a single number in each one of these but I have two chemicals I have an A and A B so let's actually I think this is a place where I could just make a literal JavaScript object and say a is you know there's zero of a and there is a zero of B so uh and you know I don't think I need to be so longwinded about it this is such a simple object I'm going to do this so I make each spot in the grid each spot in the grid for every in every y there's an A and A B with zero of each chemical and I'm going to need to change that eventually but we're going to start there so this is good I now have my grid yay now here's the thing in order to make this work right the whole this whole this whole all built on this idea of I need to get the Next Generation amount of a so I can't be me if if this grid is the snapshot of all the chemicals in a current generation I need a complete completely separate grid to start filling in the new values because if I were to use the same grid if I start overwriting the values in that grid while I'm checking other values neighbors everything's going to get all messed up so what I should do is I'm also going to create a variable here called Next and I'm going to be kind of silly about it and I'm just going to make two of these and I'm going to say next so I now have two twodimensional arrays and I think I just want to briefly mention that um I could have done this so grid is going to be the current and then next is going to be the next one so I could have done this by also using new array in JavaScript to create a sort of fixed size but I know my array should have a width and height as kind of the number of uh columns and rows okay so now we're in good shape so what I could do what I want to do is just sort of see that the basic idea of this is working so what I need to do is draw a color a pixel color in the window based on each value in that grid so by the way we're going to need this double nested Loop like a zillion times so I'm going to just copy paste that down here and one one thing I'm going to do at the very end is I'm going to say load pixels and then I'm going to uh say update pixels and what I'm going to do is I'm going to uh create a color let's just make sure I'm going to just make a nice you know pinkish purplish color just to make sure this is working and I'm going to say pixels index oh boy so guess what everybody I have a whole video that goes through the pixel array I should link to that from here the pixel array in Java in P5 JS in the JavaScript canvas is a pixel array that has four spots for every pixel so I need to figure out and it's onedimensional so I go through the derivation of this formula but I'm going to say pix equals x + y time width Time 4 and then I'm going to say pixels pix plus 0 equals uh 255 and I'm going to this I don't need and I'm going to say zero and I'm going to say 100 and then and this is uh one one two and three so what I've done here is I'm using a formula to find the right spot in that array for every single Pixel every width every column in every row and then I'm saying make its red 255 make its green zero make its blue 100 make its Alpha 255 so I just want to see that this runs okay great so I filled it with a color so I do have a way of setting every pixel color now what I want is for these colors to be based on the grid so I'm going to say grid X comma y. a and I'm going to say grid X y.b so um so I'm going to do the red and the blue as coming from the twodimensional array itself and we should see all black but if I give everything a uh random amount we should see uh okay so what am I missing here so I gave the grid a random amount of a and a random amount of of B and uh what's missing oh I I did random between zero and one so I what I want to do is multiply these by 255 there's there's lots of ways I could use color mode or get around this but I'm just going to multiply that by 255 oh and I'm gonna have to say floor because it has to be an integer I bet uh okay so I probably could have done a better job at this but there we go so you can see that this is working I have a mechanism by which based on the amount of chemicals I get pixel color this is the core thing that we need so now all we need to do is say like okay let's put this formula in great so let's unpack this formula right because right now and and actually before we even do that let's let's actually just get the structure going so before I put the formula in let's do something let's put this nested Loop in again and what I want to say is now I need to use this next right next index XY equals and let me just do something like I'm going to make up a formula this isn't the actual reaction diffusion formula but what I'm going to do is where's the camera where's the screen I'm losing my mind I'm going to say grid X comma so next. a equals grid xy. a you know times 0.2 and next next the the next B is the grids B * 1.2 so I'm going to do that so this is this again this isn't the correct formula we're going to have to actually put in the reaction diffusion formula but I'm showing this is the structure by which I say the next generation will be that so now if I run this again me come back to here well it doesn't seem to be animating or changing why so it's not animating or changing because I'm still drawing it based on grid so maybe what I actually want to do is draw the next one and I did get something strange happening here so it looks different and let's actually um not let it go over the values go over me so you can see that it is actually doing something like the values are different but importantly here I don't see anything animating so one of the major things that we need here is and let's think about is something called a swap are you with me are you still paying attention I would understand if you weren't okay so I need a swap so this is a very common technique in seller automata systems and other types of Generation by generation systems what I have here is I have oops wrong side of this marker what I have here is I have a two dimensional array called grid and then I have one called next so grid is all my starting values then next is calculated and then next is drawn to the window well what should next should then become grid again so I can get a new next and draw that to the window so what I need to do is swap them what I need to do is say let me put next back into grid and then I have a new blank one to write on and I could just pull grid over there CU it's the old one I don't need it anymore so if I if I want to have this continuous generation I have the old and the new so new gets calculated then new becomes old and I could just use that old one that I had to be the next new one and then new becomes old then then new gets calculated new becomes old again so I need to have a swap so I'm actually going to write this as a separate function so at the end of every oops after I draw I'm going to call a function called Swap and I'm going to write that down can you see this I'm going to write this down oh somewhere down here so I'm going to write a function and called Swap and so what's going on here next I want grid to be next and I want next to be grid I want grid to be next and I want next to be grid I want to swap them oh but this is no good if grid is next and then next equals grid well then next is next because grid is next we've got a problem here so in a swap what I need to do is I need to have a temporary variable that keeps track of the old grid so now grid can become next and next can become that old grid temp so this is a very simple swapping algorithm to swap the values of two variables um and that'll do the trick for me so now if I swap them this will get applied over and over again so let's let's do 0. n and 08 just so we see something happening here and you can see it it went down to zero very quickly um and I could um you know I could say 0.95 and I could try doing 1.01 so you can see it's going towards it's going to go towards blue eventually so we can see we have the system going on again this isn't this is the like shiffman rainbow reaction diffusion algorithm which isn't very interesting at all so we have the guts here we have the foundation we have the twodimensional array each spot holds the amount of each chemical the screen is colored based on those chemicals and I have some formula to calculate the new chemical value based on the old chemical value so I don't know how long I've been doing this for but we're so close now all I need to do is actually go and get that scary formula uh from that web page and stick it in the code and we're done so let's go take a look at that this is going to be a bit more difficult than I might have imagined but let's see how it let's see how it goes so now we're back to here so let's look at all of these things okay a the difference of the new a equals what a so let's start putting this in uh so this we can do difference of a equals new a so I'm going to go back and um I'm going to probably need a lot more space here so um and I'm just going to do a for a second the new a right equals what the old a now I'm going to go back to this formula plus plus now what da what is da oh I can't operate the computer sometimes I went back by accident da is a diffusion rate so where are those here we go these are some typical values so this is by the way is something that you're going to after you watch this video and use example you're going to want to like play around with these values yourself or go look up other values the different values will produce different kind of results so diffusion rate of a is one so I'm going to in my code I'm going to make these uh Global variables da equals 1 let's see what else we got uh DB equals .5 diffusion rate for B the feed feed is how fast are you feeding in chemical a is 055 I'm going to call that feed just to because F can mean other stuff in programming 0.055 was that it yep and K is 0.062 uh VAR k equal 0.062 that's that's sort of the the the kill rate how how fast is a b being removed um so these are the values that I'm going to need in that particular formula so now I can go back here and say uh plus the diffusion rate of a times upside down triangle PL 2D function okay so let's let's make that something temporarily that we're going to deal with in a little bit so I'm just going to say right now I'm going to say la I'm GNA make that a function La a we're going to deal with that later and uh times a times and you know what I should do to make this shorter I think something that can make things a little easier is I can say a equals grid X Y A so that way I don't have to every time I need that a value I can just put a time a times uh uh oh no minus minus what a * b^ 2ar uh so a * B * B and I'm going to I need a variable for a boy this is a lot of typing here guess you could fast forward now or put this on two times speed if you're watching this still uh I kind of want to like put this on multip lines also just so you can see it so uh whoops no this should be here I'm going to do each piece of this formula on a different line uh I don't know if this is making it uh um minus a * B * so we have a * the diffusion of a plus this lla thing I have to get to time a minus a * B * B and then now we have plus the feed multiply by 1 A so plus the feed multiplied 1 A did I get that right plus the feed multipli by 1 minus a and I'm going to put parentheses around these things I think I'm sure it's right anyway but this I think will help us a plus d a that doesn't seem right A Plus da times llas so I I so I'm going to um just to be consistent here I'm going to move this down here and uh I think I now have all the components of that formula a plus da * LL time a minus a * B * B plus feed * 1us a does that look right somebody watching this in the live stream will correct me I think I've gotten this right um and we will uh yeah da llas times a okay so hopefully I got this right I have to do the same thing for B why not just do it right now that we're here so B is B plus uh the the diffusion rate for B and I'm going to make a llas b function which is a little bit silly what I'm doing here but I'm going to do it anyway um uh times B and then it is plus ab^ 2 plus ab^ 2 minus uh minus k + f time B K plus feed times B okay we're in good shape here I'll put parentheses around this just to be consistent so I think I now have um so I think I now have these formulas now I I did miss a crucial point if you come back to this you'll see delta T delta T is the change in time for each iteration what does that mean well the way the world works is that Time Marches forward on and on and on the way that computer programs and animation programs work is Time Marches forward in time steps lock step and how and we're doing this calculation in this sort of like stop calculate wait stop calculate wait stop calculate so we can sort of scale the amount of time that's passing scale the calculation according to I'm going to leave that as one and basically my time scale is going to be the 60 frame per second that I hope that the um that the uh algorithm uh that I hope that the animation plays out at but you can really sort of change the quality of what you're getting and the degree of accuracy that you're getting by having a smaller time step so you might try 0.1 01 0.5 and see what you get but I'm going to kind of just leave that out for right now for the for the case of Simplicity Okay so we've done everything now except for this Lan thing and so I'm realizing by the way that this is lassi and a this is not multiply by a this this is the lloan a thing so one thing I can do is get rid of this times a and this times B um so what is that this is the convolution so this is this particular thing what I need to do in the llas function is look at the every single amount of a in all of the neighbors I need to multiply a weight and then add them all together to get the new value that's the lassan function the convolution so if we go back here let's go back to this page and here it says um the leian is performed with a three now there's different ways you could do this but this says with a 3X3 convolution with a center weight of Nega one adjacent neighbors 02 and diagonals 05 this means the following so I need to in this function look at every single cell and apply a weight 0.5.2 5 2 point uh this is the center one Nega 1 and then 2 05 2 05 the diagonals get a weight of 05 the adjacents get a weight of 0. 2 and the center gets a weight of negative 1 we're trying to determine the difference between that Center cell and its neighbors and you notice it's in a way these have higher weights because it's like the adjacent ones are closer to it than the diagonals so those chemicals are going to play a larger role in the reaction you could try messing around with different values now there are all sorts of fancy ways I could write another nested Loop and kind of use some sort of other twodimensional array to keep track of the weights I probably should do that but I'm going to be a little bit lazy right now and just do this in a very hardcoded manual way so let's look at how I might do that um so if I come back here first of all let's just write um so down here I'm going to need a function called llas a and I'm also going to need a function called llas B and I'm just going to do something right now I'm going to just say they return the value one which is obviously like wildly incor oh boy I'm not here uh so I need to add these two functions sorry I lost I didn't get back here I need to add these two functions and I'm just for right now for Simplicity to make sure my code runs just say that they return the number one so that this should do something and I should get something um and I should get something so let's run this and you can see okay so something's working and you can almost even like see it oops see it like Flicker and do something weird interesting for a second so that's good the other thing I want to change by the way and I'll deal with this later though let's leave that now okay so but now I need to actually do the correct llas function so what I think I'll do is pass into llas the function the current X and Y and then I'm going to do the entire calculation in that function and I need to do it with the grid right so what I need to do is say something like the sum for a is zero and then what I need to do is say sum a plus equal okay what's the center the center is grid X Y times that weight1 so I need to do this like nine times for all nine neighbers 2 3 4 5 6 7even 8 nine so the adjacent ones are all multiplied by 0 2 so adjacent to the left is x minus one adjacent to the right is+ one so these get multiplied by 02 then uh above and below is y + 1 and Yus one those get multiplied by 0.2 0.2 now I need to do all the diagonals again this is like a kind of terrible manual way of doing it but it's and I could do this in a loop in a much nicer way but I think this is good for figuring it out uh minus one minus one 0.05 that's up into the left + one minus one and I just need this same same value for each one of these uh uh okay then I need uh I need plus one + one and then minus one minus one does that seem right to you did I get oh no no no no I already did minus one minus one plus one so I have oh boy I've been doing this for a half an hour that's that's not good um okay look this is turning out to be a very long video I should have done it in multiple Parts but it's too late now okay so uh minus oneus minus minus plusus plus plus minus plus that's all four so I think I've gotten this right and then I just need to return and I need to get those X Y values as arguments and then I need to return that sum a uh and then oh and I'm not returning that whole object I'm not adding that I'm adding the a amount for each one of these and you know so I could do this in a more clever way by also having a B1 function to add these objects together so now it's going to do the and I could even like do a function that knows whether it's doing lla or a or b but again I'm just going to do this completely the totally manual way and we can do another video I'm gonna I can make this just a few lines of code and I'm just going to be sitting here come on Sublime it's try it's trying to be way too smart for me I just want to I don't want you to give me suggestions sometimes I want suggestions sometimes I don't want suggestions and this is silly now that I called it this but I did so I'm going to go I'm going to go all the way through with it okay so now we should we've got these lass functions I'm doing the convolution for every X and Y adding up all the neighbors and the weights so that should go right into this formula and honestly I think we might be done I'm going be shocked if this actually works we're gonna have to debug what we missed but let's run it I I I know this's kind of okay so sketch ah great I love what just happened here so what just happened here cannot read property zero of UND Define so I have I I could kind of try to figure out what's going on let's look at sketch. JS line 65 um so down here there's an issue here's the issue xus one when is xus one going to be a completely invalid spot in the Grid it's a completely invalid spot if x is zero because there's no negative one so I could do some sort of wraparound thing or whatever but I think what would be easiest here would just be to say hey you know what for this calculation I'm not going to do the edge pixels I'm going to start at one and I'm going to go to width minus one and height minus one so I'm actually going to ignore the edge pixel so I don't have that issue so that should fix that now I'm going to run it and look at this something kind of crazy happened so I think I've got the algorithm going here I'm a little worried I have a mistake but the most mostly the problem right now is that I haven't really seated this this in a way that makes sense so I think the traditional way these are done let's look here is right I'm giving the grid all random values is what I think would make sense would be to fill it with B right I want to fill the grid with B let's run this it's blue and it uh or it kind of turned red that's interesting that's not what I expected to happen but I'm going to just leave that that and then what I want to do is I want to give one spot like I'm going to say I'm going to override that I'm going to say like uh 100 100 a actually has a b out of a in it so I fill the grid with b and no a and then I give one spot I I pour in a little a in that one spot why am I getting this that's so interesting that I'm getting this weird Square thing so I must have messed something up hello I'm back I don't know where I would that's G to get edited somehow um so here's the issue I just I I wanted to add like a little bit of B like I filled the whole thing with a actually switched that from when I was maybe last in this video so I filled the whole thing with a and then I want to add a little bit of B but that's not going to work just like a one little droplet of be on one pixel not going to get enough reaction diffusion to make anything happen I actually need to give it a block a block of like I need to pour a lot more in so I need like a little area of so what I think I'm going to do is I'm going to say uh for I'm going to use I here just to use a different like IAL 100 I is less than 10 I ++ no I is less than 110 I Plus Plus+ now how you seed the system is like super interesting and I'm doing this not in a very interesting way but I'm going to use J uh j++ and what I'm going to do is I'm going to take a whole area and give it some B like a little 10 by10 pixel area so every pixel from between 100 to 110 is going to get some B right every pixel is going to start with a lot of a and no B and then this little 10x1 areas can to start with the and what I'm actually going to do is just for a second comment this out so let's just see what this looks like now why am I I'm getting this crazy flickering you can't see that actually interestingly enough I don't think the flickering is showing up because I've done something wrong with my rendering but you can see though that oh whoa oh now you're seeing interest I don't know what you're actually seeing on the stream um oh boy this is a really this was a much harder one than I imagined but I'm going to put this back in I got to figure out what the flickering is there why the flickering is happening okay so you can see this is now finally working um I'm getting a weird flickering around the edges oh oh I know what the problem is I know what the problem is because I'm not updating the edges the edges need to make sure they're seated with the original amount of stuff there we go finally we're good so it took me a little while there but but the issue was that I needed to place an area of of pixels um in order to to to seat it with some chemical B so uh this was this was much this would have been good this would have benefited from this will benefit from a second run like I could just do this whole thing again and probably get through it a lot faster with less hiccups but hopefully this helped you you can see now I now have the reaction diffusion simulation you can see this is one little area of pixels um and you know what happens if you give it like like a circular area of pixels or start stuff with like random values what kind of patterns might you get and you can see the reaction diffusion algorithm is kind of blossoming into this nice little flower we can let it run for a little bit I'm curious about the frame rate I it's JavaScript is handling this pretty well is is only 200x200 pixels um so it isn't um it isn't a tremendous amount of pixels for it to work with but so you might run into some serious performance issues if you do this in the browser it's going to run a lot faster in processing of course I'm sure there's like fancy Shader web gel ways of doing this super super fast but um I think this kind of wraps up this tutorial so to recap just now that we've kind of like just want to use this last few minutes to kind of recap what I've got is uh here we started out with uh in the code I'm just going to walk through all the pieces of the code now there is the grid which stores the amount of A and B chemicals across every pixel there are all these constants which are associated with gray Scott inter implementation so there's a an amount of diffusion for a an amount of diffusion for B there's a feed rate and a kill rate so you can look up different values for those like known values that produce different patterns you can also just play with those yourself then I have to create these twodimensional arrays I need a current and a next because I got to calculate the Next Generation and then use the current as the Next Generation then use it as the next I've got this cycling going on and I'm starting and filling it each spot with all chemical a and no B then I start a little area of pixels the 10 x10 area of pixels to put some chemical B in and this is another place where you wanting to play with this code you should try something different like what if you fill in around the Contours of a silhouette and you start getting this like silhouetted person reaction diffusion pattern then in draw I do a bunch of things number one is I just actually Implement that reaction diffusion formula I need to calculate the next amount of A and B based on the current amount of a the diffusion rate the feed the kill all of that stuff as well as this sum of all of the neighbors so the sum of all the neighbors happens in these lass functions and that is lower down in the code again I would suggest and I'd be happy to do this and post this at some point if someone else to remind me modified version I could condense this into one function and I could also make this happen in a loop but I think this really shows exactly what's happening and these weights again are defined by The Sims uh page you could use you could wait things you could have a 5x5 Matrix you could do different things there so that's calculating all those next values and then here the only thing that's happening here is I'm Now setting every single Pixel in the window a color based on the amount of a and the amount of B and I'm just using black and white so it's up to you I think I could go back you could say well the amount of a could be the amount of blue the amount of B could be amount of the green you could create Rainbow cycling colors somebody make a rainbow reaction diffusion thing um there's a lot of possibilities there for how you can play with this but this is all of the code I think this is probably a 40 to 45 minute video I'm assuming at this point um and so uh please play with this uh send me your feedback send me your comments and um let me know how it goes thanks for watching
