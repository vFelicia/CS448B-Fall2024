With timestamps:

00:00 - hello welcome I am very excited that
00:02 - this is another guest tutorial video and
00:05 - today's guest is I meant to ring the
00:07 - bell after I said her name and Alicia
00:09 - she is Peter in the studio and she just
00:13 - did a tutorial building exactly this
00:15 - what you see behind me which if you
00:16 - don't recognize is a visualization
00:19 - mirroring the rain effect in moving the
00:23 - matrix-matrix rain so this is really
00:24 - wonderful it's a perfect thing to use
00:26 - p5.js for and there's a lot of creative
00:28 - possibilities that I hope that after you
00:29 - watch the tutorial you will make and
00:31 - share and share so a couple things I
00:33 - want to mention number one if you're
00:35 - looking for the source code for this
00:36 - tutorial if you're looking for Emily's
00:38 - Twitter to share what you make with her
00:39 - everything will be in this video's
00:41 - description I also wanna mention for
00:43 - those of you viewers here we've always
00:45 - asked me to please use for each loop you
00:48 - will finally see on the coding train sub
00:50 - for each loop in this particular video
00:52 - because Emily very smartly is using them
00:54 - so without further ado I will leave this
00:57 - screen and you'll then see the tutorial
01:00 - starting from Emily oh I want to say a
01:01 - few things about Emily so Emily is a
01:03 - creative coder and artist she has done
01:05 - workshops and other projects with
01:07 - organizations great organizations like
01:09 - girl develop it and pioneer works in
01:10 - Brooklyn and she's also currently
01:12 - working for Squarespace so you could
01:14 - find out more about her to check out her
01:16 - Twitter and her website which will also
01:17 - be linked in this video's description ok
01:19 - now just enjoy the tutorial ok thanks
01:21 - bye
01:22 - ok everyone and thanks for the wonderful
01:25 - intro dan I'm super excited to be here
01:27 - especially as someone who's been
01:29 - following this YouTube channel for a
01:31 - while now so for today's tutorial we're
01:34 - going to be rekt creating that iconic
01:36 - matrix raining code using p5.js
01:40 - and some of you who have never seen the
01:43 - matrix series before don't know what it
01:45 - is that I'm talking about
01:46 - have no fear I'm going to play the clip
01:48 - from the movie to clarify
02:01 - [Music]
02:04 - cool so that ringing green code this
02:09 - right here this is what we're going to
02:11 - be recruiting using t5 and in terms of
02:14 - background level I'm going to teach with
02:16 - the assumption that you have some basic
02:18 - understanding of object-oriented
02:20 - programming and may be rich in a few
02:22 - simple p5 sketches maybe you've seen
02:25 - some advanced videos on this channel or
02:27 - maybe it just sort of explored the
02:30 - library yourself anyway let's jump right
02:33 - in so here is my sketch file where all
02:39 - the p5 magic will happen and right now
02:43 - it's empty but let's still in with our
02:45 - two core p5 functions set up being one
02:49 - of them and as some of you might know
02:54 - this is the function that gets in both
02:56 - watts immediately upon loading up your
02:58 - sketch and I know I'll also need the
03:02 - function draw which some of you might
03:05 - also know it's the function that gets
03:08 - called repeatedly at 60 frames per
03:11 - second as your sketch run so now that I
03:15 - have these down let's start first by
03:17 - flushing out setup so inside of this
03:21 - function I'm going to make my canvas so
03:24 - as to carve out where on the webpage
03:27 - I want my sketch to be we're going to
03:30 - use the function create canvas and I
03:33 - actually want the sketch to span the
03:35 - entire page so for the with argument I'm
03:39 - going to pass in window dot inner width
03:42 - and this returns the width of your
03:45 - browser's entire content area and for
03:49 - the height I'm going to pass in window
03:51 - dot inner height as what you might be
03:54 - able to guess returns the height of your
03:57 - browser's content area cool so I know I
04:02 - also want my background to be black so
04:04 - let's go ahead and set that to zero and
04:08 - let's run this there we go awesome so we
04:14 - have our initial setup
04:16 - which I blend entirely into so this is
04:19 - the scene where we'll make the matrix
04:21 - raining code happen so now let's take a
04:24 - step back and think about the sketch at
04:26 - a higher level and let's sort of
04:28 - consider what might be some of the
04:30 - general components or classes here so if
04:34 - we look at this as a matrix if you look
04:36 - at the screenshot here I can sort of
04:38 - sense that there are going to be two
04:40 - primary object types one of them being
04:43 - the symbol so it's like each one of
04:45 - these characters individually and the
04:48 - other one being the stream object so a
04:51 - stream being like one of these vertical
04:53 - lines comprised of symbols so let's go
04:57 - back to our code and let's stub out
04:59 - these prototypes and by the way I'm
05:02 - going to use the term prototype and
05:04 - claps interchangeably here so as we go
05:08 - to code and stuff out symbol there we go
05:14 - and our stream here we go so let's start
05:23 - off with our symbol class and make just
05:26 - one symbol and show chill it for now and
05:28 - we'll get to the screen coughs a little
05:31 - bit later so I'm just going to go ahead
05:32 - and move it down a bit so for our symbol
05:35 - you're going to need an X and the y to
05:39 - show the location on the canvas both of
05:41 - which will we pass in to this signature
05:44 - here and then let's add these properties
05:47 - so this dot x equals x dot y equals y
05:51 - and we also want a variable to hold the
05:55 - actual symbol itself and we'll call this
05:59 - value and this will be set later on
06:04 - using this function set to random
06:08 - symbols
06:14 - okay so one will go into this function
06:18 - what should each symbol get set to maybe
06:22 - take a look at the matrix you'll see
06:26 - that the symbols are in fact comprised
06:28 - largely of katakana which are characters
06:32 - that represent syllables in Japanese and
06:34 - I knew I knew being the an indigenous
06:37 - ethnic group living in Hokkaido and
06:39 - Russia
06:40 - so that's your a bit of trivia for today
06:43 - so how do we represent these characters
06:45 - our keyboards won't let us type in
06:49 - katakana so what do we do
06:51 - also we're almost simply enough we will
06:54 - use unicode which is an American coding
06:56 - in order to represent them and pictured
07:00 - here here is all of the katakana in the
07:04 - katakana unicode block and our 96 total
07:08 - so let's go to our code and write our
07:11 - function to randomly retrieve one of
07:13 - these beautiful symbols here we go
07:18 - and I'm actually just going to wipe this
07:21 - out and I'll explain in a bit so that's
07:23 - not value equals green dot from care
07:30 - code okay there we go the past in 0 x3 0
07:40 - a0 plus round it to a random number 0 96
07:46 - okay so that looks about right
07:49 - so the katakana unicode block starts
07:53 - encoding 0 x3 0 a0 which translates
07:58 - numerically to 1 2 4 4 8 which will then
08:02 - be added to a random whole number
08:05 - between 0 and 96 because there are 96
08:10 - available characters in the katakana
08:12 - unicode block and then whatever number
08:16 - results from this addition will be
08:18 - passed into this function from care code
08:21 - and finally converted into a string
08:25 - containing your katakana characters and
08:28 - set to this stop value okay so now that
08:33 - we have the code to retreat and set our
08:37 - symbol let's write a function to
08:39 - actually display it on our canvas and
08:42 - we'll call it render it's going to
08:47 - scroll down a little bit for everybody
08:49 - to see so we'll use the text function to
08:53 - actually display our symbol and we know
08:57 - that the symbol is contained in this top
08:59 - value and we want to display at
09:01 - coordinates X and coordinates x and y
09:04 - and we'll fill it with colored 0 for red
09:10 - 255 for green because we want it green
09:15 - but we also don't want it sugaring so
09:18 - maybe we can I don't know add a little
09:20 - bit of blue in there so maybe like a
09:22 - blue value of 7b might look nice great
09:26 - so now respecting love so that we can
09:30 - create our symbol and renters so if we
09:33 - go back up here at the top of our code
09:36 - let's start a global variable to hold
09:40 - that symbol we'll call it a symbol and
09:43 - since its global we can access this
09:47 - variable anywhere in our global scope
09:49 - and now down in our setup function let's
09:53 - stick an instance of our symbol into
09:56 - that global variable so symbol equals
09:59 - new symbol okay
10:02 - and for now we'll display the symbol
10:05 - smack-dab in the middle of the screen
10:07 - the canvas just for demonstration
10:09 - purposes so we'll set the x value to
10:12 - what's divided by 2 and the y value to
10:16 - height divided by 2 and now within the
10:21 - draw function oh we should probably set
10:24 - the symbols values symbol dot set to
10:27 - random symbol there we go and now within
10:31 - our draw function let's render it symbol
10:36 - dot oops
10:38 - of thunder okay and let's play okay so
10:47 - I've made a mistake somewhere let me go
10:49 - ahead and inspect my code so it says
10:52 - somewhere on line 12 but there's an
10:53 - unexpected token ah I have an extra
10:58 - comma here I'm going to fix that and now
11:02 - I'm going to replay this okay awesome so
11:10 - now we generate a random kind of Kanna
11:12 - character but actually it's a little bit
11:14 - small I'm not even sure if you can see
11:16 - it so let's go to our code and increase
11:20 - the size of the symbol and we'll do that
11:22 - by creating a global variable called
11:25 - symbol size and let's set it to
11:29 - something huge just so that we can see
11:31 - so I think maybe 60 and now within our
11:35 - setup let's actually assess the text
11:39 - size here text size I believe is the
11:42 - function to our symbol size and now I'm
11:49 - going to refresh okay fantastic so now
11:54 - we generate a random katakana character
11:57 - whenever we load up our sketch and if
11:59 - you refresh I'm just going to refresh
12:01 - here you'll see that you get a new one
12:04 - every single time however in the matrix
12:09 - the symbols don't just sit there in the
12:12 - middle of the page they rain down so
12:15 - let's go ahead and write some code to do
12:18 - just that so let's go back to our sketch
12:20 - file and if we go back to our symbol
12:25 - class what's that a speed value here to
12:29 - determine the rate at which this symbol
12:31 - Falls so speed will get passed in and
12:36 - the speed property will get passed a set
12:39 - as what gets passed in and what's right
12:44 - a function to actually make the symbol
12:46 - rain down and I think an appropriate
12:48 - name would be
12:50 - rain okay and inside this function all
12:55 - we're going to do really is increment
12:57 - the Y position of the symbol object
13:00 - according to the speeds still have to
13:02 - make the symbol slowly move down the
13:04 - page so this got y plus equals the stop
13:09 - speed okay and now within render let's
13:13 - pass in a random speed sorry now within
13:19 - our render function since this is what
13:21 - gets invoked on every frame by a draw
13:25 - let's make it rain
13:27 - so this stop rain right
13:31 - and now back in our setup what's passing
13:34 - a random speed whenever we create this
13:38 - new symbol object so for now let's say
13:44 - we'll give it a ballpark of five to ten
13:48 - so randomly generated but let's also
13:51 - switch the Y value out so it's not
13:54 - halfway down the page will cause it why
13:56 - I like how the symbols start up the top
13:59 - of the canvas so we'll set Y does zero
14:01 - okay so let's go ahead and refresh this
14:08 - okay voila so we now have a symbol that
14:12 - rains down the page but we actually want
14:15 - to redraw the background on every frame
14:18 - so that it erases this trail because
14:20 - this isn't what the matrix looks like
14:22 - let's go to our code let's go to
14:25 - backgrounds other let's go to draw and
14:28 - let's uh stick the background in there
14:31 - okay and now let's replay this okay
14:40 - great
14:41 - so now we have a symbol that rains down
14:44 - but once this character reaches the
14:47 - bottom of the screen we actually want it
14:50 - to loop back to the top and replay all
14:53 - over again kind of like a jiff so let's
14:56 - go to our code let's go to the rain
14:59 - function okay and let's rack
15:03 - the in a bit of a conditional with
15:08 - throughout the increment okay so if this
15:15 - dot Y is greater than or equal to height
15:18 - so if the Y value is greater than the
15:21 - height of the canvas this means that
15:23 - it's reached the bottom
15:25 - so let's reset Y to 0 otherwise let's
15:31 - just proceed as normal
15:34 - okay and actually we can make this look
15:37 - a little bit nicer using a ternary
15:39 - operator which is just a syntactic cuff
15:42 - for this commonly occurring a
15:44 - conditional pattern so there was me four
15:47 - seconds that's got y equals this cot why
15:52 - is it greater than or equal to hype if
15:56 - it is then set it equal to zero
15:59 - otherwise increments Y with the speed so
16:07 - this this here and this here are the
16:10 - same I'm going to get rid of that and
16:12 - now we have some nicer looking code so
16:14 - I'm just going to go ahead and replay
16:16 - this now okay great so now we have a
16:25 - symbol that rains down in a continuous
16:28 - loop in the R matrix but if we paid
16:32 - attention to that clip from the movie
16:35 - we'll see that a symbols randomly
16:38 - switched to other symbols as it leans
16:40 - down so let's go ahead and implement
16:43 - that let's go to our code and let's go
16:48 - to our render function since this is
16:51 - what gets called on every frame and if
16:54 - you think about it we've actually
16:55 - already written a function that allows
16:58 - us to switch from one character to
17:01 - another and that is set to random
17:04 - symbols so let's go ahead and just call
17:06 - that within this render function
17:12 - okay so now I'm going to play this again
17:18 - okay great so it's switching to a new
17:21 - random symbol but it's doing it way too
17:24 - fast it kind of looks like a blur you
17:26 - might not even be able to tell what this
17:27 - is so instead of making it switch on
17:30 - every single frame and there are 60
17:33 - frames per second let's do it
17:35 - accordingly according to a interval okay
17:39 - so let's go back to our code and um hmm
17:45 - let's go to the symbol class and let's
17:48 - make this interval a property of the
17:52 - simple class so this stops which
17:55 - interval seems like a pretty good name
17:57 - and simply know that the switch interval
18:00 - should maybe differ a bit for every
18:03 - symbol
18:03 - let's randomize it so I'm going to
18:07 - randomize it to a whole number between I
18:11 - don't know 2 and 20 let's say and now
18:16 - let's go to our set to random symbol
18:19 - function and restrict the symbol being
18:22 - reset by the switching table and we can
18:25 - do that using a conditional let's wrap
18:29 - this all in a conditional so if frame
18:32 - count I'm just going to write this and
18:34 - I'll explain it in a second
18:37 - modulo this which interval is equal to 0
18:42 - I'll move this line of code up here some
18:49 - proper indentation there great
18:54 - so frame count is a variable that is
18:59 - built into p5.js for you and keeps kind
19:02 - of just running tally of how many frames
19:05 - has passed thus far and modulo is an
19:09 - operator that performs division and
19:11 - returns the remainder so we performing
19:14 - modulo on frame count using switch
19:17 - interval and so we're looking for a
19:20 - remainder of 0
19:21 - here we're basically saying whenever the
19:25 - switch interval divides evenly into our
19:27 - frame count then execute this line of
19:30 - code so it's winter such interval over
19:33 - 15 this means that when the frame count
19:37 - is 0 or 15 or 30 or 45 the modulo will
19:42 - return a zero and then we set a new
19:46 - symbol football is very short this code
19:49 - says to reset the symbol at every end
19:51 - frame and being your switch interval
19:54 - anyway let's play this now great okay so
20:03 - now we have a symbol that rains down and
20:06 - switches to another symbol at a randomly
20:09 - determined interval so now that we have
20:12 - our symbol class figured out let's make
20:15 - it rain not just one symbol but an
20:18 - entire stream of symbols and since
20:22 - stream comprises of symbols our symbol
20:26 - should be should live inside this Greek
20:29 - stream class so let's remove that single
20:32 - symbol that we've subbed out for
20:34 - demonstration purposes let it go to my
20:37 - setup remove yeah little bit and remove
20:42 - this from as a global variable and now
20:46 - let's go to our stream class let's all
20:51 - the way down here move this up a little
20:53 - bit and without a property that contains
20:58 - an array that will hold all of our
21:00 - symbols for the stream
21:02 - so this stop symbol is what we'll call
21:04 - it let's give it an array and now
21:08 - thinking through some of what are the
21:11 - other attributes of what constitutes a
21:13 - stream I think each stream should know
21:15 - how many symbols it has
21:17 - so this thoughts total symbol pretty
21:20 - good name and let's give it a range that
21:23 - it could randomly pick from so that each
21:25 - stream has a different number of symbols
21:28 - in it so I don't know maybe
21:33 - on streams will be as short as five
21:35 - symbols and some trees will be as long
21:38 - as three symbols and they'll be screams
21:40 - of all sizes in between okay and I also
21:44 - think that each stream should know how
21:47 - how fast is traveling at so let's give
21:51 - it a speed property let's set it to a
21:55 - randomly determined one let's say
21:57 - somewhere between I don't know five and
21:59 - twenty I also think it should be the
22:03 - responsibility of the extreme to create
22:06 - all of its own symbols during the
22:08 - initial setup
22:09 - so let's write a function to do that and
22:13 - this function will use a loop to do all
22:15 - of that so we'll call it generate
22:20 - symbols okay there we go and outside of
22:29 - our loop will set a Y variable that gets
22:32 - passed into our symbol objects and we'll
22:35 - start it at zero so that it starts at
22:38 - the top of the page and for an X
22:42 - variable let's also set that to let's
22:46 - set up to a width the width divided by
22:49 - two so that we see it the symbol for the
22:52 - screen at the top of our canvas in the
22:55 - middle okay all right so let's write our
23:00 - loop so for each of our four loops looks
23:05 - more like this start at zero and we want
23:10 - to loop through however many symbols
23:15 - there are that's how many times a loop
23:17 - through and we'll increment our loop and
23:23 - on every iteration we should create a
23:27 - new symbol so we'll pass in X Y and
23:36 - speed at which the stream is going and
23:40 - right after we create the symbol we're
23:42 - going to set the symbols initial values
23:45 - so set
23:46 - - random symbol and then we're going to
23:50 - take that symbol and push it into the
23:53 - streams symbol array so that it can live
23:56 - there and then at the end of each loop
24:02 - we also want to decrement Y whoops looks
24:08 - like this
24:10 - what is decrement Y by the symbol size
24:14 - there we go so that's the third except
24:17 - the next symbol immediately above it so
24:21 - at the program start if you were to
24:24 - render all of the symbols in the stream
24:26 - what it would look like is if you're at
24:29 - the top of the canvas the streams of the
24:31 - symbol to be stacked in a straight line
24:33 - above the canvas and that's because Y
24:36 - starts at zero and gets decremented and
24:40 - since it's the streams responsibility to
24:42 - create its symbol let's also give it the
24:45 - responsibility to display each symbol on
24:47 - the canvas so let's write a function for
24:52 - this we'll call it render and we'll
25:00 - write a for each loop looping through
25:05 - all of our symbols and we're going to
25:11 - pass in an anonymous function and call
25:14 - each of the elements that were iterating
25:17 - over symbol and we can actually copy and
25:23 - paste the code that we wrote in the
25:26 - symbol class since we're transferring
25:28 - responsibility of rendering from from
25:32 - the symbol to the stream okay
25:34 - so let's copy and paste this and let's
25:39 - also get rid of the remnants of this
25:40 - function and then let's let's paste this
25:46 - so indents things correctly and since
25:52 - each elements that we're iterating over
25:56 - it's called symbol we must change all of
25:57 - this too
25:59 - bowl
26:08 - okay and there we go and by the way keep
26:16 - in mind that there is more than one way
26:18 - to skin a cat
26:19 - you can cheap it so that it is the
26:21 - symbol responsibility to render
26:23 - themselves and organize your code in
26:26 - such a way but I prefer it this way and
26:28 - I think ultimately it will make the code
26:30 - look just a little bit nicer and easier
26:32 - to read so now that we have our stream
26:35 - clock figured out
26:39 - let's go back to the top of our code and
26:41 - write a global variable to hold our
26:45 - stream so we'll call it screen and then
26:51 - what's in our setup creates our stream
26:57 - so free okay and then after we create it
27:05 - let's instruct it to generate all of its
27:09 - symbols and finally in bra let's render
27:16 - that stream so looks this symbol no
27:22 - longer exists we're gonna render the
27:24 - screen okay so let's load this thing up
27:27 - and how we did okay awesome so now we
27:34 - have a stream that rains down repeatedly
27:37 - and the stream contains characters that
27:40 - switch at their own randomly determined
27:42 - intervals but as you may have observed
27:45 - the matrix does not have just one stream
27:49 - there are streams all the way across the
27:51 - screen so let's go ahead and set things
27:54 - up so that our matrix is all the more
27:57 - exciting let's go to our code and let's
28:04 - change the global variable so that
28:08 - instead of holding just one screen it
28:11 - holds an array of extremes now let's
28:15 - give this an X so it's streams
28:19 - and now in our setup let's populate that
28:23 - array with a loop so I'm just going to
28:28 - go ahead and get rid of this one term
28:31 - that we've subbed out and outside of our
28:34 - loop we're going to have an x and a y
28:37 - variable which will inform the
28:39 - coordinates of each stream so let's
28:43 - start them both off at zero and now we
28:47 - loop so start the loop at zero and we're
28:54 - going to go until whips divided by
28:57 - symbol size and we want to divide the
29:01 - total width of the screen by the symbol
29:04 - size in order to get the total number of
29:06 - streams since each stream is a symbol
29:09 - wide so there we go
29:13 - and now let's loop so we're going to
29:17 - create a new stream on every iteration
29:26 - and then instruct the stream to create
29:30 - generates all of its symbols there we go
29:36 - and we originally hard-coded X&Y into
29:41 - the generate symbols function but since
29:43 - each stream will have a variable x and y
29:46 - that gets packed into it we should just
29:49 - go in and let's go to that function and
29:52 - let's pass those variables into it
29:56 - reflect that in the signature and get
29:58 - rid of this x and y that we hard-coded
30:00 - okay great so now going back to our loop
30:07 - where was it ah here it is so once we
30:12 - once we have our stream and all of its
30:15 - symbols we'll push it into the mega
30:18 - array containing all of the streams so
30:21 - stream dot push that one stream that we
30:26 - just made and then we also want to
30:29 - increment where X starts
30:32 - because we want each stream to start
30:35 - right next to the last one
30:36 - so we'll increment by symbol size
30:40 - because each three money know is a
30:42 - symbol symbol wide so now in draw
30:47 - instead of rendering just that one
30:49 - stream let's write a loop that will loop
30:53 - through all of our streams and render
30:55 - them all at watch so let's go to draw
30:58 - let's get rid of the rear Enders just
31:01 - that one screen and we'll write a 4h on
31:05 - our streams mega array and we're going
31:09 - to pass in a function each items that we
31:17 - iterate over and screw in this loop will
31:20 - be called stream and get rid of that
31:23 - okay
31:24 - and every time we loop through we're
31:27 - just going to OH
31:31 - screen there we go Thunder okay now I'm
31:39 - going to play this and see what happens
31:41 - oh okay so I've made a bit of a mistake
31:44 - here let me go to my console and try to
31:46 - figure that out so I have an unexpected
31:49 - token on line 12
31:51 - so line 12 oh okay so I forgot to
31:55 - increment my loop that's no good so I
31:59 - think this should be alright now
32:04 - actually I'm going to go ahead and
32:06 - change each symbol just be a little bit
32:09 - smaller while I'm there classic changes
32:11 - with size of 26 okay so let's try again
32:17 - okay and close my console and let's see
32:20 - if this works great okay awesome
32:26 - so there we have it we have the basic
32:28 - effect down this kind of looks like the
32:31 - matrix right and now I think it's just a
32:33 - matter of putting some finishing touches
32:35 - on this so what do I want to change well
32:38 - you see how the sort of on initial load
32:41 - I'm just refreshing this fricassee every
32:45 - every single screen starts at the same
32:47 - y-value of 0 I kind of want the streams
32:51 - to stagger as they come in so let's go
32:55 - ahead and change that let's go back to
32:57 - our code and on initial setup let's go
33:02 - to our setup here we're going to remove
33:07 - this Y value which is fixed at 0 and
33:12 - when we pass in to our generate symbols
33:17 - function here we're actually going to
33:19 - pass in a randomized by start value okay
33:25 - so let's call it random okay so instead
33:29 - of always starting at 0
33:31 - maybe the string will start somewhere
33:33 - between a Y position of let's say this
33:36 - is the top of the canvas say between 0
33:38 - and up to 500 negative 500 so let's code
33:42 - that in negative 500 there we go so I
33:48 - think looks like does that look right
33:51 - I'm just going to split this up into
33:52 - several lines so I can better see it
33:55 - there we go
33:57 - that looks nice okay so let's try again
34:01 - let's see how that looks okay great so I
34:06 - do think this looks a little bit better
34:08 - but I think even like even yet still I
34:11 - think it can still be staggered a little
34:13 - bit more so let's go into our code and
34:15 - let's change this random value minimum
34:21 - maybe to something even large even
34:24 - smaller so maybe like negatives 1000 so
34:28 - let's try that instead and see how that
34:30 - looks okay fantastic I think that looks
34:36 - great so now we have this nice aspect of
34:41 - the matrix more slowly trickling in and
34:45 - for the next finishing touch well right
34:48 - I think it looks a little bit too crisp
34:50 - for it to be the matrix and if you hook
34:53 - up a get a look at it so I'm going to
34:55 - pull up these screenshot once again the
34:57 - matrix have
34:58 - a little bit of a blur to it right so
35:02 - let's go ahead and let's change that
35:04 - let's do this so I'm going to go into
35:07 - where the background is set where the
35:12 - background is drawn on each on each
35:17 - frame and we're going to alter the
35:21 - opacity for this effect so the default
35:24 - opacity for this background is set to
35:27 - 255 that's maximum that's fully opaque
35:30 - and we packed in two parameters -
35:33 - background then what will happen is g5
35:37 - will interpret the second parameter as
35:40 - opacity levels so if 255 is fully opaque
35:44 - and the zero is transparent entirely
35:47 - let's set it somewhere in between I
35:50 - don't know at 150 let's say so I'm going
35:55 - to set that and let's play this again
35:59 - okay ready great awesome so now our
36:05 - matrix has this couple this nice subtle
36:09 - glow effect and has happened because
36:11 - each time the background redraws the
36:14 - background is somewhat transparent so
36:17 - some of the previous frame still shows
36:19 - through and now going back to the
36:23 - sequence from the movie the screen shot
36:25 - here we also might notice how the tips
36:28 - of these streams are actually brighter
36:31 - in color than the rest of the screen
36:33 - right kind of I guess like a whitish
36:36 - green so let's write something in our
36:39 - code - Emily this cool effect let's go
36:43 - back to our code and let's go to the
36:47 - symbol class and where is it here it is
36:49 - okay and the way that we're going to do
36:52 - this is we're going to add a first
36:54 - property to this class right here and
36:59 - the pass the sin that's top first equal
37:04 - first set it
37:06 - and this first property will inform the
37:09 - symbol so the symbol will be cognizant
37:12 - of whether it's the first in the stream
37:15 - or not so and since it's a stream that
37:18 - creates these symbols let's go there so
37:21 - let's go to the stream class and we'll
37:23 - specifically go to the generate symbol
37:26 - function that's right here
37:27 - we'll set a variable called first
37:31 - outside of this loop and we're going to
37:34 - set it to true and I'm going to pass
37:39 - this in when we make our new symbol okay
37:43 - and right before the loop plays out
37:51 - fully we're going to actually set this
37:54 - variable to false so first equals false
37:58 - so that only on the first round from
38:01 - this loop the first variable will be set
38:04 - to true so that I guess any iteration
38:09 - afterwards any iteration after the first
38:11 - one this first variable will be set to
38:15 - false okay
38:16 - and now in the render function we're
38:20 - going to write a condition so that if
38:23 - it's the first symbol then we're going
38:25 - to set it to a color to that special
38:28 - white green color so let's write our
38:32 - conditional so if it's the first symbol
38:37 - it's first this will evaluate down to
38:39 - true oh sorry we want to go inside the
38:45 - loop here
38:50 - so if it's the first symbol let's set it
38:52 - to a special fill and if 255 is the
38:57 - maximal brightness for our RGB values
39:01 - let's bring the red and blue of a notch
39:04 - so let's say 180 for our red gleams days
39:09 - maximally bright and 184 for our blue
39:15 - value and if it's not the first symbol
39:19 - well let's proceed as normal
39:22 - let's fill it in just like everything
39:24 - else okay and now if we reload those
39:28 - things okay great so there even have our
39:34 - effect what I actually think it looks a
39:36 - little bit too excessive to have the
39:38 - tips of every single stream of this
39:40 - price and in fact if you look at the
39:42 - matrix that's not the case I would say
39:45 - like 50 percent maybe even less our
39:48 - colors this like special bright green
39:50 - color so let's actually limit let's go
39:53 - ahead on our codes limit what gets this
39:56 - color so for a first variable instead of
40:00 - setting it just to true I'm actually
40:03 - going to set it equal to this and then
40:06 - explain in just one second okay so we're
40:14 - going to get a random number either 0 or
40:17 - 1 and we're going to evaluate if this
40:21 - number is equal to 1 and if it is this
40:25 - whole expression here the whole thing
40:27 - will get evaluated down to truth
40:30 - otherwise it gets evaluated down to
40:32 - false so there's a 50% chance that this
40:35 - will evaluates true therefore there's a
40:37 - 50% chance that the first symbol in a
40:40 - given stream will be colored bright
40:42 - white green kind of like a coin toss
40:45 - right so let's go ahead and replay this
40:49 - now ok great so now 50% of these screens
40:55 - have a first symbol that is a different
40:58 - color but even still I think that 50% is
41:02 - too excessive so let's go ahead
41:04 - back into our code and maybe increase
41:07 - the pool of numbers but random can
41:09 - choose from so let's say it's four so
41:12 - now there's a one in fortune of five
41:14 - chance that first will be true so now
41:20 - there's would be a lot fewer
41:21 - bright-white
41:22 - first symbols okay right I think that
41:27 - looks that looks great okay so I think
41:31 - we've now officially recreative our own
41:35 - version of the matrix digital reign in T
41:39 - 5 great so I put up my code on github at
41:45 - this URL you can read it in case you
41:47 - were sort of coding through and wanted
41:49 - my reference point just in mind however
41:52 - that the code on my github repo won't
41:56 - 100% reflect what is shown in this
41:58 - tutorial it will mostly but not 100% and
42:01 - that's because my final version includes
42:03 - some finishing touches extra finishing
42:05 - touches and a few more creative
42:07 - decisions that have made and I sort of
42:10 - encourage you to do the same feel free
42:12 - to experiment to play around or inject
42:15 - your own creative decisions into the
42:17 - sketch I mean maybe we'll make some
42:19 - matrix purple or maybe you'll make it
42:21 - rainbow or maybe it'll be 3d or maybe
42:24 - how to screw upside down I don't know
42:26 - I'm super excited though to see whatever
42:28 - you come up with and whatever direction
42:30 - you take this project in whatever the
42:33 - case if you do make something cool
42:36 - tweeted at me and also use this hashtag
42:40 - to share it with the rest of the g5
42:43 - community because I think that's part of
42:45 - the fun that's sort of the beauty of t5
42:48 - not just being able to make awesome art
42:51 - work with code but also being able to
42:54 - readily share it out on the Internet to
42:57 - share it with your friends or your
42:59 - family or randos on the internet like me
43:02 - so anyway I think that wraps it up for
43:05 - me thank you so much for watching I hope
43:08 - you had a ton of fun I know I certainly
43:10 - did so yeah thanks
43:16 - [Music]

Cleaned transcript:

hello welcome I am very excited that this is another guest tutorial video and today's guest is I meant to ring the bell after I said her name and Alicia she is Peter in the studio and she just did a tutorial building exactly this what you see behind me which if you don't recognize is a visualization mirroring the rain effect in moving the matrixmatrix rain so this is really wonderful it's a perfect thing to use p5.js for and there's a lot of creative possibilities that I hope that after you watch the tutorial you will make and share and share so a couple things I want to mention number one if you're looking for the source code for this tutorial if you're looking for Emily's Twitter to share what you make with her everything will be in this video's description I also wanna mention for those of you viewers here we've always asked me to please use for each loop you will finally see on the coding train sub for each loop in this particular video because Emily very smartly is using them so without further ado I will leave this screen and you'll then see the tutorial starting from Emily oh I want to say a few things about Emily so Emily is a creative coder and artist she has done workshops and other projects with organizations great organizations like girl develop it and pioneer works in Brooklyn and she's also currently working for Squarespace so you could find out more about her to check out her Twitter and her website which will also be linked in this video's description ok now just enjoy the tutorial ok thanks bye ok everyone and thanks for the wonderful intro dan I'm super excited to be here especially as someone who's been following this YouTube channel for a while now so for today's tutorial we're going to be rekt creating that iconic matrix raining code using p5.js and some of you who have never seen the matrix series before don't know what it is that I'm talking about have no fear I'm going to play the clip from the movie to clarify cool so that ringing green code this right here this is what we're going to be recruiting using t5 and in terms of background level I'm going to teach with the assumption that you have some basic understanding of objectoriented programming and may be rich in a few simple p5 sketches maybe you've seen some advanced videos on this channel or maybe it just sort of explored the library yourself anyway let's jump right in so here is my sketch file where all the p5 magic will happen and right now it's empty but let's still in with our two core p5 functions set up being one of them and as some of you might know this is the function that gets in both watts immediately upon loading up your sketch and I know I'll also need the function draw which some of you might also know it's the function that gets called repeatedly at 60 frames per second as your sketch run so now that I have these down let's start first by flushing out setup so inside of this function I'm going to make my canvas so as to carve out where on the webpage I want my sketch to be we're going to use the function create canvas and I actually want the sketch to span the entire page so for the with argument I'm going to pass in window dot inner width and this returns the width of your browser's entire content area and for the height I'm going to pass in window dot inner height as what you might be able to guess returns the height of your browser's content area cool so I know I also want my background to be black so let's go ahead and set that to zero and let's run this there we go awesome so we have our initial setup which I blend entirely into so this is the scene where we'll make the matrix raining code happen so now let's take a step back and think about the sketch at a higher level and let's sort of consider what might be some of the general components or classes here so if we look at this as a matrix if you look at the screenshot here I can sort of sense that there are going to be two primary object types one of them being the symbol so it's like each one of these characters individually and the other one being the stream object so a stream being like one of these vertical lines comprised of symbols so let's go back to our code and let's stub out these prototypes and by the way I'm going to use the term prototype and claps interchangeably here so as we go to code and stuff out symbol there we go and our stream here we go so let's start off with our symbol class and make just one symbol and show chill it for now and we'll get to the screen coughs a little bit later so I'm just going to go ahead and move it down a bit so for our symbol you're going to need an X and the y to show the location on the canvas both of which will we pass in to this signature here and then let's add these properties so this dot x equals x dot y equals y and we also want a variable to hold the actual symbol itself and we'll call this value and this will be set later on using this function set to random symbols okay so one will go into this function what should each symbol get set to maybe take a look at the matrix you'll see that the symbols are in fact comprised largely of katakana which are characters that represent syllables in Japanese and I knew I knew being the an indigenous ethnic group living in Hokkaido and Russia so that's your a bit of trivia for today so how do we represent these characters our keyboards won't let us type in katakana so what do we do also we're almost simply enough we will use unicode which is an American coding in order to represent them and pictured here here is all of the katakana in the katakana unicode block and our 96 total so let's go to our code and write our function to randomly retrieve one of these beautiful symbols here we go and I'm actually just going to wipe this out and I'll explain in a bit so that's not value equals green dot from care code okay there we go the past in 0 x3 0 a0 plus round it to a random number 0 96 okay so that looks about right so the katakana unicode block starts encoding 0 x3 0 a0 which translates numerically to 1 2 4 4 8 which will then be added to a random whole number between 0 and 96 because there are 96 available characters in the katakana unicode block and then whatever number results from this addition will be passed into this function from care code and finally converted into a string containing your katakana characters and set to this stop value okay so now that we have the code to retreat and set our symbol let's write a function to actually display it on our canvas and we'll call it render it's going to scroll down a little bit for everybody to see so we'll use the text function to actually display our symbol and we know that the symbol is contained in this top value and we want to display at coordinates X and coordinates x and y and we'll fill it with colored 0 for red 255 for green because we want it green but we also don't want it sugaring so maybe we can I don't know add a little bit of blue in there so maybe like a blue value of 7b might look nice great so now respecting love so that we can create our symbol and renters so if we go back up here at the top of our code let's start a global variable to hold that symbol we'll call it a symbol and since its global we can access this variable anywhere in our global scope and now down in our setup function let's stick an instance of our symbol into that global variable so symbol equals new symbol okay and for now we'll display the symbol smackdab in the middle of the screen the canvas just for demonstration purposes so we'll set the x value to what's divided by 2 and the y value to height divided by 2 and now within the draw function oh we should probably set the symbols values symbol dot set to random symbol there we go and now within our draw function let's render it symbol dot oops of thunder okay and let's play okay so I've made a mistake somewhere let me go ahead and inspect my code so it says somewhere on line 12 but there's an unexpected token ah I have an extra comma here I'm going to fix that and now I'm going to replay this okay awesome so now we generate a random kind of Kanna character but actually it's a little bit small I'm not even sure if you can see it so let's go to our code and increase the size of the symbol and we'll do that by creating a global variable called symbol size and let's set it to something huge just so that we can see so I think maybe 60 and now within our setup let's actually assess the text size here text size I believe is the function to our symbol size and now I'm going to refresh okay fantastic so now we generate a random katakana character whenever we load up our sketch and if you refresh I'm just going to refresh here you'll see that you get a new one every single time however in the matrix the symbols don't just sit there in the middle of the page they rain down so let's go ahead and write some code to do just that so let's go back to our sketch file and if we go back to our symbol class what's that a speed value here to determine the rate at which this symbol Falls so speed will get passed in and the speed property will get passed a set as what gets passed in and what's right a function to actually make the symbol rain down and I think an appropriate name would be rain okay and inside this function all we're going to do really is increment the Y position of the symbol object according to the speeds still have to make the symbol slowly move down the page so this got y plus equals the stop speed okay and now within render let's pass in a random speed sorry now within our render function since this is what gets invoked on every frame by a draw let's make it rain so this stop rain right and now back in our setup what's passing a random speed whenever we create this new symbol object so for now let's say we'll give it a ballpark of five to ten so randomly generated but let's also switch the Y value out so it's not halfway down the page will cause it why I like how the symbols start up the top of the canvas so we'll set Y does zero okay so let's go ahead and refresh this okay voila so we now have a symbol that rains down the page but we actually want to redraw the background on every frame so that it erases this trail because this isn't what the matrix looks like let's go to our code let's go to backgrounds other let's go to draw and let's uh stick the background in there okay and now let's replay this okay great so now we have a symbol that rains down but once this character reaches the bottom of the screen we actually want it to loop back to the top and replay all over again kind of like a jiff so let's go to our code let's go to the rain function okay and let's rack the in a bit of a conditional with throughout the increment okay so if this dot Y is greater than or equal to height so if the Y value is greater than the height of the canvas this means that it's reached the bottom so let's reset Y to 0 otherwise let's just proceed as normal okay and actually we can make this look a little bit nicer using a ternary operator which is just a syntactic cuff for this commonly occurring a conditional pattern so there was me four seconds that's got y equals this cot why is it greater than or equal to hype if it is then set it equal to zero otherwise increments Y with the speed so this this here and this here are the same I'm going to get rid of that and now we have some nicer looking code so I'm just going to go ahead and replay this now okay great so now we have a symbol that rains down in a continuous loop in the R matrix but if we paid attention to that clip from the movie we'll see that a symbols randomly switched to other symbols as it leans down so let's go ahead and implement that let's go to our code and let's go to our render function since this is what gets called on every frame and if you think about it we've actually already written a function that allows us to switch from one character to another and that is set to random symbols so let's go ahead and just call that within this render function okay so now I'm going to play this again okay great so it's switching to a new random symbol but it's doing it way too fast it kind of looks like a blur you might not even be able to tell what this is so instead of making it switch on every single frame and there are 60 frames per second let's do it accordingly according to a interval okay so let's go back to our code and um hmm let's go to the symbol class and let's make this interval a property of the simple class so this stops which interval seems like a pretty good name and simply know that the switch interval should maybe differ a bit for every symbol let's randomize it so I'm going to randomize it to a whole number between I don't know 2 and 20 let's say and now let's go to our set to random symbol function and restrict the symbol being reset by the switching table and we can do that using a conditional let's wrap this all in a conditional so if frame count I'm just going to write this and I'll explain it in a second modulo this which interval is equal to 0 I'll move this line of code up here some proper indentation there great so frame count is a variable that is built into p5.js for you and keeps kind of just running tally of how many frames has passed thus far and modulo is an operator that performs division and returns the remainder so we performing modulo on frame count using switch interval and so we're looking for a remainder of 0 here we're basically saying whenever the switch interval divides evenly into our frame count then execute this line of code so it's winter such interval over 15 this means that when the frame count is 0 or 15 or 30 or 45 the modulo will return a zero and then we set a new symbol football is very short this code says to reset the symbol at every end frame and being your switch interval anyway let's play this now great okay so now we have a symbol that rains down and switches to another symbol at a randomly determined interval so now that we have our symbol class figured out let's make it rain not just one symbol but an entire stream of symbols and since stream comprises of symbols our symbol should be should live inside this Greek stream class so let's remove that single symbol that we've subbed out for demonstration purposes let it go to my setup remove yeah little bit and remove this from as a global variable and now let's go to our stream class let's all the way down here move this up a little bit and without a property that contains an array that will hold all of our symbols for the stream so this stop symbol is what we'll call it let's give it an array and now thinking through some of what are the other attributes of what constitutes a stream I think each stream should know how many symbols it has so this thoughts total symbol pretty good name and let's give it a range that it could randomly pick from so that each stream has a different number of symbols in it so I don't know maybe on streams will be as short as five symbols and some trees will be as long as three symbols and they'll be screams of all sizes in between okay and I also think that each stream should know how how fast is traveling at so let's give it a speed property let's set it to a randomly determined one let's say somewhere between I don't know five and twenty I also think it should be the responsibility of the extreme to create all of its own symbols during the initial setup so let's write a function to do that and this function will use a loop to do all of that so we'll call it generate symbols okay there we go and outside of our loop will set a Y variable that gets passed into our symbol objects and we'll start it at zero so that it starts at the top of the page and for an X variable let's also set that to let's set up to a width the width divided by two so that we see it the symbol for the screen at the top of our canvas in the middle okay all right so let's write our loop so for each of our four loops looks more like this start at zero and we want to loop through however many symbols there are that's how many times a loop through and we'll increment our loop and on every iteration we should create a new symbol so we'll pass in X Y and speed at which the stream is going and right after we create the symbol we're going to set the symbols initial values so set random symbol and then we're going to take that symbol and push it into the streams symbol array so that it can live there and then at the end of each loop we also want to decrement Y whoops looks like this what is decrement Y by the symbol size there we go so that's the third except the next symbol immediately above it so at the program start if you were to render all of the symbols in the stream what it would look like is if you're at the top of the canvas the streams of the symbol to be stacked in a straight line above the canvas and that's because Y starts at zero and gets decremented and since it's the streams responsibility to create its symbol let's also give it the responsibility to display each symbol on the canvas so let's write a function for this we'll call it render and we'll write a for each loop looping through all of our symbols and we're going to pass in an anonymous function and call each of the elements that were iterating over symbol and we can actually copy and paste the code that we wrote in the symbol class since we're transferring responsibility of rendering from from the symbol to the stream okay so let's copy and paste this and let's also get rid of the remnants of this function and then let's let's paste this so indents things correctly and since each elements that we're iterating over it's called symbol we must change all of this too bowl okay and there we go and by the way keep in mind that there is more than one way to skin a cat you can cheap it so that it is the symbol responsibility to render themselves and organize your code in such a way but I prefer it this way and I think ultimately it will make the code look just a little bit nicer and easier to read so now that we have our stream clock figured out let's go back to the top of our code and write a global variable to hold our stream so we'll call it screen and then what's in our setup creates our stream so free okay and then after we create it let's instruct it to generate all of its symbols and finally in bra let's render that stream so looks this symbol no longer exists we're gonna render the screen okay so let's load this thing up and how we did okay awesome so now we have a stream that rains down repeatedly and the stream contains characters that switch at their own randomly determined intervals but as you may have observed the matrix does not have just one stream there are streams all the way across the screen so let's go ahead and set things up so that our matrix is all the more exciting let's go to our code and let's change the global variable so that instead of holding just one screen it holds an array of extremes now let's give this an X so it's streams and now in our setup let's populate that array with a loop so I'm just going to go ahead and get rid of this one term that we've subbed out and outside of our loop we're going to have an x and a y variable which will inform the coordinates of each stream so let's start them both off at zero and now we loop so start the loop at zero and we're going to go until whips divided by symbol size and we want to divide the total width of the screen by the symbol size in order to get the total number of streams since each stream is a symbol wide so there we go and now let's loop so we're going to create a new stream on every iteration and then instruct the stream to create generates all of its symbols there we go and we originally hardcoded X&Y into the generate symbols function but since each stream will have a variable x and y that gets packed into it we should just go in and let's go to that function and let's pass those variables into it reflect that in the signature and get rid of this x and y that we hardcoded okay great so now going back to our loop where was it ah here it is so once we once we have our stream and all of its symbols we'll push it into the mega array containing all of the streams so stream dot push that one stream that we just made and then we also want to increment where X starts because we want each stream to start right next to the last one so we'll increment by symbol size because each three money know is a symbol symbol wide so now in draw instead of rendering just that one stream let's write a loop that will loop through all of our streams and render them all at watch so let's go to draw let's get rid of the rear Enders just that one screen and we'll write a 4h on our streams mega array and we're going to pass in a function each items that we iterate over and screw in this loop will be called stream and get rid of that okay and every time we loop through we're just going to OH screen there we go Thunder okay now I'm going to play this and see what happens oh okay so I've made a bit of a mistake here let me go to my console and try to figure that out so I have an unexpected token on line 12 so line 12 oh okay so I forgot to increment my loop that's no good so I think this should be alright now actually I'm going to go ahead and change each symbol just be a little bit smaller while I'm there classic changes with size of 26 okay so let's try again okay and close my console and let's see if this works great okay awesome so there we have it we have the basic effect down this kind of looks like the matrix right and now I think it's just a matter of putting some finishing touches on this so what do I want to change well you see how the sort of on initial load I'm just refreshing this fricassee every every single screen starts at the same yvalue of 0 I kind of want the streams to stagger as they come in so let's go ahead and change that let's go back to our code and on initial setup let's go to our setup here we're going to remove this Y value which is fixed at 0 and when we pass in to our generate symbols function here we're actually going to pass in a randomized by start value okay so let's call it random okay so instead of always starting at 0 maybe the string will start somewhere between a Y position of let's say this is the top of the canvas say between 0 and up to 500 negative 500 so let's code that in negative 500 there we go so I think looks like does that look right I'm just going to split this up into several lines so I can better see it there we go that looks nice okay so let's try again let's see how that looks okay great so I do think this looks a little bit better but I think even like even yet still I think it can still be staggered a little bit more so let's go into our code and let's change this random value minimum maybe to something even large even smaller so maybe like negatives 1000 so let's try that instead and see how that looks okay fantastic I think that looks great so now we have this nice aspect of the matrix more slowly trickling in and for the next finishing touch well right I think it looks a little bit too crisp for it to be the matrix and if you hook up a get a look at it so I'm going to pull up these screenshot once again the matrix have a little bit of a blur to it right so let's go ahead and let's change that let's do this so I'm going to go into where the background is set where the background is drawn on each on each frame and we're going to alter the opacity for this effect so the default opacity for this background is set to 255 that's maximum that's fully opaque and we packed in two parameters background then what will happen is g5 will interpret the second parameter as opacity levels so if 255 is fully opaque and the zero is transparent entirely let's set it somewhere in between I don't know at 150 let's say so I'm going to set that and let's play this again okay ready great awesome so now our matrix has this couple this nice subtle glow effect and has happened because each time the background redraws the background is somewhat transparent so some of the previous frame still shows through and now going back to the sequence from the movie the screen shot here we also might notice how the tips of these streams are actually brighter in color than the rest of the screen right kind of I guess like a whitish green so let's write something in our code Emily this cool effect let's go back to our code and let's go to the symbol class and where is it here it is okay and the way that we're going to do this is we're going to add a first property to this class right here and the pass the sin that's top first equal first set it and this first property will inform the symbol so the symbol will be cognizant of whether it's the first in the stream or not so and since it's a stream that creates these symbols let's go there so let's go to the stream class and we'll specifically go to the generate symbol function that's right here we'll set a variable called first outside of this loop and we're going to set it to true and I'm going to pass this in when we make our new symbol okay and right before the loop plays out fully we're going to actually set this variable to false so first equals false so that only on the first round from this loop the first variable will be set to true so that I guess any iteration afterwards any iteration after the first one this first variable will be set to false okay and now in the render function we're going to write a condition so that if it's the first symbol then we're going to set it to a color to that special white green color so let's write our conditional so if it's the first symbol it's first this will evaluate down to true oh sorry we want to go inside the loop here so if it's the first symbol let's set it to a special fill and if 255 is the maximal brightness for our RGB values let's bring the red and blue of a notch so let's say 180 for our red gleams days maximally bright and 184 for our blue value and if it's not the first symbol well let's proceed as normal let's fill it in just like everything else okay and now if we reload those things okay great so there even have our effect what I actually think it looks a little bit too excessive to have the tips of every single stream of this price and in fact if you look at the matrix that's not the case I would say like 50 percent maybe even less our colors this like special bright green color so let's actually limit let's go ahead on our codes limit what gets this color so for a first variable instead of setting it just to true I'm actually going to set it equal to this and then explain in just one second okay so we're going to get a random number either 0 or 1 and we're going to evaluate if this number is equal to 1 and if it is this whole expression here the whole thing will get evaluated down to truth otherwise it gets evaluated down to false so there's a 50% chance that this will evaluates true therefore there's a 50% chance that the first symbol in a given stream will be colored bright white green kind of like a coin toss right so let's go ahead and replay this now ok great so now 50% of these screens have a first symbol that is a different color but even still I think that 50% is too excessive so let's go ahead back into our code and maybe increase the pool of numbers but random can choose from so let's say it's four so now there's a one in fortune of five chance that first will be true so now there's would be a lot fewer brightwhite first symbols okay right I think that looks that looks great okay so I think we've now officially recreative our own version of the matrix digital reign in T 5 great so I put up my code on github at this URL you can read it in case you were sort of coding through and wanted my reference point just in mind however that the code on my github repo won't 100% reflect what is shown in this tutorial it will mostly but not 100% and that's because my final version includes some finishing touches extra finishing touches and a few more creative decisions that have made and I sort of encourage you to do the same feel free to experiment to play around or inject your own creative decisions into the sketch I mean maybe we'll make some matrix purple or maybe you'll make it rainbow or maybe it'll be 3d or maybe how to screw upside down I don't know I'm super excited though to see whatever you come up with and whatever direction you take this project in whatever the case if you do make something cool tweeted at me and also use this hashtag to share it with the rest of the g5 community because I think that's part of the fun that's sort of the beauty of t5 not just being able to make awesome art work with code but also being able to readily share it out on the Internet to share it with your friends or your family or randos on the internet like me so anyway I think that wraps it up for me thank you so much for watching I hope you had a ton of fun I know I certainly did so yeah thanks
