With timestamps:

00:00 - (whistle whistles)
00:01 - - Hello and welcome to part two
00:03 - of the Rubik's Cube coding challenge.
00:04 - In this version of the coding challenge,
00:08 - I just want to take my existing
Rubik's Cube simulation
00:11 - and be able to make some
turns, I want to shift
00:14 - the faces of one side of the cubies,
00:16 - like the yellow faces,
to turn maybe clockwise
00:19 - and be on the other side
and everything follows suit.
00:21 - So I'm going to do that
with matrix transformations.
00:25 - Here's the thing, I have
to be honest with you,
00:27 - this is my second attempt at doing this.
00:30 - I did a previous livestream
where I went down
00:32 - a different road and I was
keeping track of arrays
00:35 - and different arrays and
trying to shift things
00:36 - and have custom hard coded
things for every possible way
00:39 - the Rubik's Cube could turn
and it was a total disaster.
00:43 - In the end I actually got
it to work, you can see it
00:45 - spinning around and
working here right now.
00:47 - I had some really useful suggestions,
00:49 - most notably from Michael
Raphael Panganiban,
00:52 - who suggested that I use
matrix transformations.
00:55 - And I'm going to try this again,
I'm going to try to really think
00:57 - about refactoring that
gobbledygook code I wrote before
01:01 - and try to set myself up
for success in the future.
01:05 - I also want to highlight
this website, I Am the Cube,
01:08 - made by Stewart Smith and other
collaborators from Google.
01:11 - This was made for the Google
Doodle about the Rubik's Cube
01:14 - a bunch of years ago, and
it's really phenomenal.
01:17 - The code is available.
01:19 - I really should just not
bother doing what I'm doing
01:22 - and just play with this,
but I have a mission.
01:25 - And my mission is to make this
Rubik's Cube turn and move.
01:29 - And so I'm going to do that.
01:30 - This is what I left off with in Part One.
01:32 - And one of the things
that I did in Part One
01:34 - that was a little bit weird is I really
01:35 - was thinking in terms of cube notation.
01:37 - And if you're a cuber,
you look at the cube
01:40 - in a certain direction, you're
thinking about what's up,
01:42 - what's down, what's left, what's right,
01:43 - what's clockwise, what's
counter-clockwise.
01:45 - And that really led me in
some strange directions.
01:48 - I think it's useful maybe to double back
01:49 - and add that in once I
have the cube working.
01:52 - But the thing that I'm
actually working with
01:55 - here in this code, x-axis, y-zxis, z-axis.
01:59 - And it's going to be much
simpler for me I think
02:01 - to keep track of things
and think in those terms.
02:04 - And the rotation might not be clockwise
02:06 - or counter-clockwise, it might be
02:08 - in the positive direction or
in the negative direction.
02:10 - The first thing that I want to
do to really figure this out
02:14 - and to have a more effective
way is actually keep track
02:18 - of the cube's location not
in a vector, but in a matrix.
02:26 - Dun dun dun.
02:27 - So I have done a lot of
videos about matrices
02:31 - and matrix math and some of
that's going to come up here.
02:34 - The ones that you might
want to check out if that's
02:37 - a totally new concept to you
is the video where I made
02:40 - my own 3D renderer using
matrix transformations.
02:43 - And I made a little like
bunch of functions to do
02:46 - to store matrices and to multiply them.
02:48 - I also used matrices in a bunch
02:50 - of videos I made about neural networks.
02:52 - The matrices pop up there in the math
02:55 - of machine learning with neural networks.
02:57 - But here, what I want
to do is I want to have
03:01 - a transformation matrix
for each one of the cubies
03:05 - to keep track of where it is in the world.
03:08 - And so, the way that I'm going
to do that is I'm going to
03:12 - change the cubie to receive
a matrix and for its position
03:18 - to be that matrix rather than a PVector.
03:21 - Luckily for me, Processing already
03:23 - has built into it matrix classes.
03:25 - So I don't have to write
my own matrix 3D object,
03:28 - I don't have to write a matrix 2D object,
03:30 - I've got one in the Processing.
03:31 - So, it's going to be a PMatrix3D object.
03:37 - The other thing I want to do
now, so this is how I made
03:39 - the cubes before, I made each
cubie with an x, y, and z.
03:44 - But now I want to do this.
03:46 - I want to make each cubie
03:50 - with a matrix,
03:51 - and then what I want to do
is translate that matrix.
03:55 - So in other words, each
cube, it's a way each cube
03:58 - is going to keep track
of its own 3D world,
04:00 - and it has the full matrix
of what is the translation,
04:03 - what is the rotation, what is the scale.
04:06 - And so if I translate that
matrix to its x, y, z location,
04:12 - then I'm initializing the cubie
with that particular matrix.
04:16 - Some other things, while
this nested loop is useful,
04:19 - it's going to be much simpler
for me in the end I think
04:21 - if I actually keep all of the
cubies in just a single array.
04:25 - The multidimensional array
is interesting, but let me,
04:28 - so let me change that to, I'm
just going to make it, no,
04:31 - I'm not going to make this i, I'm
going to make this like index,
04:34 - oh actually, let me make
this, I'll make this index.
04:37 - And I'm gnona say cube
index equals new cubie
04:40 - with the matrix, index plus
plus, so that I'm counting.
04:45 - And then, this will now be a single array
04:51 - that has dimensions times
dimensions times dimensions.
04:53 - Three times three times three, or 27.
04:55 - Of course, there really isn't
a cubie in the center, but eh,
04:59 - you can't see it anyway, so
we can imagine it's there.
05:03 - Now the other thing that's
really important here,
05:05 - and I'm going to, I think
this will be helpful.
05:08 - I'm going to change this to x, y, and z.
05:11 - X, y, and z.
05:15 - I'm going to change this to x, y, and z.
05:18 - I'm not going to worry
about this figuring out
05:21 - the actual position of
the cube with its length.
05:24 - I just want its position in
a three-dimensional world.
05:29 - And what are those positions?
05:32 - So if I just think about one
face of the cube, for example,
05:37 - maybe this is a face of the
cube where z equals one.
05:41 - If we're looking at the
cube with green facing us,
05:44 - facing you, this could be the
z-axis, this is z equals one.
05:48 - So we've got the x-axis
along the horizontal
05:51 - and the y-axis along the vertical.
05:53 - So what I could think about
this is really the location
05:57 - x, y, zero, zero, so it's zero, zero, one.
05:59 - So all of these have a z location of one.
06:02 - But this one is negative
one, negative one.
06:06 - Sorry, zero, negative
one, one, negative one.
06:09 - The y is negative one, the x
is negative one, zero, one.
06:12 - So this is negative one,
zero, and this is one, zero.
06:17 - This is negative one, one.
06:18 - This is zero, one, and this is one, one.
06:21 - So these are all the locations, and these
06:24 - can actually be the x,
y, z values that I apply
06:27 - to translate each
individual cubelet's matrix.
06:32 - So if I come back to the code,
06:34 - what I'm doing here is I'm saying,
06:36 - have the x goes from negative
one all the way to one.
06:40 - Same thing for the y.
06:45 - Same thing for z.
06:50 - Create a matrix for each one.
06:53 - Create the cubie, I'm not going to
06:55 - worry about this leg thing right now.
06:56 - And then say index plus plus.
06:58 - The cubie
07:03 - then is just a thing with its matrix.
07:06 - And this should say PMatrix3D.
07:08 - I've got to specifically use,
I'm going to be using a 2D matrix
07:10 - in a little bit, you'll see this is crazy.
07:12 - But right now I'm going
to use the (mumbles).
07:13 - Alright, so, I still have
this length variable here.
07:16 - The other thing I want to do
is, while it was really useful
07:19 - that I had this whole
way of doing these quads
07:22 - and coloring them, I'm going
to get rid of that right now.
07:25 - Because I think that what I want to do
07:27 - is think of each of these cubies as a box.
07:32 - And then it's also going to have faces.
07:34 - And I think I'll draw the faces
07:36 - as a separate object with a quad.
07:38 - So right now to keep things very simple,
07:42 - I'm going to show you
something kind of nuts.
07:44 - I am going to take out all of this.
07:47 - I'm going to get rid of this translate.
07:50 - I am actually going to call this
07:53 - function called apply matrix.
07:57 - So what am I doing here,
I'm taking the matrix,
08:00 - and I probably shouldn't
call it pos as in position.
08:03 - Let's actually call it matrix.
08:05 - Let's call it matrix,
each cubie has a matrix
08:08 - which really contains all
the information about where,
08:12 - its position and rotation in
the world of the cube itself.
08:15 - And this is actually the same
08:17 - as just calling translate at this point.
08:19 - But because I'm storing it in
a matrix instead of calling
08:21 - translate directly, it's
going to give me some more
08:23 - possibilities later as I need
to keep track of all these
08:26 - cubies separately or in smaller
groups and that kind of thing.
08:29 - So if I do this, and
then if I just say box,
08:32 - and I'm going to say box one,
it's going to be a small box,
08:35 - pop matrix, then, and here, the nice thing
08:38 - about this also is I can
change this to cube dot length
08:42 - and get rid of this nested loop.
08:45 - I can say cube index I dot show,
08:47 - and hope that we see the Rubik's Cube.
08:53 - Ah, where is it?
08:54 - Oh look, I think it's there.
08:56 - I think that's the Rubik's Cube.
08:57 - Oh, look, I visualized the
black hole on the day of the,
09:00 - this is the second image
of a black hole, no, okay.
09:03 - So the reason why it's
so tiny is because scale.
09:06 - So let me say scale 100,
09:10 - and let's see what happens now.
09:14 - Where's that Rubik's Cube?
09:16 - So let's think about,
ah, stroke weight eight.
09:18 - Now that's lunacy here.
09:20 - so let's make the stroke zero, let's make
09:22 - the stroke weight small
because I'm scaling up.
09:25 - And let's also make sure we say
09:26 - fill to (mumbles) that's there already.
09:30 - Oh, that's a really big
one, but there it is.
09:32 - So I don't want to scale that much.
09:34 - Let's scale it by 50 and let's
just say stroke weight .1.
09:42 - And there we go.
09:43 - So now, I have exactly the same thing.
09:45 - I have exactly what I had before,
09:47 - but I just have a matrix
for each one of the cubies.
09:51 - Now I need to figure out,
how am I going to debug this?
09:54 - Right now if I move them all around,
09:56 - I could move them around,
they're all white,
09:58 - they're all going to appear
in the same location.
09:59 - So what I'm going to do is I
am going to make a variable.
10:03 - I'll just call it Highlight false.
10:08 - And I'm going to say,
10:11 - if highlight fill zero.
10:16 - And then let me say,
10:19 - let me say cube index zero highlight.
10:23 - So there we go, we can see, ah, that one.
10:25 - See look, this one is now highlighted.
10:27 - I can address any individual cubie.
10:29 - It's not really highlighted
'cause it's black,
10:32 - it sort of looks like it's removed.
10:34 - Maybe I should make it
like red or something
10:36 - just so it's a bit more obvious.
10:38 - 'Cause everything right
now is just white, okay.
10:41 - But let me actually highlight
the one that's in the front.
10:45 - (bell dings)
10:46 - Alright, the answer by the way,
10:47 - in case you were wondering, was two.
10:49 - I'm counting with z first,
so it's going zero, one, two.
10:54 - So perfect.
10:55 - Boy, that was a lot of time
I spent trying to figure out
10:57 - that it was two, you're lucky
you didn't have to watch that.
11:00 - Okay.
11:01 - So now I can see that I'm
highlighting a given cubie.
11:05 - The next thing I want to do
is take one of these faces,
11:08 - each one has its own 3D matrix
11:10 - with an x, y, and z, and rotate It.
11:13 - I want to apply a 2D rotation
to this particular face.
11:16 - So any face, whether it's the front,
11:19 - the back, the top, the
bottom, if we look at it,
11:21 - it ends up becoming two-dimensional.
11:23 - So I just want to rotate
two, I just want to
11:26 - rotate along one particular axis.
11:28 - Any given face can become suddenly
11:31 - a 2D world that I want
to tdo a rotation to.
11:33 - So if I suddenly have this point here,
11:37 - which is at negative one, negative one,
11:40 - and I want to rotate that
relative to the center 90 degrees,
11:46 - or half pi, then it's
going to end up where?
11:50 - In one, comma negative one.
11:52 - It's going to move and rotate there.
11:54 - So how can I do that?
11:56 - I can apply a 2D rotation.
11:59 - Let's write a function called turn z.
12:03 - And I want to avoid using rotate z,
12:05 - because even though I'm
doing a z-axis rotation,
12:08 - rotate z is the built-in
function in Processing.
12:11 - So if I say turn z, first let
me look at all of the cubes.
12:15 - So I always need this particular,
12:20 - this particular loop.
12:23 - Just realized something,
I now, I sort of regret,
12:27 - I'm regretting taking out that nested loop
12:29 - because I just want all the
faces that are in the z-axis.
12:32 - And if I had that nested loop,
12:34 - I would be able to keep it that way.
12:35 - But actually, I'm going to do
something slightly redundant,
12:38 - which is that I am also going
12:40 - to keep track in a separate variable.
12:46 - I am going to keep track
of, I'm going back,
12:50 - I'm going to keep track of
its x, y, and z index values.
12:55 - I'm going to keep track
of what those values are
12:58 - within what would be a
three-dimensional array.
13:00 - And so let me actually add
those as arguments here.
13:07 - And I'm going to say x
equals x, y equals y.
13:12 - Z equals z.
13:14 - And then when I create each
cube, I'm going to say x, y, z.
13:19 - Great.
13:20 - So I have those extra
variables because now I can say
13:23 - if a cube dot z equals
one, I want only the cubes
13:29 - that are in the z-axis
one, negative, zero, one,
13:34 - those are the ones, and
this is cube index i dot z,
13:37 - these are the ones that I want to rotate.
13:39 - So now I need to make a
2D matrix, this is what
13:42 - I was saying, 2D matrix out of that face.
13:45 - So the 2D matrix is just a new 2D matrix.
13:49 - I want to do a 90 degree or a
half pi rotation of that matrix.
13:54 - And then, I want to
translate out to the cubes x,
14:01 - Spongeman on Code Pen who
made a version of this.
14:04 - I saw used actually a really cute
14:05 - variable name which I'm
going to use right now.
14:08 - qb, like the letters qb for
the cubie, equals cube index i.
14:12 - So I can actually just use qb, it's qb z
14:15 - equals one, translate by qb x and qb y.
14:22 - Essentially what I want to do here is
14:25 - I need to rotate before I translate.
14:28 - I have this thing here,
I make this matrix,
14:31 - I rotate the matrix, and
then I translate out to here
14:34 - and I have my new location
where x and y should be.
14:38 - So, I think in order to
make this more clear,
14:40 - I want to do a little
bit of console logging.
14:43 - 'Cause with this matrix,
what's actually in there?
14:46 - So let me first make,
14:51 - I'm going to call this matrix one
14:52 - and I'm going to call this matrix two.
14:54 - And this is just for debugging purposes.
14:57 - And I'm going to say matrix
one dot translate qb x qb y.
15:03 - So I want to show you,
what does it look like
15:07 - when I just apply this
translation to x and y
15:11 - without a rotation, and what happens
15:14 - when I rotate and then
apply that translation?
15:18 - So to show you that, I
could do matrix one print
15:21 - and matrix two print.
15:22 - Processing has a nice print
function associated with the,
15:26 - a nice print function
associated with matrices.
15:29 - And let me also just do print line
15:33 - something like this, and let's also,
15:35 - just so we can see, do
print line qb x qb y.
15:40 - So we can see what those values are.
15:42 - So let me run this.
15:43 - Oh, I need to call this function.
15:46 - I'm going to call turn
z right here in setup.
15:50 - Look at this.
15:52 - When the xy location is
negative one, negative one,
15:57 - you can see it as the third column
16:01 - in rows one and two of this matrix.
16:04 - This is the matrix that
keeps track of translations
16:08 - and rotations for a 2D
world in Processing.
16:11 - When I rotate it 90 degrees,
where does it end up?
16:14 - One, negative one.
16:17 - Negative one, negative one ends up
16:19 - at one, negative one, ha ha.
16:22 - When it's negative one, zero,
16:25 - it ends up at zero, negative one.
16:28 - Negative one, zero, rotating 90 degrees,
16:32 - it ends up at, where did it end up?
16:34 - Zero, negative one, which is right here.
16:36 - So you can see this rotates to here.
16:39 - So actually, in those matrices
are the new index values
16:42 - of where it is in my 3D
array that I'm imagining.
16:47 - So here we go.
16:48 - So I, and these values are all stored
16:51 - in properties of the matrix object
16:54 - which are indexed by its row and column.
16:57 - So I can basically say, hey,
qb, you have a new location.
17:03 - Update your location to matrix
two dot M, it's row, column.
17:09 - So zero, two, matrix.
17:14 - Matrix two, M two.
17:17 - Basically I'm getting, and I could've
17:19 - just done the matrix math
with sine and cosine probably,
17:22 - but I kind of like the idea that I'm using
17:25 - the built-in matrix math of Processing.
17:28 - So you can see here that
these are these two values.
17:31 - Update, oh, sorry.
17:33 - M one, two.
17:35 - And then, qb dot z.
17:37 - 'Cause I'm not affecting the z.
17:39 - There's no update function yet.
17:41 - That's a new thing I have to write,
17:43 - but this is what I'm doing.
17:45 - I'm taking the x, y, actually,
17:46 - I want to get rid of the debugging stuff,
17:47 - because this makes it so
much simpler to look at.
17:50 - And I'm just going to call this matrix.
17:53 - I don't need matrix one or matrix two.
17:55 - What I'm doing is I am
taking, I'm making a 2D matrix
17:59 - out of the xy, then I am rotating
it, and then I am getting
18:03 - the new xy and replacing it
in theory in my qb object.
18:07 - And in my qb object then,
I need an update function,
18:11 - which does something like,
18:13 - first of all, I'm just going to,
18:15 - there might be a more
thoughtful way of doing this.
18:17 - But I'm just going to reset the matrix.
18:19 - And this needs an x, a y, and a z.
18:24 - And I'm going to, and somebody
in the chat was telling me,
18:27 - and I should probably get
in the habit of doing this,
18:29 - if I have the same
variable names of things,
18:31 - I can make sure I'm referring
18:32 - to the object instance
variables with this dot,
18:35 - which is of course the thing
I like to use on this channel.
18:37 - Let's be consistent and do it here.
18:39 - So I can say matrix, I don't have
18:42 - to say reset matrix, matrix reset,
18:46 - matrix translate x, y, z.
18:49 - And then let me update, again,
18:51 - I've got a serious bit of redundancy here,
18:53 - but let me just update those
x, y, z values as well.
18:57 - So now,
19:01 - this should update,
19:03 - why is update not working?
19:06 - Oh, you know what?
19:08 - These values in the matrix are floats.
19:12 - And qb wants an in, so I'm going
to, I could just convert it
19:15 - to an in, but I'm going to
use round, because I want to
19:18 - make sure, I ran into
this in another project,
19:22 - just in case it for some reason gives me
19:25 - like 0.999999999, if I used casting it
19:29 - to an integer or floor,
it would make it zero.
19:32 - So this should work.
19:33 - Let's get rid of turn z here.
19:36 - And I'm going to add a key pressed.
19:39 - And I'm just going to say if key equals,
19:41 - just the key one, turn z.
19:47 - So now, alright, ready?
19:51 - (drum roll pattering)
19:51 - When I press the key one,
19:53 - that cubie should move over to the right.
19:58 - (horns trumpeting)
Anticlimactic, but it works.
20:01 - Now here's the interesting thing.
20:03 - I should now be able to say
give this turn z an index,
20:07 - which would be here.
20:10 - So for example, now, if I
were to say turn z zero,
20:17 - I know you want me to use a
switch statement, everybody.
20:19 - Turn z one.
20:22 - The middle is technically,
while I could program it
20:24 - with a rotation of the middle of the cube,
20:27 - that's not really a thing.
20:28 - So I'm actually just going to use one
20:29 - and two to rotate zero and two.
20:33 - Let's highlight both cube two
20:37 - and cube zero, and let's see what happens.
20:41 - So I should now be able
to, if I press one, woops.
20:46 - Oh, what happened here?
20:47 - Oh, sorry everybody, the indices
are negative one and one.
20:53 - Negative one, zero,
and one, of course, ah.
20:55 - Alright, let's try this again.
20:59 - Right, oh, is it going around?
21:01 - Look there, it's going
around, look at that.
21:04 - That one's going around.
21:06 - It's going around, look at that.
21:08 - It's going around, yay.
(hands clap)
21:11 - Yes, okay, now look at this.
21:13 - Now there's got to be
some sort of way I could
21:16 - make this function into
any, just like keep this
21:21 - functiOn generic and do any given axis.
21:24 - But that's too hard for me, I'm going to,
21:27 - this will definitely.
21:29 - ("Refactor" by Espen Sande Larsen)
21:29 - ♪ I will refactor this later ♪
21:32 - ♪ You know I will refactor ♪
21:34 - - Right now I'm just going to copy, paste.
21:36 - And I'm going to say turn y.
21:38 - And so now if y equals index,
21:40 - then what I want is x and z qb y.
21:47 - I don't need to actually round that.
21:48 - So this should be exactly the
same for a y rotation, right?
21:54 - And then, oh, and I need, mm,
I'm going to add one more thing.
21:57 - And then x, I'm going to
just check the x-axis.
22:01 - And this should be y and z.
22:04 - Then I need to keep qb x
22:06 - and adjust the y and z.
22:09 - So I'm turning any face,
like this here with turn y.
22:13 - Now it was kind of obvious to
us that when I have the x-axis
22:16 - that I turn this face into a 2D matrix.
22:19 - But when I'm using the y-axis, eh,
22:21 - let's just take this face
and turn it into a 2D matrix.
22:25 - I need the y values and the z value,
22:27 - I mean sorry, the x
values and the z values.
22:29 - That's what's changing, y is
fixed at negative one, one.
22:32 - Alright, alright.
22:34 - I'm going to use a switch statement.
22:36 - Probably going to have to
come back to my if statement,
22:39 - but let me, I know it's just too painful,
22:41 - I can't bear to deal with the comments.
22:43 - Switch key, I'm looking at it
22:45 - over here on my invisible computer.
22:48 - Case one.
22:50 - No, no, case one.
22:56 - Turn z negative one, break.
23:02 - Right, and then I just
keep doing this, right?
23:06 - Case two, turn z, one.
23:10 - Right?
23:11 - And then, alright.
23:12 - Now, actually, here's the thing.
23:15 - Let's see if I can get
clockwise and counter-clockwise.
23:19 - There's how many moves?
23:21 - I could rotate in this direction
or the other direction.
23:24 - So I'm going to consider that
to be a direction in my rotate.
23:29 - Let me just get this to work
first, then I'll add direction.
23:32 - Too many things.
23:33 - Case one and two.
23:35 - Case
23:38 - three and four,
23:40 - which is turn y.
23:42 - Case five and six, which is turn x.
23:47 - Is that actually a switch statement?
23:48 - What's the chance that's actually
23:49 - a switch statement that works?
23:53 - So one is just turning the back row.
23:57 - That still works.
23:58 - Two is turning the front row.
24:01 - Oh my god.
24:01 - Three, that's not right.
24:06 - Is that?
24:07 - So let's do something a little different.
24:10 - Let's give these a color.
24:16 - And let's do the following.
24:19 - Let's set the color equal to red.
24:24 - And the color equal to, oh, this just C.
24:28 - The color equal to blue.
24:32 - And then in the cubie itself,
24:35 - let's just fill it with its color.
24:41 - That makes much more sense.
24:43 - So now, I think it'll
look right to us now.
24:46 - So if I go and do a y rotation,
24:53 - right, that's correct.
24:55 - Now here's the thing.
24:57 - Will this all keep working,
will this continue to work,
25:00 - if I do multiple combinations?
25:02 - So let's do my z rotation
25:05 - where now, that's there.
25:07 - Now let me also rotate that there,
25:10 - but let me put it down here.
25:11 - Or let's just leave that there.
25:13 - Now let's do a y rotation.
25:15 - Yes, that still works.
25:17 - Let's do x.
25:21 - Yep, that one's going around there.
25:24 - And then the red one is going around.
25:27 - The cubes move correctly!
25:30 - Now that I have all this working,
25:31 - I need to actually color
their faces correctly.
25:33 - So if I put the actual colors
of the cube on the faces,
25:37 - then I can start to move those as well.
25:39 - So in order to do that, I have an idea.
25:42 - What I would like to do is
25:43 - I would like to make a face class.
25:46 - The idea of how I'm going
to keep track of a face,
25:49 - so every single cubie will have,
25:53 - well, in an actual Rubik's Cube, there are
25:57 - center pieces which just have
one face and they never move,
26:00 - they spin, but they just stay permanent.
26:03 - There are these corner pieces
which have three faces.
26:05 - And I don't know what these
26:07 - are called, these little
like middle pieces,
26:08 - I'm sure there's a tech name
for them, that have two faces.
26:11 - I'm going to be simple about this for now
26:13 - and I'm just going to give
every single cubie six faces.
26:16 - And there's going to be a lot
of redundancy, like you will
26:19 - never see the fact that this
cubie does not actually have
26:23 - a white face on the side, but
I'm going to give it that.
26:27 - And the way that I'm going to define
26:28 - each face, each face is
going to have a color.
26:31 - Like what is its actual color.
26:33 - And it is going to have a normal.
26:35 - So its normal is a vector that points
26:37 - perpendicularly,
perpendicular from the face.
26:40 - So if it's the front-facing face,
26:42 - it's normal will be zero, zero, one.
26:45 - It's pointing forward in the z-axis.
26:47 - If it's the backwards-facing
face, zero, zero, negative one,
26:50 - to the right, one, zero,
zero, so on and so forth.
26:53 - So here in the face class,
26:55 - we're going to have a
Pvector called normal.
26:58 - And then we're going to have
a color called C for color.
27:02 - And when I make the face,
27:04 - I will give it a normal and a color.
27:09 - And I will say this dot
normal equals normal.
27:13 - And this dot C equals C.
27:15 - Then every single cubie,
in addition to having
27:18 - all this information, will
have an array of faces
27:24 - with six faces, again, a thing
that I would want to do later,
27:28 - and maybe you can do this in your version,
27:30 - is to have the correct number
of faces for each cubie.
27:34 - But let's just do them all with six.
27:36 - And then in that case, I'm also
just going to hard code this.
27:40 - So each face, faces index zero would be,
27:45 - so I'm going to consider the z-axis
27:52 - as green.
27:54 - Forward, so the back is blue.
27:58 - Negative one of is zero.
27:59 - So that's going to be a
new face with a new Pvector
28:04 - that is zero, zero, negative one.
28:08 - And the color is zero, 0255.
28:13 - So this is the blue face.
28:15 - This is the,
28:21 - green face.
28:23 - This is (laughs) wait, up,
28:26 - up would be zero one zero.
28:29 - This would be white.
28:32 - Yellow, how do I do yellow?
28:34 - It's a little red and a little
green, something like that.
28:38 - No, no, a lot of red and red and green,
28:40 - green, yeah, but this is zero.
28:43 - It's yellow.
28:44 - Yellow, so then left and right,
28:46 - positive right is orange.
28:50 - One, zero, zero is,
28:54 - I think that should be orangeish.
28:56 - Somebody in the chat will
give me some better colors.
28:58 - And then the other side is red.
29:01 - So this is now me making
all of the faces, great.
29:05 - And then, guess what I
could do here in show.
29:08 - After I apply that matrix,
29:11 - I can draw the faces.
29:14 - For face f in faces, f dot show.
29:19 - And now, all I need is a function here
29:22 - that knows how to draw a rectangle
29:24 - pointed perpendicular to the
normal with a particular color.
29:28 - So the first thing I know I
need to do is fill the color.
29:33 - Then I need to draw a quad or a rectangle.
29:35 - Let's just use rectangle, let's just try,
29:37 - I'm just drawing a 2D rectangle.
29:40 - And I need to rotate it
according to the normal.
29:45 - Let's just draw the rectangle.
29:47 - Rectangle at zero, zero, one comma one.
29:50 - Actually it's a square,
29:52 - I can use Processing square function.
29:53 - I think its size is just one.
29:55 - So what if I do this?
29:59 - Oh.
30:00 - Okay, first of all, let
me go back to my cubie.
30:04 - And let's just say,
30:07 - no fill.
30:12 - There's the red one.
30:14 - It's in the wrong place.
30:15 - Oh, they're all just on top of each other.
30:17 - Right, of course.
30:19 - Oh, I do need to translate out,
30:20 - I do need to translate, I
can translate by the normal.
30:23 - Oh, of course.
30:24 - Okay, so I can translate
30:27 - by the normal dot x,
normal dot y, normal dot z.
30:32 - And I'm going to want to add
push matrix and pop matrix.
30:38 - And let's do no stroke here.
30:40 - So now, that should be, there they are.
30:44 - There're all the faces, sort of.
30:46 - Are they in the right place?
30:47 - They kind of are, right?
30:49 - White is back there,
yellow's there, then blue,
30:51 - then red, but they're all, the problem is
30:54 - they're all, I need a rotation.
30:55 - Can I rotate along the
normal or something?
30:58 - Can I do something like
say rotate normal dot x,
31:01 - normal dot y, normal dot z, half pi?
31:06 - Is that like going to work?
31:10 - No.
31:11 - Oh, maybe it's the other way,
maybe half pi goes first.
31:14 - That's the angle and then
this is the axis of rotation.
31:19 - Oh, oh look at this.
31:21 - Something's right sort of.
31:24 - First of all, they're, (laughs)
31:27 - I should be translating
by normal x, half of that.
31:32 - So let's multiply all these by .5.
31:36 - Okay.
31:38 - (laughs) Green and blue,
are those on opposite sides?
31:42 - Yes.
31:44 - White and yellow are in,
31:48 - the right orientation,
31:50 - everything's in the right orientation,
31:51 - but they're in the wrong place.
31:53 - Ah.
(bell dings)
31:56 - Rrrrr. (laughs)
31:59 - negative one, that's
a negative one, right?
32:03 - Ah.
32:06 - Okay, now I'm really close.
32:09 - Alright, well let me, I know
there's a way I could do this.
32:12 - I was trying to avoid this.
32:14 - But just so I get it right.
32:16 - If I were to say, if a normal dot x,
32:22 - if the absolute value of normal
dot z is greater than zero,
32:27 - right, if the normal is along the z-axis,
32:30 - I need to rotate,
32:33 - I actually don't need to rotate at all.
32:35 - The rectangle is drawn correctly.
32:38 - So I could say like rotate just,
32:41 - I could say rotate z, by half pi.
32:45 - Else if the absolute value of normal dot x
32:49 - is greater than zero,
32:51 - then I could rotate, I think it's by x.
32:55 - Else if absolute value of normal dot y
32:58 - is greater than zero, there's
got to be a better way,
33:01 - but this will work, pretty sure.
33:05 - Then I can draw the face.
33:09 - (laughs) That's the same thing.
33:11 - (bell dings)
33:12 - Oops.
33:13 - Okay, so of course, of
course, if I'm, blegh,
33:17 - if I'm along the x-axis, I want to do,
33:21 - I'm drawing the quad like,
33:22 - I'm always drawing the quad face forward.
33:25 - So if this is my quad, if I'm
along here, along the x-axis,
33:30 - I need to actually do a y rotation.
33:32 - If I'm along the, yes,
of course, so that's it.
33:35 - So what I needed to change here was not,
33:39 - and this doesn't, since
I'm drawing it forward,
33:42 - I can just basically
skip the whole z thing.
33:45 - So I only need to do a rotation
33:48 - if I'm on the x-axis of a y, if I'm on,
33:51 - if the normal is along
the y-axis, rotate by x.
33:55 - And then,
33:57 - here we go, now,
(bell dings)
33:58 - we have the Rubik's Cube.
34:00 - And, guess what, I can turn it.
34:03 - Wait, huh?
34:06 - So now I'm turning it.
34:08 - And nothing's happening.
34:11 - Guess what.
34:13 - Now that I have these faces,
34:16 - what happens when I actually
turn a Rubik's Cube?
34:19 - The faces also rotate.
34:21 - The normals need to rotate.
34:23 - This is the last piece.
34:25 - I want to animate it turning,
but this is the last piece
34:28 - to at least have it so that
I can do all the moves.
34:32 - Actually I need to add
directions and maybe make
34:34 - the keyboard controls make
a little bit more sense.
34:37 - But.
34:39 - So, now what I need is
I need inside the face,
34:44 - I need a turn x.
34:48 - I need a turn y.
34:52 - And I need a turn z.
34:58 - So I need to be able to
rotate any given face.
35:02 - Once again I can use
matrix transformations.
35:05 - Only this time, and I've done this before.
35:07 - I did this in my video
about doing 3D rendering
35:11 - without the 3D renderer,
with our own matrix math.
35:13 - And so what I need to do here,
35:15 - let me pull up the Wikipedia page.
35:17 - So here they are, these are
the three rotation matrices
35:21 - for doing an x rotation, a y
rotation, and a z rotation.
35:24 - And all I need to do is apply
35:26 - those rotations to the normal vector.
35:29 - So, I'm sure I could use PMatrix for this,
35:32 - but for whatever reason, I think I might
35:34 - have ane asier time just writing this out.
35:36 - Because ultimately what I'm saying is,
35:38 - let me make a new Pvector.
35:41 - I'll just call this V two.
35:44 - And the V two dot x equals
the normal dot x times sine.
35:48 - So I need an angle here.
35:50 - Normal dot x times cosine of the angle
35:52 - minus normal dot y
times sine of the angle.
35:55 - And then v two dot y equals
normal dot x times sine
36:00 - of the angle plus normal dot
y times cosine of the angle.
36:06 - And then v two dot z equals z.
36:09 - And then I could say normal equals v two.
36:12 - So I have just rotated the
normal according to the x-axis.
36:16 - Sorry, this should be normal dot z.
36:19 - Now here's the thing, I'm
a little worried we're
36:22 - going to run into some rounding weirdness.
36:24 - So what I probably should do is say,
36:31 - let's just put round around all of these.
36:33 - So this should be turning the face.
36:37 - And this math I sort of did
by looking at the formula
36:40 - a little bit by memory, but
I go through this particular
36:43 - formula in detail in the other
matrix transformation video.
36:47 - So now, and somebody in the chat
36:48 - will point out if I may wrong.
36:50 - So now I should be able to
take exactly this same thing
36:53 - and put it in turn Y.
36:58 - And the difference is, with turn y,
37:01 - I am changing x and z.
37:04 - So this is x times cosine,
37:06 - this should have also a float angle.
37:09 - This would be x, and this will be z.
37:11 - This is z, this is x, and this is z.
37:16 - And this is y.
37:18 - So that's just the matrix take and applied
37:22 - to x and z, because y, if I'm turning
37:24 - along the y-axis, y stays the same.
37:27 - Oh wait, this was z, by the way.
37:29 - I've got them in the wrong place.
37:31 - This was z, because z is fixed.
37:34 - This is y because y is fixed.
37:36 - And now, let me copy this
into here and this will be x.
37:41 - I think this should turn all the normals.
37:45 - And if it's turning the normals,
they'll display correctly.
37:50 - So what's a rotation that I'm doing?
37:52 - So how do I have this working?
37:54 - When I say turn z, for example,
37:59 - I say qb update.
38:04 - So I should also say here
probably qb turn faces z.
38:13 - Let's just do that, this is, yeah,
38:16 - I mean this is awkward
naming, but I need to,
38:20 - yeah, I need to turn the faces.
38:22 - I'll do that afterwards, it
doesn't really matter which.
38:24 - And so then I would add a
function here, turn faces z.
38:29 - And I would say for every
face F, faces, and faces.
38:36 - F dot turn z half pi.
38:42 - What's the chance this works?
38:44 - Very little.
38:47 - Oh, wait a sec.
38:50 - Wait a sec.
38:53 - That's right.
38:54 - Orange goes to there goes to there
38:57 - goes to there goes to there, yes.
39:01 - Oh, that one's working too.
39:04 - Right, one, two, one two, one, two.
39:08 - One, two.
39:11 - (bell dings)
39:12 - So close, alright.
39:15 - Turn faces y.
39:18 - And again, I think, there's probably a way
39:21 - to refactor this so that
these functions turn faces x.
39:29 - Okay, let's do y, which was,
39:32 - oh, wait wait wait wait.
39:33 - I need to call those.
39:35 - Turn faces z.
39:39 - Turn faces y.
39:46 - Turn faces x.
39:48 - And I forget what my key commands are.
39:50 - By the way, guess what, we
can get rid of this thing.
39:53 - All this nonsense that I had before,
39:55 - I'm not using this anymore.
39:56 - My code is so much nicer.
39:58 - So now, where's my key commands?
40:01 - Let's just put this in its own tab.
40:03 - So right now if I do y,
this should be the top four.
40:10 - Oh, that's the bottom, that's fine.
40:12 - Five
40:13 - is x.
40:14 - Three is the top.
40:17 - And then, can I start combining these?
40:20 - Yeah.
40:26 - I'm shuffling the cube.
40:29 - I think this is good.
40:30 - I got to do some like real testing of this
40:32 - to make sure this is really working.
40:34 - One thing I need to do is
I need to add direction.
40:36 - So I need to be able to add
a direction for turning here.
40:39 - So in these turn functions, I
should also have a direction.
40:46 - So each one should get a direction.
40:50 - Then, the direction is half
pi, direction times half pi.
40:55 - And turned face is z, with that direction.
41:01 - So rotate according to the direction.
41:06 - And then rotate according
to the direction.
41:10 - So now in turn faces,
41:15 - these should all also have a direction.
41:21 - And then now, alright, so
let's think about this.
41:25 - So z is forward.
41:27 - So let's use F.
41:32 - Hm.
41:34 - What's a good set of key
commands for all the moves?
41:36 - So all the moves that I have are forward,
41:40 - back,
41:41 - up,
41:43 - down,
41:45 - right, left.
41:46 - So I'll use those keys.
41:48 - And lower case will be
in a positive direction,
41:52 - upper case will mean negative direction.
41:54 - So the case f is turn z one, one.
41:57 - The case capital F is turn z
negative one, negative one.
42:02 - That's forward.
42:05 - Then, case b would be
also turn z, but one.
42:12 - One.
42:13 - And B would be one, negative one.
42:17 - Alright, I'm going to do this silently
42:18 - and this could get
fast-forwarded if it needed to.
42:22 - (laid-back music)
42:26 - (bell dings)
42:27 - Alright, I have now put
in every possible move.
42:30 - Front is turn z with a z
of one either direction.
42:34 - Back is a z of negative
one, either direction.
42:37 - Then y, then x, so then up then down is y.
42:41 - Then left and right is turn x.
42:43 - It does occur to me that I
could just have a generic
42:44 - turn function and I give it
the normal vector of the axis.
42:50 - Or the vector of the axis itself.
42:51 - But anyway, this I believe should work.
42:55 - Let's see.
42:56 - So if I want to do a
front, I should just see
42:58 - that front face, which
is the green face, turn.
43:02 - Which I am seeing.
43:03 - Back should be the back face.
43:05 - Up, oh, the up, is down.
43:08 - So up is down, whatever,
43:10 - 'cause the y points in
the other direfction.
43:12 - Down is the top, ah, you
know, spin it around.
43:17 - Up is the top, as long as I'm consistent.
43:20 - Down goes this way.
43:22 - Right, okay, now this is right.
43:25 - And left.
43:27 - Now are my clockwise and
counter-clockwise things working?
43:31 - So front, which was the green face,
43:36 - goes this way, and capital
F should go the other way.
43:43 - Yep, so now let's see.
43:45 - If I turn front, and then
now let me do the left,
43:52 - which is there, that's the right.
43:55 - Doesn't matter, long as it's one side.
43:59 - It's working.
44:01 - I think this is good.
44:04 - Here's a way that I could test this.
44:06 - What I'm going to do now
to finish off this video
44:09 - is run a set of moves shuffling it
44:13 - and then run those moves backwards.
44:17 - So to do that, let me get,
let me make a char array.
44:22 - All moves is just f,
44:26 - front, back, up, down,
44:30 - left,
44:34 - right.
44:35 - And I could deal with the
capitals, you know what,
44:37 - I should make these individual strings.
44:40 - So what I'm going to do, and I'm going to
44:42 - make a string called sequence.
44:47 - And what I'm going to do is in setup,
44:53 - I'm going to say for int i equals zero,
44:55 - i is less than, let's just do 10 moves.
44:58 - A sequence
45:02 - index i equals int.
45:05 - So let me get an index.
45:07 - Which is a random number between all,
45:11 - that's an index into the all moves array.
45:13 - Sequence plus equals,
45:20 - oh, I'm already using index.
45:22 - So let me just say r.
45:23 - Sequence plus equals all moves r.
45:29 - So if I do that, all movies, all moves,
45:33 - this would be, you can see,
there should be a sequence here.
45:35 - You can't really see that.
45:37 - This is my sequence.
45:38 - Up, forward, right right right,
left, up, right, down, back.
45:41 - And just for plausible
deniability here, let's just say
45:46 - if random, I'm going to,
random is less than .5.
45:54 - We'll do this.
45:54 - Otherwise we'll do that to upper case.
46:01 - So now I should have my sequence.
46:02 - And there you go, there's
my sequence, down, up,
46:04 - right, up, down, forward,
up, back, left, left.
46:07 - Okay.
46:08 - So now what I want to do is I
want to run through that sequence.
46:12 - So I'm going to use, I'm
actually going to use that int,
46:15 - I'm just going to use counter equals zero.
46:18 - And I'm going to say in draw,
46:23 - char move equals sequence char
46:27 - at counter, counter plus plus.
46:30 - And I'm just going to do this,
46:32 - if counter is less than
sequence dot length.
46:36 - Okay.
46:37 - Counter is less than sequence
dot length, I'm going to get
46:40 - the move, and then I'm going
to do apply move, move.
46:43 - And now in controls, this should
46:45 - really be apply move char move.
46:50 - And then switch move.
46:52 - So I could if I want to
control it by key pressed,
46:55 - I could still say key, apply move key.
47:00 - But I don't want to
control it by key press,
47:02 - I want to control it by these
moves, so let's run this.
47:07 - (laughs) It did it really fast.
47:10 - Because see, normally the rendering engine
47:12 - takes a minute to spin up.
47:15 - So I'm going to do this.
47:17 - Boolean started equals false.
47:21 - And I'm going to say in key pressed,
47:28 - if key equals the space,
then started equals true.
47:33 - So if I press the space
bar, start things going.
47:37 - And then I'm going to say here in draw,
47:43 - if started, so it won't
do this shuffling now.
47:47 - It won't do the shuffling right now
47:48 - until I press the space bar.
47:51 - See, it shuffled it.
47:53 - But let's slow that down
just so we can see it.
47:56 - If frame count modulus,
you know, 20 equals zero,
48:02 - that's going to only do
that every 20 frames.
48:06 - So I hit the space bar.
48:09 - And you can see it should be, I mean,
48:10 - it should be doing this
sequence right now.
48:13 - It should be doing that sequence.
48:16 - So when it gets to the
end of the sequence,
48:19 - I should go backwards
through the sequence.
48:22 - So sequence is less
than, so what actually,
48:25 - here's what I'm going to do.
48:27 - After I make this sequence,
now, I'm going to say
48:30 - for int i equals zero, i is
less than sequence dot length.
48:36 - I plus plus.
48:40 - Now what I want to do is say,
48:43 - so now I need to say that
move, but the other direction.
48:48 - So char move, or actually, so,
48:51 - string next move equals
sequence char at i.
48:57 - Oh, but I want to go backwards.
49:00 - So I want to go from sequence dot length
49:03 - minus one
49:06 - all the way down to zero, i minus minus.
49:09 - And then I want to get each
one of those characters
49:14 - what's wrong with char
at i, it's not a string.
49:19 - So I'll just convert it into a string.
49:23 - (laughs) Well, that.
49:27 - Can I do this to, oh, wait.
49:29 - Oh, how do I flip the case?
49:32 - Rrr.
49:33 - Thank you to MC Seem in the chat
49:36 - who just gave me a really nice suggestion.
49:39 - I'm going to say flip case.
49:42 - Sequence char at.
49:44 - So I'm going to write my
own flip case function.
49:46 - It's going to be kind of ridiculous.
49:49 - Flip case of char, any given character c.
49:55 - And what I'm going to do is if,
49:59 - so first I need to make it a string.
50:03 - Sure I could just do that.
50:04 - If s dot low two, I know it's lower case.
50:09 - If it equals itself.
50:13 - Right?
50:14 - If the lower case version
of a string is the same
50:16 - as the string, and I think
I want to say it this way,
50:19 - if s equals s, this is
just a little clearer,
50:21 - if s equals s to lower case,
then return s to upper case.
50:27 - Otherwise, return s to lower case.
50:32 - And people were giving good
suggestion about using x
50:34 - or flipping bits or
adding the ASCII values.
50:36 - That would be a nice way of doing it.
50:38 - Apparently that's not a
way you can make a string.
50:42 - I'll just do this, think that works.
50:44 - That's one way to make a string.
50:47 - Plus equals flip case.
50:49 - So, oh no, next move, yes.
50:51 - Next move equals, flip the case,
50:54 - and then sequence plus
equals next move, alright?
50:59 - Let's have it shuffle pretty fast.
51:01 - Like every five frames.
51:04 - And then let's see what happens.
51:07 - (drum roll pattering)
51:09 - Ah, it got an error.
51:10 - Oh, plus equals, (laughs)
51:12 - we don't need press two there.
51:19 - Shuffle, shuffle,
shuffle, shuffle, shuffle.
51:22 - Reverse.
51:26 - Ah.
51:27 - (horns trumpeting)
51:30 - Let's do, let's finish this off
51:34 - with just doing like
51:37 - 200 moves.
51:40 - Let's forget about slowing it down.
51:43 - And let's just enjoy this beauty.
51:46 - Let's make it full screen.
51:48 - Thank you for watching
Part Two of my Rubik's Cube
51:50 - coding challenge, where I
am now shuffling the cube,
51:53 - moving all the pieces around,
then unshuffling it backwards
51:58 - to make it appear as if
it's solving, of course
52:00 - it's not actually solving itself,
it's just doing a sequence
52:02 - and then turning it back, and there we go.
52:05 - So the next step that I
need to do is I need to be,
52:08 - I want to see it animate, I
think it would be much more
52:10 - interesting to actually watch
the faces themselves turn.
52:14 - So that's just a little
52:15 - animation thing, that'll
come in part three.
52:18 - Once I have that, then I
can start to think about,
52:20 - are there different techniques
that I can try to apply
52:23 - to have the cube solve
itself automatically?
52:27 - Thanks for watching
this very long Part Two.
52:29 - If you make your own
version of this, if you've
52:31 - figured out clever ways
to refactor my code,
52:34 - to visualize it in
interesting different ways,
52:36 - to make it more generic
with different scales,
52:38 - maybe you could make one of those pyramid,
52:40 - it's not a cube, those Rubik's pyramids.
52:42 - That would be great.
52:43 - And I'll see you in a
future video, goodbye.
52:45 - (bell dings)
52:46 - (upbeat music)

Cleaned transcript:

(whistle whistles) Hello and welcome to part two of the Rubik's Cube coding challenge. In this version of the coding challenge, I just want to take my existing Rubik's Cube simulation and be able to make some turns, I want to shift the faces of one side of the cubies, like the yellow faces, to turn maybe clockwise and be on the other side and everything follows suit. So I'm going to do that with matrix transformations. Here's the thing, I have to be honest with you, this is my second attempt at doing this. I did a previous livestream where I went down a different road and I was keeping track of arrays and different arrays and trying to shift things and have custom hard coded things for every possible way the Rubik's Cube could turn and it was a total disaster. In the end I actually got it to work, you can see it spinning around and working here right now. I had some really useful suggestions, most notably from Michael Raphael Panganiban, who suggested that I use matrix transformations. And I'm going to try this again, I'm going to try to really think about refactoring that gobbledygook code I wrote before and try to set myself up for success in the future. I also want to highlight this website, I Am the Cube, made by Stewart Smith and other collaborators from Google. This was made for the Google Doodle about the Rubik's Cube a bunch of years ago, and it's really phenomenal. The code is available. I really should just not bother doing what I'm doing and just play with this, but I have a mission. And my mission is to make this Rubik's Cube turn and move. And so I'm going to do that. This is what I left off with in Part One. And one of the things that I did in Part One that was a little bit weird is I really was thinking in terms of cube notation. And if you're a cuber, you look at the cube in a certain direction, you're thinking about what's up, what's down, what's left, what's right, what's clockwise, what's counterclockwise. And that really led me in some strange directions. I think it's useful maybe to double back and add that in once I have the cube working. But the thing that I'm actually working with here in this code, xaxis, yzxis, zaxis. And it's going to be much simpler for me I think to keep track of things and think in those terms. And the rotation might not be clockwise or counterclockwise, it might be in the positive direction or in the negative direction. The first thing that I want to do to really figure this out and to have a more effective way is actually keep track of the cube's location not in a vector, but in a matrix. Dun dun dun. So I have done a lot of videos about matrices and matrix math and some of that's going to come up here. The ones that you might want to check out if that's a totally new concept to you is the video where I made my own 3D renderer using matrix transformations. And I made a little like bunch of functions to do to store matrices and to multiply them. I also used matrices in a bunch of videos I made about neural networks. The matrices pop up there in the math of machine learning with neural networks. But here, what I want to do is I want to have a transformation matrix for each one of the cubies to keep track of where it is in the world. And so, the way that I'm going to do that is I'm going to change the cubie to receive a matrix and for its position to be that matrix rather than a PVector. Luckily for me, Processing already has built into it matrix classes. So I don't have to write my own matrix 3D object, I don't have to write a matrix 2D object, I've got one in the Processing. So, it's going to be a PMatrix3D object. The other thing I want to do now, so this is how I made the cubes before, I made each cubie with an x, y, and z. But now I want to do this. I want to make each cubie with a matrix, and then what I want to do is translate that matrix. So in other words, each cube, it's a way each cube is going to keep track of its own 3D world, and it has the full matrix of what is the translation, what is the rotation, what is the scale. And so if I translate that matrix to its x, y, z location, then I'm initializing the cubie with that particular matrix. Some other things, while this nested loop is useful, it's going to be much simpler for me in the end I think if I actually keep all of the cubies in just a single array. The multidimensional array is interesting, but let me, so let me change that to, I'm just going to make it, no, I'm not going to make this i, I'm going to make this like index, oh actually, let me make this, I'll make this index. And I'm gnona say cube index equals new cubie with the matrix, index plus plus, so that I'm counting. And then, this will now be a single array that has dimensions times dimensions times dimensions. Three times three times three, or 27. Of course, there really isn't a cubie in the center, but eh, you can't see it anyway, so we can imagine it's there. Now the other thing that's really important here, and I'm going to, I think this will be helpful. I'm going to change this to x, y, and z. X, y, and z. I'm going to change this to x, y, and z. I'm not going to worry about this figuring out the actual position of the cube with its length. I just want its position in a threedimensional world. And what are those positions? So if I just think about one face of the cube, for example, maybe this is a face of the cube where z equals one. If we're looking at the cube with green facing us, facing you, this could be the zaxis, this is z equals one. So we've got the xaxis along the horizontal and the yaxis along the vertical. So what I could think about this is really the location x, y, zero, zero, so it's zero, zero, one. So all of these have a z location of one. But this one is negative one, negative one. Sorry, zero, negative one, one, negative one. The y is negative one, the x is negative one, zero, one. So this is negative one, zero, and this is one, zero. This is negative one, one. This is zero, one, and this is one, one. So these are all the locations, and these can actually be the x, y, z values that I apply to translate each individual cubelet's matrix. So if I come back to the code, what I'm doing here is I'm saying, have the x goes from negative one all the way to one. Same thing for the y. Same thing for z. Create a matrix for each one. Create the cubie, I'm not going to worry about this leg thing right now. And then say index plus plus. The cubie then is just a thing with its matrix. And this should say PMatrix3D. I've got to specifically use, I'm going to be using a 2D matrix in a little bit, you'll see this is crazy. But right now I'm going to use the (mumbles). Alright, so, I still have this length variable here. The other thing I want to do is, while it was really useful that I had this whole way of doing these quads and coloring them, I'm going to get rid of that right now. Because I think that what I want to do is think of each of these cubies as a box. And then it's also going to have faces. And I think I'll draw the faces as a separate object with a quad. So right now to keep things very simple, I'm going to show you something kind of nuts. I am going to take out all of this. I'm going to get rid of this translate. I am actually going to call this function called apply matrix. So what am I doing here, I'm taking the matrix, and I probably shouldn't call it pos as in position. Let's actually call it matrix. Let's call it matrix, each cubie has a matrix which really contains all the information about where, its position and rotation in the world of the cube itself. And this is actually the same as just calling translate at this point. But because I'm storing it in a matrix instead of calling translate directly, it's going to give me some more possibilities later as I need to keep track of all these cubies separately or in smaller groups and that kind of thing. So if I do this, and then if I just say box, and I'm going to say box one, it's going to be a small box, pop matrix, then, and here, the nice thing about this also is I can change this to cube dot length and get rid of this nested loop. I can say cube index I dot show, and hope that we see the Rubik's Cube. Ah, where is it? Oh look, I think it's there. I think that's the Rubik's Cube. Oh, look, I visualized the black hole on the day of the, this is the second image of a black hole, no, okay. So the reason why it's so tiny is because scale. So let me say scale 100, and let's see what happens now. Where's that Rubik's Cube? So let's think about, ah, stroke weight eight. Now that's lunacy here. so let's make the stroke zero, let's make the stroke weight small because I'm scaling up. And let's also make sure we say fill to (mumbles) that's there already. Oh, that's a really big one, but there it is. So I don't want to scale that much. Let's scale it by 50 and let's just say stroke weight .1. And there we go. So now, I have exactly the same thing. I have exactly what I had before, but I just have a matrix for each one of the cubies. Now I need to figure out, how am I going to debug this? Right now if I move them all around, I could move them around, they're all white, they're all going to appear in the same location. So what I'm going to do is I am going to make a variable. I'll just call it Highlight false. And I'm going to say, if highlight fill zero. And then let me say, let me say cube index zero highlight. So there we go, we can see, ah, that one. See look, this one is now highlighted. I can address any individual cubie. It's not really highlighted 'cause it's black, it sort of looks like it's removed. Maybe I should make it like red or something just so it's a bit more obvious. 'Cause everything right now is just white, okay. But let me actually highlight the one that's in the front. (bell dings) Alright, the answer by the way, in case you were wondering, was two. I'm counting with z first, so it's going zero, one, two. So perfect. Boy, that was a lot of time I spent trying to figure out that it was two, you're lucky you didn't have to watch that. Okay. So now I can see that I'm highlighting a given cubie. The next thing I want to do is take one of these faces, each one has its own 3D matrix with an x, y, and z, and rotate It. I want to apply a 2D rotation to this particular face. So any face, whether it's the front, the back, the top, the bottom, if we look at it, it ends up becoming twodimensional. So I just want to rotate two, I just want to rotate along one particular axis. Any given face can become suddenly a 2D world that I want to tdo a rotation to. So if I suddenly have this point here, which is at negative one, negative one, and I want to rotate that relative to the center 90 degrees, or half pi, then it's going to end up where? In one, comma negative one. It's going to move and rotate there. So how can I do that? I can apply a 2D rotation. Let's write a function called turn z. And I want to avoid using rotate z, because even though I'm doing a zaxis rotation, rotate z is the builtin function in Processing. So if I say turn z, first let me look at all of the cubes. So I always need this particular, this particular loop. Just realized something, I now, I sort of regret, I'm regretting taking out that nested loop because I just want all the faces that are in the zaxis. And if I had that nested loop, I would be able to keep it that way. But actually, I'm going to do something slightly redundant, which is that I am also going to keep track in a separate variable. I am going to keep track of, I'm going back, I'm going to keep track of its x, y, and z index values. I'm going to keep track of what those values are within what would be a threedimensional array. And so let me actually add those as arguments here. And I'm going to say x equals x, y equals y. Z equals z. And then when I create each cube, I'm going to say x, y, z. Great. So I have those extra variables because now I can say if a cube dot z equals one, I want only the cubes that are in the zaxis one, negative, zero, one, those are the ones, and this is cube index i dot z, these are the ones that I want to rotate. So now I need to make a 2D matrix, this is what I was saying, 2D matrix out of that face. So the 2D matrix is just a new 2D matrix. I want to do a 90 degree or a half pi rotation of that matrix. And then, I want to translate out to the cubes x, Spongeman on Code Pen who made a version of this. I saw used actually a really cute variable name which I'm going to use right now. qb, like the letters qb for the cubie, equals cube index i. So I can actually just use qb, it's qb z equals one, translate by qb x and qb y. Essentially what I want to do here is I need to rotate before I translate. I have this thing here, I make this matrix, I rotate the matrix, and then I translate out to here and I have my new location where x and y should be. So, I think in order to make this more clear, I want to do a little bit of console logging. 'Cause with this matrix, what's actually in there? So let me first make, I'm going to call this matrix one and I'm going to call this matrix two. And this is just for debugging purposes. And I'm going to say matrix one dot translate qb x qb y. So I want to show you, what does it look like when I just apply this translation to x and y without a rotation, and what happens when I rotate and then apply that translation? So to show you that, I could do matrix one print and matrix two print. Processing has a nice print function associated with the, a nice print function associated with matrices. And let me also just do print line something like this, and let's also, just so we can see, do print line qb x qb y. So we can see what those values are. So let me run this. Oh, I need to call this function. I'm going to call turn z right here in setup. Look at this. When the xy location is negative one, negative one, you can see it as the third column in rows one and two of this matrix. This is the matrix that keeps track of translations and rotations for a 2D world in Processing. When I rotate it 90 degrees, where does it end up? One, negative one. Negative one, negative one ends up at one, negative one, ha ha. When it's negative one, zero, it ends up at zero, negative one. Negative one, zero, rotating 90 degrees, it ends up at, where did it end up? Zero, negative one, which is right here. So you can see this rotates to here. So actually, in those matrices are the new index values of where it is in my 3D array that I'm imagining. So here we go. So I, and these values are all stored in properties of the matrix object which are indexed by its row and column. So I can basically say, hey, qb, you have a new location. Update your location to matrix two dot M, it's row, column. So zero, two, matrix. Matrix two, M two. Basically I'm getting, and I could've just done the matrix math with sine and cosine probably, but I kind of like the idea that I'm using the builtin matrix math of Processing. So you can see here that these are these two values. Update, oh, sorry. M one, two. And then, qb dot z. 'Cause I'm not affecting the z. There's no update function yet. That's a new thing I have to write, but this is what I'm doing. I'm taking the x, y, actually, I want to get rid of the debugging stuff, because this makes it so much simpler to look at. And I'm just going to call this matrix. I don't need matrix one or matrix two. What I'm doing is I am taking, I'm making a 2D matrix out of the xy, then I am rotating it, and then I am getting the new xy and replacing it in theory in my qb object. And in my qb object then, I need an update function, which does something like, first of all, I'm just going to, there might be a more thoughtful way of doing this. But I'm just going to reset the matrix. And this needs an x, a y, and a z. And I'm going to, and somebody in the chat was telling me, and I should probably get in the habit of doing this, if I have the same variable names of things, I can make sure I'm referring to the object instance variables with this dot, which is of course the thing I like to use on this channel. Let's be consistent and do it here. So I can say matrix, I don't have to say reset matrix, matrix reset, matrix translate x, y, z. And then let me update, again, I've got a serious bit of redundancy here, but let me just update those x, y, z values as well. So now, this should update, why is update not working? Oh, you know what? These values in the matrix are floats. And qb wants an in, so I'm going to, I could just convert it to an in, but I'm going to use round, because I want to make sure, I ran into this in another project, just in case it for some reason gives me like 0.999999999, if I used casting it to an integer or floor, it would make it zero. So this should work. Let's get rid of turn z here. And I'm going to add a key pressed. And I'm just going to say if key equals, just the key one, turn z. So now, alright, ready? (drum roll pattering) When I press the key one, that cubie should move over to the right. (horns trumpeting) Anticlimactic, but it works. Now here's the interesting thing. I should now be able to say give this turn z an index, which would be here. So for example, now, if I were to say turn z zero, I know you want me to use a switch statement, everybody. Turn z one. The middle is technically, while I could program it with a rotation of the middle of the cube, that's not really a thing. So I'm actually just going to use one and two to rotate zero and two. Let's highlight both cube two and cube zero, and let's see what happens. So I should now be able to, if I press one, woops. Oh, what happened here? Oh, sorry everybody, the indices are negative one and one. Negative one, zero, and one, of course, ah. Alright, let's try this again. Right, oh, is it going around? Look there, it's going around, look at that. That one's going around. It's going around, look at that. It's going around, yay. (hands clap) Yes, okay, now look at this. Now there's got to be some sort of way I could make this function into any, just like keep this functiOn generic and do any given axis. But that's too hard for me, I'm going to, this will definitely. ("Refactor" by Espen Sande Larsen) ♪ I will refactor this later ♪ ♪ You know I will refactor ♪ Right now I'm just going to copy, paste. And I'm going to say turn y. And so now if y equals index, then what I want is x and z qb y. I don't need to actually round that. So this should be exactly the same for a y rotation, right? And then, oh, and I need, mm, I'm going to add one more thing. And then x, I'm going to just check the xaxis. And this should be y and z. Then I need to keep qb x and adjust the y and z. So I'm turning any face, like this here with turn y. Now it was kind of obvious to us that when I have the xaxis that I turn this face into a 2D matrix. But when I'm using the yaxis, eh, let's just take this face and turn it into a 2D matrix. I need the y values and the z value, I mean sorry, the x values and the z values. That's what's changing, y is fixed at negative one, one. Alright, alright. I'm going to use a switch statement. Probably going to have to come back to my if statement, but let me, I know it's just too painful, I can't bear to deal with the comments. Switch key, I'm looking at it over here on my invisible computer. Case one. No, no, case one. Turn z negative one, break. Right, and then I just keep doing this, right? Case two, turn z, one. Right? And then, alright. Now, actually, here's the thing. Let's see if I can get clockwise and counterclockwise. There's how many moves? I could rotate in this direction or the other direction. So I'm going to consider that to be a direction in my rotate. Let me just get this to work first, then I'll add direction. Too many things. Case one and two. Case three and four, which is turn y. Case five and six, which is turn x. Is that actually a switch statement? What's the chance that's actually a switch statement that works? So one is just turning the back row. That still works. Two is turning the front row. Oh my god. Three, that's not right. Is that? So let's do something a little different. Let's give these a color. And let's do the following. Let's set the color equal to red. And the color equal to, oh, this just C. The color equal to blue. And then in the cubie itself, let's just fill it with its color. That makes much more sense. So now, I think it'll look right to us now. So if I go and do a y rotation, right, that's correct. Now here's the thing. Will this all keep working, will this continue to work, if I do multiple combinations? So let's do my z rotation where now, that's there. Now let me also rotate that there, but let me put it down here. Or let's just leave that there. Now let's do a y rotation. Yes, that still works. Let's do x. Yep, that one's going around there. And then the red one is going around. The cubes move correctly! Now that I have all this working, I need to actually color their faces correctly. So if I put the actual colors of the cube on the faces, then I can start to move those as well. So in order to do that, I have an idea. What I would like to do is I would like to make a face class. The idea of how I'm going to keep track of a face, so every single cubie will have, well, in an actual Rubik's Cube, there are center pieces which just have one face and they never move, they spin, but they just stay permanent. There are these corner pieces which have three faces. And I don't know what these are called, these little like middle pieces, I'm sure there's a tech name for them, that have two faces. I'm going to be simple about this for now and I'm just going to give every single cubie six faces. And there's going to be a lot of redundancy, like you will never see the fact that this cubie does not actually have a white face on the side, but I'm going to give it that. And the way that I'm going to define each face, each face is going to have a color. Like what is its actual color. And it is going to have a normal. So its normal is a vector that points perpendicularly, perpendicular from the face. So if it's the frontfacing face, it's normal will be zero, zero, one. It's pointing forward in the zaxis. If it's the backwardsfacing face, zero, zero, negative one, to the right, one, zero, zero, so on and so forth. So here in the face class, we're going to have a Pvector called normal. And then we're going to have a color called C for color. And when I make the face, I will give it a normal and a color. And I will say this dot normal equals normal. And this dot C equals C. Then every single cubie, in addition to having all this information, will have an array of faces with six faces, again, a thing that I would want to do later, and maybe you can do this in your version, is to have the correct number of faces for each cubie. But let's just do them all with six. And then in that case, I'm also just going to hard code this. So each face, faces index zero would be, so I'm going to consider the zaxis as green. Forward, so the back is blue. Negative one of is zero. So that's going to be a new face with a new Pvector that is zero, zero, negative one. And the color is zero, 0255. So this is the blue face. This is the, green face. This is (laughs) wait, up, up would be zero one zero. This would be white. Yellow, how do I do yellow? It's a little red and a little green, something like that. No, no, a lot of red and red and green, green, yeah, but this is zero. It's yellow. Yellow, so then left and right, positive right is orange. One, zero, zero is, I think that should be orangeish. Somebody in the chat will give me some better colors. And then the other side is red. So this is now me making all of the faces, great. And then, guess what I could do here in show. After I apply that matrix, I can draw the faces. For face f in faces, f dot show. And now, all I need is a function here that knows how to draw a rectangle pointed perpendicular to the normal with a particular color. So the first thing I know I need to do is fill the color. Then I need to draw a quad or a rectangle. Let's just use rectangle, let's just try, I'm just drawing a 2D rectangle. And I need to rotate it according to the normal. Let's just draw the rectangle. Rectangle at zero, zero, one comma one. Actually it's a square, I can use Processing square function. I think its size is just one. So what if I do this? Oh. Okay, first of all, let me go back to my cubie. And let's just say, no fill. There's the red one. It's in the wrong place. Oh, they're all just on top of each other. Right, of course. Oh, I do need to translate out, I do need to translate, I can translate by the normal. Oh, of course. Okay, so I can translate by the normal dot x, normal dot y, normal dot z. And I'm going to want to add push matrix and pop matrix. And let's do no stroke here. So now, that should be, there they are. There're all the faces, sort of. Are they in the right place? They kind of are, right? White is back there, yellow's there, then blue, then red, but they're all, the problem is they're all, I need a rotation. Can I rotate along the normal or something? Can I do something like say rotate normal dot x, normal dot y, normal dot z, half pi? Is that like going to work? No. Oh, maybe it's the other way, maybe half pi goes first. That's the angle and then this is the axis of rotation. Oh, oh look at this. Something's right sort of. First of all, they're, (laughs) I should be translating by normal x, half of that. So let's multiply all these by .5. Okay. (laughs) Green and blue, are those on opposite sides? Yes. White and yellow are in, the right orientation, everything's in the right orientation, but they're in the wrong place. Ah. (bell dings) Rrrrr. (laughs) negative one, that's a negative one, right? Ah. Okay, now I'm really close. Alright, well let me, I know there's a way I could do this. I was trying to avoid this. But just so I get it right. If I were to say, if a normal dot x, if the absolute value of normal dot z is greater than zero, right, if the normal is along the zaxis, I need to rotate, I actually don't need to rotate at all. The rectangle is drawn correctly. So I could say like rotate just, I could say rotate z, by half pi. Else if the absolute value of normal dot x is greater than zero, then I could rotate, I think it's by x. Else if absolute value of normal dot y is greater than zero, there's got to be a better way, but this will work, pretty sure. Then I can draw the face. (laughs) That's the same thing. (bell dings) Oops. Okay, so of course, of course, if I'm, blegh, if I'm along the xaxis, I want to do, I'm drawing the quad like, I'm always drawing the quad face forward. So if this is my quad, if I'm along here, along the xaxis, I need to actually do a y rotation. If I'm along the, yes, of course, so that's it. So what I needed to change here was not, and this doesn't, since I'm drawing it forward, I can just basically skip the whole z thing. So I only need to do a rotation if I'm on the xaxis of a y, if I'm on, if the normal is along the yaxis, rotate by x. And then, here we go, now, (bell dings) we have the Rubik's Cube. And, guess what, I can turn it. Wait, huh? So now I'm turning it. And nothing's happening. Guess what. Now that I have these faces, what happens when I actually turn a Rubik's Cube? The faces also rotate. The normals need to rotate. This is the last piece. I want to animate it turning, but this is the last piece to at least have it so that I can do all the moves. Actually I need to add directions and maybe make the keyboard controls make a little bit more sense. But. So, now what I need is I need inside the face, I need a turn x. I need a turn y. And I need a turn z. So I need to be able to rotate any given face. Once again I can use matrix transformations. Only this time, and I've done this before. I did this in my video about doing 3D rendering without the 3D renderer, with our own matrix math. And so what I need to do here, let me pull up the Wikipedia page. So here they are, these are the three rotation matrices for doing an x rotation, a y rotation, and a z rotation. And all I need to do is apply those rotations to the normal vector. So, I'm sure I could use PMatrix for this, but for whatever reason, I think I might have ane asier time just writing this out. Because ultimately what I'm saying is, let me make a new Pvector. I'll just call this V two. And the V two dot x equals the normal dot x times sine. So I need an angle here. Normal dot x times cosine of the angle minus normal dot y times sine of the angle. And then v two dot y equals normal dot x times sine of the angle plus normal dot y times cosine of the angle. And then v two dot z equals z. And then I could say normal equals v two. So I have just rotated the normal according to the xaxis. Sorry, this should be normal dot z. Now here's the thing, I'm a little worried we're going to run into some rounding weirdness. So what I probably should do is say, let's just put round around all of these. So this should be turning the face. And this math I sort of did by looking at the formula a little bit by memory, but I go through this particular formula in detail in the other matrix transformation video. So now, and somebody in the chat will point out if I may wrong. So now I should be able to take exactly this same thing and put it in turn Y. And the difference is, with turn y, I am changing x and z. So this is x times cosine, this should have also a float angle. This would be x, and this will be z. This is z, this is x, and this is z. And this is y. So that's just the matrix take and applied to x and z, because y, if I'm turning along the yaxis, y stays the same. Oh wait, this was z, by the way. I've got them in the wrong place. This was z, because z is fixed. This is y because y is fixed. And now, let me copy this into here and this will be x. I think this should turn all the normals. And if it's turning the normals, they'll display correctly. So what's a rotation that I'm doing? So how do I have this working? When I say turn z, for example, I say qb update. So I should also say here probably qb turn faces z. Let's just do that, this is, yeah, I mean this is awkward naming, but I need to, yeah, I need to turn the faces. I'll do that afterwards, it doesn't really matter which. And so then I would add a function here, turn faces z. And I would say for every face F, faces, and faces. F dot turn z half pi. What's the chance this works? Very little. Oh, wait a sec. Wait a sec. That's right. Orange goes to there goes to there goes to there goes to there, yes. Oh, that one's working too. Right, one, two, one two, one, two. One, two. (bell dings) So close, alright. Turn faces y. And again, I think, there's probably a way to refactor this so that these functions turn faces x. Okay, let's do y, which was, oh, wait wait wait wait. I need to call those. Turn faces z. Turn faces y. Turn faces x. And I forget what my key commands are. By the way, guess what, we can get rid of this thing. All this nonsense that I had before, I'm not using this anymore. My code is so much nicer. So now, where's my key commands? Let's just put this in its own tab. So right now if I do y, this should be the top four. Oh, that's the bottom, that's fine. Five is x. Three is the top. And then, can I start combining these? Yeah. I'm shuffling the cube. I think this is good. I got to do some like real testing of this to make sure this is really working. One thing I need to do is I need to add direction. So I need to be able to add a direction for turning here. So in these turn functions, I should also have a direction. So each one should get a direction. Then, the direction is half pi, direction times half pi. And turned face is z, with that direction. So rotate according to the direction. And then rotate according to the direction. So now in turn faces, these should all also have a direction. And then now, alright, so let's think about this. So z is forward. So let's use F. Hm. What's a good set of key commands for all the moves? So all the moves that I have are forward, back, up, down, right, left. So I'll use those keys. And lower case will be in a positive direction, upper case will mean negative direction. So the case f is turn z one, one. The case capital F is turn z negative one, negative one. That's forward. Then, case b would be also turn z, but one. One. And B would be one, negative one. Alright, I'm going to do this silently and this could get fastforwarded if it needed to. (laidback music) (bell dings) Alright, I have now put in every possible move. Front is turn z with a z of one either direction. Back is a z of negative one, either direction. Then y, then x, so then up then down is y. Then left and right is turn x. It does occur to me that I could just have a generic turn function and I give it the normal vector of the axis. Or the vector of the axis itself. But anyway, this I believe should work. Let's see. So if I want to do a front, I should just see that front face, which is the green face, turn. Which I am seeing. Back should be the back face. Up, oh, the up, is down. So up is down, whatever, 'cause the y points in the other direfction. Down is the top, ah, you know, spin it around. Up is the top, as long as I'm consistent. Down goes this way. Right, okay, now this is right. And left. Now are my clockwise and counterclockwise things working? So front, which was the green face, goes this way, and capital F should go the other way. Yep, so now let's see. If I turn front, and then now let me do the left, which is there, that's the right. Doesn't matter, long as it's one side. It's working. I think this is good. Here's a way that I could test this. What I'm going to do now to finish off this video is run a set of moves shuffling it and then run those moves backwards. So to do that, let me get, let me make a char array. All moves is just f, front, back, up, down, left, right. And I could deal with the capitals, you know what, I should make these individual strings. So what I'm going to do, and I'm going to make a string called sequence. And what I'm going to do is in setup, I'm going to say for int i equals zero, i is less than, let's just do 10 moves. A sequence index i equals int. So let me get an index. Which is a random number between all, that's an index into the all moves array. Sequence plus equals, oh, I'm already using index. So let me just say r. Sequence plus equals all moves r. So if I do that, all movies, all moves, this would be, you can see, there should be a sequence here. You can't really see that. This is my sequence. Up, forward, right right right, left, up, right, down, back. And just for plausible deniability here, let's just say if random, I'm going to, random is less than .5. We'll do this. Otherwise we'll do that to upper case. So now I should have my sequence. And there you go, there's my sequence, down, up, right, up, down, forward, up, back, left, left. Okay. So now what I want to do is I want to run through that sequence. So I'm going to use, I'm actually going to use that int, I'm just going to use counter equals zero. And I'm going to say in draw, char move equals sequence char at counter, counter plus plus. And I'm just going to do this, if counter is less than sequence dot length. Okay. Counter is less than sequence dot length, I'm going to get the move, and then I'm going to do apply move, move. And now in controls, this should really be apply move char move. And then switch move. So I could if I want to control it by key pressed, I could still say key, apply move key. But I don't want to control it by key press, I want to control it by these moves, so let's run this. (laughs) It did it really fast. Because see, normally the rendering engine takes a minute to spin up. So I'm going to do this. Boolean started equals false. And I'm going to say in key pressed, if key equals the space, then started equals true. So if I press the space bar, start things going. And then I'm going to say here in draw, if started, so it won't do this shuffling now. It won't do the shuffling right now until I press the space bar. See, it shuffled it. But let's slow that down just so we can see it. If frame count modulus, you know, 20 equals zero, that's going to only do that every 20 frames. So I hit the space bar. And you can see it should be, I mean, it should be doing this sequence right now. It should be doing that sequence. So when it gets to the end of the sequence, I should go backwards through the sequence. So sequence is less than, so what actually, here's what I'm going to do. After I make this sequence, now, I'm going to say for int i equals zero, i is less than sequence dot length. I plus plus. Now what I want to do is say, so now I need to say that move, but the other direction. So char move, or actually, so, string next move equals sequence char at i. Oh, but I want to go backwards. So I want to go from sequence dot length minus one all the way down to zero, i minus minus. And then I want to get each one of those characters what's wrong with char at i, it's not a string. So I'll just convert it into a string. (laughs) Well, that. Can I do this to, oh, wait. Oh, how do I flip the case? Rrr. Thank you to MC Seem in the chat who just gave me a really nice suggestion. I'm going to say flip case. Sequence char at. So I'm going to write my own flip case function. It's going to be kind of ridiculous. Flip case of char, any given character c. And what I'm going to do is if, so first I need to make it a string. Sure I could just do that. If s dot low two, I know it's lower case. If it equals itself. Right? If the lower case version of a string is the same as the string, and I think I want to say it this way, if s equals s, this is just a little clearer, if s equals s to lower case, then return s to upper case. Otherwise, return s to lower case. And people were giving good suggestion about using x or flipping bits or adding the ASCII values. That would be a nice way of doing it. Apparently that's not a way you can make a string. I'll just do this, think that works. That's one way to make a string. Plus equals flip case. So, oh no, next move, yes. Next move equals, flip the case, and then sequence plus equals next move, alright? Let's have it shuffle pretty fast. Like every five frames. And then let's see what happens. (drum roll pattering) Ah, it got an error. Oh, plus equals, (laughs) we don't need press two there. Shuffle, shuffle, shuffle, shuffle, shuffle. Reverse. Ah. (horns trumpeting) Let's do, let's finish this off with just doing like 200 moves. Let's forget about slowing it down. And let's just enjoy this beauty. Let's make it full screen. Thank you for watching Part Two of my Rubik's Cube coding challenge, where I am now shuffling the cube, moving all the pieces around, then unshuffling it backwards to make it appear as if it's solving, of course it's not actually solving itself, it's just doing a sequence and then turning it back, and there we go. So the next step that I need to do is I need to be, I want to see it animate, I think it would be much more interesting to actually watch the faces themselves turn. So that's just a little animation thing, that'll come in part three. Once I have that, then I can start to think about, are there different techniques that I can try to apply to have the cube solve itself automatically? Thanks for watching this very long Part Two. If you make your own version of this, if you've figured out clever ways to refactor my code, to visualize it in interesting different ways, to make it more generic with different scales, maybe you could make one of those pyramid, it's not a cube, those Rubik's pyramids. That would be great. And I'll see you in a future video, goodbye. (bell dings) (upbeat music)
