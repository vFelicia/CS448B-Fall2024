With timestamps:

00:00 - hello welcome to part four of this video
00:03 - series thing that I'm doing about
00:05 - genetic algorithms okay what's going to
00:06 - happen now in this particular video what
00:09 - I want to do is actually finally and
00:10 - know Tak of me for videos look at the
00:12 - code itself so I have a pre-made code
00:15 - example as you know I'm not going to
00:16 - write it from scratch it's coming from
00:18 - the nature of code chapter 9 you can
00:20 - find the link to the chapter and the
00:21 - code in this video's description but
00:23 - what I'm going to do is look at the
00:25 - algorithm itself that I covered in
00:26 - detail a couple videos ago and look at
00:28 - where all those pieces are so so what
00:30 - does it mean to initialize a population
00:32 - randomly what does it mean to do step
00:35 - two selection to calculate the fitness
00:37 - of every member of that population how
00:38 - do you write a function in code to
00:40 - actually do that how do you write a
00:41 - function to to pick randomly but have
00:44 - each thing that you're picking randomly
00:45 - have some sort of higher or lower
00:47 - probability of being picked that's a
00:48 - kind of a tricky problem we'll look at
00:49 - how is that solved and then how do you
00:52 - do this thing heredity how do you do
00:54 - crossover how do you write the algorithm
00:55 - for crossover how do you write the
00:57 - algorithm for mutation and then have
00:58 - this new population that you then make
01:00 - the current population repeat over and
01:02 - over again so I want to look at every
01:03 - single one of these steps and find in
01:05 - the code where those steps happen so
01:08 - let's just start doing that okay
01:09 - actually before I do that though let me
01:11 - at least um open up this directory here
01:13 - and show you that how I have the code
01:15 - organized so I have the code organized
01:17 - you know there's the libraries folder
01:18 - for the P5 Jess uh JavaScript library
01:20 - I'm using there's the HTML file which
01:22 - references the JavaScript files and
01:23 - there's some like kind of worthless
01:25 - styling in style.css but the files that
01:28 - actually matter up to you are sketch. ja
01:30 - that's where kind of the main program is
01:32 - set up this initialization state is draw
01:34 - this looping state is that U um
01:38 - population. JS that's an object that
01:40 - manages the array of all the elements of
01:42 - the population so there's functions for
01:44 - calculating the fitness values there
01:46 - there's functions for doing the
01:47 - selection there and then there's the
01:49 - dna. JS file this is a really important
01:51 - file because this file is actually this
01:54 - object this DNA object as I look at more
01:57 - sophisticated examples in future videos
02:00 - the code in dna. JS will actually be
02:02 - present in almost all of them so a lot
02:04 - of what's great even though this example
02:05 - is kind of completely trivial example
02:07 - because again I could just type to be or
02:09 - not to be that is the question the code
02:12 - in this example can actually be almost
02:14 - lifted essentially verbatim to other
02:16 - scenarios to write your own genetic
02:18 - algorithm and that's kind of the next
02:19 - video after this one that I'll get to
02:21 - how do you take this code and implement
02:22 - it in a different scenario yourself but
02:24 - so the dna. JS has that DNA object it
02:27 - has it a function for mutation it stores
02:30 - the characters for each phrase that sort
02:31 - of thing it's each individual element of
02:33 - the population okay so let's go back to
02:35 - the
02:36 - algorithm step one create a population
02:39 - of n elements so let's go to the code
02:42 - and where this happens is actually in
02:44 - population. JS and we can actually see
02:46 - this happen right here uh I say create
02:49 - population equals a new population so
02:52 - the population is made with three
02:54 - arguments a Target which is the target
02:56 - phrase to be or not to be which I could
02:58 - change a mutation rate and a population
03:01 - Max so those values are sort of stored
03:03 - also in that population object and in
03:05 - the population object
03:07 - itself this is the kind of key variable
03:11 - this.
03:12 - population oh
03:14 - no this
03:16 - dot dot dot don't
03:19 - forget don't forget this dot so uh uh a
03:23 - variables that are part of that object
03:25 - itself are attached to it by saying
03:27 - this. population so this is a
03:28 - Constructor function that's creating a
03:30 - JavaScript object and a population is
03:32 - made as an empty array And Then There
03:35 - are a certain number of elements of the
03:38 - population made as DNA objects so the so
03:41 - what the um I think if I uh come over
03:45 - here for a second the population object
03:50 - itself is just a big
03:54 - array of n
03:56 - elements and each one of those elements
03:59 - is a random phrase you know
04:02 - popcorn you know uh unor whatever these
04:06 - sort of weird nonsense you know a a a a
04:09 - a whatever the each one of the members
04:11 - of the population is a random
04:13 - phrase and but it's not just a string so
04:16 - rather than use just a kind of literal
04:18 - string uh what I'm actually doing is
04:20 - creating a DNA object and this is kind
04:22 - of crucial and this is now where the
04:24 - dna. JS file comes in dna. JS has an
04:28 - object it's itself which is an array
04:30 - called this do genes so if I come back
04:34 - over
04:35 - here
04:38 - whoops step on a light on a
04:41 - fan I think I broke no I didn't break
04:43 - this anyway that light went off this
04:45 - might be a little bit darker for a
04:46 - second back hello everything's okay the
04:49 - fan is blowing up my legs so this is the
04:51 - population array each element of the
04:54 - array is a phrase which is actually a
04:56 - DNA object which itself is an array
04:59 - array and each element of that array
05:02 - being a single
05:04 - character okay so that's how each
05:07 - element of the population is an array of
05:09 - elements each element is an array of
05:11 - characters so this is ultimately how the
05:14 - uh whoops let me come over here this is
05:16 - ultimately how that population is made
05:19 - make a certain number of DNA objects
05:21 - each DNA object uh each element is a new
05:24 - car now one thing that's a little bit
05:26 - goofy here is I wrote an entire function
05:29 - to uh make a random character there
05:31 - might be an easier way to do this in
05:33 - JavaScript but I really just want random
05:35 - characters I'm using the sort of asky
05:37 - table here so I'm picking a random
05:39 - number between 63 and 122 and then
05:42 - converting those from that number to a
05:45 - string using its character code so like
05:47 - using the asky table and if you're not
05:48 - sure what the asky table is I'll try to
05:51 - include a reference Link in this video's
05:53 - description to that so
05:56 - that is step one initialize okay okay
06:00 - step two being selection now we need to
06:03 - evaluate the fitness of every element of
06:06 - the population so where does that happen
06:08 - so one thing by the way that I think is
06:10 - worth looking at by is this uh is this
06:13 - main program right so draw by the way
06:15 - look at this the draw function
06:18 - essentially and it's funny how I'm doing
06:20 - this in a slightly weird order I maybe I
06:22 - should flip this around but what the
06:25 - population does what the the population
06:27 - object itself has all of these steps of
06:29 - the algorithm written in a specific
06:31 - functions so I could just say population
06:33 - calculate the fitness of every element
06:36 - population perform natural selection
06:39 - population generate the next population
06:42 - and then population. evaluate why I um
06:45 - that what that function does actually is
06:47 - just sort of checks to see if we're done
06:50 - so these are the three I kind of I don't
06:52 - know why I did this I'm going to just
06:54 - right
06:55 - now put this first because it's Loop
06:59 - over and over again it doesn't
07:00 - necessarily matter but I'm going to
07:02 - calculate the fitness um first because
07:05 - this is sort of essentially the order of
07:07 - the of the genetic algorith itself so
07:08 - this is this is Step uh two right here
07:12 - uh selection which calls that function
07:14 - calculate Fitness which is right here uh
07:17 - oh I froze hopefully I didn't actually
07:21 - object um somebody in the chat will tell
07:23 - me if this sto working uh there's this
07:25 - function calculate Fitness and notice
07:28 - what that function does it Loops through
07:30 - every single member of the population
07:32 - and calls another function calc Fitness
07:35 - so when I say Cal Fitness on the
07:36 - population really what I'm just doing is
07:38 - saying Loop through the entire
07:40 - population and call a function on every
07:41 - element called calc Fitness and check
07:43 - the fitness against that Target phrase
07:45 - so now if I go into the DNA object we
07:47 - can see Cal Fitness right here this is
07:50 - now a key key function in a gen any
07:54 - genetic algorithm is the fitness
07:55 - function itself so you can see what's
07:57 - going on here I start with a schol four
07:59 - of zero I iterate over every single
08:02 - character in the phrase if the
08:04 - particular character in the genes array
08:07 - matches the character in the Target
08:09 - phrase increase that score by one and
08:12 - the fitness is the score divided by the
08:15 - total length so the number of characters
08:17 - correct divided by the total length
08:19 - gives you a percentage I got nine out of
08:20 - 10 characters correct a fitness score of
08:22 - 90% so you can see that's what's
08:24 - happening and so that's step two
08:27 - selection calculate
08:29 - Fitness initialize generate 200 random
08:34 - DNA objects step two calculate the
08:37 - fitness for those random DNA objects
08:40 - okay now the next thing we need to do is
08:42 - reproduction now here's the thing let's
08:45 - come back over here and talk about how
08:48 - this is going to
08:50 - work so let me erase this for a
08:53 - second so if you recall I had this idea
08:58 - of this spinning wheel wheel Wheel of
09:00 - Fortune so here's the wheel maybe there
09:05 - are you know a whole bunch of members of
09:08 - the population uh each with a certain
09:10 - Fitness and depending on their Fitness
09:12 - they get a bigger slice of that pie and
09:15 - then the idea is you spin this wheel and
09:17 - you pick a parent and pick another
09:18 - parent well you know I could actually
09:21 - build in the code like the sort of
09:24 - physics simulation of a spinning wheel
09:26 - but that would be a little bit Overkill
09:28 - there are a lot of different techniques
09:30 - of um of of picking uh picking random
09:34 - elements from an array based on
09:36 - probabilities there's a snack technique
09:38 - where I can pick two random numbers a
09:39 - kind of qualifying random number it's a
09:42 - I forget what I call I actually just
09:43 - recently made a video or an example
09:45 - about this uh accept reject um kind of
09:48 - algorithm but the algorithm that I'm
09:50 - going to use is actually a very uh
09:53 - simple technique that works well in this
09:55 - case so let's say I have a b c and d and
10:01 - I want a to have a 40% a has a 40% uh
10:06 - chance of being picked B has a
10:10 - 20% C uh has a 15% oh why did I make the
10:14 - math so hard on myself
10:16 - 6075 no no no I don't I don't this is
10:19 - not going to turn out well for anybody
10:20 - with 15% so we'll just make um we'll
10:24 - make C uh
10:27 - 10% 40 60 70 and D
10:30 - 30%
10:33 - okay now look at this let's say I have
10:36 - an
10:37 - array this is the array and the array
10:39 - looks like this a b c and d let's say I
10:45 - want to pick a random element from that
10:47 - array A B C or D each element has an
10:50 - index 0 1 2 or three so I could pick a
10:53 - random number between zero and you know
10:56 - four but not including
10:58 - four each one of these has a 25% chance
11:02 - being Pi of picked I have a one out of
11:04 - four chance I can't write 25% of picking
11:07 - any of those what if however I were to
11:12 - write the array a different way so I'm
11:15 - going to write the array like
11:18 - this a a a a b
11:23 - b
11:25 - c d d d notice I put a in that array
11:31 - four times I put B in that array two
11:34 - times C in that array one time and D in
11:37 - that array three times
11:42 - now there are 10 elements of the array
11:45 - four of which are a so if I pick a
11:47 - random value between 0o and 10 not
11:51 - including 10 0 and
11:53 - nine right four out of 10 times I'm
11:56 - going to pick 0 1 two or three an a two
12:00 - out of 10 times I'm going to pick a four
12:02 - or a five a b so what I can actually do
12:04 - if I have a this is the population array
12:07 - that's the actual population array in
12:09 - the code I build another array which I
12:12 - think I'm calling a mating pool or I
12:15 - might call it like Darwin or something
12:17 - where I take these elements and put them
12:20 - in this array a certain number of times
12:22 - according to their Fitness so the more
12:24 - times something is in an array the more
12:26 - likely it is to be fit picked and I
12:29 - think if I come back over here for a
12:31 - second
12:33 - um I think I have so this is kind of a
12:36 - just some other diagrams demonstrating
12:38 - this idea right what if I have all of
12:40 - these elements with a different
12:41 - probability this is the spinning the
12:42 - wheel approach but what if instead I
12:44 - just create this big bucket and I put
12:47 - like a in there so many times B in there
12:48 - so many times c in there and I pick out
12:50 - of it the more something is in the
12:51 - bucket the likelihood the likelihood the
12:55 - higher the likelihood is that it will
12:56 - get picked so how do you do this in code
12:58 - code if I go back to the code again
13:01 - we're looking now
13:03 - for this function natural selection
13:07 - which says generate a mating pool so
13:09 - let's go look in
13:10 - population and here it is notice what I
13:13 - do this mating pool is now a new empty
13:18 - array and and then ultimately later on
13:22 - right down here there is this code where
13:25 - I'm adding every member of the
13:27 - population into the mating n times so
13:31 - how do I figure out what that number n
13:33 - should be well you know this I could
13:35 - this could probably use some refinement
13:37 - and there's different ways you could do
13:38 - it but ultimately up here what I'm doing
13:41 - is finding out okay what's the number
13:44 - with what's the what's the member of the
13:46 - population with the most Fitness the
13:48 - highest Fitness value then what I do is
13:52 - I take that object's that particular
13:55 - element's Fitness and give it a number
13:58 - between Zer and one mapped from zero to
14:01 - maximum Fitness so in other words what
14:03 - I'm saying is I'm doing sort of Step
14:05 - where I'm normalizing all these Fitness
14:07 - values now ultimately I kind of made up
14:10 - an example here with sort of
14:11 - pre-normalized ex uh value like 04
14:16 - 2.1.3 but your Fitness scores might just
14:18 - be like a whole lot of numbers like this
14:20 - one got a fitness of 2,000 this one got
14:22 - a fitness of three this one got a
14:23 - fitness of
14:24 - 4,228 so what I do is I have a way of
14:27 - saying whatever the fitness numbers
14:29 - might be take them all and just have
14:31 - them have a range between 0o and one and
14:33 - actually the next thing I do is multiply
14:34 - it by 100 so actually the range is
14:37 - between zero and 100 and you can see
14:41 - that's what's happening right here I do
14:43 - that mapping then oops ah I lost my oh I
14:49 - sorry I lost control of my computer and
14:51 - then I multiply that value by 100 and
14:54 - that's n that's how many times those
14:57 - elements are in the mating pool itself
14:59 - so if I were to just do something which
15:01 - I'm a little bit afraid to do but I'm
15:03 - going to say console log this. mating
15:05 - pool and I'm going to go back to the
15:08 - sketch and run it and what you can see
15:12 - is these are the mating pools right and
15:15 - it finished and you can see that there
15:17 - are uh this array this this array is
15:21 - actually quite huge I wanted to say uh
15:23 - this do I think it might make more sense
15:25 - to say this. meting pool. length so you
15:27 - can see this is how many things are in
15:29 - The Mating pool in the in the 15 to
15:31 - 20,000 range whereas the population
15:33 - itself is just 200 but based on their
15:36 - Fitness that maing pool is built much
15:38 - larger okay so that's we're getting
15:41 - there that is let me go back to this
15:43 - particular Alum so that is selection so
15:46 - once I have the mating pool then I'm
15:48 - ready for step three reproduction all I
15:50 - need to do is I have the mating pool all
15:51 - the probabilities are already sort of
15:53 - built into that big array right now I
15:55 - just need to pick two random ones from
15:56 - the array and we can go into the code
15:58 - itself
15:59 - and we can see where that happens look
16:01 - at this this four I want to do this end
16:04 - times I want to make a new population
16:06 - here are all the steps that's the
16:08 - generate function pick two parents give
16:11 - me a random index into the mating pool a
16:15 - give me a r another random index into
16:17 - the Ming pool now technically speaking
16:19 - you might want to say to yourself ah you
16:22 - know what if B equals a I want to
16:24 - invalidate B and pick another one but
16:26 - you know me I'm sort of being Loosey
16:28 - Goosey about it doesn't really matter if
16:29 - I by accident on the rare occasion pick
16:32 - the same parent twice big deal so I have
16:34 - two parents parent or I play partner a
16:36 - and partner B both of those are DNA
16:39 - objects that come from The Mating pool
16:41 - and then I simply call crossover I take
16:43 - partner a crossover with partner B and
16:46 - that is a new child element and then
16:48 - child I call mutate for the mutation
16:51 - rate and then I have that new member of
16:53 - the population so this happens end times
16:55 - I just say I have the mating pool give
16:57 - me two parents
16:59 - uh cross them over apply mutation here's
17:02 - the new child it goes into the
17:03 - population this happens over and over
17:05 - again so we've really looked at every
17:08 - single element of this algorithm here
17:11 - the last thing though is we could look
17:13 - at what has actually happened in
17:14 - crossover mutation so again just to
17:16 - remind ourselves this is the crossover
17:18 - step the technique that I happen to be
17:20 - applying is take half of one and half of
17:23 - the other and put them together but
17:24 - certainly you could take one from each
17:26 - one I think I don't think I have a DI
17:28 - for that or you could do it a different
17:29 - way and then mutation I'm using this
17:32 - probability to say at any given random
17:35 - uh any there's a certain chance that I
17:37 - might just change that character
17:39 - randomly so let's look at how those
17:40 - functions work now notice where is that
17:44 - function happening I'm saying partner a
17:46 - that's a DNA object cross over with
17:48 - partner B that's another DNA object so
17:51 - that code for the crossover function
17:52 - itself is in this DNA object which is
17:55 - right here so look at this this is now
17:57 - the crossover over function first of all
18:00 - I'm creating a new DNA object with the
18:02 - same length the same amount of genes as
18:04 - this current DNA object I'm picking a
18:07 - random midpoint right I could just say
18:09 - oh the Rand the midpoint is always five
18:11 - or the midpoint is always this. genes.
18:13 - length divided by two but I'm picking a
18:15 - random midpoint and look at this this
18:18 - child's genes are either coming
18:22 - from right if I'm on one side of the
18:25 - midpoint they come from this particular
18:28 - DNA objects genes
18:31 - otherwise um otherwise they come from
18:34 - the partner genes so this is how I'm
18:37 - applying crossover it's literally just a
18:39 - new array take elements from one array
18:41 - or from the other array and then
18:43 - mutation you can see here mutation these
18:45 - are incredible incredibly simple fun
18:47 - then I have a new child DNA object and
18:49 - mutation these are incredibly simple
18:50 - functions all it is is hey let's look at
18:52 - every single Gene and just say pick a
18:56 - random number between zero and one if
18:58 - the m ation rate is 01 or 1% if I happen
19:01 - to pick a random number less than 01
19:03 - then just give me a new character forget
19:05 - about whatever I got through crossover
19:07 - give me a new character okay so this is
19:09 - it these are all of those pieces this is
19:12 - the main program right in setup I have
19:16 - what's the target phrase what's the
19:18 - maximum population what's the mutation
19:19 - rate then I create a new population
19:22 - object and then I just walk through the
19:24 - algorithm itself calculate the fitness
19:26 - build the mating pool generate the next
19:28 - population evaluate is just checking to
19:30 - see how everything did at the end that's
19:32 - and um and then you know there's some
19:34 - other code for sort of displaying all
19:36 - the information using Dom elements and
19:38 - that sort of thing but this is the key
19:40 - algorithm it's all in separate functions
19:42 - and each one of these functions
19:44 - calculate the fitness natural selection
19:45 - and generation simply iterates over that
19:48 - entire
19:50 - population right the population object
19:53 - has a population array I'm always
19:55 - iterating over that population array
19:57 - calculating the fitness for every
19:59 - element of that array uh assigning a
20:01 - probability for every element of that
20:03 - array picking a random parent from that
20:07 - picking a random element picking a new
20:09 - child for every element of that array
20:11 - and all of those functions are in turn
20:13 - in this DNA object the DNA object stores
20:16 - the actual genetic information it has a
20:18 - function for calculating the fitness it
20:19 - has a function for performing crossover
20:21 - and it has a function for performing
20:23 - mutation so these are all the
20:25 - elements so I've kind of finished this
20:28 - here I'm going to do a follow-up video
20:29 - where I talk about a couple things that
20:31 - I think could optimize or change the way
20:34 - this works but ultimately what the the
20:36 - project for you in your head that you
20:38 - want to think about for right now is
20:40 - well what is the thing that you want to
20:41 - make that you might want to try to
20:42 - evolve are you trying to evolve a
20:44 - particular design to make it more
20:47 - beautiful or more intuitive are you
20:48 - trying to evolve a particular animation
20:50 - behavior of an element on the screen um
20:53 - and what might be you know how could
20:55 - this algorithm apply to your scenario
20:58 - what might be the genetic information
21:00 - how are you how is how is how is I just
21:02 - made this like weird like closing my one
21:04 - eye thing expression at you I don't know
21:06 - why but um how how can how can you apply
21:11 - this sort of algorithm and idea to your
21:13 - particular uh creative project and
21:16 - that's what I'm going to start to get to
21:17 - as I look at a few more advanced or more
21:20 - advanced is the wrong word but really
21:21 - more sophisticated examples of applying
21:23 - this so I'll see you in the next few
21:25 - videos where I look at some other
21:26 - scenarios and other things with genetic
21:27 - algor
21:28 - okay byebye quick addendum here since I
21:31 - said I would do this uh for those of you
21:33 - that are interested the code for this
21:35 - example is also available in the
21:36 - processing program environment which is
21:39 - a a a creative coding environment built
21:42 - on top of the Java programming language
21:43 - so if you're looking for Java classes to
21:45 - do a genetic algorithm you can find
21:47 - those as well and really ultimately it's
21:49 - all kind of the same there's some you
21:51 - know little differences the you know
21:53 - we've got the sort of more classical
21:55 - object-oriented programming where I have
21:56 - a DNA class and and a population class
21:59 - uh the population itself is an array but
22:02 - one thing you'll notice that's kind of
22:03 - key is the mating pool I'm using as an
22:05 - array list in JavaScript arrays can
22:08 - easily just kind of be resized and
22:10 - things can be added and deleted just
22:12 - with a regular array but in in Java
22:14 - itself uh a an array is a fixed size
22:17 - which works for the population which
22:19 - always has a fixed size but the mating
22:20 - pool itself has to have a flexibly sized
22:22 - array list but otherwise everything is
22:24 - essentially the same and you can see
22:25 - here I have setup where I'm creating a
22:27 - population object and draw where these
22:30 - functions are being called natural
22:31 - selection generate calculate Fitness um
22:34 - and various things like displaying the
22:36 - info by drawing text of what's going on
22:38 - on the screen itself so uh look for the
22:40 - links in this video's description for
22:42 - also the Java code and if you have
22:43 - questions about that please let me know
22:45 - thanks

Cleaned transcript:

hello welcome to part four of this video series thing that I'm doing about genetic algorithms okay what's going to happen now in this particular video what I want to do is actually finally and know Tak of me for videos look at the code itself so I have a premade code example as you know I'm not going to write it from scratch it's coming from the nature of code chapter 9 you can find the link to the chapter and the code in this video's description but what I'm going to do is look at the algorithm itself that I covered in detail a couple videos ago and look at where all those pieces are so so what does it mean to initialize a population randomly what does it mean to do step two selection to calculate the fitness of every member of that population how do you write a function in code to actually do that how do you write a function to to pick randomly but have each thing that you're picking randomly have some sort of higher or lower probability of being picked that's a kind of a tricky problem we'll look at how is that solved and then how do you do this thing heredity how do you do crossover how do you write the algorithm for crossover how do you write the algorithm for mutation and then have this new population that you then make the current population repeat over and over again so I want to look at every single one of these steps and find in the code where those steps happen so let's just start doing that okay actually before I do that though let me at least um open up this directory here and show you that how I have the code organized so I have the code organized you know there's the libraries folder for the P5 Jess uh JavaScript library I'm using there's the HTML file which references the JavaScript files and there's some like kind of worthless styling in style.css but the files that actually matter up to you are sketch. ja that's where kind of the main program is set up this initialization state is draw this looping state is that U um population. JS that's an object that manages the array of all the elements of the population so there's functions for calculating the fitness values there there's functions for doing the selection there and then there's the dna. JS file this is a really important file because this file is actually this object this DNA object as I look at more sophisticated examples in future videos the code in dna. JS will actually be present in almost all of them so a lot of what's great even though this example is kind of completely trivial example because again I could just type to be or not to be that is the question the code in this example can actually be almost lifted essentially verbatim to other scenarios to write your own genetic algorithm and that's kind of the next video after this one that I'll get to how do you take this code and implement it in a different scenario yourself but so the dna. JS has that DNA object it has it a function for mutation it stores the characters for each phrase that sort of thing it's each individual element of the population okay so let's go back to the algorithm step one create a population of n elements so let's go to the code and where this happens is actually in population. JS and we can actually see this happen right here uh I say create population equals a new population so the population is made with three arguments a Target which is the target phrase to be or not to be which I could change a mutation rate and a population Max so those values are sort of stored also in that population object and in the population object itself this is the kind of key variable this. population oh no this dot dot dot don't forget don't forget this dot so uh uh a variables that are part of that object itself are attached to it by saying this. population so this is a Constructor function that's creating a JavaScript object and a population is made as an empty array And Then There are a certain number of elements of the population made as DNA objects so the so what the um I think if I uh come over here for a second the population object itself is just a big array of n elements and each one of those elements is a random phrase you know popcorn you know uh unor whatever these sort of weird nonsense you know a a a a a whatever the each one of the members of the population is a random phrase and but it's not just a string so rather than use just a kind of literal string uh what I'm actually doing is creating a DNA object and this is kind of crucial and this is now where the dna. JS file comes in dna. JS has an object it's itself which is an array called this do genes so if I come back over here whoops step on a light on a fan I think I broke no I didn't break this anyway that light went off this might be a little bit darker for a second back hello everything's okay the fan is blowing up my legs so this is the population array each element of the array is a phrase which is actually a DNA object which itself is an array array and each element of that array being a single character okay so that's how each element of the population is an array of elements each element is an array of characters so this is ultimately how the uh whoops let me come over here this is ultimately how that population is made make a certain number of DNA objects each DNA object uh each element is a new car now one thing that's a little bit goofy here is I wrote an entire function to uh make a random character there might be an easier way to do this in JavaScript but I really just want random characters I'm using the sort of asky table here so I'm picking a random number between 63 and 122 and then converting those from that number to a string using its character code so like using the asky table and if you're not sure what the asky table is I'll try to include a reference Link in this video's description to that so that is step one initialize okay okay step two being selection now we need to evaluate the fitness of every element of the population so where does that happen so one thing by the way that I think is worth looking at by is this uh is this main program right so draw by the way look at this the draw function essentially and it's funny how I'm doing this in a slightly weird order I maybe I should flip this around but what the population does what the the population object itself has all of these steps of the algorithm written in a specific functions so I could just say population calculate the fitness of every element population perform natural selection population generate the next population and then population. evaluate why I um that what that function does actually is just sort of checks to see if we're done so these are the three I kind of I don't know why I did this I'm going to just right now put this first because it's Loop over and over again it doesn't necessarily matter but I'm going to calculate the fitness um first because this is sort of essentially the order of the of the genetic algorith itself so this is this is Step uh two right here uh selection which calls that function calculate Fitness which is right here uh oh I froze hopefully I didn't actually object um somebody in the chat will tell me if this sto working uh there's this function calculate Fitness and notice what that function does it Loops through every single member of the population and calls another function calc Fitness so when I say Cal Fitness on the population really what I'm just doing is saying Loop through the entire population and call a function on every element called calc Fitness and check the fitness against that Target phrase so now if I go into the DNA object we can see Cal Fitness right here this is now a key key function in a gen any genetic algorithm is the fitness function itself so you can see what's going on here I start with a schol four of zero I iterate over every single character in the phrase if the particular character in the genes array matches the character in the Target phrase increase that score by one and the fitness is the score divided by the total length so the number of characters correct divided by the total length gives you a percentage I got nine out of 10 characters correct a fitness score of 90% so you can see that's what's happening and so that's step two selection calculate Fitness initialize generate 200 random DNA objects step two calculate the fitness for those random DNA objects okay now the next thing we need to do is reproduction now here's the thing let's come back over here and talk about how this is going to work so let me erase this for a second so if you recall I had this idea of this spinning wheel wheel Wheel of Fortune so here's the wheel maybe there are you know a whole bunch of members of the population uh each with a certain Fitness and depending on their Fitness they get a bigger slice of that pie and then the idea is you spin this wheel and you pick a parent and pick another parent well you know I could actually build in the code like the sort of physics simulation of a spinning wheel but that would be a little bit Overkill there are a lot of different techniques of um of of picking uh picking random elements from an array based on probabilities there's a snack technique where I can pick two random numbers a kind of qualifying random number it's a I forget what I call I actually just recently made a video or an example about this uh accept reject um kind of algorithm but the algorithm that I'm going to use is actually a very uh simple technique that works well in this case so let's say I have a b c and d and I want a to have a 40% a has a 40% uh chance of being picked B has a 20% C uh has a 15% oh why did I make the math so hard on myself 6075 no no no I don't I don't this is not going to turn out well for anybody with 15% so we'll just make um we'll make C uh 10% 40 60 70 and D 30% okay now look at this let's say I have an array this is the array and the array looks like this a b c and d let's say I want to pick a random element from that array A B C or D each element has an index 0 1 2 or three so I could pick a random number between zero and you know four but not including four each one of these has a 25% chance being Pi of picked I have a one out of four chance I can't write 25% of picking any of those what if however I were to write the array a different way so I'm going to write the array like this a a a a b b c d d d notice I put a in that array four times I put B in that array two times C in that array one time and D in that array three times now there are 10 elements of the array four of which are a so if I pick a random value between 0o and 10 not including 10 0 and nine right four out of 10 times I'm going to pick 0 1 two or three an a two out of 10 times I'm going to pick a four or a five a b so what I can actually do if I have a this is the population array that's the actual population array in the code I build another array which I think I'm calling a mating pool or I might call it like Darwin or something where I take these elements and put them in this array a certain number of times according to their Fitness so the more times something is in an array the more likely it is to be fit picked and I think if I come back over here for a second um I think I have so this is kind of a just some other diagrams demonstrating this idea right what if I have all of these elements with a different probability this is the spinning the wheel approach but what if instead I just create this big bucket and I put like a in there so many times B in there so many times c in there and I pick out of it the more something is in the bucket the likelihood the likelihood the higher the likelihood is that it will get picked so how do you do this in code code if I go back to the code again we're looking now for this function natural selection which says generate a mating pool so let's go look in population and here it is notice what I do this mating pool is now a new empty array and and then ultimately later on right down here there is this code where I'm adding every member of the population into the mating n times so how do I figure out what that number n should be well you know this I could this could probably use some refinement and there's different ways you could do it but ultimately up here what I'm doing is finding out okay what's the number with what's the what's the member of the population with the most Fitness the highest Fitness value then what I do is I take that object's that particular element's Fitness and give it a number between Zer and one mapped from zero to maximum Fitness so in other words what I'm saying is I'm doing sort of Step where I'm normalizing all these Fitness values now ultimately I kind of made up an example here with sort of prenormalized ex uh value like 04 2.1.3 but your Fitness scores might just be like a whole lot of numbers like this one got a fitness of 2,000 this one got a fitness of three this one got a fitness of 4,228 so what I do is I have a way of saying whatever the fitness numbers might be take them all and just have them have a range between 0o and one and actually the next thing I do is multiply it by 100 so actually the range is between zero and 100 and you can see that's what's happening right here I do that mapping then oops ah I lost my oh I sorry I lost control of my computer and then I multiply that value by 100 and that's n that's how many times those elements are in the mating pool itself so if I were to just do something which I'm a little bit afraid to do but I'm going to say console log this. mating pool and I'm going to go back to the sketch and run it and what you can see is these are the mating pools right and it finished and you can see that there are uh this array this this array is actually quite huge I wanted to say uh this do I think it might make more sense to say this. meting pool. length so you can see this is how many things are in The Mating pool in the in the 15 to 20,000 range whereas the population itself is just 200 but based on their Fitness that maing pool is built much larger okay so that's we're getting there that is let me go back to this particular Alum so that is selection so once I have the mating pool then I'm ready for step three reproduction all I need to do is I have the mating pool all the probabilities are already sort of built into that big array right now I just need to pick two random ones from the array and we can go into the code itself and we can see where that happens look at this this four I want to do this end times I want to make a new population here are all the steps that's the generate function pick two parents give me a random index into the mating pool a give me a r another random index into the Ming pool now technically speaking you might want to say to yourself ah you know what if B equals a I want to invalidate B and pick another one but you know me I'm sort of being Loosey Goosey about it doesn't really matter if I by accident on the rare occasion pick the same parent twice big deal so I have two parents parent or I play partner a and partner B both of those are DNA objects that come from The Mating pool and then I simply call crossover I take partner a crossover with partner B and that is a new child element and then child I call mutate for the mutation rate and then I have that new member of the population so this happens end times I just say I have the mating pool give me two parents uh cross them over apply mutation here's the new child it goes into the population this happens over and over again so we've really looked at every single element of this algorithm here the last thing though is we could look at what has actually happened in crossover mutation so again just to remind ourselves this is the crossover step the technique that I happen to be applying is take half of one and half of the other and put them together but certainly you could take one from each one I think I don't think I have a DI for that or you could do it a different way and then mutation I'm using this probability to say at any given random uh any there's a certain chance that I might just change that character randomly so let's look at how those functions work now notice where is that function happening I'm saying partner a that's a DNA object cross over with partner B that's another DNA object so that code for the crossover function itself is in this DNA object which is right here so look at this this is now the crossover over function first of all I'm creating a new DNA object with the same length the same amount of genes as this current DNA object I'm picking a random midpoint right I could just say oh the Rand the midpoint is always five or the midpoint is always this. genes. length divided by two but I'm picking a random midpoint and look at this this child's genes are either coming from right if I'm on one side of the midpoint they come from this particular DNA objects genes otherwise um otherwise they come from the partner genes so this is how I'm applying crossover it's literally just a new array take elements from one array or from the other array and then mutation you can see here mutation these are incredible incredibly simple fun then I have a new child DNA object and mutation these are incredibly simple functions all it is is hey let's look at every single Gene and just say pick a random number between zero and one if the m ation rate is 01 or 1% if I happen to pick a random number less than 01 then just give me a new character forget about whatever I got through crossover give me a new character okay so this is it these are all of those pieces this is the main program right in setup I have what's the target phrase what's the maximum population what's the mutation rate then I create a new population object and then I just walk through the algorithm itself calculate the fitness build the mating pool generate the next population evaluate is just checking to see how everything did at the end that's and um and then you know there's some other code for sort of displaying all the information using Dom elements and that sort of thing but this is the key algorithm it's all in separate functions and each one of these functions calculate the fitness natural selection and generation simply iterates over that entire population right the population object has a population array I'm always iterating over that population array calculating the fitness for every element of that array uh assigning a probability for every element of that array picking a random parent from that picking a random element picking a new child for every element of that array and all of those functions are in turn in this DNA object the DNA object stores the actual genetic information it has a function for calculating the fitness it has a function for performing crossover and it has a function for performing mutation so these are all the elements so I've kind of finished this here I'm going to do a followup video where I talk about a couple things that I think could optimize or change the way this works but ultimately what the the project for you in your head that you want to think about for right now is well what is the thing that you want to make that you might want to try to evolve are you trying to evolve a particular design to make it more beautiful or more intuitive are you trying to evolve a particular animation behavior of an element on the screen um and what might be you know how could this algorithm apply to your scenario what might be the genetic information how are you how is how is how is I just made this like weird like closing my one eye thing expression at you I don't know why but um how how can how can you apply this sort of algorithm and idea to your particular uh creative project and that's what I'm going to start to get to as I look at a few more advanced or more advanced is the wrong word but really more sophisticated examples of applying this so I'll see you in the next few videos where I look at some other scenarios and other things with genetic algor okay byebye quick addendum here since I said I would do this uh for those of you that are interested the code for this example is also available in the processing program environment which is a a a creative coding environment built on top of the Java programming language so if you're looking for Java classes to do a genetic algorithm you can find those as well and really ultimately it's all kind of the same there's some you know little differences the you know we've got the sort of more classical objectoriented programming where I have a DNA class and and a population class uh the population itself is an array but one thing you'll notice that's kind of key is the mating pool I'm using as an array list in JavaScript arrays can easily just kind of be resized and things can be added and deleted just with a regular array but in in Java itself uh a an array is a fixed size which works for the population which always has a fixed size but the mating pool itself has to have a flexibly sized array list but otherwise everything is essentially the same and you can see here I have setup where I'm creating a population object and draw where these functions are being called natural selection generate calculate Fitness um and various things like displaying the info by drawing text of what's going on on the screen itself so uh look for the links in this video's description for also the Java code and if you have questions about that please let me know thanks
