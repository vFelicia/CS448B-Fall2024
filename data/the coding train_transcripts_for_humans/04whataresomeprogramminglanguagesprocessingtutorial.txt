With timestamps:

00:02 - We're very close now.
00:03 - We're just a few videos away from actually
opening up a Processing window and typing
00:08 - in some lines of
00:09 - code, running our code and having our first
computer program.
00:11 - But I think before we do that I want
to talk about something which is -
00:16 - okay - let's just say -
00:19 - It's Time to Learn Programming, then the
big question arrives
00:23 - What programming language should I learn?
What's my project? What am I doing? What's
00:28 - the right environment? What's the right
language? And this -
00:30 - this is a question that's loaded with
00:33 - anxiety and confusion and, "Oh! What if I'm
learning the wrong thing?" and "Shouldn't I
00:39 - be really learning this?" and I
00:40 - first I just want to say a general
comment first before we
00:44 - to take a programming languages. There is no
perfect programming language. There is no
00:48 - perfect programming environment that
will do everything you always wanted it to
00:52 - do is perfect and exactly right for the
particular project you're making
00:55 - and often the answer to that question is,
you know,
01:00 - the answer to the question "what programming
language should use?" it's the one that
01:03 - you just sorta
01:04 - feel comfortable with how it looks good
kinda like you're happy to get started
01:12 - and
01:07 - the one that you're using right now.
Better to be writing code and making
01:13 - something
01:13 - then to be spending all day worrying
about trying to find that perfect
01:16 - language so
01:17 - in a sense, one answer is, "Pick something
get started."
01:20 - You can learn this language and try this
one later and another one later
01:24 - it doesn't really matter. But for us we
have to come to a decision and in many
01:28 - ways
01:29 - I'm picking a programming language
and environment
01:31 - which is one that I'm comfortable with.
It's one that I work on. It's one that I've
01:35 - known for many years. I's not perfect.
01:37 - - and so that's what you will be learning.
And and hopefully
01:41 - you will find other languages
and environments in your life
01:44 - and this will have helped to you to that end.
01:47 - So let's just - first though - okay so let's think
about what are -
01:51 - what's the kind of map
01:54 - of programming languages that are out
there and what what are the sort of pros
01:58 - and cons advantages and disadvantages
using different languages
02:05 - Hello! Okay! So one thing we can look at
02:07 - (I'll provide a link to this) this is a nice
little chart called, "The History of Programming
02:12 - Languages," I think it's available from
02:13 - O'Reilly, and we can first at least see 
like back here
02:16 - in 1954 the invention of Fortran
02:20 - which you can see right here we can
start to kind of like scroll around this
02:24 - thing, we can see that there are
02:25 - zillions of languages and they have
various relationships and they all have funny
02:28 - names like Oberon
02:29 - AINSI C and Ada and all sorts of other stuff.
The other thing I should point out about this nice
02:34 - little graph/chart
02:35 - is that ends in 2004 so
02:38 - a lot has happened by the way the last
ten years nine or ten years
02:42 - there's a lot of other languages a lot
of other innovations on this chart if
02:45 - you were to continue it
02:47 - would get even bigger and crazier but
you know just looking at you realize
02:50 - oh, my goodness, it's totally overwhelming.
02:53 - look how many language there are. We
could also kind of go to Wikipedia there's
02:57 - "Comparison of Programming Languages" page
and you can scroll down and see, look
03:01 - all these possible languages. There
are zillions of them. So
03:04 - I think we can kind of make our own
little list, just to kind of -
03:09 - you know you've probably heard -
this would be the moment where I'd say, "Hey,
03:12 - everyone out there, the three of you
watching this video,
03:16 - raise your raise your hand and shout out a
programming language that you've heard of,"
03:20 - and you might say, "Pascal!"
03:24 - (probably none of you has heard of Pascal) but -
03:27 - Pascal - (Ooh, boy this pen doesn't work)
03:30 - Pascal. There we go. You might say
C. You might say Java.
03:38 - You might even say something like, "Oh,
what this thing,
03:41 - 'Assembly Language' or 'Machine Language?'"
03:45 - I'll write Assembly Language down here.
03:47 - And you might say, "Oh, what about ActionScript?"
03:50 - And you might even learn something -
03:54 - have heard of something - probably you haven't, 
but the first programming - one of the first
03:59 - programming languages I learned actually
04:00 - was "Lingo," which was the programming
language of Macromedia's Director which I
04:04 - believe still exists? Anyway
04:07 - so we could start making this list, and I
kinda started doing this I think I
04:10 - probably put Pascal in the wrong place but
04:12 - what I've - one of the things i wanna talk
about with this kinda list of programming
04:16 - languages and what you might pick -
04:17 - and I'm gonna say say C++ / Objective-c
04:21 - is this idea of low level
04:27 - versus high level
04:32 - and this is kinda lowel-level
[corrects spelling error] low-level
04:36 - high-level this is an important concept
that comes up in
04:39 - thinking about programming languages,
right? So
04:42 - essentially let's say you want to write
the lowest level possible code,
04:48 - that you were completely insane
person who wanted to just like
04:51 - torture yourself for eternity, you would
04:54 - you would say I'm only going to write my
computer program as a sequence
04:58 - zeros and ones, right? Because ultimately
05:00 - so here's mine - you know this -
05:05 - execute this code - it's amazing - it's
beautiful. Here this is my program,
05:10 - right? (and I guess you can see it because I
wrote off the edge of the screen)
05:13 - but let's just say this is your
program - what am I talking about?
05:18 - Okay, this is like the lowest -
essentially everything that executes on
05:22 - your computer - all data - is stored -
05:24 - all instructions are stored as a
sequence of zeros and ones.
05:27 - But this is unrealistic. 
How could you possibly
05:30 - really be expected to write software
05:33 - just as a series of 0's and 1's? So
there's generally a process where
05:37 - you want to be able to write your code in
a higher level way
05:41 - the ultimate like - if I'm creating a
graphics application, which is what we're
05:45 - going to be doing,
05:46 - a really high level programs might
say - might be written something like this
05:49 - draw a red square - draw a square on the
screen that's like medium size and red
05:54 - colored
05:54 - and draw circle that's really big and blue.
That's very high level. It
05:58 - really is like English and 
what happens is
06:01 - there's a compiler that will take that high-level
06:05 - code and translate it into machine language.
06:10 - So assembly language is kinda want to
the lowest level programming languages
06:14 - that people use.
06:15 - When C came around, C was often
refered to in
06:19 - this kind of like oxymoron type way
06:23 - a high-level low-level language meaning it's
high-level
06:27 - in that you're writing code that starts to
have higher-level,
06:30 - more English-like constructs, but it still
allows you the low-level access to the
06:36 - computer -
06:37 - direct access to the computer's memory - lots
of stuff that you can do it makes it
06:41 - very very very - you can
06:42 - execute very very fast. So anyway that's just
kind of an important concept to realize
06:46 - most of the languages that I haven't
kind of written up here
06:49 - which I'll kind of like add over here
like - that you may have heard of- like Ruby,
06:54 - JavaScript, Python,
06:58 - and we could keep going here, 
we could write lot others
07:01 - these are all generally high-level
programming languages.
07:05 - Now there's another kind interesting
little component
07:07 - that I think that I'll mention
07:09 - which is this idea of a language 
that's 'compiled'
07:12 - versus 'interpreted' - now in many ways I almost
want to stop myself and not talk about this
07:17 - because - we don't really - these are some
details that when we're first
07:21 - learning to program
07:22 - we're gonna put aside. We just want to write
the code run it and make stuff happen
07:25 - but it's something to think about as you
start getting to this larger world
07:28 - of programming languages.
07:30 - So let's say you're writing a program in C,
right?
07:33 - You write out the text-based instructions
07:36 - in your high-level language. That program
gets compiled
07:40 - down into the sort of lowest level program
which is
07:44 - like one level below Assembly Language, which is
Machine Language
07:47 - the zeros and ones. Then it can be run.
This is great;
07:52 - it makes it run it makes run very very
very fast
07:54 - but it is -
07:56 - - is different that some languages that we
have now that are interpreted,
08:00 - JavaScript being one of those.
08:02 - A language which is interpreted is
actually -
08:07 - while the program is running - it is
reading your code line by line and
08:11 - executing the program. This allows for
things like
08:14 - live coding, right? If a program is
actually reading the code as it's running
08:18 - you could
08:19 - change the code as it's running and the
program would change in real time
08:22 - which cannot happen in a compiled language
because you've got to write your code,
08:26 - compile, then run it. So I the reason why
mention this
08:30 - is we're using - we are going to use Processing
08:33 - (am I recording? Yes?)
08:37 - We're going to use Processing which
08:39 - is, and our code is actually going to be
compiled before it's run
08:42 - which is something we'll see as we start to
first write our programs.
08:46 - Another topic that I want to bring up is
this idea of
08:49 - 'client-side' versus 'server-side'
programming. This is an important
08:53 - question because
08:54 - you know you you might have project
ideas in your head
08:58 - things that you want to make and one
thing might be, "I had this idea for this
09:02 - kinda interactive
09:03 - exhibit about dinosaurs for a science museum."
09:07 - In that sense you might be building a client-side
09:10 - application a desktop application that's
gonna run maybe it reads some
09:14 - pixels from a camera so the user can
interact with in a draw some
09:17 - dinosaur footprints to the screen or
something like that.
09:20 - You might also have an idea for, "Oh, I have this
website I want to make
09:24 - where the user enters all this
information about - personal information
09:28 - about themselves -
09:29 - and it gives them back their horoscope." so
09:31 - these are different applications and
require a different set of programming
09:36 - languages for them,
09:37 - and one thing that we can see here
i mean all
09:40 - this idea of anytime you go to a web
page - if this is my web browser -
09:45 - and you type in, you know, "Google.com"
and you search for something
09:51 - you are sending a request to a server
09:56 - in the cloud which - it's not really a
cloud - it's an underground bunker basically
09:59 - with some servers, but you could
10:00 - think of it as a nice cloud floating in
the sky -
10:03 - where a program - a server-side program -
"a server-side program" executes
10:10 - and returns information back to you so
you can see the result
10:15 - in the browser. This is different
10:19 - then, perhaps, there being an animation in
the browser that's running
10:23 - that you click on and when you click on
it it makes little pretty fireworks. That
10:27 - might be something written in JavaScript
10:30 - that is executing on the client side, this
animation that's running
10:34 - locally on your computer
10:35 - and reading your mouse clicks. The server
side programming is this thing that
10:39 - happens when you have to request the
program runs it says you data back.
10:42 - Perhaps that's written in Python. Now
there are lots of different languages. In
10:47 - some languages you can write,
10:49 - you know, in JavaScript you can write
client-side programs, and in Javascript you can
10:53 - write server-side programs something
called Node.js - it's not
10:55 - language-specific, but conceptually
there's a different thing going on here.
10:58 - Are you writing a program that is executing
locally on your laptop? You know, here on
11:03 - my prop here there's a
program running on this laptop. It is drawing
11:08 - pixels to the screen.
11:09 - That is a client-side program. There's a
program running
11:13 - somewhere else on a server
11:14 - that is sending me information
back about how excellent my jog was
11:18 - this morning or whatever from the
11:20 - RunKeeper website or whatever but (I
guess I just plugged RunKeeper.
11:24 - I like it)
11:24 - That's a server-side program. So this is
an important consideration when you're
11:28 - learning programming languages
11:30 - and you're creating applications with
them, and this is something you want
11:33 - familiarity with, both client-side and
server-side.
11:36 - This video series that I'm doing, while we
will refer to and demonstrate some
11:41 - examples that
11:42 - involve server-side programming later, on is
really focused on
11:46 - client-side programs. We're going to be
writing
11:49 - applications that open a window on your
computer screen
11:52 - draw pixels, draw text, draw things to
that window,
11:56 - and that you can interact with on your
laptop, so were really learning
12:00 - client-side, which I think is an
important thing to note.
12:04 - And this brings up kinda where with
12:07 - we're kinda finishing off here so
12:10 - if you want to do stuff for the web,
12:12 - there are a lot of fantastic resources
out there for you to learn
12:16 - web programming. JavaScript is a
terrific
12:19 - programming language to learn has lots of
applications
12:23 - Python is another fantastic language
to learn as a beginner,
12:28 - but we're going to use something called
Processing, and I'm going to writet
12:32 - "Processing" right here
12:37 - and I'm going to draw up like a weird
little arrow there
12:39 - that is pointing back to Java. 
So what is Processing?
12:43 - Processing (I really should be able to say it)
12:47 - Processing was developed - was created - in 2001
12:50 - by Casey Reas and Benjamin Fry while they were
students at the MIT Multimedia Lab
12:55 - under John Maeda
12:57 - so what Processing really started as
was, "Hey,
13:00 - we need something to make these projects
we're making.
13:03 - Let's make something." 
So Processing is this
13:08 - really nice simple environment.
13:11 - You can download it. It's kind of all-in-one. 
You can open it.
13:14 - You can type some code. You can run it.
It works.
13:17 - So I'm gonna get to that in a second -
13:19 - more about why we're
using Processing, but let's just think - you've
13:24 - probably heard the term
13:25 - "Creative Coding."
13:28 - The term "Creative Coding" started as a
kind of catch-all phrase
13:33 - for people making creative applications
with code,
13:37 - trying to make Art, trying to make
installations, trying to make weird
13:40 - obscure impractical crazy ideas,
13:43 - and you know there's a lot of
discussion now, "Is this a good term? Is
13:46 - this a bad term?"
13:47 - One thing I think I heard from
Jer Thorp was you could think of it as
13:52 - "creative writing" 
- the process of writing for -
13:55 - the process writing code for
creative applications. There is also now
13:58 - the term "Poetic Computation," which
i think is interesting.
14:02 - But anyway, there are lots of
environments
14:04 - and I'll draw a line here - you might
have heard of something called
14:08 - "Open Frameworks." You might have heard
of something called "Cinder."
14:13 - These are creative coding
environments.
14:16 - These are libraries - frameworks -
14:19 - for writing code, and your
14:22 - code, though, is really C++.
14:24 - C++, even with all of its advantages in terms
of having low-level access to the machine
14:31 - is a very hard language to get started in
right from the beginning.
14:35 - You have to a have to manage that
memory. There's lots of stuff you have to
14:39 - learn about,
14:40 - like these things called "pointers."
There's --
14:44 - you've got to - using these environments
in addition to writing C++
14:49 - you've got to use
14:49 - on the Mac something called Xcode - the
development environments which are
14:53 - larger and more complex, so - 
I want to use in this
14:56 - video series something that's a bit
simpler that we can
14:59 - get started with
15:00 - a bit more quickly. But these are
terrific environments with a lot of
15:04 - similar qualities to Processing. The
other thing you might have heard of
15:10 - which I think is important to mention
15:11 - is something called max "Max/MSP/Jitter"
15:17 - I'm going to put this over here
somewhere:
15:21 - Max/MSP/Jitter
15:24 - and there's also something called PD
or "Pure Data."
15:28 - these are known as dataflow
15:32 - programming environments, and the interesting
thing about dataflow programming
15:35 - environments is you
15:36 - actually aren't actually writing your code 
as text. you're essentially
15:40 - designing a flow chart for how your
program should run.
15:43 - You're putting a box on the screen and
than giving that box some
15:47 - inputs and then connecting some data to those
inputs and then the box may have an
15:51 - output which goes to another box (and it
looks like an interesting little
15:55 - alien there) - So this is actually really
fantastic and
15:58 - for many people - many people
find
16:01 - this way of programming more intuitive
and easier to do. It's certainly works
16:06 - wonderfully for audio applications because
if you think about how an audio app -
16:10 - if you build audio system physically you
have a bunch of
16:14 - mixers and instruments and cables and
things have input and output
16:17 - go through stuff it eventually make it
to a speaker that comes out. So this idea
16:21 - of writing an audio application with the
dataflow programming environment
16:24 - is a - and you can certainly do graphics
applications and many other things.
16:28 - I would encourage you to look at
Max/MSP and PD. So
16:32 - there is huge world of stuff and you
could spend your life
16:36 - learning every programming language. You could
also spend your life worrying about
16:40 - "OMG which one should I use?" So I'm
gonna say
16:43 - to you right now, "Stop worrying."
If you feel like
16:46 - you don't like the way this video series is going
16:51 - then go to another resource online and
learn a different
16:54 - programming language. But what I will -
What we're going to use is Processing.
16:59 - And I'm going to very briefly now show
you kind of the core
17:02 - basic reason -
17:03 - one of the core reasons why Processing is
gonna work well here
17:08 - for learning to program. And so let me
walk over here
17:12 - and I'm going to switch over to the desktop -
17:15 - Processing is just an application. I've
downloaded it.
17:19 - It is already sitting here on the machine.
Where do you download it? I guess I
17:24 - might as well
17:24 - show you this right now. If you go to
Processing.org
17:26 - you can actually click here to
download Processing. I guess I'll mention that
17:31 - Processing is a non-profit foundation.
17:33 - You can make a donation when you
download, and that donation is tax-deductible
17:36 - but it is available for free. You are not
required by any means to donate and I
17:41 - would imagine maybe when you're just
first trying it out you wanna see if you
17:43 - like it first.
17:44 - But the other thing I should mention
here is all these creative coding
17:48 - environments,
17:49 - Open Frameworks, Cinder, Processing, these
environments
17:53 - live in this rich landscape of "Open Source."
17:56 - So what does this mean for it to be
"Open Source?" It means not only
17:59 - can you get - are you getting this
software these things are
18:05 - available to you for free (although
18:06 - Open Source doesn't have to be free)
[but it also means]
18:11 - that the source code how - these
things are written, right? - these are libraries
18:15 - that are applications - you can actually go and
read the source code, contribute to them,
18:18 - it is all completely open to you and all
this stuff is available in something
18:22 - called GitHub which is a
18:25 - website, essentially, for sharing open source
projects. But i digress.
18:29 - This is where you can get Processing and
download it.
18:31 - Once you have it on your machine
18:33 - you can run the application and you can
see here
18:36 - when you run it you're going to get
this window like this
18:40 - and if I zoom in all the way here we can
see there's this nice little button
18:44 - called "Run."
18:45 - And if I were to actually just run - press
"Run" right there
18:49 - we get this little window and look! 
Here it is!
18:53 - Our very first computer program we've
ever written!
18:56 - There it is running. It opened this window, and
look at the code! It's amazing! It's like
19:01 - "The Emperor's New Code" or whatever. 
There's nothing there.
19:03 - Obviously the next steps were gonna get
to in the future videos - we're
19:09 - still in this sort of introductory place - but
you can just skip right ahead -
19:12 - is, "What do we write there?
What do we write there, and what is it that
19:16 - happens?"
19:17 - and - but - um -
19:18 - but I'll just write one line
of code just to
19:23 - demonstrate this - and this is what -
19:27 - one of the nice things about using Processing
is we were able to just
19:31 - write our code really simply in this
interface, run it, and we get our window
19:36 - and everything just kinda a works really
we can kind of get up and running with
19:40 - that really quickly.
19:42 - Okay so there's so much more to say
about Processing and why we're using it
19:47 - I guess um -
19:51 - but I think this video has gone on
for quite a bit of time. I've kind of rambled through
19:56 - a lot of things - so we're going to -
19:57 - We're going to get to a bit more about
Processing, the reference,
20:01 - how it is that you really learning Java
while you are writing Processing - I think we'll
20:05 - get to that as we
20:06 - as we as we start learning in some of
the future videos.
20:09 - Okay, the next thing I think I'm
actually going to continue this thread
20:13 - by showing you a kind of range of projects
and things that are made
20:17 - with Processing and Computational Media
20:19 - that might help you start to think about
the kinds of projects you might make
20:23 - a while following along
20:26 - these videos

Cleaned transcript:

We're very close now. We're just a few videos away from actually opening up a Processing window and typing in some lines of code, running our code and having our first computer program. But I think before we do that I want to talk about something which is okay let's just say It's Time to Learn Programming, then the big question arrives What programming language should I learn? What's my project? What am I doing? What's the right environment? What's the right language? And this this is a question that's loaded with anxiety and confusion and, "Oh! What if I'm learning the wrong thing?" and "Shouldn't I be really learning this?" and I first I just want to say a general comment first before we to take a programming languages. There is no perfect programming language. There is no perfect programming environment that will do everything you always wanted it to do is perfect and exactly right for the particular project you're making and often the answer to that question is, you know, the answer to the question "what programming language should use?" it's the one that you just sorta feel comfortable with how it looks good kinda like you're happy to get started and the one that you're using right now. Better to be writing code and making something then to be spending all day worrying about trying to find that perfect language so in a sense, one answer is, "Pick something get started." You can learn this language and try this one later and another one later it doesn't really matter. But for us we have to come to a decision and in many ways I'm picking a programming language and environment which is one that I'm comfortable with. It's one that I work on. It's one that I've known for many years. I's not perfect. and so that's what you will be learning. And and hopefully you will find other languages and environments in your life and this will have helped to you to that end. So let's just first though okay so let's think about what are what's the kind of map of programming languages that are out there and what what are the sort of pros and cons advantages and disadvantages using different languages Hello! Okay! So one thing we can look at (I'll provide a link to this) this is a nice little chart called, "The History of Programming Languages," I think it's available from O'Reilly, and we can first at least see like back here in 1954 the invention of Fortran which you can see right here we can start to kind of like scroll around this thing, we can see that there are zillions of languages and they have various relationships and they all have funny names like Oberon AINSI C and Ada and all sorts of other stuff. The other thing I should point out about this nice little graph/chart is that ends in 2004 so a lot has happened by the way the last ten years nine or ten years there's a lot of other languages a lot of other innovations on this chart if you were to continue it would get even bigger and crazier but you know just looking at you realize oh, my goodness, it's totally overwhelming. look how many language there are. We could also kind of go to Wikipedia there's "Comparison of Programming Languages" page and you can scroll down and see, look all these possible languages. There are zillions of them. So I think we can kind of make our own little list, just to kind of you know you've probably heard this would be the moment where I'd say, "Hey, everyone out there, the three of you watching this video, raise your raise your hand and shout out a programming language that you've heard of," and you might say, "Pascal!" (probably none of you has heard of Pascal) but Pascal (Ooh, boy this pen doesn't work) Pascal. There we go. You might say C. You might say Java. You might even say something like, "Oh, what this thing, 'Assembly Language' or 'Machine Language?'" I'll write Assembly Language down here. And you might say, "Oh, what about ActionScript?" And you might even learn something have heard of something probably you haven't, but the first programming one of the first programming languages I learned actually was "Lingo," which was the programming language of Macromedia's Director which I believe still exists? Anyway so we could start making this list, and I kinda started doing this I think I probably put Pascal in the wrong place but what I've one of the things i wanna talk about with this kinda list of programming languages and what you might pick and I'm gonna say say C++ / Objectivec is this idea of low level versus high level and this is kinda lowellevel [corrects spelling error] lowlevel highlevel this is an important concept that comes up in thinking about programming languages, right? So essentially let's say you want to write the lowest level possible code, that you were completely insane person who wanted to just like torture yourself for eternity, you would you would say I'm only going to write my computer program as a sequence zeros and ones, right? Because ultimately so here's mine you know this execute this code it's amazing it's beautiful. Here this is my program, right? (and I guess you can see it because I wrote off the edge of the screen) but let's just say this is your program what am I talking about? Okay, this is like the lowest essentially everything that executes on your computer all data is stored all instructions are stored as a sequence of zeros and ones. But this is unrealistic. How could you possibly really be expected to write software just as a series of 0's and 1's? So there's generally a process where you want to be able to write your code in a higher level way the ultimate like if I'm creating a graphics application, which is what we're going to be doing, a really high level programs might say might be written something like this draw a red square draw a square on the screen that's like medium size and red colored and draw circle that's really big and blue. That's very high level. It really is like English and what happens is there's a compiler that will take that highlevel code and translate it into machine language. So assembly language is kinda want to the lowest level programming languages that people use. When C came around, C was often refered to in this kind of like oxymoron type way a highlevel lowlevel language meaning it's highlevel in that you're writing code that starts to have higherlevel, more Englishlike constructs, but it still allows you the lowlevel access to the computer direct access to the computer's memory lots of stuff that you can do it makes it very very very you can execute very very fast. So anyway that's just kind of an important concept to realize most of the languages that I haven't kind of written up here which I'll kind of like add over here like that you may have heard of like Ruby, JavaScript, Python, and we could keep going here, we could write lot others these are all generally highlevel programming languages. Now there's another kind interesting little component that I think that I'll mention which is this idea of a language that's 'compiled' versus 'interpreted' now in many ways I almost want to stop myself and not talk about this because we don't really these are some details that when we're first learning to program we're gonna put aside. We just want to write the code run it and make stuff happen but it's something to think about as you start getting to this larger world of programming languages. So let's say you're writing a program in C, right? You write out the textbased instructions in your highlevel language. That program gets compiled down into the sort of lowest level program which is like one level below Assembly Language, which is Machine Language the zeros and ones. Then it can be run. This is great; it makes it run it makes run very very very fast but it is is different that some languages that we have now that are interpreted, JavaScript being one of those. A language which is interpreted is actually while the program is running it is reading your code line by line and executing the program. This allows for things like live coding, right? If a program is actually reading the code as it's running you could change the code as it's running and the program would change in real time which cannot happen in a compiled language because you've got to write your code, compile, then run it. So I the reason why mention this is we're using we are going to use Processing (am I recording? Yes?) We're going to use Processing which is, and our code is actually going to be compiled before it's run which is something we'll see as we start to first write our programs. Another topic that I want to bring up is this idea of 'clientside' versus 'serverside' programming. This is an important question because you know you you might have project ideas in your head things that you want to make and one thing might be, "I had this idea for this kinda interactive exhibit about dinosaurs for a science museum." In that sense you might be building a clientside application a desktop application that's gonna run maybe it reads some pixels from a camera so the user can interact with in a draw some dinosaur footprints to the screen or something like that. You might also have an idea for, "Oh, I have this website I want to make where the user enters all this information about personal information about themselves and it gives them back their horoscope." so these are different applications and require a different set of programming languages for them, and one thing that we can see here i mean all this idea of anytime you go to a web page if this is my web browser and you type in, you know, "Google.com" and you search for something you are sending a request to a server in the cloud which it's not really a cloud it's an underground bunker basically with some servers, but you could think of it as a nice cloud floating in the sky where a program a serverside program "a serverside program" executes and returns information back to you so you can see the result in the browser. This is different then, perhaps, there being an animation in the browser that's running that you click on and when you click on it it makes little pretty fireworks. That might be something written in JavaScript that is executing on the client side, this animation that's running locally on your computer and reading your mouse clicks. The server side programming is this thing that happens when you have to request the program runs it says you data back. Perhaps that's written in Python. Now there are lots of different languages. In some languages you can write, you know, in JavaScript you can write clientside programs, and in Javascript you can write serverside programs something called Node.js it's not languagespecific, but conceptually there's a different thing going on here. Are you writing a program that is executing locally on your laptop? You know, here on my prop here there's a program running on this laptop. It is drawing pixels to the screen. That is a clientside program. There's a program running somewhere else on a server that is sending me information back about how excellent my jog was this morning or whatever from the RunKeeper website or whatever but (I guess I just plugged RunKeeper. I like it) That's a serverside program. So this is an important consideration when you're learning programming languages and you're creating applications with them, and this is something you want familiarity with, both clientside and serverside. This video series that I'm doing, while we will refer to and demonstrate some examples that involve serverside programming later, on is really focused on clientside programs. We're going to be writing applications that open a window on your computer screen draw pixels, draw text, draw things to that window, and that you can interact with on your laptop, so were really learning clientside, which I think is an important thing to note. And this brings up kinda where with we're kinda finishing off here so if you want to do stuff for the web, there are a lot of fantastic resources out there for you to learn web programming. JavaScript is a terrific programming language to learn has lots of applications Python is another fantastic language to learn as a beginner, but we're going to use something called Processing, and I'm going to writet "Processing" right here and I'm going to draw up like a weird little arrow there that is pointing back to Java. So what is Processing? Processing (I really should be able to say it) Processing was developed was created in 2001 by Casey Reas and Benjamin Fry while they were students at the MIT Multimedia Lab under John Maeda so what Processing really started as was, "Hey, we need something to make these projects we're making. Let's make something." So Processing is this really nice simple environment. You can download it. It's kind of allinone. You can open it. You can type some code. You can run it. It works. So I'm gonna get to that in a second more about why we're using Processing, but let's just think you've probably heard the term "Creative Coding." The term "Creative Coding" started as a kind of catchall phrase for people making creative applications with code, trying to make Art, trying to make installations, trying to make weird obscure impractical crazy ideas, and you know there's a lot of discussion now, "Is this a good term? Is this a bad term?" One thing I think I heard from Jer Thorp was you could think of it as "creative writing" the process of writing for the process writing code for creative applications. There is also now the term "Poetic Computation," which i think is interesting. But anyway, there are lots of environments and I'll draw a line here you might have heard of something called "Open Frameworks." You might have heard of something called "Cinder." These are creative coding environments. These are libraries frameworks for writing code, and your code, though, is really C++. C++, even with all of its advantages in terms of having lowlevel access to the machine is a very hard language to get started in right from the beginning. You have to a have to manage that memory. There's lots of stuff you have to learn about, like these things called "pointers." There's you've got to using these environments in addition to writing C++ you've got to use on the Mac something called Xcode the development environments which are larger and more complex, so I want to use in this video series something that's a bit simpler that we can get started with a bit more quickly. But these are terrific environments with a lot of similar qualities to Processing. The other thing you might have heard of which I think is important to mention is something called max "Max/MSP/Jitter" I'm going to put this over here somewhere Max/MSP/Jitter and there's also something called PD or "Pure Data." these are known as dataflow programming environments, and the interesting thing about dataflow programming environments is you actually aren't actually writing your code as text. you're essentially designing a flow chart for how your program should run. You're putting a box on the screen and than giving that box some inputs and then connecting some data to those inputs and then the box may have an output which goes to another box (and it looks like an interesting little alien there) So this is actually really fantastic and for many people many people find this way of programming more intuitive and easier to do. It's certainly works wonderfully for audio applications because if you think about how an audio app if you build audio system physically you have a bunch of mixers and instruments and cables and things have input and output go through stuff it eventually make it to a speaker that comes out. So this idea of writing an audio application with the dataflow programming environment is a and you can certainly do graphics applications and many other things. I would encourage you to look at Max/MSP and PD. So there is huge world of stuff and you could spend your life learning every programming language. You could also spend your life worrying about "OMG which one should I use?" So I'm gonna say to you right now, "Stop worrying." If you feel like you don't like the way this video series is going then go to another resource online and learn a different programming language. But what I will What we're going to use is Processing. And I'm going to very briefly now show you kind of the core basic reason one of the core reasons why Processing is gonna work well here for learning to program. And so let me walk over here and I'm going to switch over to the desktop Processing is just an application. I've downloaded it. It is already sitting here on the machine. Where do you download it? I guess I might as well show you this right now. If you go to Processing.org you can actually click here to download Processing. I guess I'll mention that Processing is a nonprofit foundation. You can make a donation when you download, and that donation is taxdeductible but it is available for free. You are not required by any means to donate and I would imagine maybe when you're just first trying it out you wanna see if you like it first. But the other thing I should mention here is all these creative coding environments, Open Frameworks, Cinder, Processing, these environments live in this rich landscape of "Open Source." So what does this mean for it to be "Open Source?" It means not only can you get are you getting this software these things are available to you for free (although Open Source doesn't have to be free) [but it also means] that the source code how these things are written, right? these are libraries that are applications you can actually go and read the source code, contribute to them, it is all completely open to you and all this stuff is available in something called GitHub which is a website, essentially, for sharing open source projects. But i digress. This is where you can get Processing and download it. Once you have it on your machine you can run the application and you can see here when you run it you're going to get this window like this and if I zoom in all the way here we can see there's this nice little button called "Run." And if I were to actually just run press "Run" right there we get this little window and look! Here it is! Our very first computer program we've ever written! There it is running. It opened this window, and look at the code! It's amazing! It's like "The Emperor's New Code" or whatever. There's nothing there. Obviously the next steps were gonna get to in the future videos we're still in this sort of introductory place but you can just skip right ahead is, "What do we write there? What do we write there, and what is it that happens?" and but um but I'll just write one line of code just to demonstrate this and this is what one of the nice things about using Processing is we were able to just write our code really simply in this interface, run it, and we get our window and everything just kinda a works really we can kind of get up and running with that really quickly. Okay so there's so much more to say about Processing and why we're using it I guess um but I think this video has gone on for quite a bit of time. I've kind of rambled through a lot of things so we're going to We're going to get to a bit more about Processing, the reference, how it is that you really learning Java while you are writing Processing I think we'll get to that as we as we as we start learning in some of the future videos. Okay, the next thing I think I'm actually going to continue this thread by showing you a kind of range of projects and things that are made with Processing and Computational Media that might help you start to think about the kinds of projects you might make a while following along these videos
