With timestamps:

00:00 - [TOY TRAIN WHISTLE]
00:00 - Hello, and welcome to
a coding challenge.
00:02 - Today, I'm going to tackle
the gift wrapping challenge.
00:05 - I'm going to make
this code, I'm going
00:06 - to wrap it up as a
nice present, and I'm
00:08 - going to hand it over to you.
00:09 - And hopefully you will make
something beautiful out of it,
00:11 - or you'll learn something,
or all that kind
00:13 - of stuff, that jazz.
00:15 - This is some code that I wrote
a long time ago for an example.
00:18 - And this is a demonstration
of calculating a convex hull.
00:23 - This, if I did it
correctly, is actually
00:25 - using a different algorithm from
gift wrapping called the Graham
00:28 - scam.
00:29 - It's not a scam.
00:30 - It's not a scam.
00:31 - The Graham scan.
00:33 - And there are a
variety of algorithms
00:35 - for computing a convex hull.
00:37 - There's the Chan
algorithm, and more.
00:39 - And they have various
different efficiencies.
00:42 - The gift wrapping algorithm is
probably the least efficient,
00:45 - but it's a good starter one.
00:47 - So let me talk about what
a convex hull is first,
00:50 - and then look at what
the algorithm is,
00:52 - and then we'll go and
write the code for it.
00:54 - And this, I should say,
is an algorithm part
00:56 - of the field of research
called computational geometry.
01:00 - And I would really
like to do a variety
01:02 - of coding challenges around
different computational
01:05 - geometry topics.
01:06 - So if you have an idea for
one, write it in the comments.
01:09 - So the idea of a convex
hull is, first, we
01:13 - need just a random
collection of points.
01:15 - So if we have a
two-dimensional space--
01:18 - and these algorithms
typically generalize
01:20 - to higher dimensions.
01:21 - But you know me, I just like
to be in two dimensions.
01:24 - Here's my random
collection of points.
01:26 - Now, first I need to make the
distinction between convex
01:29 - and concave.
01:30 - So here is a shape that
is distinctly concave,
01:35 - a Pac-Man-like
creature, so to speak.
01:37 - All of these angles
that are made out
01:39 - of the vertices of
the shape, there
01:40 - is one that is greater
than 180 degrees.
01:44 - So a convex shape--
01:46 - I always get this confused, but
now that I know the term convex
01:49 - hull, I won't forget it again.
01:51 - If I wanted to turn this
into a convex shape,
01:54 - I would eliminate this point
and connect these two points.
01:58 - And now I have a convex shape.
02:01 - And a convex hull is
a polygon that you
02:05 - construct that is convex and
contains all of the points.
02:10 - So I can eyeball this, and I can
say, OK, I'm going to go here,
02:13 - then here, then here, then here.
02:15 - Now, would I go in here?
02:17 - No, I'm going to go down
to here, here, here.
02:19 - Am I going to go here?
02:20 - Nope, I'm going to go here.
02:21 - So this is essentially
the gift wrap--
02:23 - I just sort of did my own
performance, with my brain,
02:29 - of the gift wrapping algorithm.
02:31 - I'm eyeballing it, you know,
I think I got it right.
02:33 - But there's a proper way we
can actually calculate it.
02:36 - And the way that you do that is
by first starting with a point
02:41 - that we know is exterior
to what will be--
02:44 - that's on the convex hull.
02:45 - The way to start with
the point that we
02:47 - know that will be
on the convex hull,
02:48 - the vertex of the
convex hull, is
02:50 - by picking out the
leftmost or the rightmost
02:52 - or the topmost,
or the bottommost.
02:53 - So a convention is just
to pick the leftmost.
02:56 - So I can see, this is
the leftmost point.
02:58 - Now what I want to do
is check this point
03:01 - against every other point.
03:03 - And whichever one is
furthest to the left--
03:06 - whichever one is furthest to
the left is the next point.
03:09 - So these are going to
be in some random order,
03:11 - I'm going to check
them in some order,
03:13 - and I'm eventually going to
determine that, ah, OK, which
03:16 - vector is most to the left?
03:18 - It's this one.
03:19 - So now I'm going to go here.
03:20 - And now I'm here, and I
want to do the same thing.
03:23 - But now I want to pick
which one is left of this,
03:27 - relative to this point.
03:28 - And that's going to
be this one over here.
03:29 - We can sort of see--
03:30 - like if I draw a line
out to all of the points,
03:33 - if I sort them all
along a radial path,
03:36 - the one that's all the way
to the left will be this one.
03:39 - And then I just do
that over and over
03:41 - and over again, until
eventually I get over here.
03:43 - And I find that the one
furthest to the left
03:45 - is the one that I started with.
03:46 - And that's going to
be my convex hull.
03:50 - Coming back over
to the computer,
03:51 - on the Wikipedia page, we
can see a nice animation
03:54 - of this playing out.
03:56 - And this, by the way, is
one of the reasons why
03:59 - I like to write the code
for these algorithms
04:03 - without a library.
04:04 - So ultimately, if, when I'm
working on a larger project
04:07 - and I need to compute a
complex hull for some reason,
04:10 - having a nice
efficient, maintained
04:13 - computational geometry
library is most certainly
04:16 - the way to go.
04:16 - And maybe I'll try to find
some examples of that.
04:18 - There's plenty in
JavaScript that I'll link to
04:20 - in this video's description.
04:22 - But most of those libraries will
just compute all of the points
04:26 - all at once and hand
them back to you.
04:28 - And if you want to create some
type of interactive explanation
04:31 - of the algorithm, some
kind of animation,
04:34 - whether it's for
artistic purposes
04:35 - or educational
purposes, you're going
04:37 - to have to write the
algorithm itself.
04:38 - And it actually is harder
to write the algorithm
04:41 - and animate it.
04:42 - So I'm going to try to do
that as part of this coding
04:44 - challenge.
04:45 - Rather than write the algorithm
all at once so that is just
04:47 - calculates it and
shows the end result,
04:49 - I want to be able
to see something
04:52 - like this animation playing out.
04:53 - That will make this
take quite a bit longer.
04:55 - It will be more to figure out.
04:56 - But I think it'll be more
satisfying in the end.
04:58 - I also should
mention that this 2D
05:00 - case is known as the
Jarvis march, invented
05:03 - by R. A. Jarvis.
05:05 - Then the time complexity
is O [? nh, ?]
05:08 - n being the number
of points, and h
05:10 - being the number of points
around the convex hull.
05:12 - And the reason it's that
is because, for every point
05:15 - around the convex hull, I have
to check all the other points.
05:19 - So that's the number of points
around the hull times all
05:21 - of the points.
05:22 - It's a little bit better than
o n-squared, but not by much.
05:25 - And again, there are plenty of
other more efficient algorithms
05:28 - for doing it, this is just the
one that I'm starting with.
05:30 - [BELL DINGING]
05:30 - All right, let's
write some code.
05:32 - So I'm just starting with
some boilerplate code.
05:34 - I've got an empty array.
05:35 - I'm putting p5 vectors in it.
05:37 - I'm using a p5 vector
object to store a point.
05:40 - And then I'm just
drawing all the points
05:41 - on the canvas itself.
05:43 - So the first step that
I want to do is find--
05:45 - you could say I
could run this over
05:46 - and I'm going to get a random
collection of 10 points.
05:48 - And eventually I'll do this with
a much higher number of points,
05:50 - but let's start with just 10.
05:51 - So the first thing I want to
do is find the leftmost point.
05:54 - And an easy way
for me to do that
05:55 - would just be to
sort the points.
05:57 - So I can actually go here,
and I could say points.sort.
06:01 - And the JavaScript sort function
takes a callback function,
06:05 - which is a comparison function
which compares two elements.
06:08 - And so I'm going
to say a, comma, b.
06:12 - I'm going to use
the arrow syntax.
06:14 - If you haven't seen the
arrow syntax before,
06:16 - I'll refer you to
my video on that.
06:17 - I'll say a.x minus b.x.
06:19 - So what this is doing is it's
returning a positive number
06:23 - any time a is to the right of b,
and a negative number anytime a
06:28 - is to the left of b.
06:29 - And that should
make it such that I
06:32 - can create a global variable.
06:34 - I'll call it left, for
like the leftmost point.
06:37 - Left equals points index .
06:41 - Zero and now if I were
to say, stroke 0, 255, 0,
06:47 - and say point p.x, p.y, I should
see that the left point-- oh,
06:52 - I'm sorry, left.x and left.y--
06:56 - I should see that the
left point is green.
06:58 - So there you can see that.
06:59 - And every time I run it,
whichever point is most
07:01 - to the left is
going to be green.
07:03 - Great.
07:03 - [CLAPPING HANDS]
07:05 - Now I need to find the next
point on the convex hull.
07:09 - And remember, I want
to animate this.
07:12 - So really if I were to just
go back to the Wikipedia page
07:17 - and look at the
pseudocode, you're
07:19 - going to see everything happens
in just a set of nested loops.
07:22 - I don't want any loops to
happen because I want--
07:24 - every time through
draw, I want to--
07:26 - the p5 draw loop, I want
to draw the next stage.
07:30 - So I'm going to need
another array, which
07:33 - will be the points that
I'm placing along the hull.
07:36 - I want to say a left
can be kind of--
07:40 - I think I want the original,
left like the leftmost.
07:43 - I'll call this leftmost.
07:44 - And then I'm going to call this
current hull, current vertex,
07:49 - like that's the current
vertex that I'm checking with.
07:53 - And then I want to say,
let, and then current point.
07:58 - So vertex, I'm going to use
that term, when it's basically
08:01 - a vertex along the hull.
08:02 - And point is the current
point that I'm checking
08:05 - to see if it's the next vertex.
08:07 - So maybe I also
need next vertex.
08:11 - So I think these
are what I need.
08:13 - And so leftmost is this.
08:18 - And that's also
the current vertex
08:25 - is going to start
as the leftmost.
08:27 - And then, actually, the current
point is really an index.
08:30 - So let me call that, index.
08:33 - And this is next vertex.
08:35 - And index it's
going to start at 0.
08:38 - And this is leftmost.
08:42 - We can make the leftmost
point a little bigger.
08:44 - Let's also do current
vertex as blue.
08:53 - So we don't see the
green one anymore
08:55 - because the current vertex-- and
I should make these brighter.
08:58 - So let's just do that.
09:00 - The current vertex is now being
drawn over the leftmost vertex.
09:04 - So I'm going to make a guess
that the next vertex is just
09:08 - points index 1.
09:12 - I'm going to make
a guess when I'm
09:14 - starting that the next vertex
is whatever it happens to be
09:19 - the next point in the array.
09:20 - It's could be by coincidence,
but it's probably not
09:23 - going to be.
09:24 - And then actually the one that
I want to check is, then, at 2.
09:29 - So the leftmost point is 0.
09:31 - The one that I'm
guessing is going
09:33 - to be the next point is at 1.
09:35 - And then I got to start
comparing everything at 2.
09:39 - So just for the sake
of argument here,
09:44 - I want to draw a line from
current vertex to next vertex.
10:00 - And let's say stroke,
255, stroke weight, 2.
10:10 - So we can see-- look at that.
10:12 - Oh, no, because they're sorted.
10:14 - So of I actually get
lucky a lot of the time,
10:16 - because they're sorted.
10:18 - But you can see, in
this case, that's
10:19 - not-- it's really got to pick,
probably, this one or that one.
10:22 - So that's where it's starting.
10:24 - Now what I need to
do is I also want
10:26 - to draw a line with the
one that I'm checking.
10:28 - So I'm going to say
checking is points index.
10:36 - Then I also want to draw a line
to the one that I'm checking.
10:43 - So we can see those are
the two that I'm comparing.
10:46 - So these are the two
that I'm comparing.
10:48 - And let's make this stroke--
10:50 - so this one's going to be green.
10:54 - And the one that I'm
checking will just be white.
10:58 - So this is what's
happening right now.
11:00 - I need to compare these two.
11:02 - I need to figure out
which one is to the left.
11:05 - And by to the left,
I mean basically
11:07 - like counterclockwise rotation.
11:09 - And guess what, there's a really
nice way that I can do that.
11:13 - And the way that I could do
that is with the cross product.
11:17 - The cross product is a
particular vector operation
11:21 - that you can apply
on a 2D vector--
11:23 - two vectors that are
in the same plane.
11:26 - And it will return to you a
vector pointing perpendicularly
11:30 - in the third dimension, away.
11:32 - And so what's interesting
about this is--
11:35 - let me let me show
you what I mean.
11:36 - And I can never
remember which is which,
11:38 - but it doesn't really
matter because we just
11:40 - need to know that
it's one or the other.
11:42 - If this is vector a
and this is vector b,
11:47 - the cross product
of these two vectors
11:49 - will give me a vector
pointing out this way.
11:52 - This would be in like a
left-handed system, I guess,
11:55 - because that's my left hand.
11:56 - No no no, left-handed
would point the other way,
11:58 - right handed, I'm pointing out.
12:00 - I think that's how you do it.
12:02 - The point is, it's pointing out.
12:03 - But if I were to say, this one
is b so I'm doing a cross b,
12:09 - and this one is
a, then I'm going
12:11 - to get the cross product
pointing in the other way.
12:14 - So I just need to test, is the
z-value of a cross product b,
12:21 - is it greater than
0 or less than 0?
12:23 - If, by the way, they
were colinear or along
12:28 - the same path, you'll get 0.
12:30 - And we're just going to
assume, for this case,
12:32 - that when I'm picking
random points, none of them
12:34 - are going to be colinear.
12:35 - It will probably sort
of work out anyway.
12:36 - But so if b is to the left
of a if z is less than 0,
12:41 - it's to the right
of a if z is greater
12:44 - than 0-- or the other way
around, but I'll just test it.
12:47 - And it's flipped, anyway, in
a computer graphics system,
12:50 - so it'll work itself out.
12:51 - Let's go try that.
12:52 - So let's write
the code for that.
12:54 - So what I need is I
need those two vectors.
12:56 - So a is a vector that points--
so I can use the subtraction
12:59 - function, because I can
point from what is currently
13:05 - the next vertex to
the current vertex.
13:07 - That will be vector a.
13:08 - And then B will be
pointing from what I'm
13:14 - checking to the current vertex.
13:19 - And then the cross
product is a.cross b.
13:25 - So I can implement the
math for the cross product,
13:28 - but it's actually just there
in the p5 library for me.
13:31 - And then I just want to say,
if cross is greater than 0,
13:35 - then probably something like--
13:38 - So let me not do
anything right now.
13:40 - Let's just see.
13:41 - Let's just console.log
the cross product.
13:43 - So let's see.
13:44 - We got-- oh, cross.z,
the z-component.
13:48 - We got a negative-- oh, come
on, it's becoming more obvious.
13:51 - All right, so we got
a negative number.
13:53 - So the one that I'm
checking is white.
13:56 - The one that it currently
thinks is green.
14:01 - So is that right?
14:03 - The current one is green.
14:04 - So if it's less than 0,
then that's to the left.
14:09 - So if cross.z is less
than zero, then nextVertex
14:20 - should actually be the
one that I'm checking.
14:23 - And then I just want to say
index equals index plus 1.
14:29 - There we go.
14:30 - So you can see, as
it goes through,
14:33 - it's always going to
find the correct one.
14:35 - It's checking them all.
14:36 - Let's make a lot of
points so it takes longer.
14:44 - Ooh, that was weird.
14:45 - Why did that mess up?
14:48 - It found it, like, instantly,
but it's checking them all.
14:53 - Yeah, it's going to find it
pretty close because they're
14:55 - sorted.
14:58 - But I think it's doing
it correctly now.
15:00 - Something that I want to
add that I think will just
15:02 - make this a little
visually easier to follow
15:04 - is, let me make a little
variable called buffer.
15:07 - And I'm going to say, pick
a point between buffer
15:14 - and width minus buffer, and
the height also between buffer
15:21 - and height minus buffer.
15:26 - And let's make that
buffer even bigger.
15:30 - So now the points won't get
picked super close to the edge.
15:33 - So clearly I need
an exit condition.
15:35 - So I'm going to
say, if index equals
15:38 - points.length, that means I've
gotten to the end of the array.
15:40 - Let me at least
say, no loop here.
15:42 - So I'm going to just
stop it from animating
15:45 - once it gets to the end.
15:47 - And let me just go back
to many fewer points.
15:51 - I'll just go back to 20.
15:52 - We'll do that pretty quickly.
15:55 - And so what should
happen is hull should
15:59 - get the next vertex.
16:03 - Did I put the
current vertex into--
16:08 - so hull should get
the current vertex.
16:14 - So now there are two
points in the hull.
16:18 - The current vertex
should equal next vertex.
16:23 - And then I need to reset
index back to something.
16:27 - So let's also now add something
where I draw the hull.
16:32 - So I'm going to say
beginShape, stroke--
16:39 - let's have the hull be blue.
16:44 - beginShape-- I'm going
to draw a let p of hull.
16:49 - And I'm going to draw all
the hull points and shape.
16:54 - And I'm not going to say
close, but I am going
16:57 - to give it a really light fill.
16:59 - So I'm going to say fill,
also have it be blue,
17:02 - but with a lot of alpha.
17:04 - Then I need to add vertex.
17:06 - And I don't think I'm
going to see the hull yet.
17:08 - Because I've only drawn
two points so far,
17:11 - and I've stopped the
loop from looping.
17:12 - So let's see what happens.
17:13 - What if I just reset index back
to zero and turn off no loop?
17:21 - OK, it got stuck.
17:24 - So I don't want to-- oh, first
of all, that's two equals.
17:27 - That should be equals.
17:29 - Oh, interesting--
so even though you
17:31 - see that it's doing it
over and over again,
17:32 - it's stuck just picking the
same vertex over and over again
17:35 - because that one is one
of the ones I'm checking.
17:38 - So one way I could approach
it is remove that one.
17:42 - So the easiest way to do
that would be with splice.
17:45 - So I also would
want to pick the--
17:49 - I'm going to say,
the next vertex,
17:51 - I also should keep track
of that next index.
17:53 - [? Let me ?] just set
that equal to negative 1
17:55 - as an initial value.
17:57 - And then when I find
it, I want next index
18:01 - to be that index value.
18:04 - And then I can say,
points.splice nextIndex,
18:11 - and just take that
[? 1 ?] value out.
18:13 - Now I'm still stuck.
18:15 - So the reason why
I'm still stuck
18:17 - is because nextVertex that
it's comparing everything to
18:20 - is still that same one
that it got before.
18:23 - So what I should do is
just reset nextVertex
18:25 - to something else.
18:27 - I'll just put it back
to be that leftmost one.
18:30 - There we go.
18:31 - So now you can see it's working.
18:34 - Now it's stuck when
it gets to the end.
18:36 - But guess what?
18:37 - The reason why is--
18:39 - I know when I'm done, right?
18:41 - I am done if it actually
picks nextVertex
18:47 - as the same as the leftmost.
18:50 - So when it finds
that one, then I
18:51 - can say console.log
done, noLoop,
18:56 - and then, otherwise, do
all of this other stuff
19:00 - that I'm doing.
19:02 - So let's see how this goes.
19:06 - (SINGING) Voila.
19:07 - So the chat actually is pointing
out to me, and rightfully so,
19:10 - that this splicing-out
of the one that I saved
19:14 - is problematic because I've
corrupted the data itself.
19:18 - I don't have that original
array of points anymore,
19:21 - and the context that I
might be doing this in,
19:23 - that might actually
be important.
19:24 - So I could keep that
in a separate array,
19:25 - I could add it back in.
19:26 - But actually it turns out--
and I've just discovered this
19:29 - through some debugging-- that
I don't even need to delete it.
19:31 - The problem was really the
fact that nextVertex was not
19:36 - reset back to the leftmost.
19:38 - So it's actually going to work
just fine every single time
19:43 - without splicing that out, as
long as I reset the next vertex
19:47 - back to, like, leftmost, so that
it sort of skips getting stuck.
19:51 - So let's just make sure this--
let's watch this happen now
19:53 - with like 200 points.
19:55 - And I will speed
this up for you.
19:56 - [ISLAND MUSIC PLAYING]
20:06 - [BELL DINGING]
20:07 - OK, we can see that it's
done, and it looks correct.
20:10 - I'm pretty sure I
did this correctly,
20:11 - because it seems to be working.
20:13 - Of course, this
is less efficient
20:15 - because I'm checking
extra points
20:17 - that I don't need to check
because they're already
20:19 - part of the convex hull array.
20:22 - So I could add
something to skip those.
20:24 - But this isn't even the
most efficient algorithm
20:26 - in the first place.
20:27 - But I just want to
get this idea to work.
20:29 - So you could see that it doesn't
actually connect at the end
20:32 - because I don't have
close as one of the--
20:38 - in endShape.
20:38 - So I could add that in.
20:39 - Let me just put that in for you.
20:41 - You'll see what this
does differently.
20:43 - [JAZZ MUSIC PLAYING]
20:47 - All right, so you can
see what it's doing now.
20:50 - It is always closing the
shape with whatever the latest
20:53 - vertex is.
20:53 - But really, while I have
implemented this and gotten
20:56 - this working, I have
not picked nice colors
21:01 - or been really thoughtful
about the stroke weight,
21:03 - or how-- this takes a
very long time to animate,
21:05 - so it's nice that
I'm kind of animating
21:07 - every single possibility.
21:08 - But I think you could
probably make something pretty
21:11 - interesting out of this by
changing the way you draw it,
21:13 - or thinking about how you
might make this interactive,
21:15 - or maybe the user
can add points.
21:18 - There's a lot of possibilities.
21:19 - But this will be a nice
building block, a foundation
21:21 - to hopefully do more
computational geometry coding
21:24 - challenges.
21:25 - In particular,
eventually, I want
21:26 - to build a triangulation
around all these points,
21:29 - and then figure out how to make
a Delaunay triangulation, which
21:31 - has to do with a way of
having all the triangles--
21:34 - the circle that fits
any given triangle
21:36 - doesn't include
any other points.
21:38 - It's known as a circumcircle.
21:39 - So I think I will come back
and do a coding challenge just
21:42 - to do the circle that
fits any given triangle.
21:44 - It's a pretty quick thing
that I can show you.
21:47 - But there's a lot more
to come with this.
21:48 - Make your own version of
this, share it with me,
21:50 - go to thecodingtrain.com,
to the page with this coding
21:53 - challenge, and there's
instructions there
21:55 - of how to share your
version of this.
21:57 - Maybe you could tie this
to sound or something
22:00 - else that I can't even
possibly imagine now.
22:02 - I look forward to
seeing what you make.
22:04 - Oh, also, you might
want to investigate
22:06 - one of the other
algorithms, in particularly
22:08 - Graham scan algorithm.
22:09 - Maybe I'll come back
and actually just do
22:11 - that as a video also.
22:12 - But if you make a
version of that,
22:14 - please submit that as well.
22:15 - OK, thanks for watching.
22:16 - See you soon.
22:17 - [TOY TRAIN WHISTLE]
22:17 - [DANCE MUSIC PLAYING]
22:25 - [BELL DINGING]

Cleaned transcript:

[TOY TRAIN WHISTLE] Hello, and welcome to a coding challenge. Today, I'm going to tackle the gift wrapping challenge. I'm going to make this code, I'm going to wrap it up as a nice present, and I'm going to hand it over to you. And hopefully you will make something beautiful out of it, or you'll learn something, or all that kind of stuff, that jazz. This is some code that I wrote a long time ago for an example. And this is a demonstration of calculating a convex hull. This, if I did it correctly, is actually using a different algorithm from gift wrapping called the Graham scam. It's not a scam. It's not a scam. The Graham scan. And there are a variety of algorithms for computing a convex hull. There's the Chan algorithm, and more. And they have various different efficiencies. The gift wrapping algorithm is probably the least efficient, but it's a good starter one. So let me talk about what a convex hull is first, and then look at what the algorithm is, and then we'll go and write the code for it. And this, I should say, is an algorithm part of the field of research called computational geometry. And I would really like to do a variety of coding challenges around different computational geometry topics. So if you have an idea for one, write it in the comments. So the idea of a convex hull is, first, we need just a random collection of points. So if we have a twodimensional space and these algorithms typically generalize to higher dimensions. But you know me, I just like to be in two dimensions. Here's my random collection of points. Now, first I need to make the distinction between convex and concave. So here is a shape that is distinctly concave, a PacManlike creature, so to speak. All of these angles that are made out of the vertices of the shape, there is one that is greater than 180 degrees. So a convex shape I always get this confused, but now that I know the term convex hull, I won't forget it again. If I wanted to turn this into a convex shape, I would eliminate this point and connect these two points. And now I have a convex shape. And a convex hull is a polygon that you construct that is convex and contains all of the points. So I can eyeball this, and I can say, OK, I'm going to go here, then here, then here, then here. Now, would I go in here? No, I'm going to go down to here, here, here. Am I going to go here? Nope, I'm going to go here. So this is essentially the gift wrap I just sort of did my own performance, with my brain, of the gift wrapping algorithm. I'm eyeballing it, you know, I think I got it right. But there's a proper way we can actually calculate it. And the way that you do that is by first starting with a point that we know is exterior to what will be that's on the convex hull. The way to start with the point that we know that will be on the convex hull, the vertex of the convex hull, is by picking out the leftmost or the rightmost or the topmost, or the bottommost. So a convention is just to pick the leftmost. So I can see, this is the leftmost point. Now what I want to do is check this point against every other point. And whichever one is furthest to the left whichever one is furthest to the left is the next point. So these are going to be in some random order, I'm going to check them in some order, and I'm eventually going to determine that, ah, OK, which vector is most to the left? It's this one. So now I'm going to go here. And now I'm here, and I want to do the same thing. But now I want to pick which one is left of this, relative to this point. And that's going to be this one over here. We can sort of see like if I draw a line out to all of the points, if I sort them all along a radial path, the one that's all the way to the left will be this one. And then I just do that over and over and over again, until eventually I get over here. And I find that the one furthest to the left is the one that I started with. And that's going to be my convex hull. Coming back over to the computer, on the Wikipedia page, we can see a nice animation of this playing out. And this, by the way, is one of the reasons why I like to write the code for these algorithms without a library. So ultimately, if, when I'm working on a larger project and I need to compute a complex hull for some reason, having a nice efficient, maintained computational geometry library is most certainly the way to go. And maybe I'll try to find some examples of that. There's plenty in JavaScript that I'll link to in this video's description. But most of those libraries will just compute all of the points all at once and hand them back to you. And if you want to create some type of interactive explanation of the algorithm, some kind of animation, whether it's for artistic purposes or educational purposes, you're going to have to write the algorithm itself. And it actually is harder to write the algorithm and animate it. So I'm going to try to do that as part of this coding challenge. Rather than write the algorithm all at once so that is just calculates it and shows the end result, I want to be able to see something like this animation playing out. That will make this take quite a bit longer. It will be more to figure out. But I think it'll be more satisfying in the end. I also should mention that this 2D case is known as the Jarvis march, invented by R. A. Jarvis. Then the time complexity is O [? nh, ?] n being the number of points, and h being the number of points around the convex hull. And the reason it's that is because, for every point around the convex hull, I have to check all the other points. So that's the number of points around the hull times all of the points. It's a little bit better than o nsquared, but not by much. And again, there are plenty of other more efficient algorithms for doing it, this is just the one that I'm starting with. [BELL DINGING] All right, let's write some code. So I'm just starting with some boilerplate code. I've got an empty array. I'm putting p5 vectors in it. I'm using a p5 vector object to store a point. And then I'm just drawing all the points on the canvas itself. So the first step that I want to do is find you could say I could run this over and I'm going to get a random collection of 10 points. And eventually I'll do this with a much higher number of points, but let's start with just 10. So the first thing I want to do is find the leftmost point. And an easy way for me to do that would just be to sort the points. So I can actually go here, and I could say points.sort. And the JavaScript sort function takes a callback function, which is a comparison function which compares two elements. And so I'm going to say a, comma, b. I'm going to use the arrow syntax. If you haven't seen the arrow syntax before, I'll refer you to my video on that. I'll say a.x minus b.x. So what this is doing is it's returning a positive number any time a is to the right of b, and a negative number anytime a is to the left of b. And that should make it such that I can create a global variable. I'll call it left, for like the leftmost point. Left equals points index . Zero and now if I were to say, stroke 0, 255, 0, and say point p.x, p.y, I should see that the left point oh, I'm sorry, left.x and left.y I should see that the left point is green. So there you can see that. And every time I run it, whichever point is most to the left is going to be green. Great. [CLAPPING HANDS] Now I need to find the next point on the convex hull. And remember, I want to animate this. So really if I were to just go back to the Wikipedia page and look at the pseudocode, you're going to see everything happens in just a set of nested loops. I don't want any loops to happen because I want every time through draw, I want to the p5 draw loop, I want to draw the next stage. So I'm going to need another array, which will be the points that I'm placing along the hull. I want to say a left can be kind of I think I want the original, left like the leftmost. I'll call this leftmost. And then I'm going to call this current hull, current vertex, like that's the current vertex that I'm checking with. And then I want to say, let, and then current point. So vertex, I'm going to use that term, when it's basically a vertex along the hull. And point is the current point that I'm checking to see if it's the next vertex. So maybe I also need next vertex. So I think these are what I need. And so leftmost is this. And that's also the current vertex is going to start as the leftmost. And then, actually, the current point is really an index. So let me call that, index. And this is next vertex. And index it's going to start at 0. And this is leftmost. We can make the leftmost point a little bigger. Let's also do current vertex as blue. So we don't see the green one anymore because the current vertex and I should make these brighter. So let's just do that. The current vertex is now being drawn over the leftmost vertex. So I'm going to make a guess that the next vertex is just points index 1. I'm going to make a guess when I'm starting that the next vertex is whatever it happens to be the next point in the array. It's could be by coincidence, but it's probably not going to be. And then actually the one that I want to check is, then, at 2. So the leftmost point is 0. The one that I'm guessing is going to be the next point is at 1. And then I got to start comparing everything at 2. So just for the sake of argument here, I want to draw a line from current vertex to next vertex. And let's say stroke, 255, stroke weight, 2. So we can see look at that. Oh, no, because they're sorted. So of I actually get lucky a lot of the time, because they're sorted. But you can see, in this case, that's not it's really got to pick, probably, this one or that one. So that's where it's starting. Now what I need to do is I also want to draw a line with the one that I'm checking. So I'm going to say checking is points index. Then I also want to draw a line to the one that I'm checking. So we can see those are the two that I'm comparing. So these are the two that I'm comparing. And let's make this stroke so this one's going to be green. And the one that I'm checking will just be white. So this is what's happening right now. I need to compare these two. I need to figure out which one is to the left. And by to the left, I mean basically like counterclockwise rotation. And guess what, there's a really nice way that I can do that. And the way that I could do that is with the cross product. The cross product is a particular vector operation that you can apply on a 2D vector two vectors that are in the same plane. And it will return to you a vector pointing perpendicularly in the third dimension, away. And so what's interesting about this is let me let me show you what I mean. And I can never remember which is which, but it doesn't really matter because we just need to know that it's one or the other. If this is vector a and this is vector b, the cross product of these two vectors will give me a vector pointing out this way. This would be in like a lefthanded system, I guess, because that's my left hand. No no no, lefthanded would point the other way, right handed, I'm pointing out. I think that's how you do it. The point is, it's pointing out. But if I were to say, this one is b so I'm doing a cross b, and this one is a, then I'm going to get the cross product pointing in the other way. So I just need to test, is the zvalue of a cross product b, is it greater than 0 or less than 0? If, by the way, they were colinear or along the same path, you'll get 0. And we're just going to assume, for this case, that when I'm picking random points, none of them are going to be colinear. It will probably sort of work out anyway. But so if b is to the left of a if z is less than 0, it's to the right of a if z is greater than 0 or the other way around, but I'll just test it. And it's flipped, anyway, in a computer graphics system, so it'll work itself out. Let's go try that. So let's write the code for that. So what I need is I need those two vectors. So a is a vector that points so I can use the subtraction function, because I can point from what is currently the next vertex to the current vertex. That will be vector a. And then B will be pointing from what I'm checking to the current vertex. And then the cross product is a.cross b. So I can implement the math for the cross product, but it's actually just there in the p5 library for me. And then I just want to say, if cross is greater than 0, then probably something like So let me not do anything right now. Let's just see. Let's just console.log the cross product. So let's see. We got oh, cross.z, the zcomponent. We got a negative oh, come on, it's becoming more obvious. All right, so we got a negative number. So the one that I'm checking is white. The one that it currently thinks is green. So is that right? The current one is green. So if it's less than 0, then that's to the left. So if cross.z is less than zero, then nextVertex should actually be the one that I'm checking. And then I just want to say index equals index plus 1. There we go. So you can see, as it goes through, it's always going to find the correct one. It's checking them all. Let's make a lot of points so it takes longer. Ooh, that was weird. Why did that mess up? It found it, like, instantly, but it's checking them all. Yeah, it's going to find it pretty close because they're sorted. But I think it's doing it correctly now. Something that I want to add that I think will just make this a little visually easier to follow is, let me make a little variable called buffer. And I'm going to say, pick a point between buffer and width minus buffer, and the height also between buffer and height minus buffer. And let's make that buffer even bigger. So now the points won't get picked super close to the edge. So clearly I need an exit condition. So I'm going to say, if index equals points.length, that means I've gotten to the end of the array. Let me at least say, no loop here. So I'm going to just stop it from animating once it gets to the end. And let me just go back to many fewer points. I'll just go back to 20. We'll do that pretty quickly. And so what should happen is hull should get the next vertex. Did I put the current vertex into so hull should get the current vertex. So now there are two points in the hull. The current vertex should equal next vertex. And then I need to reset index back to something. So let's also now add something where I draw the hull. So I'm going to say beginShape, stroke let's have the hull be blue. beginShape I'm going to draw a let p of hull. And I'm going to draw all the hull points and shape. And I'm not going to say close, but I am going to give it a really light fill. So I'm going to say fill, also have it be blue, but with a lot of alpha. Then I need to add vertex. And I don't think I'm going to see the hull yet. Because I've only drawn two points so far, and I've stopped the loop from looping. So let's see what happens. What if I just reset index back to zero and turn off no loop? OK, it got stuck. So I don't want to oh, first of all, that's two equals. That should be equals. Oh, interesting so even though you see that it's doing it over and over again, it's stuck just picking the same vertex over and over again because that one is one of the ones I'm checking. So one way I could approach it is remove that one. So the easiest way to do that would be with splice. So I also would want to pick the I'm going to say, the next vertex, I also should keep track of that next index. [? Let me ?] just set that equal to negative 1 as an initial value. And then when I find it, I want next index to be that index value. And then I can say, points.splice nextIndex, and just take that [? 1 ?] value out. Now I'm still stuck. So the reason why I'm still stuck is because nextVertex that it's comparing everything to is still that same one that it got before. So what I should do is just reset nextVertex to something else. I'll just put it back to be that leftmost one. There we go. So now you can see it's working. Now it's stuck when it gets to the end. But guess what? The reason why is I know when I'm done, right? I am done if it actually picks nextVertex as the same as the leftmost. So when it finds that one, then I can say console.log done, noLoop, and then, otherwise, do all of this other stuff that I'm doing. So let's see how this goes. (SINGING) Voila. So the chat actually is pointing out to me, and rightfully so, that this splicingout of the one that I saved is problematic because I've corrupted the data itself. I don't have that original array of points anymore, and the context that I might be doing this in, that might actually be important. So I could keep that in a separate array, I could add it back in. But actually it turns out and I've just discovered this through some debugging that I don't even need to delete it. The problem was really the fact that nextVertex was not reset back to the leftmost. So it's actually going to work just fine every single time without splicing that out, as long as I reset the next vertex back to, like, leftmost, so that it sort of skips getting stuck. So let's just make sure this let's watch this happen now with like 200 points. And I will speed this up for you. [ISLAND MUSIC PLAYING] [BELL DINGING] OK, we can see that it's done, and it looks correct. I'm pretty sure I did this correctly, because it seems to be working. Of course, this is less efficient because I'm checking extra points that I don't need to check because they're already part of the convex hull array. So I could add something to skip those. But this isn't even the most efficient algorithm in the first place. But I just want to get this idea to work. So you could see that it doesn't actually connect at the end because I don't have close as one of the in endShape. So I could add that in. Let me just put that in for you. You'll see what this does differently. [JAZZ MUSIC PLAYING] All right, so you can see what it's doing now. It is always closing the shape with whatever the latest vertex is. But really, while I have implemented this and gotten this working, I have not picked nice colors or been really thoughtful about the stroke weight, or how this takes a very long time to animate, so it's nice that I'm kind of animating every single possibility. But I think you could probably make something pretty interesting out of this by changing the way you draw it, or thinking about how you might make this interactive, or maybe the user can add points. There's a lot of possibilities. But this will be a nice building block, a foundation to hopefully do more computational geometry coding challenges. In particular, eventually, I want to build a triangulation around all these points, and then figure out how to make a Delaunay triangulation, which has to do with a way of having all the triangles the circle that fits any given triangle doesn't include any other points. It's known as a circumcircle. So I think I will come back and do a coding challenge just to do the circle that fits any given triangle. It's a pretty quick thing that I can show you. But there's a lot more to come with this. Make your own version of this, share it with me, go to thecodingtrain.com, to the page with this coding challenge, and there's instructions there of how to share your version of this. Maybe you could tie this to sound or something else that I can't even possibly imagine now. I look forward to seeing what you make. Oh, also, you might want to investigate one of the other algorithms, in particularly Graham scan algorithm. Maybe I'll come back and actually just do that as a video also. But if you make a version of that, please submit that as well. OK, thanks for watching. See you soon. [TOY TRAIN WHISTLE] [DANCE MUSIC PLAYING] [BELL DINGING]
