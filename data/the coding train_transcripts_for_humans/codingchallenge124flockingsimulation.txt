With timestamps:

00:00 - (train whistle blows)
00:01 - - Hello and welcome to a coding challenge.
00:03 - In this coding challenge,
00:05 - I should probably go eat
lunch but I'm going to just
00:06 - try this coding challenge.
00:08 - I am going to attempt to program this.
00:10 - This is a flocking simulation.
00:11 - What you're seeing right now is an example
00:13 - that I made many years ago
00:15 - of a flocking simulation, a Boids system
00:18 - running and processing.
00:20 - I'm going to try to make
exactly this or close to it
00:23 - in JavaScript with the p5 library
00:26 - starting from no code at all.
00:28 - Obviously besides the dependencies.
00:30 - Okay, so this is the example running.
00:32 - Let me just give you a little
bit of background here.
00:34 - If you want to learn
more about the flocking
00:37 - algorithm as invented by Craig Reynolds,
00:40 - you can go to this link to
read this explanation of it.
00:45 - And find many other links and resources
00:47 - down here, whoa, that's a lot of stuff.
00:49 - Have fun, see you in a few weeks.
00:52 - You can also check out this YouTube video
00:55 - of the original 1986 flocking simulation.
00:59 - Wow, that's amazing.
01:01 - This is so cool, oh my God, I love that.
01:04 - You can also find an explanation of it
01:07 - as part of my Nature of Code book online
01:10 - with some diagrams and
code written in Processing
01:13 - and an exercise that you
can try which I'll refer to
01:15 - back at the end.
01:16 - But I'm going to start
from this, a blank slate.
01:19 - I just have the canvas,
you have some amount
01:22 - of pixels in it.
01:23 - There is nothing happening in the console.
01:27 - I've got this code set up and draw.
01:30 - So I'm going to write this
code without worrying about
01:32 - being perfectly organized
and being able to scale
01:36 - it very easily.
01:36 - I just want to get the
algorithm working but of course,
01:41 - where is the button?
01:42 - (pop music)
01:44 - If you want to see a
refactored example of it,
01:46 - you can probably go and look and actually,
01:48 - at my finished version
in the Nature of Code
01:49 - which I'll also link to.
01:51 - The first thing that
I want to do though is
01:53 - I want to add another JavaScript
01:59 - file called particle.js.
02:02 - Actually, I should rename this to boid.js.
02:07 - What is this term Boid?
02:09 - When Craig Reynolds
invented this algorithm
02:11 - for simulating a flocking
system like a flock of birds
02:16 - or a swarm of bees, I
suppose he didn't want
02:21 - to use the term bird, but
it is kind of like bird,
02:23 - so Boid, it's kind of like droid but Boid.
02:26 - Go read the original paper
about steering behaviors
02:30 - and flocking systems
and you'll find out more
02:32 - about the history about this.
02:33 - But I'm going to make a class called Boid
02:39 - and I am going to use
the p5 vector object.
02:46 - I'm going to make Boid
objects and each time
02:50 - I made a Boid object, I need a constructor
02:53 - and I am going to give
each Boid a position.
02:58 - I'm going to give each Boid a velocity.
03:04 - I'm going to give each
Boid an acceleration.
03:09 - All of those are going to be vectors.
03:10 - I'm doing this is 2D.
03:11 - You should, after you watch
this, if you watch this,
03:14 - you should make your
own 3D version of this.
03:16 - All of the math will
work exactly the same way
03:18 - but you'll just need to rethink
how you're visualizing this.
03:23 - Just to give things a
start, let's just put
03:26 - the position in the middle of the window
03:31 - and let's write a function called show
03:34 - which will just draw them
as a circle right now.
03:36 - Actually, I'll just even use
point, like strokeWeight 16.
03:42 - Stroke 255, point this.position.x.
03:49 - I think Visual Studio
code will do this for me.
03:52 - No, where does it?
03:54 - It fixed that for me once, whatever.
03:57 - This PointerEvent, I'm not a PointerEvent,
04:02 - I'm a point.
04:03 - So now, if I were to
then here make a flock,
04:09 - which is an array, and
I should probably make
04:13 - a flock class, that might be
a thing to refactor later.
04:16 - But I'm just going to
say a flock.push new Boid
04:21 - and then I just want to say
for every Boid in the flock
04:28 - and I'm using of, I'm using a for-of loop
04:29 - but I said in because that's
the way I feel right now.
04:33 - A boid.show and then I need to make sure
04:36 - I am also referencing
boid.js in my index HTML
04:41 - so I have the basic Boid
class, which just creates
04:45 - a position, velocity,
acceleration and draws it
04:47 - as a point and then I have
my sketch where I make
04:50 - one Boid and I draw it in
the center of the screen.
04:53 - There it is, there's my boid.
04:55 - (bell rings)
04:56 - Step one complete.
04:57 - I probably should plan this out
04:58 - but I have one Boid, that's good.
05:00 - Now, let's have that Boid move.
05:03 - Let's actually write in the Boid object
05:06 - a function called update
and this I probably covered
05:10 - ad nauseum in a lot of other videos
05:12 - in my whole Nature of Code series.
05:14 - But the idea here is
that position is updated
05:18 - based on the Boid's
velocity and its velocity
05:24 - is updated based on the
Boid's acceleration.
05:27 - If I now actually create
a p5.vector, a random 2D.
05:35 - I believe this is a
function that will give me
05:37 - a random velocity vector
and I now go in here
05:42 - and say boid.update.
05:46 - Oh I just spelled it wrong.
05:47 - I thought I missed the this dots.
05:49 - Here we go, look, it's moving.
05:51 - It's moving with a random
velocity each time.
05:54 - Okay, now let's just
make a bunch of these.
06:02 - Now I have a system of 100
Boids but it's interesting,
06:04 - look at this, it fans out
in the perfect circle.
06:08 - Do you know why that is?
06:10 - Because I make a Boid and I
give it a random velocity.
06:17 - That random vector is
always of unit length one.
06:21 - The direction is something
different so they're all
06:24 - actually moving with the same speed.
06:25 - If I wanted them to have,
and this is not an important
06:27 - detail to the flocking
stuff, but just to sort of
06:30 - get a sense of how this
vector stuff works,
06:32 - I could say this.velocity.setMag,
which is set the
06:37 - magnitude to a random
value between 0.5 and 1.5.
06:45 - Now, you can see now
they're all moving with a
06:48 - slightly different velocity.
06:49 - This is by the way, a nice
little almost like explosion
06:53 - motif and I could have
them with a real big burst
06:55 - then they slow down.
06:56 - There's all sorts of
physics-y stuff I could do
06:58 - with this but I just want to do flocking.
07:00 - How, how, how do I do flocking?
07:03 - Let's return to this paper here.
07:06 - This is the key behind Craig
Reynolds' flocking algorithm.
07:11 - Three rules.
07:14 - Separation: steer to avoid
crowding local flockmates.
07:19 - Alignment: steer towards
the average heading
07:23 - of local flockmates.
07:24 - Cohesion: steer to move
toward the average position
07:28 - of local flockmates.
07:30 - Something so crucial in
that description is the
07:33 - word local, local.
07:35 - Local, what does that mean?
07:37 - Let's just do, I think
the easiest one to do
07:40 - actually is alignment.
07:43 - Let's say there are five Boids.
07:47 - Actually, let's make a lot more of them.
07:49 - These are all of my Boids.
07:52 - This is the one that I'm
currently operating around.
07:55 - It has a velocity vector like this.
07:57 - Let me just make up, let's just pretend
07:59 - like the ones around it are kind of moving
08:01 - all in the same direction.
08:02 - Because that'll be easier to think about.
08:05 - This is the current one
that I'm looking at.
08:08 - And maybe some of these
others are also moving
08:10 - in other directions also.
08:14 - I could take the approach
to say this particular Boid
08:17 - needs to align itself to everything.
08:21 - But this is not really how complex systems
08:25 - in nature actually work.
08:27 - The emergent phenomena
comes from this Boid having
08:30 - a limited perception of its environment.
08:33 - So maybe, it's actually
only able to see things
08:36 - that are in front of it or behind it
08:37 - or to the right or what's
probably the most simplest
08:39 - thing to implement is within some radius.
08:43 - So I only want to look
at the Boids that are
08:45 - within this radius,
meaning this one, this one,
08:48 - this one, this one, this one.
08:50 - What if I iterate over
all these ones that are
08:53 - within some distance, average
all of their velocities
08:57 - and shift this velocity in the direction
08:59 - of all those velocities.
09:01 - That's what we want to do.
09:03 - I am going to write a function now.
09:07 - I'm going to put it in
the Boid and I'm going to
09:09 - call it align and it's
going to get presumably
09:13 - an array of other Boids.
09:15 - The idea is this function align this Boid
09:18 - with all the other Boids.
09:20 - So what do I need to do?
09:22 - I'm going to make a
variable called average
09:25 - which is going to be a
vector then I am going to
09:29 - iterate over and I could
do all of these with
09:32 - reduce probably in some
higher order array functions.
09:36 - That's a great thing for you to do.
09:38 - (pop music)
09:41 - Refactor it later but
I'm just going to do it
09:44 - this way, I'm actually going
to use i because that's
09:50 - maybe going to help me.
09:51 - I'm not really sure but I'm
going to use i right now.
09:54 - Actually, no, I'll
still use a for-of loop.
09:56 - Let other, I'm going to
call it other of Boids
10:03 - and I'm going to just say
average.add other.velocity.
10:09 - So I'm adding up all of the velocities.
10:12 - This is how you do an average, right?
10:13 - Vectors, again you might
want to go watch my videos
10:16 - about how vectors work,
but a vector, a p5 vector
10:19 - just holds an x and a
y or a x and y and a z.
10:22 - So I want to average the
vector, represented as an arrow
10:25 - with an x component and a y component.
10:27 - If I want to average,
just like I might average
10:28 - an array of numbers, I
add them all up and divide
10:31 - by the total.
10:32 - Then I would say
average.divide by Boids.length.
10:38 - This would be a way of
getting the average velocity
10:44 - of all the Boids but remember I only want
10:48 - the ones within some distance.
10:49 - So actually, let's
implement that right now.
10:53 - Let's have some sort of distance like max.
10:58 - I'll call it perception
equals let's just make it
11:01 - arbitrarily like 100 and
then I'm going to now
11:04 - say if the distance
between this.position.x.
11:10 - You know what?
11:12 - I think there's a p5.
11:13 - This is fine.
11:14 - It's just going to be, it's kind
of long the way I'm writing this
11:16 - but I don't mind.
11:17 - Let's actually make it in a variable.
11:19 - D = the distance between
this Boid's position
11:26 - and the other Boid's position, x and y.
11:34 - If that distance is less than 100,
11:39 - look at that.
11:40 - Look at this fancy thing that it's doing.
11:42 - I have some prettier
stuff that doesn't want
11:45 - to let me write a long line of code.
11:46 - I guess I'll keep that
in there for right now.
11:49 - So I'm calculating the
distance between this Boid's
11:51 - position and the other Boid's position.
11:53 - If that distance is less
than 100, I'm adding
11:55 - it up and I should also
probably have a total number,
12:00 - total = zero.
12:03 - Add it up.
12:04 - I also should probably
ignore myself and if other
12:11 - does not equal this, right?
12:16 - So I basically, I might
as well put that first.
12:19 - As long as the other thing is not me
12:22 - and the distance is
less than 100, add it up
12:26 - and then divide by the total.
12:28 - But obviously, I only want
to divide by the total
12:33 - if total is greater than zero.
12:37 - All right, so this is
kind of a little bit of
12:39 - a long-winded algorithm now.
12:41 - And perception.
12:42 - If d is less than perception.
12:46 - So I'm starting with a
perception, a radius of 100.
12:49 - Maybe that would be better if I called it
12:51 - perceptionRadius, that's
really what it is.
12:55 - Starting with a perception radius of 100,
12:57 - an empty vector, adding up the velocities
13:00 - of any vector, any Boid that's near me,
13:04 - dividing by the total and
as long as I've found one,
13:07 - dividing by that total.
13:08 - Now here's the thing.
13:09 - I could just say, for
example I could do something
13:11 - weird, this will be really weird.
13:13 - I could just say
this.velocity equals average.
13:17 - What if I did that?
13:19 - Then I said Boid, like here
I said boid.align flock.
13:27 - I don't know what's going to happen here,
13:29 - but let's refresh this.
13:31 - They just basically don't go anywhere.
13:33 - Because they're all instantly equal
13:35 - to each other's velocity.
13:37 - That's not really a good way.
13:38 - What I need to do now is
if I don't want to actually
13:41 - assign its velocity to
that average directly.
13:44 - I want to steer towards it.
13:48 - This is where Craig Reynolds'
steering formula comes in.
13:52 - A steering force equals
some desired velocity
13:58 - minus the current actual velocity.
14:02 - It's kind of like the error.
14:04 - If I am moving this way.
14:08 - Sorry, if I'm moving this way
but I want to move this way,
14:11 - the way I want to move
minus the way I am moving
14:16 - is the steering force meaning
push me in that direction.
14:21 - Apply a force.
14:22 - Maybe I'm going to turn
the steering wheel.
14:24 - You can think of these as bees or cars
14:26 - or birds or whatever.
14:27 - This formula desired minus
velocity will give me
14:30 - the steering force and what
is the desired velocity here?
14:35 - The desired velocity is
actually that average.
14:37 - I'm actually going to
rename this to desired
14:40 - and I'm going to add it up
14:43 - and divide by total and
then I'm going to say
14:46 - this.velocity equals, no,
I'm not going to say that.
14:48 - I'm going to say steering equals.
14:57 - I should actually call this
steering because I could
15:00 - do all of this.
15:02 - I don't need to save
anything as I'm going.
15:04 - I'm going to call that the steering force.
15:06 - I'm going to add all the velocities.
15:09 - I'm going to divide by the total and then,
15:11 - I'm going to say steering
force is the desired
15:15 - subtract this.velocity.
15:20 - And I'm going to say return steering.
15:23 - I want this function to basically,
15:26 - I want this function to return that force.
15:28 - So really what I should
be doing is I should have,
15:30 - I'm going to write a
function called flock.
15:33 - That's maybe more like, yeah.
15:36 - Flock with some number of
Boids and then I'm going to say
15:42 - alignment equals align with those Boids.
15:49 - So I'm going to get
this force and I suppose
15:59 - steering is here, so you know what?
16:02 - I should always return steering.
16:04 - I want to always return a
vector but if it didn't find
16:07 - anything, I'll just
return the zero vector.
16:10 - Then, what I'm going to
do is I'm going to say
16:12 - acceleration add alignment.
16:17 - The idea, the way that
a physics engine works,
16:20 - and this has to do with,
16:23 - this is a very simple
crude physics engine.
16:26 - Force equals mass times acceleration.
16:29 - This is Newton's Law of Motion.
16:31 - Or acceleration equals
force divided by mass
16:35 - or in a world where the
mass of everything is one,
16:37 - acceleration equals force.
16:39 - So if I want to apply
a force to this object,
16:42 - I just need to set the
acceleration to that force.
16:45 - Actually, that's what I'm going
to do just starting out here.
16:48 - I'm going to say acceleration
equals alignment.
16:53 - So now, if I go back to sketch and I say
16:58 - Boid.flock Boids, we should
now have all of Boids
17:05 - doing that with just implemented
with that alignment rule.
17:12 - Let's see.
17:13 - Boids is not defined.
17:14 - Sketch.js line 14.
17:17 - Oh, it's called flock.
17:17 - Oh, this is my variable
naming is terrible.
17:22 - But I'm going to leave
it that way right way.
17:25 - Align is not defined.
17:26 - Boid.js align Boids.
17:31 - Oh, this .align, this .align Boids.
17:35 - Acceleration is not
defined, oh my goodness.
17:40 - (pop music)
17:47 - Let me actually not have them all start
17:49 - in the same place because
that is just to see
17:52 - this effect happen, let
me actually start them
17:55 - in random places on the screen.
17:58 - Let me change that.
18:00 - Let me make the perception
radius a little bit smaller
18:03 - and I don't know why this
matters, but let me draw them
18:05 - like a little bit smaller.
18:08 - Let me actually have them start out going
18:13 - quite a bit faster.
18:17 - You can see as they get near each other,
18:19 - they start to get each other's velocity.
18:23 - They start to average each
velocity with their neighbor's.
18:26 - You start to see these
clumps moving together.
18:29 - So much more to do on this.
18:30 - Oh my goodness, but first a couple things.
18:34 - One is I have now basically
allowed these Boids
18:43 - to steer with infinite power in a way.
18:47 - We should probably have a variable.
18:50 - I'm going to call it maxForce.
18:53 - I'm going to set it
equal to one for a second
18:56 - and then what I'm going to do is here,
18:58 - I'm going to say a steering
limit this.maxForce.
19:05 - What this does is it limits the magnitude,
19:07 - the length of that vector
to some maximum force
19:10 - so this should be exactly the same.
19:12 - We're not seeing anything different but if
19:14 - I were to make maximum force
0.01, like really small
19:19 - right now, you're going to
see they're not actually
19:22 - changing their velocity.
19:24 - They are, but very, very slowly.
19:27 - The other thing we're
really going to need to do
19:28 - is I just have to give up and do this.
19:31 - I'm going to add something
for the edges here.
19:34 - I'm going to say if
this.position.x is greater than
19:38 - the width, this.position.x
should equal zero.
19:45 - Else, if this.position.x
is less than zero,
19:49 - this.position.x equals width.
19:52 - Then I'm just going to do that for the y,
19:54 - with, with, x, x, y, y, y, x, x, x, x,
19:58 - with, with.
19:59 - All right, and now here,
let's do boid.edges.
20:07 - We should see them
reappear wrapping around
20:10 - and now, let's go back to the Boid and
20:16 - let's make this 0.2 is
kind of reasonable-ish.
20:23 - Interestingly enough, they're kind of like
20:25 - it slows them down which is interesting.
20:30 - But I'm only doing alignment right now,
20:31 - but you can see how this works.
20:33 - You can see how they're
all starting to align
20:34 - with each other.
20:35 - I could keep them going
at some minimum velocity
20:37 - which might make sense.
20:38 - You can see how these
are going back and forth.
20:41 - But you get the idea.
20:42 - Why are they all slowing down?
20:46 - Is that just a coincidence?
20:48 - One thing I could do is
20:50 - this is actually going to be worth it
20:54 - because I should also
give them a maximum speed.
20:56 - This is going to be a
parameter of a variable
20:59 - that's going to allow
me to control the system
21:00 - pretty well and I could
consider their desired
21:04 - velocity in the alignment
to not actually be
21:10 - the actual average velocity
but just the average
21:13 - direction because I could
then say steering.setMag
21:17 - to this.maximum speed.
21:19 - So basically I'm saying I
always want to go in the
21:21 - direction of my neighbor
but at maximum speed.
21:24 - I don't know that that's
really an important detail,
21:26 - but if I add that in here,
we might get the effect
21:29 - that I was hoping to get.
21:30 - Now, this is what I was expecting to see.
21:32 - As they get near each other,
21:34 - they're all starting to align together.
21:36 - Let me refresh that one more time.
21:38 - You can see that they're
clumping and as they group,
21:41 - they all start to align.
21:42 - This is the alignment rule.
21:43 - This is a very simple rule.
21:45 - It's predictable, it's
obvious, this is alignment.
21:48 - Now, all we need to do is
add cohesion and separation.
21:52 - Separation is going to
be the hardest one to do.
21:54 - So let's do cohesion next.
21:56 - Same thing, we're going
to look at our neighbors.
21:59 - We should go back to what
the rule was actually
22:01 - defined as, let's go back to
Craig Reynolds' original page.
22:05 - Cohesion: steer to move
toward the average position
22:09 - of local flockmates.
22:10 - This is actually not going to be that hard
22:13 - because we've already
calculated the average velocity
22:17 - of local flockmates.
22:19 - Now, let's just duplicate that code.
22:21 - I know, I know we could refactor it.
22:22 - I won't play the song.
22:24 - Because we could probably do
this all in one fell swoop.
22:26 - There's so many possibilities
but now I just want
22:28 - to get the average location
of my local flockmates
22:31 - and steer towards that.
22:33 - So, the way I'm going to do
that is I'm just going to
22:38 - go nuts and copy paste this whole thing
22:45 - and call it cohesion and I'm going to keep
22:49 - the perception radius, I'm
going to keep this idea
22:51 - of steering, keep this idea of total.
22:53 - Go through all the
Boids, check the distance
22:55 - between myself and the other ones,
22:58 - as long as I'm not myself and
within the perception radius,
23:00 - what am I doing?
23:01 - Steering not the others' velocity
but the others' position.
23:05 - This should clearly be
refactored into its own function
23:08 - but whatever.
23:10 - Then as long as I have
at least one, I'm going
23:14 - to divide by the total.
23:16 - Now I don't want to set the
magnitude to the maximum speed
23:18 - so what I have now in steering
is the average location.
23:22 - So if this is the average location,
23:27 - let's say it's over here, then what I need
23:29 - is a vector that,
23:30 - that's clearly not the average location.
23:32 - But let's just say it was.
23:34 - The average location is kind of like
23:35 - where this Boid is.
23:36 - But I want to steer in that direction
23:38 - so to get a vector in that direction,
23:40 - I take the average location
minus the current position
23:44 - of me which is basically saying
23:47 - now what I want to do
is say steering subtract
23:52 - this.position so subtract my position now,
23:57 - I've got a vector that's pointing from me
23:58 - to the average location,
remember which is in
24:00 - the steering variable
then let's say I want to
24:03 - go at maximum speed.
24:06 - Then, this is now my desired velocity.
24:10 - I'm going to subtract
out my current velocity,
24:12 - limit it to max force and there we go.
24:14 - That's cohesion.
24:15 - (bell rings)
24:16 - Now, in flock, let cohesion
equal this.cohesion
24:26 - Boids and then oh, we have a big problem.
24:29 - This.acceleration equals alignment.
24:31 - This.acceleration equals cohesion.
24:32 - So how can I set the acceleration
to two different forces?
24:36 - But before I even answer
that, there's an easy answer
24:39 - to that question.
24:40 - Let's just comment out
alignment and let's watch
24:42 - cohesion happen.
24:48 - We can see they start to group together.
24:50 - This is cohesion happening.
24:51 - And that neighbor radius, by the way,
24:53 - is a super important value.
24:55 - Right?
24:56 - That neighbor radius,
if I were to change that
25:01 - and I have a different,
that perception radius,
25:03 - if I were to change that to 10,000
25:07 - they're all going to come together as one.
25:10 - Because they all see everybody.
25:12 - If I were to change that to 10,
25:15 - there's really little pairs.
25:18 - You can see they kind
of get in groups of two.
25:20 - The force though isn't so strong.
25:23 - So if I were to change
the maximum force to one,
25:28 - now you see them, almost like these little
25:30 - electron thingies that
start, magnetic things
25:35 - that start to spin around
each other and then fan off.
25:37 - There's so many possibilities here.
25:42 - I could make the maximum speed two.
25:44 - I'm not actually limiting it, you can see.
25:45 - There you go, that's
what I was looking for.
25:47 - They get into these little groups
25:48 - but let me go back and
say maximum speed is four.
25:51 - Maximum force is 22 and I realize
25:53 - this maximum speed is not
actually a maximum speed
25:56 - because in update if I
really wanted it to be
25:59 - a maximum speed, I would want to say
26:03 - this.velocity limit this.maxSpeed.
26:08 - Let's actually add that
in and see what we get.
26:12 - Oh, and let's put the
perception radius back
26:15 - at 100 and there we go.
26:18 - Now we have cohesion.
26:20 - We have cohesion, what
happens if we have cohesion
26:22 - and alignment?
26:23 - How do we get cohesion and alignment?
26:26 - Okay, this is fun.
26:27 - This is really working.
26:28 - This is going to be a really long video.
26:30 - All right, cohesion and alignment.
26:31 - The problem rests here.
26:35 - This is actually a really
easy thing to solve
26:37 - because this is called force,
26:39 - the answer here is force accumulation.
26:42 - In physics, if two forces
are acting on an object,
26:46 - the resulting acceleration
is the sum of those forces.
26:49 - So all I need to do is say
acceleration.add alignment
26:53 - and acceleration.add cohesion because
26:56 - why is this not falling?
27:00 - Because the force of
gravity is pointed this way
27:03 - and the other force of
my hand holding it up
27:06 - is pointed in the other direction
with an equal magnitude.
27:09 - Therefore, it is at rest.
27:11 - Those two forces added together
have a net acceleration
27:15 - of zero.
27:16 - But obviously, all you
do is add them together
27:19 - but there is this, if I
actually do this right now,
27:22 - we're going to see some
really crazy behavior.
27:24 - Looks like it's kind of
working but it really isn't
27:27 - because what it should also
have is this acceleration
27:31 - shouldn't accumulate over time.
27:33 - Every moment in time, I
start with a net acceleration
27:36 - of zero and add all the forces together.
27:39 - So what I should do right
before I flock is say
27:43 - this.acceleration set zero, zero.
27:46 - This is setting its
values to zero and zero.
27:49 - Another way I could do
that is just multiplying
27:50 - it by zero, because
multiplying a vector by zero
27:53 - takes everything out.
27:54 - It could make a new vector, whatever.
27:55 - But this will work nicely and technically,
27:58 - this also might make more sense here
28:00 - because it's kind of like
after I finish updating
28:02 - the velocity then I can
reset the acceleration
28:04 - in case there's other things at play.
28:07 - Now we can see both cohesion and alignment
28:14 - are at play, look at this.
28:15 - Eventually, they're just all
going to become this one clump.
28:18 - Come on, you can catch
up, you got it, go go!
28:21 - Go, catch up!
28:22 - Yeah! One clump.
28:24 - One thing I would like to do.
28:28 - I really want to attach
sliders to those parameters
28:30 - but I got to resist because
we got to have separation.
28:34 - We've got alignment.
28:35 - (bell rings)
And cohesion.
28:35 - (bell rings)
28:37 - Separation, this one is a little bit hard.
28:39 - Steer to avoid crowding local flockmates.
28:46 - Here's the me.
28:48 - That's me, here's my local flockmate.
28:52 - If this local flockmate
is too close, it's within
28:56 - some sort of distance
threshold, I want to steer
28:59 - to avoid that.
29:01 - What would be my desired velocity?
29:03 - My desired velocity would be to move
29:06 - in the opposite direction.
29:09 - So the idea is my desired
velocity is in the observable.
29:13 - What if there is one here?
29:16 - My desired velocity would
also be opposite direction
29:18 - so then my next desired velocity would be
29:21 - the average of these two.
29:23 - It even would make sense
for the magnitude of that
29:26 - desired velocity to be
proportional to the distance.
29:31 - So if this one is here,
I maybe want to avoid it
29:34 - but I only really need to
think about avoiding it
29:37 - a little bit.
29:38 - If this one's really close,
I need to avoid it a lot.
29:40 - So the magnitude of the vector
is inversely proportional
29:43 - to the distance of the local flockmate.
29:46 - This might end up with kind
of like a desired velocity
29:48 - of something like this if I'm
averaging those two together.
29:52 - So let's see if we can implement that.
29:54 - Not going to be super
easy but let's do it.
29:59 - The nice thing is I'm going
to start with cohesion
30:02 - because we've kind of,
30:03 - cohesion is close to separation.
30:05 - Again, boy.
30:08 - (pop music)
30:09 - ♪ I will refactor this later ♪
30:11 - ♪ You know I will refactor this later ♪
30:16 - ♪ I will refactor this later ♪
30:18 - - I should show you that I'm wearing my
30:19 - I will factor this later
t-shirt, by the way.
30:22 - Okay, so separation.
30:24 - I'm going to leave this at 100.
30:26 - Steering, I think I might need to use,
30:29 - I like the idea of just having one vector
30:33 - that ends up as, it's
sort of the average here
30:36 - then it's the difference
but I think I need
30:39 - to think, one step at a time.
30:45 - I'm creating this vector.
30:46 - This is the same.
30:47 - If it's not me and it's
within the perception radius,
30:51 - what do I need?
30:52 - I need a vector, I'm going
to call it difference
30:59 - which is the other's.
31:04 - I want a vector, sorry, that points from
31:10 - the other to me.
31:13 - Because I want that to go
to the opposite direction.
31:16 - So it's my position minus the other.
31:21 - I want a vector, the new vector which is
31:25 - the subtraction between my position
31:30 - and the other's position.
31:34 - This is a way of calling
the subtract function
31:36 - which doesn't operate on a vector
31:38 - but subtracts two vectors and gives us
31:40 - a new vector which is difference.
31:42 - Then, I want the
difference to be inversely
31:47 - proportional to the distance
31:51 - so I'm going to multiply
it or set its magnitude
31:53 - something like that.
31:54 - Or divide by distance.
31:57 - I could just say divide
by distance, right?
32:00 - It's inversely proportional,
the farther away
32:02 - it is, the lower the magnitude.
32:07 - The closer, the higher the magnitude.
32:11 - The distance, I guess
technically that distance
32:12 - could be zero and that
would be problematic
32:14 - but with floating point math rule,
32:16 - it's never going to get a value of zero.
32:18 - Then I want to add.
32:20 - Then that is the thing I add up.
32:23 - That's the thing I want to average.
32:24 - All those vectors that are pointed away
32:27 - from the things near me,
I think we're actually
32:28 - in pretty good shape here.
32:30 - This isn't as hard as I thought.
32:32 - This was the tricky part here.
32:34 - Get a vector that's pointing away
32:36 - from the local flockmate,
make it inversely proportional
32:38 - to the distance, add it
up, then this is the same.
32:42 - Because, oh no.
32:44 - I don't need to subtract position.
32:46 - I kind of don't know if I want to.
32:49 - Let's leave this whole always
go at maximum speed thing
32:52 - and then the rest is the same.
32:55 - Once I have that, just average it,
32:58 - set it to max speed,
subtract out the velocity
33:01 - and limit it to maximum
force and that's the end.
33:03 - Okay, just to be sure this is right,
33:07 - let's go into Boid.
33:09 - Let's go to flock.
33:12 - Let's add let separation
equal this.separation
33:21 - and then let's add in separation.
33:26 - I want to not bother adding
cohesion and alignment.
33:30 - Are these separating?
33:32 - Yeah, it looks like they are.
33:33 - It looks like when they
get close to each other,
33:35 - they're kind of moving
away from each other.
33:38 - Weird, weird behavior.
33:40 - This doesn't look like
exactly what I expected.
33:42 - Let's give the maximum
force, like really let
33:47 - them be super strong about separating.
33:49 - There we go.
33:50 - So that's more like what I expected.
33:52 - That's way too strong.
33:54 - Yeah.
33:55 - Why do they feel like they're,
something is weird here.
33:59 - Let's give it a much
smaller perception radius.
34:03 - Oh yeah, this is what I expected to see
34:05 - and I think it wasn't
really a bug in my code.
34:07 - It's sort of a bug in my conceptual sense
34:10 - of how this works.
34:11 - This is pretty good, this
is what I want to see.
34:13 - This is separation only.
34:15 - Now, we should be able to see and let's
34:18 - I'm going to do this really quickly.
34:21 - I'm going to not be thoughtful
at all about the interface
34:24 - but just so I can debug this effectively,
34:29 - I am going to go into sketch.js.
34:32 - I am going to say let
alignSlider, cohesionSlider
34:40 - and separationSlider.
34:43 - AlignSlider equals createSlider.
34:45 - I'm going to give it a
range between one and five.
34:48 - Actually, let's give it
a range between zero,
34:50 - sorry, zero and five, with
a starting value of one
34:54 - and increment value of 0.1.
34:58 - I want to do this for
all of these sliders.
35:00 - Then in Boid, I want to
say where I call in flock,
35:05 - I want to just scale them.
35:07 - I'm going to say separation.multiply
separationSlider.value.
35:16 - I'm going to do this also for
cohesion and for alignment.
35:21 - Now, by the way.
35:22 - (bell rings)
35:24 - (train whistle blows)
35:25 - Flocking.
35:26 - This is now the flocking simulation.
35:27 - I didn't draw them as triangles.
35:28 - They're not rotating, but this
is the flocking simulation.
35:31 - But just for the sake of
argument, this should be
35:33 - what order did I make them in?
35:35 - They're not labeled.
35:36 - So let's just turn all
the way up to separation.
35:38 - Oh boy.
35:39 - Let's turn off.
35:43 - This is only separation.
35:46 - Now, turn that off.
35:47 - Let's turn on only alignment.
35:50 - Whoa, that's oh they're just the alignment
35:53 - is so strong.
35:54 - When the alignment is
so strong, it makes them
35:57 - go in circles around each other.
35:58 - I have to talk about why.
36:00 - Why did that happen that they
were twirling in circles?
36:02 - Well, look at this.
36:03 - I'm updating them one at a time.
36:06 - The next one is flocking
with the previous ones
36:09 - updated value, right?
36:10 - Instead of taking a snapshot
of all their current
36:12 - velocities and then each one updates based
36:15 - on that snapshot, I start
with a set of velocities.
36:18 - I update the first one based
on the set of velocities
36:20 - and now its new velocity is there.
36:22 - So when the next one, it's
actually updating itself
36:24 - based on the previous one that I updated
36:26 - which is not how the world works.
36:27 - It's not how time works.
36:29 - That's causing them to
ripple into each other
36:31 - based on the order and go in circles.
36:33 - That is something that you
might want to consider fixing.
36:34 - I'm not going to fix that
but now I can really play
36:38 - with these, I can get
different sort of qualities
36:40 - of flocking based on how
strong I make these rules.
36:43 - So no alignment, a lot of cohesion.
36:45 - No separation, add a lot of separation.
36:48 - Less cohesion.
36:51 - Separation, I shouldn't make too strong
36:52 - but it's important and then
let's add some alignment
36:55 - back in and there we go.
36:56 - Flocking.
36:57 - (bell rings)
36:59 - Okay, this coding challenge is complete.
37:01 - It is done.
37:02 - I will be uploading the
code, if you want you can
37:05 - look at the video
description to find the code
37:06 - as a snapshot, that's exactly what it is.
37:08 - Let's go make a list.
37:10 - Let's make a list on the board of things
37:12 - you might try to do.
37:14 - Number one, snapshot of all velocities.
37:20 - That's going to be my code for that.
37:21 - Number two, an optimization you can do
37:25 - is called spatial subdivision
or a quadtree optimization.
37:31 - One of the things that
makes this really slow.
37:34 - And I'll just show you here for a second,
37:36 - is if I were to try to do
this with a 1,000 Boids.
37:43 - Look how slow this is.
37:44 - But you have to realize,
it's not a big deal
37:49 - for p5 to draw 1,000 things moving.
37:52 - Why it's fine drawing 1,000 things moving
37:54 - but as soon as I put
the flock function in,
37:57 - it's super slow.
37:58 - The reason that is is
because it's got to do
38:02 - and every Boid, check
every Boid against every
38:05 - other Boid check.
38:06 - So there's a way of subdividing the space,
38:11 - spatial subdivision into bins or buckets
38:14 - and have the Boids only
check ones that are near
38:16 - each other in the same buckets.
38:17 - That's called, I probably
have a lot of distance
38:20 - calculation, I could
reduce the number of times
38:22 - I call it.
38:24 - But for this, quadtree or just
simple spatial subdivision.
38:31 - These are things you could try.
38:32 - These are just code refactoring, really.
38:34 - Actually, the other thing you could try
38:39 - is really build a more
sophisticated interface
38:44 - and there's lots of
other parameters that you
38:47 - could control and try.
38:49 - There's the perception
radius, there's maximum force,
38:56 - there's maximum speed.
39:00 - Each rule could have a
different perception radius.
39:03 - So many possibilities.
39:06 - This is the stuff that
you could do to really
39:08 - control and tweak all the
values and play with it.
39:12 - Another thing you could do is just design,
39:15 - visual design, like are they triangles,
39:18 - circles, are they flapping butterflies.
39:21 - How do you, design of the Boids?
39:25 - Make your own beautiful
visualization of how you
39:27 - design and draw them.
39:28 - Tadpole-like, there's so many ideas there.
39:32 - Another thing you could try to do is 3D.
39:35 - Can you extrapolate this into 3D?
39:38 - If you see the word
quaternian anywhere you start
39:40 - to research, you might want to turn back.
39:43 - But you could extrapolate this into 3D.
39:46 - Another suggestion which
came from the chat,
39:48 - thank you, is Boids with
different parameters.
39:54 - There's no reason why
every Boid has to have
39:56 - the same max speed or maximum force.
39:59 - Or same perception radius.
40:02 - You could implement this
thing called the view rule.
40:06 - There's two things about this one.
40:07 - Each Boid can see everything around it.
40:10 - But what if the Boid
itself could actually only
40:12 - see if it's moving in this direction,
40:14 - things that are within its
particular view in front of it.
40:18 - Maybe it doesn't deal with
anything that's behind it.
40:20 - It doesn't try to do cohesion
or alignment or separation.
40:24 - Then the view rule which
is posited by Flake
40:28 - in the book A Computational
Beauty of Nature,
40:30 - I'll link to that book also.
40:31 - It's a wonderful book with tons,
40:33 - probably like 90% of
the things on my channel
40:35 - are all from the Computational
Beauty of Nature book.
40:39 - But Flake posits this additional rule
40:41 - that you always want to
keep your view empty.
40:44 - So if there is a Boid in front of you,
40:47 - you want to steer that way
to keep your view empty,
40:52 - clear and this might result, the theory is
40:55 - that this will result
in something that looks
40:57 - more like that pattern that you'll see of
40:59 - actual birds flocking where they kind of
41:02 - appear almost in this triangular pattern.
41:05 - What's interesting about
this, you see a pattern
41:07 - like this, you think, "Ah ha."
41:09 - This is a top-down behavior.
41:11 - There is a leader, this
bird, who is saying
41:14 - to all the other birds, "Fan
out from me and follow me."
41:16 - But yet, this type of intelligent behavior
41:20 - emergent phenomena can
come actually only from
41:24 - simple, local rules of interaction.
41:26 - This by the way, this
is what this whole video
41:27 - was about, if you didn't
gather that already.
41:30 - Other ideas might be adding obstacles,
41:33 - other forces, there's thinking about these
41:37 - living in a world where
they're interacting
41:39 - with other things,
maybe there's a predator
41:40 - that comes in and is chasing them.
41:42 - All sorts of unique and
interesting possibilities.
41:46 - So thank you everyone for
watching this coding challenge.
41:50 - Put your other ideas for
things people could do
41:52 - in the comments and then
if you make your own
41:54 - version of this flocking
code, please go to the
41:57 - codingtrain.com challenge
page and submit a link
42:00 - to what you made.
42:01 - I will also make a
version of this that runs
42:03 - in the web editor and link
to all those resources
42:06 - like the Craig Reynolds original paper
42:07 - about flocking, the video
on YouTube and the chapter
42:11 - in my Nature of Code book, okay?
42:12 - Thanks for watching this coding challenge
42:14 - on flocking and I'll see you soon.
42:15 - (train whistle blows)
42:16 - (upbeat music)

Cleaned transcript:

(train whistle blows) Hello and welcome to a coding challenge. In this coding challenge, I should probably go eat lunch but I'm going to just try this coding challenge. I am going to attempt to program this. This is a flocking simulation. What you're seeing right now is an example that I made many years ago of a flocking simulation, a Boids system running and processing. I'm going to try to make exactly this or close to it in JavaScript with the p5 library starting from no code at all. Obviously besides the dependencies. Okay, so this is the example running. Let me just give you a little bit of background here. If you want to learn more about the flocking algorithm as invented by Craig Reynolds, you can go to this link to read this explanation of it. And find many other links and resources down here, whoa, that's a lot of stuff. Have fun, see you in a few weeks. You can also check out this YouTube video of the original 1986 flocking simulation. Wow, that's amazing. This is so cool, oh my God, I love that. You can also find an explanation of it as part of my Nature of Code book online with some diagrams and code written in Processing and an exercise that you can try which I'll refer to back at the end. But I'm going to start from this, a blank slate. I just have the canvas, you have some amount of pixels in it. There is nothing happening in the console. I've got this code set up and draw. So I'm going to write this code without worrying about being perfectly organized and being able to scale it very easily. I just want to get the algorithm working but of course, where is the button? (pop music) If you want to see a refactored example of it, you can probably go and look and actually, at my finished version in the Nature of Code which I'll also link to. The first thing that I want to do though is I want to add another JavaScript file called particle.js. Actually, I should rename this to boid.js. What is this term Boid? When Craig Reynolds invented this algorithm for simulating a flocking system like a flock of birds or a swarm of bees, I suppose he didn't want to use the term bird, but it is kind of like bird, so Boid, it's kind of like droid but Boid. Go read the original paper about steering behaviors and flocking systems and you'll find out more about the history about this. But I'm going to make a class called Boid and I am going to use the p5 vector object. I'm going to make Boid objects and each time I made a Boid object, I need a constructor and I am going to give each Boid a position. I'm going to give each Boid a velocity. I'm going to give each Boid an acceleration. All of those are going to be vectors. I'm doing this is 2D. You should, after you watch this, if you watch this, you should make your own 3D version of this. All of the math will work exactly the same way but you'll just need to rethink how you're visualizing this. Just to give things a start, let's just put the position in the middle of the window and let's write a function called show which will just draw them as a circle right now. Actually, I'll just even use point, like strokeWeight 16. Stroke 255, point this.position.x. I think Visual Studio code will do this for me. No, where does it? It fixed that for me once, whatever. This PointerEvent, I'm not a PointerEvent, I'm a point. So now, if I were to then here make a flock, which is an array, and I should probably make a flock class, that might be a thing to refactor later. But I'm just going to say a flock.push new Boid and then I just want to say for every Boid in the flock and I'm using of, I'm using a forof loop but I said in because that's the way I feel right now. A boid.show and then I need to make sure I am also referencing boid.js in my index HTML so I have the basic Boid class, which just creates a position, velocity, acceleration and draws it as a point and then I have my sketch where I make one Boid and I draw it in the center of the screen. There it is, there's my boid. (bell rings) Step one complete. I probably should plan this out but I have one Boid, that's good. Now, let's have that Boid move. Let's actually write in the Boid object a function called update and this I probably covered ad nauseum in a lot of other videos in my whole Nature of Code series. But the idea here is that position is updated based on the Boid's velocity and its velocity is updated based on the Boid's acceleration. If I now actually create a p5.vector, a random 2D. I believe this is a function that will give me a random velocity vector and I now go in here and say boid.update. Oh I just spelled it wrong. I thought I missed the this dots. Here we go, look, it's moving. It's moving with a random velocity each time. Okay, now let's just make a bunch of these. Now I have a system of 100 Boids but it's interesting, look at this, it fans out in the perfect circle. Do you know why that is? Because I make a Boid and I give it a random velocity. That random vector is always of unit length one. The direction is something different so they're all actually moving with the same speed. If I wanted them to have, and this is not an important detail to the flocking stuff, but just to sort of get a sense of how this vector stuff works, I could say this.velocity.setMag, which is set the magnitude to a random value between 0.5 and 1.5. Now, you can see now they're all moving with a slightly different velocity. This is by the way, a nice little almost like explosion motif and I could have them with a real big burst then they slow down. There's all sorts of physicsy stuff I could do with this but I just want to do flocking. How, how, how do I do flocking? Let's return to this paper here. This is the key behind Craig Reynolds' flocking algorithm. Three rules. Separation steer to avoid crowding local flockmates. Alignment steer towards the average heading of local flockmates. Cohesion steer to move toward the average position of local flockmates. Something so crucial in that description is the word local, local. Local, what does that mean? Let's just do, I think the easiest one to do actually is alignment. Let's say there are five Boids. Actually, let's make a lot more of them. These are all of my Boids. This is the one that I'm currently operating around. It has a velocity vector like this. Let me just make up, let's just pretend like the ones around it are kind of moving all in the same direction. Because that'll be easier to think about. This is the current one that I'm looking at. And maybe some of these others are also moving in other directions also. I could take the approach to say this particular Boid needs to align itself to everything. But this is not really how complex systems in nature actually work. The emergent phenomena comes from this Boid having a limited perception of its environment. So maybe, it's actually only able to see things that are in front of it or behind it or to the right or what's probably the most simplest thing to implement is within some radius. So I only want to look at the Boids that are within this radius, meaning this one, this one, this one, this one, this one. What if I iterate over all these ones that are within some distance, average all of their velocities and shift this velocity in the direction of all those velocities. That's what we want to do. I am going to write a function now. I'm going to put it in the Boid and I'm going to call it align and it's going to get presumably an array of other Boids. The idea is this function align this Boid with all the other Boids. So what do I need to do? I'm going to make a variable called average which is going to be a vector then I am going to iterate over and I could do all of these with reduce probably in some higher order array functions. That's a great thing for you to do. (pop music) Refactor it later but I'm just going to do it this way, I'm actually going to use i because that's maybe going to help me. I'm not really sure but I'm going to use i right now. Actually, no, I'll still use a forof loop. Let other, I'm going to call it other of Boids and I'm going to just say average.add other.velocity. So I'm adding up all of the velocities. This is how you do an average, right? Vectors, again you might want to go watch my videos about how vectors work, but a vector, a p5 vector just holds an x and a y or a x and y and a z. So I want to average the vector, represented as an arrow with an x component and a y component. If I want to average, just like I might average an array of numbers, I add them all up and divide by the total. Then I would say average.divide by Boids.length. This would be a way of getting the average velocity of all the Boids but remember I only want the ones within some distance. So actually, let's implement that right now. Let's have some sort of distance like max. I'll call it perception equals let's just make it arbitrarily like 100 and then I'm going to now say if the distance between this.position.x. You know what? I think there's a p5. This is fine. It's just going to be, it's kind of long the way I'm writing this but I don't mind. Let's actually make it in a variable. D = the distance between this Boid's position and the other Boid's position, x and y. If that distance is less than 100, look at that. Look at this fancy thing that it's doing. I have some prettier stuff that doesn't want to let me write a long line of code. I guess I'll keep that in there for right now. So I'm calculating the distance between this Boid's position and the other Boid's position. If that distance is less than 100, I'm adding it up and I should also probably have a total number, total = zero. Add it up. I also should probably ignore myself and if other does not equal this, right? So I basically, I might as well put that first. As long as the other thing is not me and the distance is less than 100, add it up and then divide by the total. But obviously, I only want to divide by the total if total is greater than zero. All right, so this is kind of a little bit of a longwinded algorithm now. And perception. If d is less than perception. So I'm starting with a perception, a radius of 100. Maybe that would be better if I called it perceptionRadius, that's really what it is. Starting with a perception radius of 100, an empty vector, adding up the velocities of any vector, any Boid that's near me, dividing by the total and as long as I've found one, dividing by that total. Now here's the thing. I could just say, for example I could do something weird, this will be really weird. I could just say this.velocity equals average. What if I did that? Then I said Boid, like here I said boid.align flock. I don't know what's going to happen here, but let's refresh this. They just basically don't go anywhere. Because they're all instantly equal to each other's velocity. That's not really a good way. What I need to do now is if I don't want to actually assign its velocity to that average directly. I want to steer towards it. This is where Craig Reynolds' steering formula comes in. A steering force equals some desired velocity minus the current actual velocity. It's kind of like the error. If I am moving this way. Sorry, if I'm moving this way but I want to move this way, the way I want to move minus the way I am moving is the steering force meaning push me in that direction. Apply a force. Maybe I'm going to turn the steering wheel. You can think of these as bees or cars or birds or whatever. This formula desired minus velocity will give me the steering force and what is the desired velocity here? The desired velocity is actually that average. I'm actually going to rename this to desired and I'm going to add it up and divide by total and then I'm going to say this.velocity equals, no, I'm not going to say that. I'm going to say steering equals. I should actually call this steering because I could do all of this. I don't need to save anything as I'm going. I'm going to call that the steering force. I'm going to add all the velocities. I'm going to divide by the total and then, I'm going to say steering force is the desired subtract this.velocity. And I'm going to say return steering. I want this function to basically, I want this function to return that force. So really what I should be doing is I should have, I'm going to write a function called flock. That's maybe more like, yeah. Flock with some number of Boids and then I'm going to say alignment equals align with those Boids. So I'm going to get this force and I suppose steering is here, so you know what? I should always return steering. I want to always return a vector but if it didn't find anything, I'll just return the zero vector. Then, what I'm going to do is I'm going to say acceleration add alignment. The idea, the way that a physics engine works, and this has to do with, this is a very simple crude physics engine. Force equals mass times acceleration. This is Newton's Law of Motion. Or acceleration equals force divided by mass or in a world where the mass of everything is one, acceleration equals force. So if I want to apply a force to this object, I just need to set the acceleration to that force. Actually, that's what I'm going to do just starting out here. I'm going to say acceleration equals alignment. So now, if I go back to sketch and I say Boid.flock Boids, we should now have all of Boids doing that with just implemented with that alignment rule. Let's see. Boids is not defined. Sketch.js line 14. Oh, it's called flock. Oh, this is my variable naming is terrible. But I'm going to leave it that way right way. Align is not defined. Boid.js align Boids. Oh, this .align, this .align Boids. Acceleration is not defined, oh my goodness. (pop music) Let me actually not have them all start in the same place because that is just to see this effect happen, let me actually start them in random places on the screen. Let me change that. Let me make the perception radius a little bit smaller and I don't know why this matters, but let me draw them like a little bit smaller. Let me actually have them start out going quite a bit faster. You can see as they get near each other, they start to get each other's velocity. They start to average each velocity with their neighbor's. You start to see these clumps moving together. So much more to do on this. Oh my goodness, but first a couple things. One is I have now basically allowed these Boids to steer with infinite power in a way. We should probably have a variable. I'm going to call it maxForce. I'm going to set it equal to one for a second and then what I'm going to do is here, I'm going to say a steering limit this.maxForce. What this does is it limits the magnitude, the length of that vector to some maximum force so this should be exactly the same. We're not seeing anything different but if I were to make maximum force 0.01, like really small right now, you're going to see they're not actually changing their velocity. They are, but very, very slowly. The other thing we're really going to need to do is I just have to give up and do this. I'm going to add something for the edges here. I'm going to say if this.position.x is greater than the width, this.position.x should equal zero. Else, if this.position.x is less than zero, this.position.x equals width. Then I'm just going to do that for the y, with, with, x, x, y, y, y, x, x, x, x, with, with. All right, and now here, let's do boid.edges. We should see them reappear wrapping around and now, let's go back to the Boid and let's make this 0.2 is kind of reasonableish. Interestingly enough, they're kind of like it slows them down which is interesting. But I'm only doing alignment right now, but you can see how this works. You can see how they're all starting to align with each other. I could keep them going at some minimum velocity which might make sense. You can see how these are going back and forth. But you get the idea. Why are they all slowing down? Is that just a coincidence? One thing I could do is this is actually going to be worth it because I should also give them a maximum speed. This is going to be a parameter of a variable that's going to allow me to control the system pretty well and I could consider their desired velocity in the alignment to not actually be the actual average velocity but just the average direction because I could then say steering.setMag to this.maximum speed. So basically I'm saying I always want to go in the direction of my neighbor but at maximum speed. I don't know that that's really an important detail, but if I add that in here, we might get the effect that I was hoping to get. Now, this is what I was expecting to see. As they get near each other, they're all starting to align together. Let me refresh that one more time. You can see that they're clumping and as they group, they all start to align. This is the alignment rule. This is a very simple rule. It's predictable, it's obvious, this is alignment. Now, all we need to do is add cohesion and separation. Separation is going to be the hardest one to do. So let's do cohesion next. Same thing, we're going to look at our neighbors. We should go back to what the rule was actually defined as, let's go back to Craig Reynolds' original page. Cohesion steer to move toward the average position of local flockmates. This is actually not going to be that hard because we've already calculated the average velocity of local flockmates. Now, let's just duplicate that code. I know, I know we could refactor it. I won't play the song. Because we could probably do this all in one fell swoop. There's so many possibilities but now I just want to get the average location of my local flockmates and steer towards that. So, the way I'm going to do that is I'm just going to go nuts and copy paste this whole thing and call it cohesion and I'm going to keep the perception radius, I'm going to keep this idea of steering, keep this idea of total. Go through all the Boids, check the distance between myself and the other ones, as long as I'm not myself and within the perception radius, what am I doing? Steering not the others' velocity but the others' position. This should clearly be refactored into its own function but whatever. Then as long as I have at least one, I'm going to divide by the total. Now I don't want to set the magnitude to the maximum speed so what I have now in steering is the average location. So if this is the average location, let's say it's over here, then what I need is a vector that, that's clearly not the average location. But let's just say it was. The average location is kind of like where this Boid is. But I want to steer in that direction so to get a vector in that direction, I take the average location minus the current position of me which is basically saying now what I want to do is say steering subtract this.position so subtract my position now, I've got a vector that's pointing from me to the average location, remember which is in the steering variable then let's say I want to go at maximum speed. Then, this is now my desired velocity. I'm going to subtract out my current velocity, limit it to max force and there we go. That's cohesion. (bell rings) Now, in flock, let cohesion equal this.cohesion Boids and then oh, we have a big problem. This.acceleration equals alignment. This.acceleration equals cohesion. So how can I set the acceleration to two different forces? But before I even answer that, there's an easy answer to that question. Let's just comment out alignment and let's watch cohesion happen. We can see they start to group together. This is cohesion happening. And that neighbor radius, by the way, is a super important value. Right? That neighbor radius, if I were to change that and I have a different, that perception radius, if I were to change that to 10,000 they're all going to come together as one. Because they all see everybody. If I were to change that to 10, there's really little pairs. You can see they kind of get in groups of two. The force though isn't so strong. So if I were to change the maximum force to one, now you see them, almost like these little electron thingies that start, magnetic things that start to spin around each other and then fan off. There's so many possibilities here. I could make the maximum speed two. I'm not actually limiting it, you can see. There you go, that's what I was looking for. They get into these little groups but let me go back and say maximum speed is four. Maximum force is 22 and I realize this maximum speed is not actually a maximum speed because in update if I really wanted it to be a maximum speed, I would want to say this.velocity limit this.maxSpeed. Let's actually add that in and see what we get. Oh, and let's put the perception radius back at 100 and there we go. Now we have cohesion. We have cohesion, what happens if we have cohesion and alignment? How do we get cohesion and alignment? Okay, this is fun. This is really working. This is going to be a really long video. All right, cohesion and alignment. The problem rests here. This is actually a really easy thing to solve because this is called force, the answer here is force accumulation. In physics, if two forces are acting on an object, the resulting acceleration is the sum of those forces. So all I need to do is say acceleration.add alignment and acceleration.add cohesion because why is this not falling? Because the force of gravity is pointed this way and the other force of my hand holding it up is pointed in the other direction with an equal magnitude. Therefore, it is at rest. Those two forces added together have a net acceleration of zero. But obviously, all you do is add them together but there is this, if I actually do this right now, we're going to see some really crazy behavior. Looks like it's kind of working but it really isn't because what it should also have is this acceleration shouldn't accumulate over time. Every moment in time, I start with a net acceleration of zero and add all the forces together. So what I should do right before I flock is say this.acceleration set zero, zero. This is setting its values to zero and zero. Another way I could do that is just multiplying it by zero, because multiplying a vector by zero takes everything out. It could make a new vector, whatever. But this will work nicely and technically, this also might make more sense here because it's kind of like after I finish updating the velocity then I can reset the acceleration in case there's other things at play. Now we can see both cohesion and alignment are at play, look at this. Eventually, they're just all going to become this one clump. Come on, you can catch up, you got it, go go! Go, catch up! Yeah! One clump. One thing I would like to do. I really want to attach sliders to those parameters but I got to resist because we got to have separation. We've got alignment. (bell rings) And cohesion. (bell rings) Separation, this one is a little bit hard. Steer to avoid crowding local flockmates. Here's the me. That's me, here's my local flockmate. If this local flockmate is too close, it's within some sort of distance threshold, I want to steer to avoid that. What would be my desired velocity? My desired velocity would be to move in the opposite direction. So the idea is my desired velocity is in the observable. What if there is one here? My desired velocity would also be opposite direction so then my next desired velocity would be the average of these two. It even would make sense for the magnitude of that desired velocity to be proportional to the distance. So if this one is here, I maybe want to avoid it but I only really need to think about avoiding it a little bit. If this one's really close, I need to avoid it a lot. So the magnitude of the vector is inversely proportional to the distance of the local flockmate. This might end up with kind of like a desired velocity of something like this if I'm averaging those two together. So let's see if we can implement that. Not going to be super easy but let's do it. The nice thing is I'm going to start with cohesion because we've kind of, cohesion is close to separation. Again, boy. (pop music) ♪ I will refactor this later ♪ ♪ You know I will refactor this later ♪ ♪ I will refactor this later ♪ I should show you that I'm wearing my I will factor this later tshirt, by the way. Okay, so separation. I'm going to leave this at 100. Steering, I think I might need to use, I like the idea of just having one vector that ends up as, it's sort of the average here then it's the difference but I think I need to think, one step at a time. I'm creating this vector. This is the same. If it's not me and it's within the perception radius, what do I need? I need a vector, I'm going to call it difference which is the other's. I want a vector, sorry, that points from the other to me. Because I want that to go to the opposite direction. So it's my position minus the other. I want a vector, the new vector which is the subtraction between my position and the other's position. This is a way of calling the subtract function which doesn't operate on a vector but subtracts two vectors and gives us a new vector which is difference. Then, I want the difference to be inversely proportional to the distance so I'm going to multiply it or set its magnitude something like that. Or divide by distance. I could just say divide by distance, right? It's inversely proportional, the farther away it is, the lower the magnitude. The closer, the higher the magnitude. The distance, I guess technically that distance could be zero and that would be problematic but with floating point math rule, it's never going to get a value of zero. Then I want to add. Then that is the thing I add up. That's the thing I want to average. All those vectors that are pointed away from the things near me, I think we're actually in pretty good shape here. This isn't as hard as I thought. This was the tricky part here. Get a vector that's pointing away from the local flockmate, make it inversely proportional to the distance, add it up, then this is the same. Because, oh no. I don't need to subtract position. I kind of don't know if I want to. Let's leave this whole always go at maximum speed thing and then the rest is the same. Once I have that, just average it, set it to max speed, subtract out the velocity and limit it to maximum force and that's the end. Okay, just to be sure this is right, let's go into Boid. Let's go to flock. Let's add let separation equal this.separation and then let's add in separation. I want to not bother adding cohesion and alignment. Are these separating? Yeah, it looks like they are. It looks like when they get close to each other, they're kind of moving away from each other. Weird, weird behavior. This doesn't look like exactly what I expected. Let's give the maximum force, like really let them be super strong about separating. There we go. So that's more like what I expected. That's way too strong. Yeah. Why do they feel like they're, something is weird here. Let's give it a much smaller perception radius. Oh yeah, this is what I expected to see and I think it wasn't really a bug in my code. It's sort of a bug in my conceptual sense of how this works. This is pretty good, this is what I want to see. This is separation only. Now, we should be able to see and let's I'm going to do this really quickly. I'm going to not be thoughtful at all about the interface but just so I can debug this effectively, I am going to go into sketch.js. I am going to say let alignSlider, cohesionSlider and separationSlider. AlignSlider equals createSlider. I'm going to give it a range between one and five. Actually, let's give it a range between zero, sorry, zero and five, with a starting value of one and increment value of 0.1. I want to do this for all of these sliders. Then in Boid, I want to say where I call in flock, I want to just scale them. I'm going to say separation.multiply separationSlider.value. I'm going to do this also for cohesion and for alignment. Now, by the way. (bell rings) (train whistle blows) Flocking. This is now the flocking simulation. I didn't draw them as triangles. They're not rotating, but this is the flocking simulation. But just for the sake of argument, this should be what order did I make them in? They're not labeled. So let's just turn all the way up to separation. Oh boy. Let's turn off. This is only separation. Now, turn that off. Let's turn on only alignment. Whoa, that's oh they're just the alignment is so strong. When the alignment is so strong, it makes them go in circles around each other. I have to talk about why. Why did that happen that they were twirling in circles? Well, look at this. I'm updating them one at a time. The next one is flocking with the previous ones updated value, right? Instead of taking a snapshot of all their current velocities and then each one updates based on that snapshot, I start with a set of velocities. I update the first one based on the set of velocities and now its new velocity is there. So when the next one, it's actually updating itself based on the previous one that I updated which is not how the world works. It's not how time works. That's causing them to ripple into each other based on the order and go in circles. That is something that you might want to consider fixing. I'm not going to fix that but now I can really play with these, I can get different sort of qualities of flocking based on how strong I make these rules. So no alignment, a lot of cohesion. No separation, add a lot of separation. Less cohesion. Separation, I shouldn't make too strong but it's important and then let's add some alignment back in and there we go. Flocking. (bell rings) Okay, this coding challenge is complete. It is done. I will be uploading the code, if you want you can look at the video description to find the code as a snapshot, that's exactly what it is. Let's go make a list. Let's make a list on the board of things you might try to do. Number one, snapshot of all velocities. That's going to be my code for that. Number two, an optimization you can do is called spatial subdivision or a quadtree optimization. One of the things that makes this really slow. And I'll just show you here for a second, is if I were to try to do this with a 1,000 Boids. Look how slow this is. But you have to realize, it's not a big deal for p5 to draw 1,000 things moving. Why it's fine drawing 1,000 things moving but as soon as I put the flock function in, it's super slow. The reason that is is because it's got to do and every Boid, check every Boid against every other Boid check. So there's a way of subdividing the space, spatial subdivision into bins or buckets and have the Boids only check ones that are near each other in the same buckets. That's called, I probably have a lot of distance calculation, I could reduce the number of times I call it. But for this, quadtree or just simple spatial subdivision. These are things you could try. These are just code refactoring, really. Actually, the other thing you could try is really build a more sophisticated interface and there's lots of other parameters that you could control and try. There's the perception radius, there's maximum force, there's maximum speed. Each rule could have a different perception radius. So many possibilities. This is the stuff that you could do to really control and tweak all the values and play with it. Another thing you could do is just design, visual design, like are they triangles, circles, are they flapping butterflies. How do you, design of the Boids? Make your own beautiful visualization of how you design and draw them. Tadpolelike, there's so many ideas there. Another thing you could try to do is 3D. Can you extrapolate this into 3D? If you see the word quaternian anywhere you start to research, you might want to turn back. But you could extrapolate this into 3D. Another suggestion which came from the chat, thank you, is Boids with different parameters. There's no reason why every Boid has to have the same max speed or maximum force. Or same perception radius. You could implement this thing called the view rule. There's two things about this one. Each Boid can see everything around it. But what if the Boid itself could actually only see if it's moving in this direction, things that are within its particular view in front of it. Maybe it doesn't deal with anything that's behind it. It doesn't try to do cohesion or alignment or separation. Then the view rule which is posited by Flake in the book A Computational Beauty of Nature, I'll link to that book also. It's a wonderful book with tons, probably like 90% of the things on my channel are all from the Computational Beauty of Nature book. But Flake posits this additional rule that you always want to keep your view empty. So if there is a Boid in front of you, you want to steer that way to keep your view empty, clear and this might result, the theory is that this will result in something that looks more like that pattern that you'll see of actual birds flocking where they kind of appear almost in this triangular pattern. What's interesting about this, you see a pattern like this, you think, "Ah ha." This is a topdown behavior. There is a leader, this bird, who is saying to all the other birds, "Fan out from me and follow me." But yet, this type of intelligent behavior emergent phenomena can come actually only from simple, local rules of interaction. This by the way, this is what this whole video was about, if you didn't gather that already. Other ideas might be adding obstacles, other forces, there's thinking about these living in a world where they're interacting with other things, maybe there's a predator that comes in and is chasing them. All sorts of unique and interesting possibilities. So thank you everyone for watching this coding challenge. Put your other ideas for things people could do in the comments and then if you make your own version of this flocking code, please go to the codingtrain.com challenge page and submit a link to what you made. I will also make a version of this that runs in the web editor and link to all those resources like the Craig Reynolds original paper about flocking, the video on YouTube and the chapter in my Nature of Code book, okay? Thanks for watching this coding challenge on flocking and I'll see you soon. (train whistle blows) (upbeat music)
