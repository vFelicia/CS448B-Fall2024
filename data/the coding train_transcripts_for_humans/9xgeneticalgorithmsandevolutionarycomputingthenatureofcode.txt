With timestamps:

00:00 - okay so I'm going to talk about genetic
00:02 - algorithms and I first encountered
00:05 - genetic algorithms with um by watching
00:09 - this video this is from
00:10 - 94
00:12 - um I'm going to uh play a little bit of
00:15 - it for you um this is a project called
00:18 - I'm going to just turn the sound off
00:20 - although um this is a project called
00:22 - evolved virtual creatures actually the
00:23 - nice thing if you I encourage you to
00:25 - Google this and watch it it's Carl Sims
00:27 - evolved virtual creatures and um the the
00:30 - the audio soundtrack is kind of nice
00:32 - because it's like a National Geographic
00:34 - style uh video but it's all computer
00:36 - generated uh creatures so what Carl Sims
00:39 - did with this project is create
00:41 - essentially this physics framework for
00:43 - making these creatures they're all these
00:45 - node based creatures so all these
00:47 - creatures are essentially if I were to
00:49 - diagram them they're kind of you can
00:50 - think of them as particles with spring
00:52 - Connections in a way so they're boxes um
00:55 - and these spring connections are muscles
00:57 - and they can expand and contract and so
00:59 - car Sims was able to encode the design
01:02 - for these creatures into a virtual DNA
01:05 - and then say hey let me stick them all
01:07 - into this physics world and see how they
01:08 - do the ones that run really fast jump
01:11 - really high swim really well there's a
01:13 - water simulation in a little bit those
01:15 - are the ones that I will pick as parents
01:18 - quote unquote to make a strange virtual
01:21 - creature baby um for the next generation
01:24 - and they'll get the better that they do
01:25 - the more likely they are to reproduce
01:27 - and he evolved these creatures to to
01:30 - perform different tasks and so looking
01:32 - at this I was looking at this at a time
01:33 - where I was super fascinated with just
01:36 - even just trying to model kind of basic
01:38 - physics um and so I wanted to see if I
01:42 - could make something like this yeah this
01:45 - is this is the running sequence um this
01:48 - is the jumping
01:50 - sequence skip ahead a little bit this is
01:52 - following a red dot while swimming um
01:55 - and what's really amazing about this is
01:56 - it's very unexpected like you would
01:58 - never design a creature to look like
02:00 - that or do like that but this one is
02:02 - very very good at kind of swimming
02:04 - around in this water environment and um
02:07 - and at the end here there's this like
02:08 - hockey like competition where all these
02:10 - different creatures try to compete for
02:12 - this green Cube so I and so he would he
02:14 - would build these algorithms and then
02:16 - like kind of set them up in this like
02:18 - physics 3D environment and then have to
02:20 - like churn out frame by frame what would
02:23 - happen right so you know I don't know
02:25 - that's a good question I don't know the
02:26 - exact process that he used because in
02:28 - theory you don't need to watch the
02:30 - simulation in order to find out the
02:33 - result he might have just like but we're
02:36 - watching the res we're watching certain
02:37 - creatures that were evolved and then
02:39 - seeing them play out but it's all just
02:41 - data it's all just numbers and that's
02:42 - kind of what I wanted to get to into a
02:45 - description for how this worked and it's
02:46 - like funny they have all these weird
02:47 - gestures but there's a great um all of
02:50 - this is linked um on the nature of code
02:52 - website there's a further reading
02:54 - section and there's a paper by Sims
02:56 - which outlines how all this works and
02:58 - the design of these creatures um this
03:00 - one's a cruel one that likes to beat up
03:01 - on it um so that I'm I'm really not
03:05 - doing Justice to the soundtrack is
03:06 - really quite nice but you can watch that
03:08 - on your own time um okay so what I
03:10 - wanted to start with is kind of talking
03:12 - through okay so the thing about genetic
03:14 - algorithms is I for the book I kind of
03:16 - divided my thinking into three um
03:19 - different categories let me just erase
03:21 - this um which um uh you know there is
03:24 - this genetic algorithms were developed
03:26 - for solving certain kinds of computer
03:28 - science problems search problems where a
03:31 - brute force method is no good so if you
03:33 - need to check every possibility it would
03:35 - take too long maybe we could evolve
03:37 - towards the right answer and then there
03:39 - there's this category called interactive
03:41 - selection which is really used in art
03:43 - and design and I'm going to show you
03:44 - some examples of that and then this idea
03:46 - of thinking of um ecosystem simulation
03:48 - so what I wanted to talk about first is
03:51 - the um now it looks like I have a
03:53 - prepared presentation but these are just
03:55 - images from the book but um so I wanted
03:57 - to talk about the infinite monkey
03:58 - theorem which is kind kind of a classic
04:00 - classic test case uh classic example of
04:05 - an application of genetic algorithm so
04:07 - the infinite monkey theorem if you're
04:08 - not familiar with it is this idea that
04:10 - oh if we had an infinite number of
04:12 - monkeys and an infinite number of time
04:14 - and they're all just randomly typing at
04:16 - these keyboards typ typewriters
04:17 - typewriters maybe keyboards iPads I
04:19 - don't know um that eventually they would
04:22 - type the complete works of shakespare
04:24 - and so this is theoretically true I
04:26 - suppose I believe to be true yes it is
04:29 - theoretic true but the the problem is
04:32 - it's not something we could ever
04:33 - understand or or experience in our
04:35 - lifetime and just to like make this
04:37 - argument for a second so let's say we
04:38 - have just the phrase to be or not to be
04:40 - that is the question that phrase is 39
04:43 - characters long so let's say we have a
04:46 - simplified keyboard it only has 26
04:48 - characters and one
04:49 - spacebar so just to type a t there's a
04:52 - one in 27 chance of typing a t right now
04:55 - if you know anything about probability
04:57 - event probability if we have if we want
04:58 - the probability of two events happening
05:00 - in sequence we multiply the
05:01 - probabilities together so the chance of
05:03 - typing to is one 1 out of 27 * 1 out of
05:07 - 27 so the whole phrase 1 over 27 to the
05:10 - 39th power is a one in that big number a
05:14 - chance of that occurring randomly so
05:16 - that's a very large number which is kind
05:19 - of hard to even fathom but that's not
05:21 - even for the complete works of
05:21 - Shakespeare that's just for to be or not
05:23 - to be the question so and I I I worked
05:26 - it out a little bit with that if um
05:28 - there's a similar discussion by the way
05:30 - on Wikipedia if you go to infinite
05:31 - monkey theorem which kind of goes
05:32 - through um uh the same sort of stuff but
05:36 - if you if you were able to have a
05:37 - computer simulation that could do 1
05:39 - million random phrases per second it
05:42 - would take that many years for there to
05:44 - be I don't think I put this up here for
05:45 - there would be a 99% probability that
05:47 - you would have at least gotten to be or
05:49 - not to be that is the question somewhere
05:50 - in there so if that's much longer than
05:53 - the entire much much much longer than
05:55 - the uh age of the entire universe I
05:57 - think like on Wikipedia when I was
05:58 - reading it the the other day it said
06:00 - something like if you had a monkey for
06:02 - every atom in the entire universe it
06:05 - would still take you know anyway just
06:08 - way too long that we can't possibly
06:09 - understand so the point this is a stupid
06:11 - problem right because we could just type
06:12 - to be or not to be the question that is
06:14 - the question if we needed it but it it
06:15 - illustrates the point that there are
06:17 - some problems for which you don't know
06:18 - the answer like we know the answer here
06:20 - some problems that you don't know the
06:21 - answer for which uh it still it would
06:25 - take that long by brute force method so
06:28 - a genetic algorithm is a way of saying
06:31 - okay what if we had a population of
06:34 - phrases so let's just say to simplify
06:36 - for a second we're trying to evolve the
06:39 - phrase cat and we had a population of
06:42 - phrases like bad car I don't know hog
06:47 - it's very hard to think of I was going
06:48 - to say p as a three-letter word I don't
06:50 - know um I can only think of like weird
06:52 - uncomfortable word anyway the bunch of
06:55 - uh hat hat is good what what paa you're
06:58 - good P what paa paa thank you there you
07:01 - go um okay so a bunch of of of of
07:05 - phrases what we could do is evaluate
07:07 - these so the way the genetic algorithm
07:09 - works and I think I have you know I like
07:11 - to sort of write this out but I'll just
07:12 - use these um there's this this very
07:15 - specific algorithm and I'm using by the
07:17 - way the word setup and draw are some are
07:19 - things that are very specific to
07:20 - processing this algorithm Works where
07:22 - there is kind of this moment of begin
07:24 - like the big bang happens and there's
07:26 - this initial population that's seated
07:28 - and then there's something that happens
07:30 - over and over again a new generation is
07:32 - born evaluated a new generation is born
07:34 - so the very first thing that okay so one
07:36 - of the things I should mention is that
07:38 - um if you look at darwinian Natural
07:40 - Selection by the way I don't really know
07:42 - anything about biology and evolution so
07:44 - I you know and that's the nice thing
07:45 - about doing this stuff in like Pro you
07:46 - know computer programming you and just
07:48 - like make it up and be I'm like Inspire
07:49 - it's like it's like the TV shows where
07:51 - they say inspired by actual events
07:53 - that's what this is um it's not fired by
07:56 - actual science yeah fired by actual
07:57 - science so there's heredity
08:00 - uh selection and I would like to write
08:03 - first uh variation so if you think about
08:06 - darwinian um Evolution these are three
08:09 - key principles that need to be present
08:11 - for evolution to happen one thing is
08:13 - that we need to have variation so we
08:15 - would never be able to get to be or not
08:17 - to be if we just had you know one phrase
08:20 - to start with and all we could ever do
08:22 - is combine and recombine that one phrase
08:24 - we'd only ever have that one phrase if
08:26 - we only ever had bad we could never get
08:28 - to cat but if we have a random um if we
08:31 - seed our initial population that's the
08:33 - first thing we do with a random um set
08:36 - of elements then uh we have variation
08:38 - and we have the chance to evolve towards
08:40 - some optimal solution so to speak so um
08:44 - the one of the other principles that we
08:46 - need is this idea of selection so
08:48 - selection often referred to as survival
08:50 - of the fittest we have this idea nature
08:52 - that you know the most fit the strongest
08:54 - the thing that can run the fastest will
08:57 - you know make the most children but
08:59 - really what it is if you think about it
09:00 - is just survival of the survivors
09:02 - anything that lives longer for any
09:04 - reason whatsoever is more likely to
09:07 - reproduce so for but but you know that's
09:10 - nature and here what we actually
09:11 - unfortunately need to do in this
09:13 - particular computer simulation is we
09:15 - need to uh calculate uh Fitness so this
09:18 - is a mathematical formula that we're
09:20 - going to apply to these members of this
09:23 - population we're going to say we're
09:24 - going to evaluate their Fitness and this
09:26 - is how we perform perform selection once
09:29 - we've evaluated the fitness of all these
09:31 - elements we can pick the ones that
09:32 - should be selected to be parents so for
09:35 - example um what you know a really simple
09:37 - Fitness function for these would be
09:41 - count the number of letter characters
09:42 - they got correct b a d one c a r 2 got
09:47 - two h o g zero hat is also two p is zero
09:52 - so you can see oh wow this worked out
09:53 - really well by the way by accident so
09:56 - it's not just a character choice but
09:58 - it's position yes so you know this is an
10:01 - open interesting question in other
10:04 - scenarios the actual data could matter
10:07 - and and could be but this the this the
10:10 - this having an a the way the algorithm
10:12 - is going to work having an A in the
10:14 - first character would do us no good
10:16 - we're not shifting them around that that
10:18 - that that is a sort of discreet Chunk in
10:19 - that particular order so now we have
10:22 - this question of um what we're going to
10:24 - do what we need to do is make the the
10:26 - whole goal of this is to make the Next
10:27 - Generation so what is the next
10:30 - generation of I don't know what to call
10:32 - these creatures it's kind of silly to
10:33 - call these phrases phrases so the
10:35 - members of our population are phrases
10:37 - what is the next Generation we have to
10:39 - figure out a way to pick them now
10:41 - there's a lot of different strategies
10:42 - for performing selection in this type of
10:44 - simulation we could just say I don't
10:46 - care pick the best ones car and hat you
10:49 - make all the babies so car and hat just
10:50 - reproduce and make all the all the the
10:53 - the the the all the members of the Next
10:55 - Generation we could do something where
10:56 - we take the top half there are different
10:58 - strategies a a common sort of what a
11:01 - common strategy which I think in many
11:02 - ways is the best is a probabilistic
11:04 - approach so what we could do is assign
11:06 - the fitness values to be probabilities
11:09 - and we could say unfortunately P has a
11:11 - 0% chance uh hat has a 40% chance 0%
11:16 - chance uh 40% chance oh no sorry TW yes
11:20 - oh uh 40% 20% chance and if we add all
11:22 - those up we get 100% yes good job okay
11:25 - so you can see how I'm mapping these
11:27 - scores to probability
11:29 - and um typically speaking you're not
11:31 - really going to have Fitness values that
11:32 - are this simple which you're having just
11:34 - Z one and two so you're going to have a
11:36 - much more of a range of probabilities
11:37 - and this is really key because in a
11:39 - longer phrase we don't want we want to
11:43 - keep it's possible that this this one
11:46 - let's say Okay bad here even though it
11:48 - only got one right it could have a gem
11:50 - in there that isn't anywhere else in the
11:52 - population and we want even though it
11:54 - should be less likely than car or hat to
11:56 - be picked it still should be possible
11:58 - that it should get picked and I think
12:00 - kind of jumping around here but uh here
12:03 - so this is kind of an illustration of
12:04 - that you can think of it as all of the
12:06 - parents being this roulette wheel or
12:08 - this Wheel of Fortune with a where you
12:10 - spin it and what we're going to do is
12:11 - now over and over again in our genetic
12:13 - algorithm to make the Next Generation
12:15 - we're going to spin it twice pick two
12:18 - parents and we're going to make a child
12:21 - element from those and if we go back to
12:23 - the uh this algorithm it says the the so
12:27 - the next thing is reproduction so this
12:30 - so variation we got from initializing
12:32 - the population selection we get from
12:34 - this sort of awkward thing that I
12:36 - described of evaluating all the members
12:38 - of the population giving them a score
12:40 - then assigning those scores to
12:41 - probabilities and that's how we pick the
12:43 - next members now we need to reproduce
12:45 - and this is where the third principle of
12:48 - evolution comes in which is heredity we
12:50 - need a mechanism for passing the genetic
12:53 - information down to the Next Generation
12:55 - this may seem obvious to you and this
12:57 - the point of this example is that it's
12:59 - simple enough that hopefully this can
13:00 - seem somewhat intuitive and obvious but
13:02 - if you had to combine um hat and
13:07 - car you know we could look at this and
13:09 - say aha take the C from here take the a
13:13 - from here put those together and we have
13:15 - cat we're done but again we're not
13:16 - taking a top down approach here what
13:18 - we're doing is two things one is called
13:20 - crossover and one is called mutation and
13:23 - I think one of these
13:26 - diagrams uh yeah one of these diagrams
13:29 - just demonstrates this idea of crossover
13:31 - so crossover one um so if you if you've
13:35 - done any programming um you know
13:37 - something called an array an array is a
13:39 - list of information and usually most in
13:41 - my examples at least the DNA is encoded
13:44 - into an array of information an array of
13:45 - characters array of floating points an
13:47 - array I mean a true genetic algorithm be
13:49 - all just zeros and ones and that's all
13:51 - it ever is because it's you know much
13:52 - cooler that way or whatever but um but
13:54 - here we could say um what we're doing is
13:58 - we're picking half half of one and half
13:59 - of the other we could alternate we could
14:01 - sort of flip a coin for each gene so to
14:03 - speak for each element of the array
14:05 - heads pick from the left Tails pick from
14:07 - the right we could pick a random
14:08 - midpoint there's a lot of other options
14:10 - but that's the first step so the idea is
14:12 - to intermingle the genes of the parents
14:14 - into a new generation correct exactly
14:16 - and now we get this next we get a new we
14:19 - get we get this and and in theory we're
14:21 - picking parents that have performed well
14:23 - and by recombining their genetic
14:26 - information we're going to get a child
14:27 - that will perform equally well or
14:29 - hopefully by by by luck a little bit
14:31 - better um and so um but we want to add
14:34 - one more step here and this is kind of
14:36 - important because even though we got
14:38 - variation in the first step by making
14:40 - this random population we might not have
14:43 - enough variation right if we only have a
14:45 - population of 50 elements and we need to
14:48 - evolve to be or not to be there might NE
14:50 - there might not have been one with t as
14:52 - the first character and with crossover
14:54 - if there's no t as the first character
14:56 - we'll never ever get to be or not to be
14:58 - but but what mutation allows us to do is
15:00 - say at any point there is a small
15:03 - probability that after crossover one of
15:06 - the genes so to speak one of the
15:08 - elements of the array of the data would
15:10 - just randomly change so here we could
15:13 - say you can see here in this diagram we
15:15 - we got f r y and uh we change it to Foxy
15:19 - I guess um we you know um so we we we
15:22 - sort of flip a coin again and and mo
15:24 - typically a mutation rate would be
15:26 - something like a small probability 1% 2%
15:29 - somewhere around there so we say there's
15:30 - a 1% chance of of just changing one of
15:33 - those elements randomly and that
15:35 - introduces just additional variation
15:37 - into the
15:38 - system um does anybody want to ask any
15:42 - questions uh okay let's see here so okay
15:45 - so let's I'm going to come back to this
15:47 - but let's just look at I'm going to run
15:49 - this example now
15:51 - um so if I go into uh my chapter 9
15:55 - examples there is one example called G
15:59 - Shakespeare and I'm just going to run it
16:01 - and this is currently running basically
16:04 - this simulation that we talked about in
16:06 - processing so you can see on the right
16:08 - on the right left right on the right I'm
16:11 - going to do it this way um all uh stage
16:15 - right stage right yes all all of the
16:17 - current phrases in the population
16:18 - there's 150 they don't all fit into the
16:20 - window um it it after 764 we started
16:23 - with 150 random phrases there's a
16:26 - mutation rate of 1% and
16:29 - um after 764 Generations one of them
16:32 - happened to be the exactly right to be
16:34 - or not to be um so um some things that I
16:37 - would just want to kind of quickly
16:39 - demonstrate here is that again the point
16:42 - of this example is not that this this
16:44 - doesn't have any value right I could I
16:47 - could solve this problem in one line of
16:49 - code print to be or not to be that is
16:51 - the question right the point of this is
16:53 - if we want to sort of learn about
16:54 - genetic algorithm understand how they
16:56 - work we need a kind of example where the
16:58 - answer is unbelievably obvious so that's
17:00 - what we're kind of demonstrating here
17:02 - the other thing I just show you is that
17:04 - there's various variables that we can
17:05 - kind of play with um here for example if
17:09 - I were to suddenly just make the
17:10 - population
17:11 - 1,500 instead of 150 we got to to be or
17:15 - not to be in 38 Generations because we
17:17 - just have so much variety to work with
17:19 - so the other thing that we that I could
17:22 - um that I wanted to demonstrate here is
17:24 - if I make the mutation rate zero and the
17:27 - population only 150 this isn't enough
17:30 - variation for example we can see here
17:32 - there clearly was no second character
17:35 - ever that was an O there was no fourth
17:38 - character that was a b so we're just
17:39 - sort of stuck in to key a b or whatever
17:43 - but um so this idea of mutation is
17:45 - really important but of course um if we
17:48 - had 1500 elements again that's probably
17:51 - enough variety and boom we got it right
17:53 - there so it's kind of it's it's sort of
17:55 - you can play with some of these
17:56 - variables total population Nation that's
17:58 - a typo somebody do a pull pull request
18:01 - to fix that um there was something else
18:04 - I wanted to show here yeah okay so one
18:05 - of the other things I think is use
18:06 - important to see like even if I make the
18:08 - mutation rate
18:10 - 10% Like That is introducing so much
18:13 - Randomness into the system it's too much
18:16 - Randomness um you could think about it's
18:18 - likely that we're going to be randomly
18:19 - changing a character almost in every new
18:21 - member of the population so and to
18:24 - illustrate the point of that we need a
18:26 - lot of lifetimes of the universe if I
18:28 - made the utation rate 100% right this is
18:31 - this is the brute force method we're
18:33 - sitting here doing you know essentially
18:36 - 150 time 30 per per second uh random
18:40 - phrases and we're I mean there could be
18:42 - some kind of like amazing moment here
18:43 - where we actually got it but and then we
18:46 - realize then we should I'm going to go
18:48 - buy some lottery tickets if that happens
18:50 - okay um in this case what it's doing is
18:53 - it's just thrashing it with the whole
18:55 - phrase and if it doesn't get the whole
18:56 - phrase then it just moves off well right
18:57 - now it's actually running through the
18:59 - genetic algorithm but we've essentially
19:00 - negated the gentic algorithm because at
19:02 - the very last step we said I don't care
19:03 - what evolution you did I'm randomly
19:05 - mutating everything so it's as if we're
19:07 - just newly picking random elements every
19:10 - time so I you know I think there's I
19:12 - mean I'm sure there are lots of
19:14 - applications to this to solving
19:16 - different kinds of you know standard
19:17 - computer science problems data related
19:20 - problems the direction that I went
19:23 - in with um with the examples in the book
19:27 - is really in the animation and
19:29 - simulation Direction so I want to talk
19:32 - through a few um elements oh there's an
19:35 - eraser here I was using um I want to
19:37 - talk through a few
19:38 - elements um talk through a few other
19:40 - examples and then I think we can you can
19:42 - answer some questions and wrap up or
19:44 - whatever um so one thing that I kind of
19:47 - glossed over here is again uh I I don't
19:50 - know anything about actual science um
19:52 - there is something if you read about
19:56 - this kind of stuff called a genotype and
19:58 - and a
19:59 - phenotype and one thing this is a really
20:01 - important distinction that's actually
20:03 - sort of secretly happening behind the
20:04 - scenes here genotype we can think of as
20:06 - the data itself right the actual raw
20:09 - encoding the the bits the DNA itself
20:13 - phenotype is the expression of that data
20:16 - and um in this particular
20:20 - example this distinction is blurred
20:22 - there is no distinction here because the
20:24 - data is the phrase cat the expression of
20:27 - that is oh the phrase cat but when you
20:30 - actually go to use a genetic algorithm
20:31 - in a more of a real world scenario if
20:34 - you think of that Carl Sims um video
20:37 - that I showed the data might have been
20:39 - this kind of network diagram U data
20:42 - structure the expression was this kind
20:44 - of visual physics simulation we need to
20:46 - be able to have a mapping towards how
20:48 - are we what is our system is it
20:49 - something visual is it something is it
20:51 - behavioral and how do we encode that
20:53 - into data and this is you know in many
20:55 - ways if you look at these examples and
20:57 - you want to do a project with them you
20:58 - can just copy paste the code verbatim
21:01 - the the two things there probably three
21:03 - I'll think of more the things that you
21:05 - really have to think about are the
21:06 - fitness
21:09 - function you know what is that you know
21:11 - a a good Fitness function makes a
21:13 - genetic algorithm work well and then
21:16 - what is how are you encoding the data
21:17 - and how are you expressing that data so
21:19 - um there's a project from many years ago
21:22 - by J Thorp called uh smart Rockets I
21:26 - think I have that somewhere here uh okay
21:28 - I'll hit okay and um this is done in
21:31 - Flash I believe it's on the web I'm sure
21:33 - you can just Google smart Rockets jar
21:34 - Thorp and find it it's also referenced
21:36 - in the book but excuse me what's
21:39 - happening here and again this is just a
21:41 - search Problem by the way what's
21:42 - Happening Here is there are these
21:43 - rockets that launch from the bottom and
21:45 - the rockets launch from the bottom and
21:48 - uh they have um each rocket I might
21:51 - botch this slightly has like five
21:54 - thrusters attached to it that thrust in
21:57 - random directions
21:58 - so they're vectors they're forces that
22:00 - can Thrust out in random directions and
22:02 - the DNA the Gen genotype is the sequence
22:06 - of how those thrusters fire the
22:08 - expression is the actual physics
22:10 - stimulation of them moving so if you
22:12 - think about it here those these Rockets
22:14 - their goal is to reach the Target and um
22:19 - their Fitness function in this case is
22:21 - you know how close did they make it to
22:22 - the Target so inversely proportional to
22:24 - the distance the closer they get to the
22:26 - Target the higher the fitness so the
22:28 - ones that do better pass their genetic
22:30 - information to make new rockets for the
22:31 - next generation and if you run this over
22:33 - time you'll see these these Rockets
22:35 - start to evolve this really nice
22:36 - swooping path around that obstacle in
22:39 - the middle and there's some nice Design
22:41 - Elements here you can sort of see this
22:43 - path over time so um this is this is a
22:47 - nice example of kind of taking Genting
22:49 - Al we could say like there's a known
22:51 - solution here which is like I could go
22:54 - you know I don't want to mess up the the
22:56 - the screen I could go and draw a path
22:58 - like we could figure out possibly what's
22:59 - the but here we could imagine this being
23:01 - part of a some type of simulation a game
23:04 - a museum exhibit some interactive
23:06 - experience where the elements are
23:07 - evolving a certain Behavior if you were
23:09 - to move the obstacle around they would
23:11 - they would have to re-evolve A New Path
23:13 - I'm going to show you some examples like
23:14 - this in processing so
23:17 - um the second example I have in the book
23:20 - is essentially a simplified so Jar's has
23:22 - a lot of bells and whistles for looking
23:25 - nice and doing um extra features um
23:27 - there I in the in the book I have a very
23:30 - simple I think it's this one that I want
23:32 - to look at um very simple implementation
23:35 - of it it's it's much uglier less
23:38 - interesting to look at um I put that
23:40 - eraser somewhere I he it this um so the
23:43 - thing that I just wanted to mention here
23:45 - is that we're we kind of you have we
23:48 - have this question we have to answer
23:50 - which is that
23:52 - DNA as we saw we think of as this list
23:54 - of information it could be zeros and
23:57 - ones
23:59 - it could be as we saw characters you
24:02 - know I don't know what I'm writing here
24:04 - um in this case one of the things that's
24:07 - interesting about a couple of my
24:08 - examples or I like to think it's
24:09 - interesting at least is that the DNA is
24:12 - vectors so it's uh directions and
24:15 - magnitudes velocity vectors Force
24:17 - vectors so each each one of these
24:19 - Rockets has a kind of sequence of
24:21 - vectors that control its path and
24:23 - they're evolving if you know these take
24:26 - a little while to run but um
24:28 - if we ran it for a while it would evolve
24:30 - sort of this path around around that
24:32 - Target I'm GNA quickly so just to be so
24:35 - like when they they die and then
24:37 - everyone's evaluated yeah okay so I'm
24:39 - kind of meant to get to this but I'll
24:40 - just mention this for now so you may be
24:42 - wondering boy this doesn't seem very
24:44 - natural this is like this absurd way of
24:46 - thinking about Evolution right if we
24:47 - were to map what we've just done here or
24:49 - in the um to be not to be them into the
24:52 - real world it's it's as if we'd be
24:54 - saying okay let's evolve some monkeys
24:56 - let's get 20 monkeys in this room let's
24:58 - have them run around for a while we'll
24:59 - give them hats we'll put a score on them
25:01 - and then we'll tell which monkeys to
25:03 - mate and then they'll have babies and
25:05 - we'll kill all those monkeys and let the
25:06 - next monkeys run around so it the real
25:09 - world is much more fluid there's no
25:10 - scoring it's just so that is the the the
25:15 - that that is I think a sort of important
25:16 - distinction here and um the next uh was
25:21 - going to say the last the last example
25:23 - that I have to show you kind of ask that
25:25 - question of could we do a more fluid
25:27 - simulation where just things that live
25:29 - longer somehow through whatever
25:31 - arbitrary parameters have are more
25:33 - likely to then reproduce so yeah it's a
25:35 - little weird but you're right that's
25:36 - what's happening I'm letting the
25:38 - simulation run it gets to the times out
25:41 - I evaluate them make the Next Generation
25:43 - Um just to just show you one more
25:46 - example um which is basically the same
25:49 - thing but a little more uh interesting
25:52 - just in terms of the technical
25:54 - implementation so this is exactly the
25:56 - same thing just a lot more rockets and
25:58 - I'm visually just showing you the one
26:00 - that's kind of doing the best that
26:01 - generation and there's no obstacles here
26:03 - one thing I want to show you about this
26:05 - in the previous example each object's
26:07 - DNA was a linear list of
26:10 - vectors in this one their DNA what's in
26:13 - their brain is actually a flow field so
26:15 - a flow field is a two-dimensional grid
26:18 - of vectors you know those you can't tell
26:21 - whether which is pointing forward or
26:22 - back and what I'm showing you here but
26:24 - so the each one of those triangles is
26:27 - essentially looking at an arrow that
26:29 - sits underneath itself which tells it
26:31 - which way to move and in theory if we
26:33 - ran this for long enough what we would
26:35 - evolve hopefully I think you got it is
26:38 - just a lot of lines that point straight
26:40 - across um and one of the things that I
26:42 - think is kind of interesting to play
26:44 - with with this example is um I can kind
26:47 - of draw obstacles so if I draw a little
26:50 - obstacle here that blocks them and
26:53 - you'll you'll see it engage kind of in
26:54 - the Next Generation and they'll start to
26:56 - evolve a path around it um maybe what
27:00 - I'll do is draw a few obstacles here and
27:03 - then I'll let them I'll let oh it's
27:05 - going to be way too
27:08 - hard I didn't they didn't get very far
27:10 - in the first place but um anyway so
27:13 - you'll see once one gets kind of far
27:16 - it'll start to a few more of them will
27:18 - the next generation will kind of get
27:20 - there there's a lot of Randomness that
27:21 - play here I actually have the mutation
27:23 - rate very high in this particular
27:24 - scenario because I find that this is a
27:27 - difficult enough problem that there
27:28 - needs to be a lot of random fluctuation
27:29 - to get um around these kind of Corners
27:32 - so I'll try to let this run as I
27:35 - continue um to show you some more other
27:38 - things the fitness thing is kind of
27:39 - picking out the best guy until he dies
27:42 - yeah um so like right now he dies and
27:44 - then it picks another one no you know
27:45 - what I'm just uh draw highlighting
27:47 - whichever one is currently the best okay
27:49 - so it it changes over time um you know
27:52 - there were it was that that one for a
27:53 - little while now it's that one um so uh
27:57 - so I'm glad you mention that so so this
27:59 - idea of genotype and phenotype is
28:00 - important the fitness function is also
28:02 - really important um one thing I didn't
28:04 - mention is that our fitness function for
28:07 - to be or not to be that is the question
28:08 - was actually not a very good one just
28:10 - counting how many characters are right
28:12 - isn't very good and I I'll try to
28:14 - explain to you why let's say the target
28:16 - phrase was 8,000 characters long and we
28:19 - had one one member of the population
28:21 - that got 7,000 correct and one that got
28:24 - 7,000 And1 correct if we evaluate these
28:27 - if we turn these two numbers into
28:29 - probabilities the probability of picking
28:31 - one or the other is going to be very
28:33 - very very similar but 7,000 And1 is
28:36 - really a lot better than 7,000 so you'll
28:40 - see in a lot of these examples and I I
28:42 - think I have a like very very basic
28:45 - illustration of this right that in a lot
28:48 - of the examples if you go look at the
28:49 - code in the actual Fitness
28:51 - Formula that um we were mapping the
28:54 - number of characters correct
28:55 - exponentially so whether we Square or
28:58 - the power of this or whatever so that we
29:00 - ex the more characters we get correct
29:02 - the higher the score is exponentially so
29:04 - a linear mapping of number of characters
29:07 - correct to score and the same thing with
29:08 - distance so um that's something that
29:11 - you'll see in a lot of the how you tune
29:12 - that Fitness function can really affect
29:14 - how the system behaves and let's check
29:17 - on these guys because I'm afraid it's
29:19 - going to quit and we'll be very sad oh
29:21 - you know what it's it's running really
29:22 - slow because I'm drawing all those lines
29:24 - in the background which we don't need to
29:25 - do um
29:28 - see how well they're doing good pretty
29:30 - good so uh you'll see they'll make it
29:32 - there eventually I also not giving them
29:33 - very long amount of time to get there it
29:35 - cuts off before so I probably should
29:37 - have um tweaked those variables as well
29:39 - but okay so
29:41 - um yeah and in this case I'm also the
29:45 - other thing I should mention yes you
29:47 - feel like really attached to these
29:49 - little creatures maybe it just matches
29:50 - me um so uh the another thing I wanted
29:54 - to mention here is that one thing I'm
29:55 - also doing is they haven't reached reach
29:57 - the end yet but when they reach the end
29:59 - I keep track of the order of them so who
30:01 - was first who was second who was third
30:03 - and if you were first boy your Fitness
30:04 - is much higher that way they in theory
30:07 - you know they would optimize towards the
30:09 - fastest path as well um okay so so close
30:13 - don't change yeah no I'll let it run
30:14 - we'll come back you guys really want to
30:17 - watch this okay just I'll let it I'll
30:19 - let okay so the last thing I wanted to
30:20 - mention is and for those of you who are
30:23 - doing stuff on the web or web developers
30:26 - um this is this is probably where it
30:27 - might get even more relevant if or
30:30 - possibly I don't know um all of these
30:33 - examples I've shown you so far have
30:34 - taken an algorithmic approach to Fitness
30:37 - it's a mathematical function we're
30:39 - scoring the elements but we could take a
30:41 - different approach which is often known
30:42 - as interactive selection where we say
30:44 - Fitness is user-driven so in other words
30:47 - by that I say hey and so here's I
30:50 - apparently all I can use is Carl Sims as
30:52 - my examples but um Carl Sims has a
30:55 - project an art piece an art installation
30:56 - for many years
30:58 - ago uh uh called galap you can see how
31:01 - old this is by um you know this the
31:03 - state of the art the state of the art
31:05 - okay so this is called Galapagos and
31:07 - there're these monitors in a kind of
31:09 - gallery space there's sensors on the
31:10 - floor and they're showing these images
31:13 - and as anybody stands on one of those
31:15 - sensors it registers a value and what
31:17 - it's doing is it's assigning Fitness
31:19 - based on how long somebody is looking at
31:21 - something so it makes a kind there's a
31:24 - kind of open question here which is that
31:26 - you know what is that really evolving
31:28 - the most beautiful image the thing
31:29 - people are most likely to stand in front
31:31 - of who who knows but it is an
31:33 - interesting um technique for saying
31:36 - Fitness is user generated it's evaluated
31:39 - and the one thing about this is you know
31:41 - in to be or not to be we could do
31:42 - thousands of of generations per second
31:45 - right frames of Animation computer
31:47 - calculations this type of thing is very
31:49 - very slow people have to stand in front
31:51 - of it over long periods of time you know
31:54 - in a in a public space over years maybe
31:56 - you could get some data
31:57 - the place that I think something like
31:59 - this could really work is on the web
32:00 - where you have a distributed way of
32:02 - saying hey world everybody quick assign
32:05 - some fitnesses and we could evolve
32:07 - something maybe anyway um you know it's
32:09 - the SE at home kind of approach of of
32:12 - you know the mass audience kind of
32:14 - helping out a single problem so um and
32:17 - also like these are what the images look
32:19 - like I think they were all like these
32:20 - lisp sequences um anyway so um I wanted
32:24 - to show you just briefly a kind of
32:26 - simple so here is the so inter
32:29 - interactive selection is really
32:30 - interesting I've seen people do it with
32:31 - music with images um I saw a project
32:34 - which was like evolving cell phone rings
32:37 - um ringtones but here I have what might
32:40 - possibly be the lamest example of
32:42 - interactive selection ever but just to
32:44 - demonstrate the point um these are a
32:46 - bunch of designs for faces they have
32:49 - there's a there's data here the data is
32:52 - color size position U width of the mouth
32:56 - and what what this example does is it
32:58 - allows you to say okay um I really like
33:00 - green so I really like this one I'm
33:02 - giving that a much higher score when I
33:04 - evolve the Next Generation you can see
33:06 - you know I did that in a very um I only
33:09 - rated one of them but I could say I like
33:10 - this one a lot and this one a little bit
33:13 - and you can see I'm starting to mix and
33:14 - match there's some mutation in there so
33:17 - again there's nothing particularly
33:19 - exciting visually about this or even
33:22 - that creative in its thinking but it
33:23 - demonstrates the process of creating a
33:26 - visual Based on data and one of the
33:28 - things about this example is that every
33:30 - the DNA this is a kind of a nice
33:32 - technique every element in the in the
33:34 - DNA is just a floating Point number
33:35 - between 0o and one one thing that's nice
33:38 - about that is you can always map a
33:39 - number between 0 one to any range so I
33:42 - could say this is the red value and I
33:45 - map it to 0255 this is the green value
33:48 - 05 this is like the I size I map it from
33:52 - 10 to 20 so you can have this kind of
33:54 - generic DNA where everything's a
33:55 - floating point value and then map that
33:58 - those values to the design of something
34:00 - you know for I would say if you're
34:01 - looking to create a design you know
34:03 - thinking of a node based approach or
34:06 - there you know parameter based approach
34:07 - there's lots of other possibilities
34:09 - there um okay so I think I'm kind of
34:12 - nearing the end of the end of time maybe
34:16 - we have the to be or not to be that's
34:17 - the question by now let's check on uh oh
34:20 - that's is that the same one yeah oh yeah
34:24 - see see kind is not highlighting the guy
34:26 - that right so you know what the problem
34:28 - with that is we don't I don't know which
34:30 - one's going to get there so I could run
34:33 - it secret twice like I could zoom
34:35 - through it figure out which one it is
34:37 - it's funny I actually just added most
34:39 - did made this example most of it this
34:40 - afternoon so I what's what's so cool
34:42 - about this is that the guy that ends up
34:44 - winning is not the winner for a lot for
34:47 - like the first third of it right yeah
34:50 - there's a lot of mess going on here and
34:52 - what's interesting what I don't like
34:54 - what I what's interesting about this is
34:55 - that you know there's really only a
34:57 - small number of vectors that are really
34:58 - at play here all that stuff in the
35:00 - corner like it's not being used it's
35:02 - just it's only just random because
35:04 - anyone going up there is kind of lost
35:05 - and off is not going to be picked so
35:07 - there's it would be nice if what I was
35:09 - hoping visualizing the flow field is
35:11 - that eventually you could really see the
35:13 - flow field the path of the flow field
35:15 - it's kind of happening more mysteriously
35:18 - um but I think there's probably other
35:19 - ways of visualizing this that could be
35:21 - kind of interesting to demonstrate the
35:23 - process and so so each node or each guy
35:27 - has the entire flow field as its
35:31 - DNA that's correct so it's a
35:34 - two-dimensional array of vectors in the
35:36 - example so it's crunching a lot of
35:37 - numbers to do
35:39 - this yeah yes yes I think you said
35:43 - earlier that it's um one that gets their
35:47 - first gets higher priority but it's not
35:49 - in direct correlation with how fast it
35:51 - get them no you're right yes so I didn't
35:52 - actually time them and use their time to
35:55 - Fitness which I could have I just quick
35:56 - quickly ordered them and said number one
35:58 - Higher number two yeah so you're right
36:01 - if it's sort of the fitness function is
36:04 - really here just mapped to as if they
36:05 - like all finished in like perfect lock
36:07 - step timing yeah but you could use their
36:10 - time but you absolutely could use their
36:11 - time yes for for c for
36:14 - sure um you know the other thing about
36:17 - this is I'm you know most of these are
36:18 - kind of pure but I'm trying to with
36:21 - these examples not put any top- down
36:23 - thinking onto this but you could do
36:26 - certain things like I could have maybe
36:27 - seated the system with all the vectors
36:29 - pointing to the right start and that
36:31 - might have given us at least you know
36:33 - more we might be able sort see that path
36:35 - more clearly without it all being random
36:37 - to start So eventually all of these guys
36:39 - are going to figure out a better path no
36:42 - there's so much mutation that I think at
36:45 - this point it's probably going to look
36:46 - like this forever but I think we'll get
36:49 - we'll get some marginal improvements
36:51 - like there will be some some they'll
36:53 - start to get a little bit faster you're
36:54 - right if I use time that would would
36:56 - really help that's a great
36:59 - idea um yeah because right now it's just
37:02 - getting there first if everybody's
37:04 - really slow you know so yeah um so let
37:08 - me just show you this last example and
37:09 - then we can kind of be finished so um I
37:12 - think I have a a diagram that I'll just
37:14 - kind of use oh here it is um so um I
37:19 - there's the last example I want to show
37:20 - you just demonstrates the idea of a kind
37:22 - of more I'm calling an ecosystem
37:24 - simulation so more like the real world
37:26 - would work so we have these creatures
37:29 - called bloops and they're either big or
37:31 - small or they have a size they have one
37:34 - their DNA is one number a single number
37:36 - it maps to their size and how fast they
37:39 - move so the big ones move very slowly
37:42 - the small ones move very fast and they
37:45 - need to eat food to survive and there's
37:47 - food in the system so if I run this
37:50 - simulation
37:53 - now uh I'll leave all these running I
37:55 - guess
37:57 - sorry ah I can't it's very hard to use
37:59 - your my computer in this strange
38:02 - configuration okay oh here we go um
38:05 - Evolution
38:06 - ecosystem okay so let me run this one
38:08 - hopefully this will work and what's
38:11 - happening here all of these creatures so
38:12 - this is I guess a simulation of asexual
38:14 - reproduction um each creature just
38:17 - clones itself when it has a baby so at
38:21 - any moment in time there is a small
38:23 - probability that it will clone itself so
38:25 - the ones that live long longer just have
38:27 - a longer amount of time to have that
38:29 - happen and one thing you'll notice here
38:31 - if um is that the system tends to evolve
38:34 - towards medium-sized objects so it's not
38:37 - that interesting of a result the big
38:38 - ones are really good at intersecting the
38:40 - food but they move too slowly so they
38:42 - don't really find the food the little
38:44 - ones are move super fast but they're so
38:47 - tiny they don't seem to run into the
38:48 - food that often so medium tends to be
38:51 - about the right um the right the the
38:53 - kind of the perfect size to intersect
38:56 - the food and move about the space and so
38:58 - so the food is getting randomly
38:59 - distributed yeah it starts with a random
39:01 - amount of food and then um I think when
39:04 - they die they leave food so what the
39:06 - only thing that I find the only
39:09 - unexpected result that I've noticed here
39:10 - is sometimes there's a cluster of big
39:12 - ones that just like a lot of them die
39:14 - and there's a lot of food in one area
39:16 - and then there's another big one that
39:17 - just keeps eating it and making new big
39:19 - ones so a little cluster of big ones can
39:20 - kind of survive for a while in one part
39:22 - of the screen um so this is to me what
39:25 - kind of thinking the most basic way I
39:28 - mean there's so many things you could do
39:30 - to a simulation like this to make it
39:32 - more sophisticated for example you could
39:34 - give these creatures some intelligence I
39:36 - have a whole section about steering
39:38 - behaviors so you could allow them to
39:39 - kind of see where the food is choose to
39:42 - seek the food avoid a predator you could
39:45 - also uh add things like they only make a
39:47 - child when they come together for a
39:49 - certain amount of time so um so there's
39:51 - a lot more that you could do with a
39:53 - simulation like this but this just kind
39:55 - of at least demonstrates the idea
39:56 - there's no Fitness function and there's
39:59 - no Generations it's just a system that
40:01 - lives the the circles are moving around
40:04 - they live or die and they reproduce and
40:07 - eventually um I guess I added so many
40:10 - it's kind of still has a lot of variety
40:11 - there but if we run this for a while you
40:13 - you'll tend to see that um it mostly
40:15 - ends up with medium siiz um elements
40:18 - what determines their movement um it's
40:20 - so it's it's I'm using something called
40:21 - pein noise in this example pearlin noise
40:23 - is like a smooth Randomness so there
40:26 - there's no it it's kind of um a quick
40:29 - way to get things look like they're
40:30 - wandering around the screen but um just
40:33 - to now I'm kind of uh jumping around
40:36 - here a little bit but uh if you're
40:38 - interested in this type of ecosystem
40:41 - simulation I would recommend taking a
40:43 - look at um Craig Reynold steering
40:44 - behaviors and I have I'll just show you
40:47 - like here's an example of one this is
40:49 - all
40:50 - um from the chapter six in the book and
40:53 - so this is an example of crowd path
40:55 - following so here are entities that are
40:57 - following a path as well as trying not
40:59 - to run into each other so one thing that
41:01 - I always say as a exercise for uh
41:04 - students in the class is build a system
41:07 - where autonomous agents have a wide
41:09 - variety of steering behaviors and make
41:11 - the weights of those behaviors their DNA
41:13 - so how much they try to follow a path
41:15 - versus avoid a neighbor versus seek food
41:17 - versus run away from a predator see if
41:19 - you can evolve some type of optimal
41:21 - Behavior this the weights for these
41:22 - steering forces are just hardcoded in so
41:24 - they follow the path and um but so
41:27 - combining this kind of intelligence of
41:28 - an autonomous agent with a genetic
41:30 - algorithm is perhaps you know something
41:32 - that could yield some
41:35 - results other
41:38 - questions I think that's I finished with
41:41 - all of the examples with genetic
41:43 - algorithms like where are people taking
41:45 - it right now um you know that's a good
41:47 - question I don't know that I really know
41:48 - the answer to that I mean I think there
41:50 - is kind of a state-of-the-art in
41:51 - computer science research um for me I
41:54 - see this kind of work um in in in in um
41:57 - game design a lot with really
41:59 - interesting results so you could think
42:00 - about if you're trying to create
42:01 - autonomous characters in a game that can
42:03 - adapt to the way a player you could
42:05 - certainly use this in like Museum
42:07 - exhibits as well that's sort of more
42:08 - that the space that I see at ITP at
42:10 - least um kind of picking and choosing
42:13 - from the kind of computer science
42:14 - research what's kind of easy to
42:16 - understand and use and apply um vers
42:18 - rather than kind of dig deep into the
42:20 - the depths of the
42:24 - stuff thank you so much great thank
42:32 - you

Cleaned transcript:

okay so I'm going to talk about genetic algorithms and I first encountered genetic algorithms with um by watching this video this is from 94 um I'm going to uh play a little bit of it for you um this is a project called I'm going to just turn the sound off although um this is a project called evolved virtual creatures actually the nice thing if you I encourage you to Google this and watch it it's Carl Sims evolved virtual creatures and um the the the audio soundtrack is kind of nice because it's like a National Geographic style uh video but it's all computer generated uh creatures so what Carl Sims did with this project is create essentially this physics framework for making these creatures they're all these node based creatures so all these creatures are essentially if I were to diagram them they're kind of you can think of them as particles with spring Connections in a way so they're boxes um and these spring connections are muscles and they can expand and contract and so car Sims was able to encode the design for these creatures into a virtual DNA and then say hey let me stick them all into this physics world and see how they do the ones that run really fast jump really high swim really well there's a water simulation in a little bit those are the ones that I will pick as parents quote unquote to make a strange virtual creature baby um for the next generation and they'll get the better that they do the more likely they are to reproduce and he evolved these creatures to to perform different tasks and so looking at this I was looking at this at a time where I was super fascinated with just even just trying to model kind of basic physics um and so I wanted to see if I could make something like this yeah this is this is the running sequence um this is the jumping sequence skip ahead a little bit this is following a red dot while swimming um and what's really amazing about this is it's very unexpected like you would never design a creature to look like that or do like that but this one is very very good at kind of swimming around in this water environment and um and at the end here there's this like hockey like competition where all these different creatures try to compete for this green Cube so I and so he would he would build these algorithms and then like kind of set them up in this like physics 3D environment and then have to like churn out frame by frame what would happen right so you know I don't know that's a good question I don't know the exact process that he used because in theory you don't need to watch the simulation in order to find out the result he might have just like but we're watching the res we're watching certain creatures that were evolved and then seeing them play out but it's all just data it's all just numbers and that's kind of what I wanted to get to into a description for how this worked and it's like funny they have all these weird gestures but there's a great um all of this is linked um on the nature of code website there's a further reading section and there's a paper by Sims which outlines how all this works and the design of these creatures um this one's a cruel one that likes to beat up on it um so that I'm I'm really not doing Justice to the soundtrack is really quite nice but you can watch that on your own time um okay so what I wanted to start with is kind of talking through okay so the thing about genetic algorithms is I for the book I kind of divided my thinking into three um different categories let me just erase this um which um uh you know there is this genetic algorithms were developed for solving certain kinds of computer science problems search problems where a brute force method is no good so if you need to check every possibility it would take too long maybe we could evolve towards the right answer and then there there's this category called interactive selection which is really used in art and design and I'm going to show you some examples of that and then this idea of thinking of um ecosystem simulation so what I wanted to talk about first is the um now it looks like I have a prepared presentation but these are just images from the book but um so I wanted to talk about the infinite monkey theorem which is kind kind of a classic classic test case uh classic example of an application of genetic algorithm so the infinite monkey theorem if you're not familiar with it is this idea that oh if we had an infinite number of monkeys and an infinite number of time and they're all just randomly typing at these keyboards typ typewriters typewriters maybe keyboards iPads I don't know um that eventually they would type the complete works of shakespare and so this is theoretically true I suppose I believe to be true yes it is theoretic true but the the problem is it's not something we could ever understand or or experience in our lifetime and just to like make this argument for a second so let's say we have just the phrase to be or not to be that is the question that phrase is 39 characters long so let's say we have a simplified keyboard it only has 26 characters and one spacebar so just to type a t there's a one in 27 chance of typing a t right now if you know anything about probability event probability if we have if we want the probability of two events happening in sequence we multiply the probabilities together so the chance of typing to is one 1 out of 27 * 1 out of 27 so the whole phrase 1 over 27 to the 39th power is a one in that big number a chance of that occurring randomly so that's a very large number which is kind of hard to even fathom but that's not even for the complete works of Shakespeare that's just for to be or not to be the question so and I I I worked it out a little bit with that if um there's a similar discussion by the way on Wikipedia if you go to infinite monkey theorem which kind of goes through um uh the same sort of stuff but if you if you were able to have a computer simulation that could do 1 million random phrases per second it would take that many years for there to be I don't think I put this up here for there would be a 99% probability that you would have at least gotten to be or not to be that is the question somewhere in there so if that's much longer than the entire much much much longer than the uh age of the entire universe I think like on Wikipedia when I was reading it the the other day it said something like if you had a monkey for every atom in the entire universe it would still take you know anyway just way too long that we can't possibly understand so the point this is a stupid problem right because we could just type to be or not to be the question that is the question if we needed it but it it illustrates the point that there are some problems for which you don't know the answer like we know the answer here some problems that you don't know the answer for which uh it still it would take that long by brute force method so a genetic algorithm is a way of saying okay what if we had a population of phrases so let's just say to simplify for a second we're trying to evolve the phrase cat and we had a population of phrases like bad car I don't know hog it's very hard to think of I was going to say p as a threeletter word I don't know um I can only think of like weird uncomfortable word anyway the bunch of uh hat hat is good what what paa you're good P what paa paa thank you there you go um okay so a bunch of of of of phrases what we could do is evaluate these so the way the genetic algorithm works and I think I have you know I like to sort of write this out but I'll just use these um there's this this very specific algorithm and I'm using by the way the word setup and draw are some are things that are very specific to processing this algorithm Works where there is kind of this moment of begin like the big bang happens and there's this initial population that's seated and then there's something that happens over and over again a new generation is born evaluated a new generation is born so the very first thing that okay so one of the things I should mention is that um if you look at darwinian Natural Selection by the way I don't really know anything about biology and evolution so I you know and that's the nice thing about doing this stuff in like Pro you know computer programming you and just like make it up and be I'm like Inspire it's like it's like the TV shows where they say inspired by actual events that's what this is um it's not fired by actual science yeah fired by actual science so there's heredity uh selection and I would like to write first uh variation so if you think about darwinian um Evolution these are three key principles that need to be present for evolution to happen one thing is that we need to have variation so we would never be able to get to be or not to be if we just had you know one phrase to start with and all we could ever do is combine and recombine that one phrase we'd only ever have that one phrase if we only ever had bad we could never get to cat but if we have a random um if we seed our initial population that's the first thing we do with a random um set of elements then uh we have variation and we have the chance to evolve towards some optimal solution so to speak so um the one of the other principles that we need is this idea of selection so selection often referred to as survival of the fittest we have this idea nature that you know the most fit the strongest the thing that can run the fastest will you know make the most children but really what it is if you think about it is just survival of the survivors anything that lives longer for any reason whatsoever is more likely to reproduce so for but but you know that's nature and here what we actually unfortunately need to do in this particular computer simulation is we need to uh calculate uh Fitness so this is a mathematical formula that we're going to apply to these members of this population we're going to say we're going to evaluate their Fitness and this is how we perform perform selection once we've evaluated the fitness of all these elements we can pick the ones that should be selected to be parents so for example um what you know a really simple Fitness function for these would be count the number of letter characters they got correct b a d one c a r 2 got two h o g zero hat is also two p is zero so you can see oh wow this worked out really well by the way by accident so it's not just a character choice but it's position yes so you know this is an open interesting question in other scenarios the actual data could matter and and could be but this the this the this having an a the way the algorithm is going to work having an A in the first character would do us no good we're not shifting them around that that that that is a sort of discreet Chunk in that particular order so now we have this question of um what we're going to do what we need to do is make the the whole goal of this is to make the Next Generation so what is the next generation of I don't know what to call these creatures it's kind of silly to call these phrases phrases so the members of our population are phrases what is the next Generation we have to figure out a way to pick them now there's a lot of different strategies for performing selection in this type of simulation we could just say I don't care pick the best ones car and hat you make all the babies so car and hat just reproduce and make all the all the the the the the all the members of the Next Generation we could do something where we take the top half there are different strategies a a common sort of what a common strategy which I think in many ways is the best is a probabilistic approach so what we could do is assign the fitness values to be probabilities and we could say unfortunately P has a 0% chance uh hat has a 40% chance 0% chance uh 40% chance oh no sorry TW yes oh uh 40% 20% chance and if we add all those up we get 100% yes good job okay so you can see how I'm mapping these scores to probability and um typically speaking you're not really going to have Fitness values that are this simple which you're having just Z one and two so you're going to have a much more of a range of probabilities and this is really key because in a longer phrase we don't want we want to keep it's possible that this this one let's say Okay bad here even though it only got one right it could have a gem in there that isn't anywhere else in the population and we want even though it should be less likely than car or hat to be picked it still should be possible that it should get picked and I think kind of jumping around here but uh here so this is kind of an illustration of that you can think of it as all of the parents being this roulette wheel or this Wheel of Fortune with a where you spin it and what we're going to do is now over and over again in our genetic algorithm to make the Next Generation we're going to spin it twice pick two parents and we're going to make a child element from those and if we go back to the uh this algorithm it says the the so the next thing is reproduction so this so variation we got from initializing the population selection we get from this sort of awkward thing that I described of evaluating all the members of the population giving them a score then assigning those scores to probabilities and that's how we pick the next members now we need to reproduce and this is where the third principle of evolution comes in which is heredity we need a mechanism for passing the genetic information down to the Next Generation this may seem obvious to you and this the point of this example is that it's simple enough that hopefully this can seem somewhat intuitive and obvious but if you had to combine um hat and car you know we could look at this and say aha take the C from here take the a from here put those together and we have cat we're done but again we're not taking a top down approach here what we're doing is two things one is called crossover and one is called mutation and I think one of these diagrams uh yeah one of these diagrams just demonstrates this idea of crossover so crossover one um so if you if you've done any programming um you know something called an array an array is a list of information and usually most in my examples at least the DNA is encoded into an array of information an array of characters array of floating points an array I mean a true genetic algorithm be all just zeros and ones and that's all it ever is because it's you know much cooler that way or whatever but um but here we could say um what we're doing is we're picking half half of one and half of the other we could alternate we could sort of flip a coin for each gene so to speak for each element of the array heads pick from the left Tails pick from the right we could pick a random midpoint there's a lot of other options but that's the first step so the idea is to intermingle the genes of the parents into a new generation correct exactly and now we get this next we get a new we get we get this and and in theory we're picking parents that have performed well and by recombining their genetic information we're going to get a child that will perform equally well or hopefully by by by luck a little bit better um and so um but we want to add one more step here and this is kind of important because even though we got variation in the first step by making this random population we might not have enough variation right if we only have a population of 50 elements and we need to evolve to be or not to be there might NE there might not have been one with t as the first character and with crossover if there's no t as the first character we'll never ever get to be or not to be but but what mutation allows us to do is say at any point there is a small probability that after crossover one of the genes so to speak one of the elements of the array of the data would just randomly change so here we could say you can see here in this diagram we we got f r y and uh we change it to Foxy I guess um we you know um so we we we sort of flip a coin again and and mo typically a mutation rate would be something like a small probability 1% 2% somewhere around there so we say there's a 1% chance of of just changing one of those elements randomly and that introduces just additional variation into the system um does anybody want to ask any questions uh okay let's see here so okay so let's I'm going to come back to this but let's just look at I'm going to run this example now um so if I go into uh my chapter 9 examples there is one example called G Shakespeare and I'm just going to run it and this is currently running basically this simulation that we talked about in processing so you can see on the right on the right left right on the right I'm going to do it this way um all uh stage right stage right yes all all of the current phrases in the population there's 150 they don't all fit into the window um it it after 764 we started with 150 random phrases there's a mutation rate of 1% and um after 764 Generations one of them happened to be the exactly right to be or not to be um so um some things that I would just want to kind of quickly demonstrate here is that again the point of this example is not that this this doesn't have any value right I could I could solve this problem in one line of code print to be or not to be that is the question right the point of this is if we want to sort of learn about genetic algorithm understand how they work we need a kind of example where the answer is unbelievably obvious so that's what we're kind of demonstrating here the other thing I just show you is that there's various variables that we can kind of play with um here for example if I were to suddenly just make the population 1,500 instead of 150 we got to to be or not to be in 38 Generations because we just have so much variety to work with so the other thing that we that I could um that I wanted to demonstrate here is if I make the mutation rate zero and the population only 150 this isn't enough variation for example we can see here there clearly was no second character ever that was an O there was no fourth character that was a b so we're just sort of stuck in to key a b or whatever but um so this idea of mutation is really important but of course um if we had 1500 elements again that's probably enough variety and boom we got it right there so it's kind of it's it's sort of you can play with some of these variables total population Nation that's a typo somebody do a pull pull request to fix that um there was something else I wanted to show here yeah okay so one of the other things I think is use important to see like even if I make the mutation rate 10% Like That is introducing so much Randomness into the system it's too much Randomness um you could think about it's likely that we're going to be randomly changing a character almost in every new member of the population so and to illustrate the point of that we need a lot of lifetimes of the universe if I made the utation rate 100% right this is this is the brute force method we're sitting here doing you know essentially 150 time 30 per per second uh random phrases and we're I mean there could be some kind of like amazing moment here where we actually got it but and then we realize then we should I'm going to go buy some lottery tickets if that happens okay um in this case what it's doing is it's just thrashing it with the whole phrase and if it doesn't get the whole phrase then it just moves off well right now it's actually running through the genetic algorithm but we've essentially negated the gentic algorithm because at the very last step we said I don't care what evolution you did I'm randomly mutating everything so it's as if we're just newly picking random elements every time so I you know I think there's I mean I'm sure there are lots of applications to this to solving different kinds of you know standard computer science problems data related problems the direction that I went in with um with the examples in the book is really in the animation and simulation Direction so I want to talk through a few um elements oh there's an eraser here I was using um I want to talk through a few elements um talk through a few other examples and then I think we can you can answer some questions and wrap up or whatever um so one thing that I kind of glossed over here is again uh I I don't know anything about actual science um there is something if you read about this kind of stuff called a genotype and and a phenotype and one thing this is a really important distinction that's actually sort of secretly happening behind the scenes here genotype we can think of as the data itself right the actual raw encoding the the bits the DNA itself phenotype is the expression of that data and um in this particular example this distinction is blurred there is no distinction here because the data is the phrase cat the expression of that is oh the phrase cat but when you actually go to use a genetic algorithm in a more of a real world scenario if you think of that Carl Sims um video that I showed the data might have been this kind of network diagram U data structure the expression was this kind of visual physics simulation we need to be able to have a mapping towards how are we what is our system is it something visual is it something is it behavioral and how do we encode that into data and this is you know in many ways if you look at these examples and you want to do a project with them you can just copy paste the code verbatim the the two things there probably three I'll think of more the things that you really have to think about are the fitness function you know what is that you know a a good Fitness function makes a genetic algorithm work well and then what is how are you encoding the data and how are you expressing that data so um there's a project from many years ago by J Thorp called uh smart Rockets I think I have that somewhere here uh okay I'll hit okay and um this is done in Flash I believe it's on the web I'm sure you can just Google smart Rockets jar Thorp and find it it's also referenced in the book but excuse me what's happening here and again this is just a search Problem by the way what's Happening Here is there are these rockets that launch from the bottom and the rockets launch from the bottom and uh they have um each rocket I might botch this slightly has like five thrusters attached to it that thrust in random directions so they're vectors they're forces that can Thrust out in random directions and the DNA the Gen genotype is the sequence of how those thrusters fire the expression is the actual physics stimulation of them moving so if you think about it here those these Rockets their goal is to reach the Target and um their Fitness function in this case is you know how close did they make it to the Target so inversely proportional to the distance the closer they get to the Target the higher the fitness so the ones that do better pass their genetic information to make new rockets for the next generation and if you run this over time you'll see these these Rockets start to evolve this really nice swooping path around that obstacle in the middle and there's some nice Design Elements here you can sort of see this path over time so um this is this is a nice example of kind of taking Genting Al we could say like there's a known solution here which is like I could go you know I don't want to mess up the the the screen I could go and draw a path like we could figure out possibly what's the but here we could imagine this being part of a some type of simulation a game a museum exhibit some interactive experience where the elements are evolving a certain Behavior if you were to move the obstacle around they would they would have to reevolve A New Path I'm going to show you some examples like this in processing so um the second example I have in the book is essentially a simplified so Jar's has a lot of bells and whistles for looking nice and doing um extra features um there I in the in the book I have a very simple I think it's this one that I want to look at um very simple implementation of it it's it's much uglier less interesting to look at um I put that eraser somewhere I he it this um so the thing that I just wanted to mention here is that we're we kind of you have we have this question we have to answer which is that DNA as we saw we think of as this list of information it could be zeros and ones it could be as we saw characters you know I don't know what I'm writing here um in this case one of the things that's interesting about a couple of my examples or I like to think it's interesting at least is that the DNA is vectors so it's uh directions and magnitudes velocity vectors Force vectors so each each one of these Rockets has a kind of sequence of vectors that control its path and they're evolving if you know these take a little while to run but um if we ran it for a while it would evolve sort of this path around around that Target I'm GNA quickly so just to be so like when they they die and then everyone's evaluated yeah okay so I'm kind of meant to get to this but I'll just mention this for now so you may be wondering boy this doesn't seem very natural this is like this absurd way of thinking about Evolution right if we were to map what we've just done here or in the um to be not to be them into the real world it's it's as if we'd be saying okay let's evolve some monkeys let's get 20 monkeys in this room let's have them run around for a while we'll give them hats we'll put a score on them and then we'll tell which monkeys to mate and then they'll have babies and we'll kill all those monkeys and let the next monkeys run around so it the real world is much more fluid there's no scoring it's just so that is the the the that that is I think a sort of important distinction here and um the next uh was going to say the last the last example that I have to show you kind of ask that question of could we do a more fluid simulation where just things that live longer somehow through whatever arbitrary parameters have are more likely to then reproduce so yeah it's a little weird but you're right that's what's happening I'm letting the simulation run it gets to the times out I evaluate them make the Next Generation Um just to just show you one more example um which is basically the same thing but a little more uh interesting just in terms of the technical implementation so this is exactly the same thing just a lot more rockets and I'm visually just showing you the one that's kind of doing the best that generation and there's no obstacles here one thing I want to show you about this in the previous example each object's DNA was a linear list of vectors in this one their DNA what's in their brain is actually a flow field so a flow field is a twodimensional grid of vectors you know those you can't tell whether which is pointing forward or back and what I'm showing you here but so the each one of those triangles is essentially looking at an arrow that sits underneath itself which tells it which way to move and in theory if we ran this for long enough what we would evolve hopefully I think you got it is just a lot of lines that point straight across um and one of the things that I think is kind of interesting to play with with this example is um I can kind of draw obstacles so if I draw a little obstacle here that blocks them and you'll you'll see it engage kind of in the Next Generation and they'll start to evolve a path around it um maybe what I'll do is draw a few obstacles here and then I'll let them I'll let oh it's going to be way too hard I didn't they didn't get very far in the first place but um anyway so you'll see once one gets kind of far it'll start to a few more of them will the next generation will kind of get there there's a lot of Randomness that play here I actually have the mutation rate very high in this particular scenario because I find that this is a difficult enough problem that there needs to be a lot of random fluctuation to get um around these kind of Corners so I'll try to let this run as I continue um to show you some more other things the fitness thing is kind of picking out the best guy until he dies yeah um so like right now he dies and then it picks another one no you know what I'm just uh draw highlighting whichever one is currently the best okay so it it changes over time um you know there were it was that that one for a little while now it's that one um so uh so I'm glad you mention that so so this idea of genotype and phenotype is important the fitness function is also really important um one thing I didn't mention is that our fitness function for to be or not to be that is the question was actually not a very good one just counting how many characters are right isn't very good and I I'll try to explain to you why let's say the target phrase was 8,000 characters long and we had one one member of the population that got 7,000 correct and one that got 7,000 And1 correct if we evaluate these if we turn these two numbers into probabilities the probability of picking one or the other is going to be very very very similar but 7,000 And1 is really a lot better than 7,000 so you'll see in a lot of these examples and I I think I have a like very very basic illustration of this right that in a lot of the examples if you go look at the code in the actual Fitness Formula that um we were mapping the number of characters correct exponentially so whether we Square or the power of this or whatever so that we ex the more characters we get correct the higher the score is exponentially so a linear mapping of number of characters correct to score and the same thing with distance so um that's something that you'll see in a lot of the how you tune that Fitness function can really affect how the system behaves and let's check on these guys because I'm afraid it's going to quit and we'll be very sad oh you know what it's it's running really slow because I'm drawing all those lines in the background which we don't need to do um see how well they're doing good pretty good so uh you'll see they'll make it there eventually I also not giving them very long amount of time to get there it cuts off before so I probably should have um tweaked those variables as well but okay so um yeah and in this case I'm also the other thing I should mention yes you feel like really attached to these little creatures maybe it just matches me um so uh the another thing I wanted to mention here is that one thing I'm also doing is they haven't reached reach the end yet but when they reach the end I keep track of the order of them so who was first who was second who was third and if you were first boy your Fitness is much higher that way they in theory you know they would optimize towards the fastest path as well um okay so so close don't change yeah no I'll let it run we'll come back you guys really want to watch this okay just I'll let it I'll let okay so the last thing I wanted to mention is and for those of you who are doing stuff on the web or web developers um this is this is probably where it might get even more relevant if or possibly I don't know um all of these examples I've shown you so far have taken an algorithmic approach to Fitness it's a mathematical function we're scoring the elements but we could take a different approach which is often known as interactive selection where we say Fitness is userdriven so in other words by that I say hey and so here's I apparently all I can use is Carl Sims as my examples but um Carl Sims has a project an art piece an art installation for many years ago uh uh called galap you can see how old this is by um you know this the state of the art the state of the art okay so this is called Galapagos and there're these monitors in a kind of gallery space there's sensors on the floor and they're showing these images and as anybody stands on one of those sensors it registers a value and what it's doing is it's assigning Fitness based on how long somebody is looking at something so it makes a kind there's a kind of open question here which is that you know what is that really evolving the most beautiful image the thing people are most likely to stand in front of who who knows but it is an interesting um technique for saying Fitness is user generated it's evaluated and the one thing about this is you know in to be or not to be we could do thousands of of generations per second right frames of Animation computer calculations this type of thing is very very slow people have to stand in front of it over long periods of time you know in a in a public space over years maybe you could get some data the place that I think something like this could really work is on the web where you have a distributed way of saying hey world everybody quick assign some fitnesses and we could evolve something maybe anyway um you know it's the SE at home kind of approach of of you know the mass audience kind of helping out a single problem so um and also like these are what the images look like I think they were all like these lisp sequences um anyway so um I wanted to show you just briefly a kind of simple so here is the so inter interactive selection is really interesting I've seen people do it with music with images um I saw a project which was like evolving cell phone rings um ringtones but here I have what might possibly be the lamest example of interactive selection ever but just to demonstrate the point um these are a bunch of designs for faces they have there's a there's data here the data is color size position U width of the mouth and what what this example does is it allows you to say okay um I really like green so I really like this one I'm giving that a much higher score when I evolve the Next Generation you can see you know I did that in a very um I only rated one of them but I could say I like this one a lot and this one a little bit and you can see I'm starting to mix and match there's some mutation in there so again there's nothing particularly exciting visually about this or even that creative in its thinking but it demonstrates the process of creating a visual Based on data and one of the things about this example is that every the DNA this is a kind of a nice technique every element in the in the DNA is just a floating Point number between 0o and one one thing that's nice about that is you can always map a number between 0 one to any range so I could say this is the red value and I map it to 0255 this is the green value 05 this is like the I size I map it from 10 to 20 so you can have this kind of generic DNA where everything's a floating point value and then map that those values to the design of something you know for I would say if you're looking to create a design you know thinking of a node based approach or there you know parameter based approach there's lots of other possibilities there um okay so I think I'm kind of nearing the end of the end of time maybe we have the to be or not to be that's the question by now let's check on uh oh that's is that the same one yeah oh yeah see see kind is not highlighting the guy that right so you know what the problem with that is we don't I don't know which one's going to get there so I could run it secret twice like I could zoom through it figure out which one it is it's funny I actually just added most did made this example most of it this afternoon so I what's what's so cool about this is that the guy that ends up winning is not the winner for a lot for like the first third of it right yeah there's a lot of mess going on here and what's interesting what I don't like what I what's interesting about this is that you know there's really only a small number of vectors that are really at play here all that stuff in the corner like it's not being used it's just it's only just random because anyone going up there is kind of lost and off is not going to be picked so there's it would be nice if what I was hoping visualizing the flow field is that eventually you could really see the flow field the path of the flow field it's kind of happening more mysteriously um but I think there's probably other ways of visualizing this that could be kind of interesting to demonstrate the process and so so each node or each guy has the entire flow field as its DNA that's correct so it's a twodimensional array of vectors in the example so it's crunching a lot of numbers to do this yeah yes yes I think you said earlier that it's um one that gets their first gets higher priority but it's not in direct correlation with how fast it get them no you're right yes so I didn't actually time them and use their time to Fitness which I could have I just quick quickly ordered them and said number one Higher number two yeah so you're right if it's sort of the fitness function is really here just mapped to as if they like all finished in like perfect lock step timing yeah but you could use their time but you absolutely could use their time yes for for c for sure um you know the other thing about this is I'm you know most of these are kind of pure but I'm trying to with these examples not put any top down thinking onto this but you could do certain things like I could have maybe seated the system with all the vectors pointing to the right start and that might have given us at least you know more we might be able sort see that path more clearly without it all being random to start So eventually all of these guys are going to figure out a better path no there's so much mutation that I think at this point it's probably going to look like this forever but I think we'll get we'll get some marginal improvements like there will be some some they'll start to get a little bit faster you're right if I use time that would would really help that's a great idea um yeah because right now it's just getting there first if everybody's really slow you know so yeah um so let me just show you this last example and then we can kind of be finished so um I think I have a a diagram that I'll just kind of use oh here it is um so um I there's the last example I want to show you just demonstrates the idea of a kind of more I'm calling an ecosystem simulation so more like the real world would work so we have these creatures called bloops and they're either big or small or they have a size they have one their DNA is one number a single number it maps to their size and how fast they move so the big ones move very slowly the small ones move very fast and they need to eat food to survive and there's food in the system so if I run this simulation now uh I'll leave all these running I guess sorry ah I can't it's very hard to use your my computer in this strange configuration okay oh here we go um Evolution ecosystem okay so let me run this one hopefully this will work and what's happening here all of these creatures so this is I guess a simulation of asexual reproduction um each creature just clones itself when it has a baby so at any moment in time there is a small probability that it will clone itself so the ones that live long longer just have a longer amount of time to have that happen and one thing you'll notice here if um is that the system tends to evolve towards mediumsized objects so it's not that interesting of a result the big ones are really good at intersecting the food but they move too slowly so they don't really find the food the little ones are move super fast but they're so tiny they don't seem to run into the food that often so medium tends to be about the right um the right the the kind of the perfect size to intersect the food and move about the space and so so the food is getting randomly distributed yeah it starts with a random amount of food and then um I think when they die they leave food so what the only thing that I find the only unexpected result that I've noticed here is sometimes there's a cluster of big ones that just like a lot of them die and there's a lot of food in one area and then there's another big one that just keeps eating it and making new big ones so a little cluster of big ones can kind of survive for a while in one part of the screen um so this is to me what kind of thinking the most basic way I mean there's so many things you could do to a simulation like this to make it more sophisticated for example you could give these creatures some intelligence I have a whole section about steering behaviors so you could allow them to kind of see where the food is choose to seek the food avoid a predator you could also uh add things like they only make a child when they come together for a certain amount of time so um so there's a lot more that you could do with a simulation like this but this just kind of at least demonstrates the idea there's no Fitness function and there's no Generations it's just a system that lives the the circles are moving around they live or die and they reproduce and eventually um I guess I added so many it's kind of still has a lot of variety there but if we run this for a while you you'll tend to see that um it mostly ends up with medium siiz um elements what determines their movement um it's so it's it's I'm using something called pein noise in this example pearlin noise is like a smooth Randomness so there there's no it it's kind of um a quick way to get things look like they're wandering around the screen but um just to now I'm kind of uh jumping around here a little bit but uh if you're interested in this type of ecosystem simulation I would recommend taking a look at um Craig Reynold steering behaviors and I have I'll just show you like here's an example of one this is all um from the chapter six in the book and so this is an example of crowd path following so here are entities that are following a path as well as trying not to run into each other so one thing that I always say as a exercise for uh students in the class is build a system where autonomous agents have a wide variety of steering behaviors and make the weights of those behaviors their DNA so how much they try to follow a path versus avoid a neighbor versus seek food versus run away from a predator see if you can evolve some type of optimal Behavior this the weights for these steering forces are just hardcoded in so they follow the path and um but so combining this kind of intelligence of an autonomous agent with a genetic algorithm is perhaps you know something that could yield some results other questions I think that's I finished with all of the examples with genetic algorithms like where are people taking it right now um you know that's a good question I don't know that I really know the answer to that I mean I think there is kind of a stateoftheart in computer science research um for me I see this kind of work um in in in in um game design a lot with really interesting results so you could think about if you're trying to create autonomous characters in a game that can adapt to the way a player you could certainly use this in like Museum exhibits as well that's sort of more that the space that I see at ITP at least um kind of picking and choosing from the kind of computer science research what's kind of easy to understand and use and apply um vers rather than kind of dig deep into the the depths of the stuff thank you so much great thank you
