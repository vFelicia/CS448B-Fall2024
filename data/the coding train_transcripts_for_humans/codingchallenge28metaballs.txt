With timestamps:

00:00 - hello and welcome to another coding
00:02 - challenge in this coding challenge I'm
00:03 - going to take a look at netball bet meta
00:06 - balls I'm just so afraid of saying
00:08 - meatballs but so far I haven't done it
00:10 - except for the fact that I just said it
00:11 - but anyway I'm going to explore meta
00:13 - balls which is also a concept known as
00:16 - isosurfaces and I'm going to look at it
00:17 - in just 2d and I'm going to use the
00:19 - pixel based approach where I'm going to
00:21 - generate this by processing every pixel
00:23 - of a window I'm going to do this in
00:25 - processing which is a Java based
00:27 - programming creative programming
00:28 - environment
00:29 - I will also release JavaScript code that
00:31 - goes along with it and at some point I
00:32 - might hopefully do it geometry based or
00:35 - make you like this fancy like shader
00:36 - thing we'll see but right now I'm going
00:38 - to create this from scratch and I'm
00:40 - going to talk through also what is this
00:42 - isosurface meta ball thing okay
00:47 - so first let's come over here and talk
00:49 - about how this is going to work the idea
00:51 - of an isosurface is basically a
00:54 - two-dimensional surface like a canvas
00:56 - and a canvas a window a computer
01:00 - graphics window has a whole lot of XY
01:03 - points and the idea here is that the
01:06 - color of a given point is a function of
01:09 - x and y so I want to create a function
01:12 - of x and y equal to something and
01:15 - whatever this is I want to use the
01:18 - result of that mathematical function to
01:20 - color that pixel so for example I could
01:22 - just say it's equal to X or I could say
01:24 - it's equal to X plus y or I could say
01:27 - it's the color somehow based on its
01:29 - distance from the center let's just look
01:31 - at sort of that basic idea first in code
01:33 - so if I come over here and I'm going to
01:35 - close this finished example I'm going to
01:38 - minimize the browser here oops
01:39 - lots of things are going on and what I'm
01:41 - going to do now is first just say load
01:43 - pixels I hope you can this font is good
01:45 - enough let make it a little bit bigger
01:47 - actually I shouldn't be doing this live
01:52 - that didn't work whatever update pixels
01:56 - and what I'm going to do is say I need
02:00 - two loops so I want some loops to look
02:03 - at every single X and then I want that
02:07 - same loop but to look at every single Y
02:10 - so I have a nested loop here so I can
02:13 - hit every
02:13 - single pixel and in processing the
02:16 - pixels all live in a one-dimensional
02:18 - array and I can get the index into that
02:21 - array by saying by saying X plus y times
02:24 - width and I can mix up some color like I
02:29 - want it every pixel to be likes pink or
02:32 - purple so you can see I've now colored
02:34 - every single pixel so now what I want to
02:36 - do is make this an isosurface I want
02:39 - every pixel to be a function of X plus y
02:41 - so let's do something like color X comma
02:46 - zero comma Y now let's see what we get
02:48 - you can see that as X gets higher I get
02:51 - more of a red as Y gets higher get more
02:54 - of a blue and as those mix I get more of
02:56 - a purple so you can see this is an
02:57 - isosurface so to speak I could do
02:59 - something a little bit fancier like I
03:01 - could say give me the distance between X
03:05 - Y and the center of the window and then
03:10 - let me have that distance be math to the
03:18 - color so you can see now here that as
03:20 - things are closer to the center they're
03:22 - darker as they're closer to the edge
03:24 - they're brighter this isosurface is
03:27 - using the distance function so I don't
03:30 - have an eraser tada so in other words
03:36 - I'm using the distance function here now
03:40 - we were going to talk about meta balls
03:43 - so the metal ball isosurface is a kind
03:47 - of surface where just like I'm taking
03:50 - the distance to the center but instead
03:52 - of to the center I'm actually going to
03:53 - take a distance to this idea of a ball
03:56 - which I can also refer to as a blob
03:59 - because it's like this blobby thing and
04:01 - so what I want to know is the distance
04:03 - to that but the formula is actually 1
04:09 - divided by the distance between the blob
04:12 - and the X&Y so that's the formula
04:15 - I want to inverse I want inversely
04:17 - proportional to the distance so the
04:19 - closer it is the bigger the number the
04:21 - further away it is the smaller the
04:23 - number and actually
04:25 - instead of one here that in this formula
04:27 - each of these blobs also has a radius
04:29 - and that number is tied to the radius so
04:33 - let's make what I'm going to do this is
04:35 - a what I'm going to do because
04:36 - eventually I'm going to move all these
04:38 - things around so even though this is
04:39 - overkill for what I'm just demonstrating
04:41 - to you right now I'm going to create a
04:44 - class of a called glob and I'm going to
04:50 - use a P vector object to store its
04:52 - position and I'm going to use a float to
04:55 - store a radius and I'm going to be able
04:59 - to give make the blob I'll just make
05:06 - there at a certain location so position
05:08 - equals a new P vector at that X Y and
05:13 - the radius is some let's just make the
05:15 - radius like 40 so what I'm going to do
05:20 - now is I want to make a blob object and
05:24 - I want to say blob equals a new blob at
05:27 - you know like 100 100 and I want to have
05:29 - a function just so I can see it called
05:32 - show and I'm going to say no fill stroke
05:36 - 255 and I'm going to draw it as an
05:39 - ellipse
05:40 - pause X pause dot Y and at R times 2r
05:44 - times 2 so I also want to put a B oops
05:50 - now this is tricky because I'm doing all
05:52 - the pixel stuff let's put it afterwards
05:55 - so you can see there it is there is that
05:59 - blob right up there in the top left
06:02 - corner at 100 100 so now what I want to
06:04 - do is not I want to take the distance
06:06 - not from the center but from that blobs
06:11 - position and you can see now that's
06:13 - making more sense it's darker near it
06:15 - brighter further away but I actually
06:17 - want the color so that's the distance I
06:21 - want the I'm going to make this a
06:22 - separate variable like the color to be
06:25 - one the blobs radius divided by that
06:30 - distance and I can put the color in here
06:33 - and now you can see well this didn't
06:36 - really do me any good
06:38 - because there is this white dot there
06:40 - but it's just so so tiny
06:42 - so really the radius the the because I'm
06:45 - dividing by distance um the radius value
06:48 - is really like really got to be a much
06:50 - different number like it must be a must
06:52 - it needs to be like a really high number
06:53 - like it could make it like forty
06:54 - thousand and now I'm going to get
06:56 - something that looks more like what I'm
06:58 - interested in almost this like glowing
06:59 - orb near the center fanning out but you
07:02 - can't see it anymore because forty
07:04 - thousand is like way too big to draw an
07:06 - actual circle so I'm going to keep these
07:08 - radiuses as small and just do something
07:10 - like say ten ten thousand I'm just going
07:14 - to scale it up by like ten thousand and
07:15 - so now you can see and I also to show it
07:18 - I'm going to say actually stroke zero
07:20 - and Stroke wait for just so you could
07:24 - really see it so you can see whoa what
07:26 - did I do wrong here Oh
07:28 - too big till it scale it up by a
07:29 - thousand there you go so this is the
07:31 - idea this is the idea of the isosurface
07:34 - the pixels are color is a function
07:38 - inversely proportional to their distance
07:40 - from this blob object so now what if
07:44 - this blob object were to move around
07:45 - let's give this blob a velocity and I'm
07:52 - going to make it a random there's a
07:54 - function called random 2d for a random
07:56 - vector unit vector pointing in a random
07:58 - direction and I'm going to give it also
08:00 - like a random speed I'm going to scale
08:02 - that amount by some random amount and
08:06 - then I'm going to write an update
08:09 - function where I just add that velocity
08:14 - to the object and you can see looks and
08:16 - now what I need to do is in addition to
08:19 - showing it I need to update it so it
08:22 - moves and you can see as it moves the
08:25 - pixels kind of go with it drive it one
08:27 - more time oops right as it moves the
08:32 - pixels go along with it so let me do
08:34 - something so that it bounces off the
08:36 - edges really quick I can say if position
08:40 - X is greater than width or position dot
08:44 - dot X is less than zero velocity X
08:48 - multiplied by negative one and I can
08:50 - just do this
08:50 - same exact thing with y but height and
08:54 - the y component of the velocity so now
08:57 - we can watch this and we can say okay
08:59 - so now those pixels are moving along
09:02 - with it now this may not seem so
09:04 - exciting I've really just got this like
09:06 - glowing orb moving but it gets exciting
09:09 - if I have more than one of these
09:11 - particular blobs so let's see how that
09:13 - might work so I'm going to go now to set
09:16 - up to the main tab and instead of having
09:18 - a single object I'm going to create an
09:21 - ArrayList of them you know what I'm
09:23 - gonna I'm gonna have a fixed number yeah
09:26 - I'm gonna have a fixed number I'm gonna
09:29 - have a fixed number it'll just be a
09:30 - little bit simpler for right now
09:35 - so I'm going to say a new I'm going to
09:39 - just have two of them and in here I'm
09:43 - going to say for int I equals zero I is
09:45 - less than blobs dot length I plus plus
09:51 - and I'm going to say blobs index I
09:57 - equals a new blob with a random blue
10:00 - with and a random height this is taking
10:04 - so long to type right and then this I
10:07 - can then here I could say ah-ha
10:08 - instead of AHA I can say ah for all the
10:13 - blobs update and show them so I think I
10:19 - kind of got everything in there enough
10:21 - so here there's an issue here okay well
10:23 - let's just do something really quick
10:26 - let's let's just do index 0 and let's
10:36 - run this a so you can see there's two
10:38 - moving but the color is only based on
10:42 - the distance from one of them so I need
10:45 - to have that color now based on the
10:46 - distance from two of them so how do I do
10:49 - that well right inside here
10:51 - I need another loop I want to say for
10:54 - every blob bleed every blob be every
10:57 - blob be in that array
11:02 - I want to look for that distance and
11:06 - look for that color and then what do I
11:09 - want to do I actually want to sum all of
11:12 - them so the way this isosurface works if
11:15 - the function is based on its distance if
11:17 - the formula is you know if I to go back
11:19 - to this formula the function of x and y
11:21 - is based on the sum you know I could use
11:23 - the Greek letter Sigma here to imply sum
11:26 - of all of the inverse distance of the
11:29 - radius of divided by the distance
11:31 - between all of the things that are on
11:33 - the screen so I just need to add all
11:34 - those things together so I'm going to
11:36 - say I have a variable called sum and
11:39 - it's equal to zero and then I'm going to
11:42 - add them up and now I'm going to make a
11:46 - color based on that sum and take a look
11:48 - at this now I think my values are so big
11:52 - that we're not really seeing very much
11:55 - going on here so let's let's make this a
11:58 - 100 just so we can see more clearly okay
12:01 - so now you see them it's not enough
12:04 - ulema to stop showing them because i
12:06 - think there we go so now you're seeing
12:09 - more like what you might expect because
12:11 - it's a sum based on that distance as
12:13 - they come together they start to sort of
12:15 - like glom onto each other like there's
12:16 - these gloppy gluey blobby things and of
12:19 - course now because I've done this to
12:21 - program it this way I can suddenly add
12:23 - ten of them and I can make my screen who
12:25 - you know what I know I got to be true
12:27 - because I'm doing pixel processing I'm
12:29 - afraid to okay so and then of course if
12:31 - I have so many of them you know maybe it
12:34 - would be good to just now we can sort of
12:35 - see now this might be more like what
12:37 - you're sort of more commonly used to
12:39 - seeing when you see a meta balls
12:42 - visualization and I could go back and I
12:44 - could look at you know where it's the
12:46 - raw data that's moving around it's these
12:48 - things and the pixel colors are
12:50 - associated with that those are some
12:52 - really beautiful meatballs got me metal
12:54 - balls ah okay so let's make them let's
12:57 - do two more you can see you stopped
12:59 - watching how if you want but I'm going
13:00 - to do some more stuff in this video
13:02 - normally there'd be like a subscribe
13:04 - support annotation that would come up at
13:06 - the end you gotta wait till the very end
13:07 - to get that somebody do a few things
13:08 - number one let's make these
13:09 - rainbow-colored why not so I'm just
13:12 - going to say colormode HSB
13:15 - and then what I'm going to do here is
13:17 - I'm going to say some 0 255 255 so all I
13:23 - did was I want the hue just to be
13:24 - attached so that was one really quick
13:26 - thing so you can see here's a quick way
13:28 - that I could color them differently I
13:29 - really wanted the center to be I love
13:31 - this like pinkish purple color which is
13:33 - probably like so I'm going to constrain
13:37 - the sum to like the hue of 220 this is
13:39 - so silly that I'm doing this there we go
13:42 - that's good so anyway so you can see you
13:44 - can play around you could cycle the
13:46 - colors I could do something kind of
13:47 - crazy which I could do like some mod 255
13:51 - and you can see now I've got this like
13:53 - weird thing because it's actually going
13:54 - above 255 and you can see I got these
13:56 - like crazy weird like a little of color
13:59 - or things in the center so that's one
14:01 - thing that I can do now I'm going to do
14:05 - some more of them so this this really
14:06 - ends the sort of meta balls isosurfaces
14:09 - discussion but because I would like I'm
14:11 - doing some synergy thing here yesterday
14:14 - I made a video which was about blob
14:15 - tracking and I'm going to pull that up
14:19 - here and I'm going to show this to you
14:21 - so here is I've got a live image from a
14:26 - camera and it's looking for the color
14:29 - red it's not finding it it's gonna click
14:33 - on it Oh sad my threshold what happened
14:38 - to the lighting in this room something
14:39 - happened here let's try this one more
14:41 - time I'm uh we restart this again they
14:48 - try this one more time
14:58 - okay so I'm tracking this pretty good
15:00 - I'm tracking these two you can see that
15:03 - this is doing blob detection to try to
15:05 - find these cups that I'm holding and
15:06 - what I want to do right now is control
15:08 - the metaball with the blob tracking so
15:13 - what I'm going to do is I'm going to
15:14 - combine two projects I'm going to
15:16 - combine blob tracking with meta balls I
15:19 - will include a link to the blob tracking
15:21 - videos in the description of this video
15:22 - that you're watching right now so what
15:24 - do I need I need a couple things
15:26 - I mean amazingly horrifyingly I've named
15:29 - a class called blob in this particular
15:33 - sketch and I named something called blob
15:35 - and the other one so I need to correct
15:36 - that I'm going to take this over to this
15:38 - sketch I'm gonna make a new tab I'm
15:40 - going to call it meta ball and I'm going
15:44 - to rename this meta ball and give it a
15:49 - constructor you know I could have just
15:51 - combined better idea a better idea a
15:55 - better idea I don't know why I needed to
15:59 - do that I don't need to do anything I
16:00 - have all the stuff already a better idea
16:03 - I don't need a new object what I need is
16:06 - all I need is this code actually all I
16:08 - need is this code so I'm going to take
16:10 - this code this loop and I'm going to
16:15 - bring it into this particular sketch and
16:18 - I'm going to take it all the way at the
16:20 - end now I'm going to put it before I
16:23 - show the block so but now what I want to
16:25 - do is I want to look at the distance
16:28 - between the XY of each pixel and each
16:31 - particular blob in that array its
16:34 - position now it's position is no longer
16:39 - a is no longer a I'm sorry I'm spacing
16:44 - out here is no longer a vector and I'm
16:47 - going to actually write a function
16:48 - called get X and get Y because really
16:51 - what I want is the center and because I
16:56 - the blob is just keeping track of the
16:58 - edges so I want to add a function called
17:02 - get X which is going to return max
17:07 - X minus
17:10 - - max - min X divided by 2 and x is a
17:18 - little faster say point times 0.5 min X
17:21 - so this is finding the center it's the
17:23 - minimum plus halfway between the maximum
17:26 - and the minimum
17:26 - so that's get X and this is get Y so let
17:32 - me just do that really quickly that
17:34 - should be the center of those blobs so
17:38 - what I work now and then I want it so I
17:40 - already have a size function so I'm
17:43 - pretty sure I wrote oh I had a mistake
17:49 - in my previous code I got to go back and
17:51 - fix that I already had blobs index 0 dot
17:53 - size that should have been be all along
17:55 - so there I believe there is a size
17:57 - function which just returns the sort of
17:59 - area of that square and now if I run
18:04 - this that should be all I need I want to
18:09 - say I'm going to I'm going to say here
18:15 - call it let's see if this works
18:16 - colormode HSB and then afterwards just
18:22 - in case other parts of my sketch and say
18:24 - color mode RGB let's run this this is
18:28 - like okay
18:37 - isn't working No
18:40 - so one thing that I really need to be
18:41 - able to do is I want to do I'm going to
18:44 - create a boolean variable Shou Shou blah
18:50 - Shou Mehta is false and I'm only going
18:55 - to do this pixel stuff if show Mehta is
18:59 - true and then in my key pressed function
19:08 - I'm going to just use the space bar if
19:12 - ki equals the space bar show Mehta
19:16 - equals not show Mehta so I want this to
19:19 - work so it should when it starts oh you
19:24 - know I have a feeling that the let's see
19:26 - okay I'm tracking the blobs rather
19:28 - nicely ah there we go
19:32 - whoa so look at that I am controlling so
19:35 - a couple things I want to fix here is a
19:38 - number one is um this scale is probably
19:44 - way off because the size of those is
19:46 - much bigger so I'm going to say 10 I'm
19:48 - going to use I'm going to just use the
19:50 - constrain approach and that should fix
19:55 - things make things better so let's make
19:57 - sure the blob tracking is working you
20:02 - know it's like based on the sort of like
20:04 - white balance here I'm gonna have to
20:06 - click on it till I calibrate it okay
20:10 - that's working pretty well I don't care
20:11 - that my mouth is also a blob Oh what did
20:15 - I do wrong
20:16 - I guess did I'm oh whoa oh whoa whoa
20:23 - Oh craziness what did I get wrong here I
20:27 - multiplied it by less well let me just
20:31 - give it a fixed size right now like we
20:34 - know that like 20,000 will do something
20:36 - useful and then I have to think about
20:39 - what the sizes are of these particular
20:41 - blobs
20:46 - does anybody still watching this video
20:51 - so you can see you can see that it's the
20:54 - basic ideas working it needs some
20:56 - refinement but you can see that the
21:00 - basic idea here is working
21:02 - I should really but I just need to sort
21:06 - of some refinement on the size-wise so
21:08 - I'll leave as an exercise for those of
21:10 - you who might want to make this better
21:11 - but you can see that the point of this
21:15 - meta balls example is to realize that
21:19 - these things just bouncing around the
21:21 - screen is just an arbitrary way of
21:23 - moving them around to get this colorful
21:25 - visualization but I could easily take
21:27 - any other physics example particle
21:30 - system type things where things are
21:31 - swirling or following each other and
21:32 - create all sorts of interesting results
21:34 - by kind of merging the stuff so I want
21:36 - to make sure there's a good actually
21:38 - I'll do this afterwards so thanks for
21:40 - watching this vegetarian mehta balls and
21:44 - I will see you in in some other coding
21:49 - challenge perhaps in the future thanks
21:50 - for watching good bye
21:51 - oops I'm back I realized I left a bug in
21:55 - my meta Balls example which is here that
21:58 - when I was looping through and and
22:01 - looping through all of the blob objects
22:03 - to sum up those distances I always took
22:05 - the radius of the first one because I
22:07 - was demonstrating at first just using
22:09 - one so this really should be BR so now
22:12 - I've corrected it you'll see though
22:14 - visually the result is basically exactly
22:16 - the same why is that the reason that is
22:20 - is because doesn't uh um I have every
22:26 - single one gets the same radius so now I
22:28 - have an opportunity to say something
22:29 - like let's give them all a random radius
22:31 - between 20 and 60 let's make that a bit
22:34 - more extreme between 10 and 150 so you
22:40 - can see now and let me um let's see here
22:44 - let's let me uh let me also get rid of
22:48 - this modulus thing oh wow that modulus
22:54 - thing really makes a big difference
22:57 - hold on what is going on here
22:59 - there we go interesting so the size I
23:03 - the modulus thing really makes a
23:04 - difference in how it's visualized so now
23:07 - I'm kind of like Tooting this a little
23:09 - bit better
23:09 - and anyway you can play at this with
23:20 - your heart's content but now you can see
23:22 - that these blobby things have a slightly
23:24 - different size which gives it kind of a
23:26 - different quality as the things move
23:28 - around randomly so you know I wasn't
23:30 - started going about to defend there so
23:31 - enjoy the metabolic code example make
23:35 - something with it I'll try to release a
23:37 - JavaScript version of it and at some
23:38 - point I'll come back and try to do a 3d
23:40 - one as well as such sort of geometry
23:41 - version as well okay thanks again for
23:43 - watching good this now concludes this
23:45 - video I think goodbye

Cleaned transcript:

hello and welcome to another coding challenge in this coding challenge I'm going to take a look at netball bet meta balls I'm just so afraid of saying meatballs but so far I haven't done it except for the fact that I just said it but anyway I'm going to explore meta balls which is also a concept known as isosurfaces and I'm going to look at it in just 2d and I'm going to use the pixel based approach where I'm going to generate this by processing every pixel of a window I'm going to do this in processing which is a Java based programming creative programming environment I will also release JavaScript code that goes along with it and at some point I might hopefully do it geometry based or make you like this fancy like shader thing we'll see but right now I'm going to create this from scratch and I'm going to talk through also what is this isosurface meta ball thing okay so first let's come over here and talk about how this is going to work the idea of an isosurface is basically a twodimensional surface like a canvas and a canvas a window a computer graphics window has a whole lot of XY points and the idea here is that the color of a given point is a function of x and y so I want to create a function of x and y equal to something and whatever this is I want to use the result of that mathematical function to color that pixel so for example I could just say it's equal to X or I could say it's equal to X plus y or I could say it's the color somehow based on its distance from the center let's just look at sort of that basic idea first in code so if I come over here and I'm going to close this finished example I'm going to minimize the browser here oops lots of things are going on and what I'm going to do now is first just say load pixels I hope you can this font is good enough let make it a little bit bigger actually I shouldn't be doing this live that didn't work whatever update pixels and what I'm going to do is say I need two loops so I want some loops to look at every single X and then I want that same loop but to look at every single Y so I have a nested loop here so I can hit every single pixel and in processing the pixels all live in a onedimensional array and I can get the index into that array by saying by saying X plus y times width and I can mix up some color like I want it every pixel to be likes pink or purple so you can see I've now colored every single pixel so now what I want to do is make this an isosurface I want every pixel to be a function of X plus y so let's do something like color X comma zero comma Y now let's see what we get you can see that as X gets higher I get more of a red as Y gets higher get more of a blue and as those mix I get more of a purple so you can see this is an isosurface so to speak I could do something a little bit fancier like I could say give me the distance between X Y and the center of the window and then let me have that distance be math to the color so you can see now here that as things are closer to the center they're darker as they're closer to the edge they're brighter this isosurface is using the distance function so I don't have an eraser tada so in other words I'm using the distance function here now we were going to talk about meta balls so the metal ball isosurface is a kind of surface where just like I'm taking the distance to the center but instead of to the center I'm actually going to take a distance to this idea of a ball which I can also refer to as a blob because it's like this blobby thing and so what I want to know is the distance to that but the formula is actually 1 divided by the distance between the blob and the X&Y so that's the formula I want to inverse I want inversely proportional to the distance so the closer it is the bigger the number the further away it is the smaller the number and actually instead of one here that in this formula each of these blobs also has a radius and that number is tied to the radius so let's make what I'm going to do this is a what I'm going to do because eventually I'm going to move all these things around so even though this is overkill for what I'm just demonstrating to you right now I'm going to create a class of a called glob and I'm going to use a P vector object to store its position and I'm going to use a float to store a radius and I'm going to be able to give make the blob I'll just make there at a certain location so position equals a new P vector at that X Y and the radius is some let's just make the radius like 40 so what I'm going to do now is I want to make a blob object and I want to say blob equals a new blob at you know like 100 100 and I want to have a function just so I can see it called show and I'm going to say no fill stroke 255 and I'm going to draw it as an ellipse pause X pause dot Y and at R times 2r times 2 so I also want to put a B oops now this is tricky because I'm doing all the pixel stuff let's put it afterwards so you can see there it is there is that blob right up there in the top left corner at 100 100 so now what I want to do is not I want to take the distance not from the center but from that blobs position and you can see now that's making more sense it's darker near it brighter further away but I actually want the color so that's the distance I want the I'm going to make this a separate variable like the color to be one the blobs radius divided by that distance and I can put the color in here and now you can see well this didn't really do me any good because there is this white dot there but it's just so so tiny so really the radius the the because I'm dividing by distance um the radius value is really like really got to be a much different number like it must be a must it needs to be like a really high number like it could make it like forty thousand and now I'm going to get something that looks more like what I'm interested in almost this like glowing orb near the center fanning out but you can't see it anymore because forty thousand is like way too big to draw an actual circle so I'm going to keep these radiuses as small and just do something like say ten ten thousand I'm just going to scale it up by like ten thousand and so now you can see and I also to show it I'm going to say actually stroke zero and Stroke wait for just so you could really see it so you can see whoa what did I do wrong here Oh too big till it scale it up by a thousand there you go so this is the idea this is the idea of the isosurface the pixels are color is a function inversely proportional to their distance from this blob object so now what if this blob object were to move around let's give this blob a velocity and I'm going to make it a random there's a function called random 2d for a random vector unit vector pointing in a random direction and I'm going to give it also like a random speed I'm going to scale that amount by some random amount and then I'm going to write an update function where I just add that velocity to the object and you can see looks and now what I need to do is in addition to showing it I need to update it so it moves and you can see as it moves the pixels kind of go with it drive it one more time oops right as it moves the pixels go along with it so let me do something so that it bounces off the edges really quick I can say if position X is greater than width or position dot dot X is less than zero velocity X multiplied by negative one and I can just do this same exact thing with y but height and the y component of the velocity so now we can watch this and we can say okay so now those pixels are moving along with it now this may not seem so exciting I've really just got this like glowing orb moving but it gets exciting if I have more than one of these particular blobs so let's see how that might work so I'm going to go now to set up to the main tab and instead of having a single object I'm going to create an ArrayList of them you know what I'm gonna I'm gonna have a fixed number yeah I'm gonna have a fixed number I'm gonna have a fixed number it'll just be a little bit simpler for right now so I'm going to say a new I'm going to just have two of them and in here I'm going to say for int I equals zero I is less than blobs dot length I plus plus and I'm going to say blobs index I equals a new blob with a random blue with and a random height this is taking so long to type right and then this I can then here I could say ahha instead of AHA I can say ah for all the blobs update and show them so I think I kind of got everything in there enough so here there's an issue here okay well let's just do something really quick let's let's just do index 0 and let's run this a so you can see there's two moving but the color is only based on the distance from one of them so I need to have that color now based on the distance from two of them so how do I do that well right inside here I need another loop I want to say for every blob bleed every blob be every blob be in that array I want to look for that distance and look for that color and then what do I want to do I actually want to sum all of them so the way this isosurface works if the function is based on its distance if the formula is you know if I to go back to this formula the function of x and y is based on the sum you know I could use the Greek letter Sigma here to imply sum of all of the inverse distance of the radius of divided by the distance between all of the things that are on the screen so I just need to add all those things together so I'm going to say I have a variable called sum and it's equal to zero and then I'm going to add them up and now I'm going to make a color based on that sum and take a look at this now I think my values are so big that we're not really seeing very much going on here so let's let's make this a 100 just so we can see more clearly okay so now you see them it's not enough ulema to stop showing them because i think there we go so now you're seeing more like what you might expect because it's a sum based on that distance as they come together they start to sort of like glom onto each other like there's these gloppy gluey blobby things and of course now because I've done this to program it this way I can suddenly add ten of them and I can make my screen who you know what I know I got to be true because I'm doing pixel processing I'm afraid to okay so and then of course if I have so many of them you know maybe it would be good to just now we can sort of see now this might be more like what you're sort of more commonly used to seeing when you see a meta balls visualization and I could go back and I could look at you know where it's the raw data that's moving around it's these things and the pixel colors are associated with that those are some really beautiful meatballs got me metal balls ah okay so let's make them let's do two more you can see you stopped watching how if you want but I'm going to do some more stuff in this video normally there'd be like a subscribe support annotation that would come up at the end you gotta wait till the very end to get that somebody do a few things number one let's make these rainbowcolored why not so I'm just going to say colormode HSB and then what I'm going to do here is I'm going to say some 0 255 255 so all I did was I want the hue just to be attached so that was one really quick thing so you can see here's a quick way that I could color them differently I really wanted the center to be I love this like pinkish purple color which is probably like so I'm going to constrain the sum to like the hue of 220 this is so silly that I'm doing this there we go that's good so anyway so you can see you can play around you could cycle the colors I could do something kind of crazy which I could do like some mod 255 and you can see now I've got this like weird thing because it's actually going above 255 and you can see I got these like crazy weird like a little of color or things in the center so that's one thing that I can do now I'm going to do some more of them so this this really ends the sort of meta balls isosurfaces discussion but because I would like I'm doing some synergy thing here yesterday I made a video which was about blob tracking and I'm going to pull that up here and I'm going to show this to you so here is I've got a live image from a camera and it's looking for the color red it's not finding it it's gonna click on it Oh sad my threshold what happened to the lighting in this room something happened here let's try this one more time I'm uh we restart this again they try this one more time okay so I'm tracking this pretty good I'm tracking these two you can see that this is doing blob detection to try to find these cups that I'm holding and what I want to do right now is control the metaball with the blob tracking so what I'm going to do is I'm going to combine two projects I'm going to combine blob tracking with meta balls I will include a link to the blob tracking videos in the description of this video that you're watching right now so what do I need I need a couple things I mean amazingly horrifyingly I've named a class called blob in this particular sketch and I named something called blob and the other one so I need to correct that I'm going to take this over to this sketch I'm gonna make a new tab I'm going to call it meta ball and I'm going to rename this meta ball and give it a constructor you know I could have just combined better idea a better idea a better idea I don't know why I needed to do that I don't need to do anything I have all the stuff already a better idea I don't need a new object what I need is all I need is this code actually all I need is this code so I'm going to take this code this loop and I'm going to bring it into this particular sketch and I'm going to take it all the way at the end now I'm going to put it before I show the block so but now what I want to do is I want to look at the distance between the XY of each pixel and each particular blob in that array its position now it's position is no longer a is no longer a I'm sorry I'm spacing out here is no longer a vector and I'm going to actually write a function called get X and get Y because really what I want is the center and because I the blob is just keeping track of the edges so I want to add a function called get X which is going to return max X minus max min X divided by 2 and x is a little faster say point times 0.5 min X so this is finding the center it's the minimum plus halfway between the maximum and the minimum so that's get X and this is get Y so let me just do that really quickly that should be the center of those blobs so what I work now and then I want it so I already have a size function so I'm pretty sure I wrote oh I had a mistake in my previous code I got to go back and fix that I already had blobs index 0 dot size that should have been be all along so there I believe there is a size function which just returns the sort of area of that square and now if I run this that should be all I need I want to say I'm going to I'm going to say here call it let's see if this works colormode HSB and then afterwards just in case other parts of my sketch and say color mode RGB let's run this this is like okay isn't working No so one thing that I really need to be able to do is I want to do I'm going to create a boolean variable Shou Shou blah Shou Mehta is false and I'm only going to do this pixel stuff if show Mehta is true and then in my key pressed function I'm going to just use the space bar if ki equals the space bar show Mehta equals not show Mehta so I want this to work so it should when it starts oh you know I have a feeling that the let's see okay I'm tracking the blobs rather nicely ah there we go whoa so look at that I am controlling so a couple things I want to fix here is a number one is um this scale is probably way off because the size of those is much bigger so I'm going to say 10 I'm going to use I'm going to just use the constrain approach and that should fix things make things better so let's make sure the blob tracking is working you know it's like based on the sort of like white balance here I'm gonna have to click on it till I calibrate it okay that's working pretty well I don't care that my mouth is also a blob Oh what did I do wrong I guess did I'm oh whoa oh whoa whoa Oh craziness what did I get wrong here I multiplied it by less well let me just give it a fixed size right now like we know that like 20,000 will do something useful and then I have to think about what the sizes are of these particular blobs does anybody still watching this video so you can see you can see that it's the basic ideas working it needs some refinement but you can see that the basic idea here is working I should really but I just need to sort of some refinement on the sizewise so I'll leave as an exercise for those of you who might want to make this better but you can see that the point of this meta balls example is to realize that these things just bouncing around the screen is just an arbitrary way of moving them around to get this colorful visualization but I could easily take any other physics example particle system type things where things are swirling or following each other and create all sorts of interesting results by kind of merging the stuff so I want to make sure there's a good actually I'll do this afterwards so thanks for watching this vegetarian mehta balls and I will see you in in some other coding challenge perhaps in the future thanks for watching good bye oops I'm back I realized I left a bug in my meta Balls example which is here that when I was looping through and and looping through all of the blob objects to sum up those distances I always took the radius of the first one because I was demonstrating at first just using one so this really should be BR so now I've corrected it you'll see though visually the result is basically exactly the same why is that the reason that is is because doesn't uh um I have every single one gets the same radius so now I have an opportunity to say something like let's give them all a random radius between 20 and 60 let's make that a bit more extreme between 10 and 150 so you can see now and let me um let's see here let's let me uh let me also get rid of this modulus thing oh wow that modulus thing really makes a big difference hold on what is going on here there we go interesting so the size I the modulus thing really makes a difference in how it's visualized so now I'm kind of like Tooting this a little bit better and anyway you can play at this with your heart's content but now you can see that these blobby things have a slightly different size which gives it kind of a different quality as the things move around randomly so you know I wasn't started going about to defend there so enjoy the metabolic code example make something with it I'll try to release a JavaScript version of it and at some point I'll come back and try to do a 3d one as well as such sort of geometry version as well okay thanks again for watching good this now concludes this video I think goodbye
