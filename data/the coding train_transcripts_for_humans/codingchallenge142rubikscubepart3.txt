With timestamps:

00:00 - (bell dings)
00:00 - - Hello and welcome to part three
00:02 - of my Rubik's Cube coding challenge.
00:05 - So I've done two parts already,
00:06 - if you watch those,
00:07 - I'm very thankful to you.
00:09 - But I'm going to do something
really important in this.
00:11 - And it's really not about
the Rubik's Cube at all,
00:13 - it's really about animation.
00:14 - And I want to be able to just do something
00:16 - to make it a little more visually pleasing
00:18 - to watch it do stuff.
00:19 - So what it does right now is,
00:20 - if I hit the space bar,
00:21 - it's going to shuffle
a whole bunch of moves.
00:23 - All the possible moves,
00:25 - up, down
00:26 - left, right
00:26 - clockwise, counterclockwise.
00:27 - It could do any move along any axis.
00:29 - It's also then going to whatever,
00:30 - it's doing a random sequence of 100 moves
00:33 - and then it's going to
do those in reverse.
00:34 - And you can see it looks
kind of like it's solving it,
00:36 - of course it's not.
00:37 - Just doing a random sequence
00:38 - and then applying it in reverse.
00:39 - Hit the space bar again,
00:40 - it's going to go again.
00:41 - It's actually doing the
same sequence again.
00:43 - So this would be I think more,
00:46 - I would be a little more confident
00:47 - that it's working correctly,
00:49 - if I could actually watch the,
00:52 - the cubies
00:53 - rotate themselves to actually turn.
00:55 - So in order to do that,
00:58 - I need to add animation,
00:59 - I need to actually use the rotate function
01:01 - to do that.
01:02 - So (chuckles), I have to
figure out how to do that.
01:05 - Alright I think a way
that's going to make sense
01:07 - to do this is
01:08 - to create a class,
01:10 - called move.
01:13 - And each move is what?
01:16 - It's a given axis,
01:17 - like what's the axis that's moving,
01:19 - what's the direction it's moving
01:21 - and then if I'm going to do an animation,
01:22 - I need to animate an angle
from zero to 90 degrees.
01:26 - So I need an angle
01:29 - which will start as zero.
01:31 - I need to have an axis
01:33 - and maybe what I'll do is just do x,
01:35 - y
01:37 - and z.
01:39 - An angle and an axis.
01:40 - And I'll have that access
01:42 - distort in variables x, y and z.
01:44 - So the x will be one
01:47 - or negative one,
01:48 - if it's right or left.
01:49 - The y will be one
01:50 - or negative one, if it's up or down.
01:51 - The z will be one
01:52 - or negative one, if it's front or back.
01:54 - So, that's kind of I think how I'll deal
01:56 - with this right now.
01:57 - So when I make a move,
01:59 - I have to give it an x, a y
02:01 - and a z.
02:02 - And that's all I have to give it.
02:04 - And a direction.
02:05 - So I need to know whether I'm rotating,
02:08 - whether I'm rotating clockwise
02:10 - or counter clockwise.
02:11 - Or the angle is going up
02:12 - or the angle is going down.
02:13 - So this dot x equals x.
02:16 - This dot y equals y.
02:18 - This dot Z equals Z.
02:19 - This dot direction equals direction.
02:21 - And this is this.
02:24 - Ultimately I've kind of done this already
02:26 - in the sense that I have these functions,
02:31 - called turn z,
02:32 - turn y, turn x.
02:34 - And those actually move the cubes around
02:37 - and rotate their faces.
02:38 - But they do it instantaneously.
02:40 - So what I think I want to do is,
02:41 - create an animation that happens,
02:44 - then I finish that animation
02:45 - then I quickly move everything around.
02:46 - And it'll look as if it's
happening seamlessly.
02:48 - So let's just say,
02:50 - for the sake of argument,
02:51 - I'm going to have one move.
02:53 - Move m.
02:54 - I'll call it move.
02:56 - And move m,
02:58 - forget about this,
02:58 - well I'll leave the sequence thing in here
03:00 - for a second.
03:00 - Move, is a new move
03:03 - which is going to rotate the z-axis,
03:06 - the front face.
03:08 - So that is zero, zero,
03:10 - one in a clockwise direction.
03:12 - That's a move.
03:14 - Then I want to say,
03:16 - move dot start.
03:19 - I think I'll have a function called start
03:21 - and what does that do?
03:25 - It sets a variable,
03:26 - I'll have a variable called animating.
03:30 - And it sets animating
03:33 - equal to true.
03:33 - I don't know that I'm going to need this,
03:35 - but I feel like I might need a flag
03:36 - to know when I've started
03:37 - or stopped.
03:38 - So then I need
03:40 - an update function
03:41 - and what update will do,
03:43 - is, I could use LERP
03:45 - for to like interpolate
from zero to 90 degrees
03:48 - or I could just increase the angle.
03:50 - So let's just increase
the angle right now.
03:52 - I'm going to say, angle
plus equals direction times,
03:56 - you know some amount like point one.
03:58 - So I'm going to increment
the angle by point one
04:01 - and if angle is greater than HALF_PI,
04:04 - then,
04:07 - angle should go back
04:08 - to being zero actually.
04:12 - And then I'm going to say,
04:15 - animating equals false.
04:17 - So let's just see if I
can get this to happen.
04:20 - So basically, if I have a move,
04:24 - then I say move dot start,
04:26 - then in draw, I just want to say
04:29 - move dot update.
04:31 - And if I run this.
04:34 - (chuckles) so the data
of the move is happening.
04:37 - That angle is changing
04:38 - but I need to actually rotate these.
04:40 - So the way that I could do that is,
04:43 - right here when I'm showing the cube,
04:45 - I could check
04:46 - and say,
04:47 - if cube, well right
here you could just say,
04:50 - if cube dot z
04:52 - equals move dot z.
04:54 - Let's just do that alright.
04:55 - If cube dot z equals move z.
04:59 - Then I want to rotate
05:02 - z
05:03 - by move dot angle.
05:06 - And I'm going to want to have a push
05:09 - and a pop here.
05:10 - Right? That should then,
05:13 - z cannot be resolved
05:15 - or is not a field.
05:18 - Move has a z.
05:21 - Cube index i.
05:23 - If cube index i right.
05:25 - If cube index i dot z.
05:29 - Here we go! Look at it!
05:31 - It's turning!
05:32 - (grunts) It's kind of doing something.
05:34 - What's it doing?
05:35 - Why is it keep going?
05:37 - Okay (chuckles).
05:38 - So, (clears throat)
05:41 - update, (laughs)
05:43 - should only update the angle
05:46 - if it's animating.
05:48 - So once it reaches the end,
05:49 - it stops animating.
05:51 - So now, we should see it
05:54 - turn.
05:55 - You know what, I think,
05:56 - I'm having this weird
issue with processing
05:59 - which is that, it takes a little while
06:00 - for processing to start.
06:02 - So what I'm actually going to do is,
06:04 - I'm going to have move dot start
06:08 - go into,
06:10 - when I press the space bar.
06:13 - Just so I can be sure
it hasn't started yet.
06:15 - So I'm going to run this sketch.
06:16 - I'm going to hit the space bar.
06:17 - There we go.
06:18 - Look at that. It moves,
06:20 - but look at this, it moves
06:21 - but the red stuff doesn't stay there.
06:23 - Because all I'm doing is
creating the animation
06:23 - of the moving,
06:25 - I'm not actually updating the data.
06:28 - But I need to update the data
06:29 - so I can do all the future moves.
06:31 - But I think there's an
easy thing I can do here
06:33 - which is I can say, move dot update if
06:37 - move dot finished.
06:40 - Then, what do I want to do?
06:43 - Turn z move dot direction.
06:47 - Turning z, isn't that a function?
06:49 - Turn z move dot z,
06:51 - move dot direction.
06:52 - So I think there's got to be a way
06:53 - I can encapsulate this into one function.
06:55 - There's no finished,
06:57 - so I probably could just use
the animating Boolean right?
07:00 - Let's add another one (laughs).
07:03 - Finished is false,
07:05 - finished is true
07:08 - and then,
07:10 - Boolean finished,
07:13 - returned finished.
07:16 - So now, what should happen is,
07:19 - it should animate, (laughs)
07:23 - because it's doing this over
07:24 - and over again.
07:26 - So it ultimately,
07:28 - I want them,
07:28 - when the move is finished,
07:29 - I want to turn it once
07:31 - and then be done.
07:32 - So really what I should do,
07:34 - is put this turn z
07:36 - into the move.
07:38 - Yes.
07:42 - So actually, I don't know if I need
07:43 - that Boolean variable at all.
07:45 - What I want, is when it's done,
07:47 - I want to actually just say turn z,
07:50 - move according to this z
07:52 - and this direction right?
07:54 - And then I don't need this finished stuff.
07:55 - I'm going to keep that in
there just in case I need it.
07:58 - So now, it should turn.
08:00 - There we go!
08:01 - Look at this!
08:02 - (exclaims excitedly)
08:04 - So now, I'm turning it.
08:06 - So this is the idea.
08:07 - This is the logic.
08:08 - I just want to hit the space bar,
08:10 - it's doing every single move.
08:11 - Now the question is,
08:13 - now that I've got this working,
08:15 - how can I make every move
work in the same way?
08:19 - So there's some things
08:20 - that are kind of hard coded in here.
08:22 - For example, this
shouldn't always be turn z.
08:25 - Right, this should sometimes be turn x
08:27 - or turn y
08:28 - or turn
08:31 - z.
08:32 - Before I do that though,
08:33 - let me just make sure it
works in other directions.
08:36 - So for example,
08:38 - if I were to say a negative one,
08:40 - that should be the back of the cube.
08:43 - Okay. So that's working.
08:46 - And if I were to say one,
08:49 - negative one,
08:50 - that should be the front of the cube
08:52 - but going now in counter
clockwise direction.
08:55 - Okay.
08:56 - So that doesn't work.
08:57 - So why doesn't that work?
08:59 - Because if I'm going in
counterclockwise direction,
09:01 - I'm going all the way to negative HALF_PI.
09:03 - So that's something I need to fix.
09:05 - So here, if angle,
09:07 - so I could say, if
absolute value of the angle
09:11 - is greater than HALF_PI.
09:12 - So if I'm going in the negative direction,
09:14 - I need to check negative HALF_PI.
09:15 - That should fix that.
09:18 - Great! So now I can go
in either direction.
09:21 - Only in the z axis.
09:23 - So what if I make a move,
09:27 - that is now
09:29 - the x axis?
09:32 - So if I say one, zero,
09:33 - zero, one,
09:34 - this should be right.
09:35 - I think I have things flipped
09:36 - so it might end up being in the left,
09:37 - in the way that we're looking at it.
09:38 - But if I want to rotate along the x axis.
09:42 - So if I do that now,
09:46 - it's confused.
09:49 - It's doing something totally nonsensical.
09:51 - So here what I really want to say if
09:54 - absolute value of cube index
i dot z is greater than zero.
10:00 - So I probably should have a variable
10:02 - that's keeping track of the actual index.
10:06 - But really what I want to just say is,
10:07 - is cubes,
10:08 - is it the z axis?
10:09 - Then do this.
10:12 - So now, nothing should happen.
10:15 - Something did happen.
10:16 - It's still doing this.
10:17 - But then we shouldn't see that animation.
10:19 - Okay.
10:20 - So let's try to get the x axis.
10:22 - Else,
10:24 - if the absolute value of cube x
10:26 - and cube x equals move x,
10:29 - then I should say,
10:32 - rotate x move dot angle.
10:35 - Alright. So this now would do the x axis.
10:37 - And this should be an else-if
10:40 - cause I'm never going to do two
10:41 - at the same time.
10:42 - So this should be rotating the x axis.
10:44 - The issue is now in move update,
10:48 - when I get to this part,
10:50 - I don't want to do turn z,
10:52 - I want to do turn x.
10:55 - So that I could do the same thing I guess.
10:58 - If absolute value of z
is greater than zero,
11:01 - turn z.
11:02 - Otherwise if absolute value of x,
11:04 - is great zero,
11:06 - turn x,
11:08 - x direction,
11:11 - So let's,
11:12 - this should be x.
11:13 - so I'm kind of getting lucky here
11:15 - cause there's only three possible axes.
11:17 - But it definitely would be useful
11:18 - for me to use like a numeral bowl
11:21 - with like a index
11:22 - to the access.
11:23 - But let's just see if this works.
11:25 - So now, this should be
11:28 - the x-axis.
11:29 - Awesome!
11:30 - So that works.
11:32 - I've got the x-axis.
11:33 - Now I should be able to the y-axis,
11:35 - turn the y-axis.
11:37 - Let's just check a y move.
11:40 - Let's make the move,
11:43 - zero,
11:44 - one, zero.
11:48 - It's not animating.
11:50 - Why is it not animating?
11:53 - I didn't do that here.
11:55 - I need to add the y.
12:02 - So now, this should do the y-axis.
12:06 - Something's wrong
12:07 - I'm going the wrong direction.
12:09 - So I think this should be
negative angle (laughs)
12:14 - Cause my y-axis is flipped.
12:17 - Yeah! There we go!
12:18 - You know,
12:21 - I might have,
12:22 - whatever! It works! (laughs)
12:24 - There might be something
12:25 - that I'm actually done wrong here.
12:26 - But I want,
12:27 - the data is moving correctly.
12:29 - I just need make sure the
animation matches that.
12:31 - So now,
12:34 - instead of having,
12:36 - this all moves
12:38 - be just these letters,
12:41 - now all moves
12:43 - is,
12:46 - an array of move objects.
12:48 - Move,
12:49 - new move array
12:51 - with new move.
12:53 - So up is
12:54 - zero, one, zero
12:57 - in the one direction.
12:59 - You know what,
13:02 - let's just do,
13:03 - I might as well just do them all.
13:04 - I mean I can always invert them
13:06 - but let's do it,
13:06 - let's just actually do them all.
13:07 - So this is,
13:08 - this is up in both directions.
13:10 - This is,
13:12 - okay, hold on. (chuckles)
13:14 - I'm going to speed through this
13:16 - so you don't have to watch all this.
13:18 - (lively music)
13:22 - (bell dings)
13:23 - Alright I put in all the moves.
13:25 - Up, down.
13:26 - Left, right.
13:27 - Front, back.
13:28 - Clockwise, counterclockwise.
13:30 - This should be everything.
13:31 - It should be 12 in there.
13:32 - One, two, three, four, five,
13:33 - six, seven, eight, nine, 10, 11, 12.
13:34 - That's all the moves.
13:35 - So I should be able to
now pick any given move
13:43 - and,
13:44 - all moves
13:46 - and animate that one.
13:47 - And just sort of see.
13:51 - This sequence stuff has to change.
13:52 - So, the sequence stuff I'm
going to do in a second
13:54 - but I was using strings before.
13:56 - That won't work
13:57 - and take this out.
13:58 - So any given move,
14:00 - I should be able to do.
14:01 - So this is move three,
14:03 - index three,
14:04 - zero, one, two, three.
14:05 - So that should be the bottom.
14:07 - I've already spun it. (laughs)
14:10 - That should be the bottom
in a certain direction.
14:12 - Whatever!
14:16 - Great.
14:17 - So hopefully that's the
right one that matches up.
14:18 - Now the sequence
14:22 - is, let's make it an Array List.
14:25 - An Array List of move objects.
14:29 - This will be the sequence.
14:32 - And I know if you're a cue bird,
14:33 - there's actually like a back to
14:34 - which is what I'll just consider
14:36 - that back in the same direction twice,
14:38 - for now.
14:40 - So we can consider this
to be an Array List
14:43 - of moves.
14:45 - And when I'm making that sequence,
14:49 - if I'm going to make,
14:50 - let's just do 10,
14:52 - I'm going to pick the size
14:55 - and I'm going to say,
14:58 - pick an index.
14:59 - Then I'm going to have
move m equals all moves,
15:03 - get that index.
15:05 - And this has an extra,
15:07 - wait, int-random all moves size,
15:10 - sorry, all moves is an array,
15:13 - moves is an Array List.
15:16 - So that's all moves index r.
15:18 - That stays the same
15:20 - and then I'm going to say sequence,
15:22 - dot add m.
15:24 - So this is me putting in
15:28 - 10 moves in a sequence.
15:30 - So let's not worry about
inverting the sequence,
15:33 - let's not flip case,
15:34 - I think is no longer a thing anymore.
15:37 - And then I need a current
indexes current move
15:40 - which is counter.
15:41 - So I also need this to be,
15:44 - let's call this current move.
15:45 - So there's a current move
15:47 - and current move starts at,
15:50 - current moves equals sequence get
15:55 - counter.
15:56 - So it gets the first one.
15:58 - Then I'm going to say,
16:00 - current move update,
16:01 - guess what, this finished thing
is going to come in handy.
16:04 - Perfect! If current move
16:07 - is finished,
16:08 - then index, (murmurs inaudibly) counter,
16:12 - plus plus
16:14 - and
16:16 - current move equals
16:19 - sequence
16:21 - dot get counter.
16:23 - And I definitely need to
16:27 - make sure
16:29 - that I only do this
16:31 - if counter is less than
sequence dot length.
16:36 - So I'll put this if statement in here
16:39 - I don't think,
16:41 - and I'm going to do this,
16:42 - put this sequence in there
16:43 - and then I'm going to say
if started around here.
16:46 - So this is how
16:50 - sequence dot size not length.
16:53 - So this is the same exact algorithm
16:55 - but instead of the move being indicated
16:57 - by a single character,
16:58 - it's now this object.
16:59 - So I'm updating that move,
17:01 - when it's done,
17:02 - as long as I'm not at
the end of the sequence,
17:03 - go to the next one
17:07 - and then get the next one.
17:08 - And then this current move,
17:10 - is what determines
17:12 - the rotation.
17:13 - And so I called it just move before
17:16 - but let's call it current move.
17:19 - And I think this should work now.
17:21 - Move dot start,
17:23 - okay, I'm not going to worry,
17:24 - this should be,
17:25 - just started equals true.
17:27 - So now it's just a Boolean
17:28 - but I'm not starting...
17:32 - this could be current move start.
17:33 - This actually could be current move start.
17:40 - So because this,
17:42 - this can actually current
move update could happen,
17:44 - if it's not animating.
17:46 - So yes.
17:47 - So I just want to start,
17:47 - hitting the space bar
starts the first move
17:50 - which does all of these.
17:51 - And then each one,
17:53 - cause I have this start function,
17:55 - needs to actually explicitly call start.
17:57 - Okay this I think should work.
18:01 - (drum rolls)
So if I press the space bar,
18:04 - you can see the move happen in sequence.
18:06 - (drum rolls)
18:13 - Wait,
18:14 - if counter is less than,
18:16 - it's got to be less than size minus one
18:19 - because this is where I increment.
18:21 - So I'm going to the next one.
18:22 - The last one is size minus one.
18:24 - So that's good.
18:26 - So let's give it 50 random moves.
18:31 - And let's say get it started.
18:33 - So now it's playing 50 random moves.
18:35 - It's a little silly
18:36 - that sometimes the moves are inverted.
18:37 - So now I should be able
to add that sequence.
18:40 - (laughs) What just happened there?
18:45 - I'm not making a copy of the move.
18:48 - So a move is like animated
18:50 - and finished.
18:51 - And then it, when it gets it again,
18:52 - if it does that move again,
18:53 - it's not like a copy of the move.
18:56 - So this should actually be,
18:58 - when I make that sequence,
18:59 - yes, this should be
like all moves dot clone
19:02 - or, cause there's a way to clone objects
19:03 - but I'm just going to
write my own copy function.
19:05 - So all moves index r dot copy,
19:10 - or when I call start,
19:12 - I could set,
19:13 - I think it's actually as simple
19:14 - as just setting...
19:15 - you know what, I might be able
19:16 - to just not do a copy
19:17 - but set the angle back to zero.
19:19 - Couldn't I do that?
19:20 - If animating equals true,
19:22 - finished equals false,
19:24 - like that might actually work.
19:25 - So I could have made a copy of the move
19:27 - but I think just in start,
19:29 - since I have to do that with everything,
19:31 - that might fix it.
19:32 - Let's see if that fixes it.
19:37 - A bunch of moves.
19:39 - It's going to do the same move again.
19:40 - Just by the laws of probability.
19:42 - I think this is working, dare I say
19:44 - and I could still spin around it.
19:48 - I mean, it doesn't look like
it's making any mistakes.
19:50 - So now let's make a speed.
19:52 - Let's just make that a global variable.
19:56 - And right now it's point one.
19:58 - So let's make it like point five
19:59 - to make it kind of faster.
20:01 - And then in move, this,
20:04 - I mean I suppose that could be a property
20:05 - of the move itself.
20:07 - But let's just see it do it faster.
20:11 - Cause that's more fun to
watch it do it faster.
20:13 - So let's see if now,
20:15 - if I add the moves in reverse,
20:17 - when it's done, it should be solved.
20:19 - Then I have all the moves.
20:21 - Now all I need to do,
20:22 - is go through the
sequence backwards right?
20:25 - Start with the last element
20:27 - of the sequence, go down to zero.
20:31 - This is why I kind of want to,
20:32 - I do need to make a copy
20:34 - because I need to make it a
completely different move,
20:36 - in the opposite direction.
20:38 - So I do want to say,
20:39 - move, next move equals sequence
20:44 - get i
20:45 - and I really actually need a copy here.
20:47 - So we'll see this both ways
20:48 - because then I want to say
like next move dot reverse.
20:52 - So in the move object,
20:55 - or though I could just
point to the other move
20:57 - but I'm going to do it this way.
20:58 - I'm just figuring out.
20:59 - Missed having fun figuring this out.
21:01 - I'm going to make a function called copy
21:03 - which returns a new move with what?
21:06 - X, y, z and direction.
21:08 - And then I'm going to
make a function called
21:12 - reverse
21:15 - which just says,
21:16 - direction times equals negative one.
21:18 - so this, if I make those two functions,
21:21 - as I'm going through the sequence,
21:23 - I'm copying all of them
21:24 - but reversing them.
21:25 - And now I have, it
should be twice as long.
21:28 - So let's just do this
21:29 - with just like five moves,
21:31 - just to see if it works.
21:32 - I've got to add them.
21:34 - No wonder.
21:34 - I've got to add those moves.
21:37 - Okay.
21:40 - Let's go. Here we go.
21:42 - So it should do those
moves in reverse and boom!
21:44 - There's the Rubik's Cube
back in its original state.
21:46 - Now, here we go.
21:52 - Let's make it full screen
21:55 - and enjoy,
21:57 - this.
21:59 - Make it a little bit faster.
22:00 - Enjoy this Rubik's Cube doing 500 moves,
22:05 - then in reverse.
22:07 - This is going to take a long time.
22:08 - Let's not do 500. (laughs)
22:10 - Let's just do 100.
22:13 - And you will get the feeling
22:14 - of the cube solving itself.
22:15 - You know I really should do something
22:17 - where if I pick a certain move,
22:18 - I'm not allowed to pick the reverse
22:20 - of that move next
22:21 - cause that's going to
make it look really weird.
22:23 - And like why is it doing that?
22:24 - But that's neither here
22:25 - nor there.
22:26 - Let me actually draw the counter
22:27 - so I can see what move we're on.
22:29 - Cause that'll be somewhat useful.
22:30 - So I'm going to say,
22:31 - fill 255,
22:33 - text
22:34 - counter,
22:35 - I don't know.
22:36 - It's just going to end
up being in 3D space
22:38 - in some weird location.
22:39 - Let's just say 100,
22:41 - counter 100, 100.
22:43 - The scale is going to be weird.
22:44 - Let's just try that.
22:46 - Text size
22:48 - 32.
22:49 - Alright. Let me put this,
22:52 - let's have some fun with this.
22:54 - Let me put this on speed of 1.5.
22:58 - Let me make it do 1000 moves
23:01 - and here we go.
23:04 - And thank you for watching
this coding challenge.
23:08 - (chuckles) You're not
really seeing the rotation.
23:10 - It's just like shaking.
23:12 - Okay that's too fast.
23:13 - Let's try a speed just of like 1.0.
23:21 - Alright.
23:22 - Thanks for watching this coding challenge
23:23 - where I am shuffling the Rubik's Cube
23:25 - with random moves,
23:27 - then playing those moves back in reverse.
23:29 - When it gets to 2,000 moves,
23:31 - it will actually,
23:33 - be back in its original orientation.
23:35 - I hope that works.
23:36 - I hope you make your own version of this.
23:37 - If I come back
23:38 - and make a par four,
23:39 - which I intend to do,
23:40 - I'm going to see if I can
use a genetic algorithm
23:42 - to take any shuffled state
23:45 - and evolve a solution
23:47 - within maybe a certain number of moves,
23:48 - I suppose 20 might be the number
23:50 - to pick in terms
23:51 - of the genetic information
23:52 - which will be a sequence of moves.
23:54 - This should be similar to what I did
23:55 - with searching for the phrase
23:57 - to be or not to be,
23:58 - in the space of all
possible random phrases.
24:01 - We'll see if that works.
24:02 - I have no idea if that will work.
24:03 - But I'm going to come back
24:04 - and do more with this in part four,
24:06 - in a future coding challenge.
24:07 - And please share with me.
24:09 - Go to the codingtraining.com,
24:10 - look at the link in this
video's description too.
24:12 - If you make a version of this,
24:13 - whether it's in JavaScript
24:14 - or processing
24:15 - or some other programming language
24:16 - or environment,
24:17 - you can submit a link to your version
24:18 - so that I can see it
24:19 - and the rest of the community can as well.
24:21 - Alright, thanks very much.
24:21 - (blows kiss) Goodbye.
24:23 - (bell dings)
24:24 - (lively music)

Cleaned transcript:

(bell dings) Hello and welcome to part three of my Rubik's Cube coding challenge. So I've done two parts already, if you watch those, I'm very thankful to you. But I'm going to do something really important in this. And it's really not about the Rubik's Cube at all, it's really about animation. And I want to be able to just do something to make it a little more visually pleasing to watch it do stuff. So what it does right now is, if I hit the space bar, it's going to shuffle a whole bunch of moves. All the possible moves, up, down left, right clockwise, counterclockwise. It could do any move along any axis. It's also then going to whatever, it's doing a random sequence of 100 moves and then it's going to do those in reverse. And you can see it looks kind of like it's solving it, of course it's not. Just doing a random sequence and then applying it in reverse. Hit the space bar again, it's going to go again. It's actually doing the same sequence again. So this would be I think more, I would be a little more confident that it's working correctly, if I could actually watch the, the cubies rotate themselves to actually turn. So in order to do that, I need to add animation, I need to actually use the rotate function to do that. So (chuckles), I have to figure out how to do that. Alright I think a way that's going to make sense to do this is to create a class, called move. And each move is what? It's a given axis, like what's the axis that's moving, what's the direction it's moving and then if I'm going to do an animation, I need to animate an angle from zero to 90 degrees. So I need an angle which will start as zero. I need to have an axis and maybe what I'll do is just do x, y and z. An angle and an axis. And I'll have that access distort in variables x, y and z. So the x will be one or negative one, if it's right or left. The y will be one or negative one, if it's up or down. The z will be one or negative one, if it's front or back. So, that's kind of I think how I'll deal with this right now. So when I make a move, I have to give it an x, a y and a z. And that's all I have to give it. And a direction. So I need to know whether I'm rotating, whether I'm rotating clockwise or counter clockwise. Or the angle is going up or the angle is going down. So this dot x equals x. This dot y equals y. This dot Z equals Z. This dot direction equals direction. And this is this. Ultimately I've kind of done this already in the sense that I have these functions, called turn z, turn y, turn x. And those actually move the cubes around and rotate their faces. But they do it instantaneously. So what I think I want to do is, create an animation that happens, then I finish that animation then I quickly move everything around. And it'll look as if it's happening seamlessly. So let's just say, for the sake of argument, I'm going to have one move. Move m. I'll call it move. And move m, forget about this, well I'll leave the sequence thing in here for a second. Move, is a new move which is going to rotate the zaxis, the front face. So that is zero, zero, one in a clockwise direction. That's a move. Then I want to say, move dot start. I think I'll have a function called start and what does that do? It sets a variable, I'll have a variable called animating. And it sets animating equal to true. I don't know that I'm going to need this, but I feel like I might need a flag to know when I've started or stopped. So then I need an update function and what update will do, is, I could use LERP for to like interpolate from zero to 90 degrees or I could just increase the angle. So let's just increase the angle right now. I'm going to say, angle plus equals direction times, you know some amount like point one. So I'm going to increment the angle by point one and if angle is greater than HALF_PI, then, angle should go back to being zero actually. And then I'm going to say, animating equals false. So let's just see if I can get this to happen. So basically, if I have a move, then I say move dot start, then in draw, I just want to say move dot update. And if I run this. (chuckles) so the data of the move is happening. That angle is changing but I need to actually rotate these. So the way that I could do that is, right here when I'm showing the cube, I could check and say, if cube, well right here you could just say, if cube dot z equals move dot z. Let's just do that alright. If cube dot z equals move z. Then I want to rotate z by move dot angle. And I'm going to want to have a push and a pop here. Right? That should then, z cannot be resolved or is not a field. Move has a z. Cube index i. If cube index i right. If cube index i dot z. Here we go! Look at it! It's turning! (grunts) It's kind of doing something. What's it doing? Why is it keep going? Okay (chuckles). So, (clears throat) update, (laughs) should only update the angle if it's animating. So once it reaches the end, it stops animating. So now, we should see it turn. You know what, I think, I'm having this weird issue with processing which is that, it takes a little while for processing to start. So what I'm actually going to do is, I'm going to have move dot start go into, when I press the space bar. Just so I can be sure it hasn't started yet. So I'm going to run this sketch. I'm going to hit the space bar. There we go. Look at that. It moves, but look at this, it moves but the red stuff doesn't stay there. Because all I'm doing is creating the animation of the moving, I'm not actually updating the data. But I need to update the data so I can do all the future moves. But I think there's an easy thing I can do here which is I can say, move dot update if move dot finished. Then, what do I want to do? Turn z move dot direction. Turning z, isn't that a function? Turn z move dot z, move dot direction. So I think there's got to be a way I can encapsulate this into one function. There's no finished, so I probably could just use the animating Boolean right? Let's add another one (laughs). Finished is false, finished is true and then, Boolean finished, returned finished. So now, what should happen is, it should animate, (laughs) because it's doing this over and over again. So it ultimately, I want them, when the move is finished, I want to turn it once and then be done. So really what I should do, is put this turn z into the move. Yes. So actually, I don't know if I need that Boolean variable at all. What I want, is when it's done, I want to actually just say turn z, move according to this z and this direction right? And then I don't need this finished stuff. I'm going to keep that in there just in case I need it. So now, it should turn. There we go! Look at this! (exclaims excitedly) So now, I'm turning it. So this is the idea. This is the logic. I just want to hit the space bar, it's doing every single move. Now the question is, now that I've got this working, how can I make every move work in the same way? So there's some things that are kind of hard coded in here. For example, this shouldn't always be turn z. Right, this should sometimes be turn x or turn y or turn z. Before I do that though, let me just make sure it works in other directions. So for example, if I were to say a negative one, that should be the back of the cube. Okay. So that's working. And if I were to say one, negative one, that should be the front of the cube but going now in counter clockwise direction. Okay. So that doesn't work. So why doesn't that work? Because if I'm going in counterclockwise direction, I'm going all the way to negative HALF_PI. So that's something I need to fix. So here, if angle, so I could say, if absolute value of the angle is greater than HALF_PI. So if I'm going in the negative direction, I need to check negative HALF_PI. That should fix that. Great! So now I can go in either direction. Only in the z axis. So what if I make a move, that is now the x axis? So if I say one, zero, zero, one, this should be right. I think I have things flipped so it might end up being in the left, in the way that we're looking at it. But if I want to rotate along the x axis. So if I do that now, it's confused. It's doing something totally nonsensical. So here what I really want to say if absolute value of cube index i dot z is greater than zero. So I probably should have a variable that's keeping track of the actual index. But really what I want to just say is, is cubes, is it the z axis? Then do this. So now, nothing should happen. Something did happen. It's still doing this. But then we shouldn't see that animation. Okay. So let's try to get the x axis. Else, if the absolute value of cube x and cube x equals move x, then I should say, rotate x move dot angle. Alright. So this now would do the x axis. And this should be an elseif cause I'm never going to do two at the same time. So this should be rotating the x axis. The issue is now in move update, when I get to this part, I don't want to do turn z, I want to do turn x. So that I could do the same thing I guess. If absolute value of z is greater than zero, turn z. Otherwise if absolute value of x, is great zero, turn x, x direction, So let's, this should be x. so I'm kind of getting lucky here cause there's only three possible axes. But it definitely would be useful for me to use like a numeral bowl with like a index to the access. But let's just see if this works. So now, this should be the xaxis. Awesome! So that works. I've got the xaxis. Now I should be able to the yaxis, turn the yaxis. Let's just check a y move. Let's make the move, zero, one, zero. It's not animating. Why is it not animating? I didn't do that here. I need to add the y. So now, this should do the yaxis. Something's wrong I'm going the wrong direction. So I think this should be negative angle (laughs) Cause my yaxis is flipped. Yeah! There we go! You know, I might have, whatever! It works! (laughs) There might be something that I'm actually done wrong here. But I want, the data is moving correctly. I just need make sure the animation matches that. So now, instead of having, this all moves be just these letters, now all moves is, an array of move objects. Move, new move array with new move. So up is zero, one, zero in the one direction. You know what, let's just do, I might as well just do them all. I mean I can always invert them but let's do it, let's just actually do them all. So this is, this is up in both directions. This is, okay, hold on. (chuckles) I'm going to speed through this so you don't have to watch all this. (lively music) (bell dings) Alright I put in all the moves. Up, down. Left, right. Front, back. Clockwise, counterclockwise. This should be everything. It should be 12 in there. One, two, three, four, five, six, seven, eight, nine, 10, 11, 12. That's all the moves. So I should be able to now pick any given move and, all moves and animate that one. And just sort of see. This sequence stuff has to change. So, the sequence stuff I'm going to do in a second but I was using strings before. That won't work and take this out. So any given move, I should be able to do. So this is move three, index three, zero, one, two, three. So that should be the bottom. I've already spun it. (laughs) That should be the bottom in a certain direction. Whatever! Great. So hopefully that's the right one that matches up. Now the sequence is, let's make it an Array List. An Array List of move objects. This will be the sequence. And I know if you're a cue bird, there's actually like a back to which is what I'll just consider that back in the same direction twice, for now. So we can consider this to be an Array List of moves. And when I'm making that sequence, if I'm going to make, let's just do 10, I'm going to pick the size and I'm going to say, pick an index. Then I'm going to have move m equals all moves, get that index. And this has an extra, wait, intrandom all moves size, sorry, all moves is an array, moves is an Array List. So that's all moves index r. That stays the same and then I'm going to say sequence, dot add m. So this is me putting in 10 moves in a sequence. So let's not worry about inverting the sequence, let's not flip case, I think is no longer a thing anymore. And then I need a current indexes current move which is counter. So I also need this to be, let's call this current move. So there's a current move and current move starts at, current moves equals sequence get counter. So it gets the first one. Then I'm going to say, current move update, guess what, this finished thing is going to come in handy. Perfect! If current move is finished, then index, (murmurs inaudibly) counter, plus plus and current move equals sequence dot get counter. And I definitely need to make sure that I only do this if counter is less than sequence dot length. So I'll put this if statement in here I don't think, and I'm going to do this, put this sequence in there and then I'm going to say if started around here. So this is how sequence dot size not length. So this is the same exact algorithm but instead of the move being indicated by a single character, it's now this object. So I'm updating that move, when it's done, as long as I'm not at the end of the sequence, go to the next one and then get the next one. And then this current move, is what determines the rotation. And so I called it just move before but let's call it current move. And I think this should work now. Move dot start, okay, I'm not going to worry, this should be, just started equals true. So now it's just a Boolean but I'm not starting... this could be current move start. This actually could be current move start. So because this, this can actually current move update could happen, if it's not animating. So yes. So I just want to start, hitting the space bar starts the first move which does all of these. And then each one, cause I have this start function, needs to actually explicitly call start. Okay this I think should work. (drum rolls) So if I press the space bar, you can see the move happen in sequence. (drum rolls) Wait, if counter is less than, it's got to be less than size minus one because this is where I increment. So I'm going to the next one. The last one is size minus one. So that's good. So let's give it 50 random moves. And let's say get it started. So now it's playing 50 random moves. It's a little silly that sometimes the moves are inverted. So now I should be able to add that sequence. (laughs) What just happened there? I'm not making a copy of the move. So a move is like animated and finished. And then it, when it gets it again, if it does that move again, it's not like a copy of the move. So this should actually be, when I make that sequence, yes, this should be like all moves dot clone or, cause there's a way to clone objects but I'm just going to write my own copy function. So all moves index r dot copy, or when I call start, I could set, I think it's actually as simple as just setting... you know what, I might be able to just not do a copy but set the angle back to zero. Couldn't I do that? If animating equals true, finished equals false, like that might actually work. So I could have made a copy of the move but I think just in start, since I have to do that with everything, that might fix it. Let's see if that fixes it. A bunch of moves. It's going to do the same move again. Just by the laws of probability. I think this is working, dare I say and I could still spin around it. I mean, it doesn't look like it's making any mistakes. So now let's make a speed. Let's just make that a global variable. And right now it's point one. So let's make it like point five to make it kind of faster. And then in move, this, I mean I suppose that could be a property of the move itself. But let's just see it do it faster. Cause that's more fun to watch it do it faster. So let's see if now, if I add the moves in reverse, when it's done, it should be solved. Then I have all the moves. Now all I need to do, is go through the sequence backwards right? Start with the last element of the sequence, go down to zero. This is why I kind of want to, I do need to make a copy because I need to make it a completely different move, in the opposite direction. So I do want to say, move, next move equals sequence get i and I really actually need a copy here. So we'll see this both ways because then I want to say like next move dot reverse. So in the move object, or though I could just point to the other move but I'm going to do it this way. I'm just figuring out. Missed having fun figuring this out. I'm going to make a function called copy which returns a new move with what? X, y, z and direction. And then I'm going to make a function called reverse which just says, direction times equals negative one. so this, if I make those two functions, as I'm going through the sequence, I'm copying all of them but reversing them. And now I have, it should be twice as long. So let's just do this with just like five moves, just to see if it works. I've got to add them. No wonder. I've got to add those moves. Okay. Let's go. Here we go. So it should do those moves in reverse and boom! There's the Rubik's Cube back in its original state. Now, here we go. Let's make it full screen and enjoy, this. Make it a little bit faster. Enjoy this Rubik's Cube doing 500 moves, then in reverse. This is going to take a long time. Let's not do 500. (laughs) Let's just do 100. And you will get the feeling of the cube solving itself. You know I really should do something where if I pick a certain move, I'm not allowed to pick the reverse of that move next cause that's going to make it look really weird. And like why is it doing that? But that's neither here nor there. Let me actually draw the counter so I can see what move we're on. Cause that'll be somewhat useful. So I'm going to say, fill 255, text counter, I don't know. It's just going to end up being in 3D space in some weird location. Let's just say 100, counter 100, 100. The scale is going to be weird. Let's just try that. Text size 32. Alright. Let me put this, let's have some fun with this. Let me put this on speed of 1.5. Let me make it do 1000 moves and here we go. And thank you for watching this coding challenge. (chuckles) You're not really seeing the rotation. It's just like shaking. Okay that's too fast. Let's try a speed just of like 1.0. Alright. Thanks for watching this coding challenge where I am shuffling the Rubik's Cube with random moves, then playing those moves back in reverse. When it gets to 2,000 moves, it will actually, be back in its original orientation. I hope that works. I hope you make your own version of this. If I come back and make a par four, which I intend to do, I'm going to see if I can use a genetic algorithm to take any shuffled state and evolve a solution within maybe a certain number of moves, I suppose 20 might be the number to pick in terms of the genetic information which will be a sequence of moves. This should be similar to what I did with searching for the phrase to be or not to be, in the space of all possible random phrases. We'll see if that works. I have no idea if that will work. But I'm going to come back and do more with this in part four, in a future coding challenge. And please share with me. Go to the codingtraining.com, look at the link in this video's description too. If you make a version of this, whether it's in JavaScript or processing or some other programming language or environment, you can submit a link to your version so that I can see it and the rest of the community can as well. Alright, thanks very much. (blows kiss) Goodbye. (bell dings) (lively music)
