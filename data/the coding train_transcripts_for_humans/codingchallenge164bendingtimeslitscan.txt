With timestamps:

00:03 - hello and welcome to a time displacement
00:06 - slit scan coding challenge this video is
00:10 - part of the support p5 campaign adopt a
00:14 - function series thank you to tim
00:16 - rodenbroker who adopted the copy
00:19 - function for this video if you're not
00:21 - familiar with tim's work he teaches all
00:23 - about creative coding on his website you
00:25 - can see beautiful examples of what he's
00:27 - done with the copy function on his
00:29 - instagram he's got an upcoming course
00:31 - all about the copy function and i would
00:33 - certainly encourage you to subscribe to
00:35 - his patreon to get access to all of his
00:37 - courses i've already finished recording
00:38 - this coding challenge what you're seeing
00:40 - here is the end result of the video i'm
00:42 - going to start by just what is the copy
00:44 - function what arguments does it take how
00:46 - does it work how can it be used to
00:47 - create a slit scan effect and from there
00:50 - move on to warping time and space itself
00:54 - enjoy i'm going to begin this
00:56 - exploration of the copy function with
00:57 - just this basic processing sketch one
00:59 - red circle right there in the top left
01:02 - corner at its core the copy function
01:04 - does one thing
01:07 - it takes a rectangle of pixels
01:10 - this is known as the source
01:13 - and copies them to another rectangle of
01:15 - pixels known as the destination
01:20 - to execute the process call the copy
01:22 - function
01:24 - with eight arguments
01:28 - the x y width and height of the source
01:30 - rectangle the x y being the top left the
01:33 - width and height of that rectangle and
01:35 - then the x y width and height of the
01:38 - destination rectangle once again the x y
01:41 - being in the top left and then the width
01:43 - and height let's see this in action i'm
01:45 - going to attempt to copy the top left
01:48 - quadrant of the canvas to the bottom
01:50 - right
01:53 - there we go it looks like i just called
01:55 - the circle function again for a
01:57 - different location but i have not i'm
01:59 - actually just copying the pixels from a
02:01 - rectangular portion of the canvas to
02:04 - another one what is especially exciting
02:07 - about using the copy function is
02:09 - the destination the dimensions of the
02:12 - destination rectangle do not have to
02:14 - match the dimensions of the source one
02:17 - so i also have the opportunity to
02:18 - stretch and skew and twist that original
02:22 - image
02:25 - here i'm just setting the width and
02:26 - height of the destination rectangle
02:29 - according to the mouse x and mouse y
02:32 - location this isn't a particularly
02:33 - engaging example if i really just wanted
02:35 - to draw multiple shapes and kind of skew
02:37 - them i would just keep using circle and
02:40 - ellipse and change the colors and the
02:41 - dimensions of the actual geometry that
02:43 - i'm drawing while i do think there is
02:46 - lots of potential for what you could do
02:48 - with generated graphics and the copy
02:51 - function what i'm going to move to
02:52 - demonstrating now is what happens if i
02:54 - start to use the copy function with an
02:57 - image that i'm loading or perhaps even a
03:00 - real-time video in this particular
03:02 - sketch i've got an image of the choo
03:05 - choo bot character in the data directory
03:13 - now i can load the image from the file
03:15 - and display the image using the image
03:17 - function now what happens if i put back
03:19 - in the copy function
03:22 - here we see the top left portion of the
03:24 - image copied and overlaid onto the image
03:27 - itself this admittedly though is a
03:28 - little bit strange here i am taking the
03:31 - image drawing it to the canvas so that i
03:33 - can copy a portion of it to also draw it
03:35 - to the canvas
03:38 - the copy function can take an additional
03:41 - argument right up front
03:43 - the source image itself
03:47 - so rather than draw the bot image
03:50 - i can just place
03:52 - a reference to the bot image as the
03:54 - first argument in copy and there we go
03:57 - now i'm copying just that one section of
04:00 - the image to the same spot in this
04:02 - window this immediately opens up a lot
04:05 - of possibilities for example what if i
04:07 - draw the image by copying a sequence of
04:10 - slices
04:16 - so this looks like i'm just drawing the
04:17 - image as it was before but i'm not i'm
04:20 - displaying it as
04:22 - 40 slices each of width of 10 pixels
04:25 - i'll put a rectangle overlay just so you
04:27 - can see it
04:31 - there now you can see the scale and size
04:34 - of each of those slices so there's
04:36 - really no reason why
04:38 - i couldn't take a different part of the
04:40 - image and display it in a different
04:42 - place shuffle up the slices
04:50 - here the moment i'm about to copy from
04:52 - the image i pick a random x location to
04:54 - copy from i'm still going to put them in
04:56 - their linear sequence but the source
04:59 - will be random i've added no loop so
05:01 - that it just does it once now you can
05:03 - see i've completely mixed up the image
05:06 - taking away that rectangular overlay and
05:08 - there you go here's an exercise for you
05:11 - could you shuffle up an image in a grid
05:13 - rather than instead of just horizontal
05:16 - slices a checkerboard pattern i would
05:18 - like to take this in a different
05:20 - direction and just explore some
05:22 - algorithmic visual possibilities let's
05:24 - start by adding a sine wave pattern to
05:26 - the location i'm copying from if sine
05:29 - waves are unfamiliar to you it's simple
05:31 - harmonic oscillating motion i'll refer
05:33 - you to my nature of code video series
05:35 - all about these wave patterns
05:38 - i'm going to use the variable name sx
05:40 - for the source x
05:42 - again if i just use x directly from the
05:44 - loop
05:46 - we get the image as is
05:48 - what if i were to
05:50 - offset the source x location by some
05:54 - counter variable
05:58 - x plus counter there is a built-in frame
06:00 - count variable in processing but i'm
06:02 - putting my own variable in here because
06:03 - i'm going to start to do more with it
06:05 - once i get to harmonic motion
06:08 - amazingly enough
06:09 - it's just sliding the image because i'm
06:12 - moving where i'm copying from so what if
06:15 - i were to introduce the modulo operator
06:19 - the modulo operator takes the remainder
06:21 - of division so numbers as they increment
06:24 - past the width of the window will cycle
06:26 - back to zero and again and again
06:29 - sort of little blinking accidental
06:31 - blinking effect as it's kind of working
06:33 - with those end pixels a little by little
06:36 - if i were to use the width itself as my
06:38 - incrementation variable then i will get
06:40 - rid of that little flickery effect
06:44 - of course it's moving much faster
06:46 - because it's going by 10 pixels each
06:48 - time so what if though instead of
06:50 - offsetting by just a counter variable
06:52 - that's going up by one and one and one
06:55 - what if i offset by some variable amount
06:57 - that's smoothly oscillating up and down
07:00 - let's change counter to angle
07:05 - angle plus equal
07:08 - some small amount i'm going to make a
07:11 - separate offset variable
07:14 - which is sine of that angle
07:16 - i'm going to map that value
07:20 - the result of the sine function is
07:21 - between negative one and one
07:24 - and i want to offset it by
07:26 - some amount of the width of the image
07:30 - now because i'm dealing with pixels it's
07:32 - important that i stick with integers
07:34 - because there's no
07:36 - subpixel values there's no pixel 1.5 1.6
07:39 - so i will also convert that offset to an
07:42 - integer
07:44 - and let's see what we get
07:47 - now it's shaking back and forth i think
07:49 - i've really got to deal with the fact
07:52 - that there's a specific number of
07:54 - columns here even though i have the full
07:56 - width of pixels i only have 40 slices
07:59 - because each one is a width of 10. and
08:02 - i'll call those columns
08:06 - the number of columns is the total width
08:08 - or image divided by the width of each
08:11 - slice now i'm really looking to map the
08:13 - offset
08:14 - not to the total number of pixels but
08:18 - the total number of columns
08:20 - and then to find that source location i
08:22 - can expand by the width
08:25 - there we go back and forth back and
08:27 - forth
08:28 - this is getting somewhere i think i mean
08:30 - i haven't actually done this before i'm
08:31 - doing this just in real time right now
08:33 - as i'm recording this video let me slow
08:35 - it down a little bit
08:37 - there we go looks kind of stuttery
08:38 - because it's actually moving by 10
08:40 - pixels each time so what's happening
08:42 - here i have a sine wave
08:45 - this motion up and down
08:47 - you can think of it as i'll use a train
08:50 - whistle here as a slider sliding back
08:53 - and forth across the image so right now
08:56 - every slice
08:58 - is sliding back and forth at the same
09:00 - speed but what if some slices slide more
09:04 - quickly
09:06 - or some slices slide more slowly
09:10 - then wouldn't i start to see the image
09:13 - break itself apart put itself back
09:15 - together as the slices become out of
09:17 - sync from each other one way to approach
09:19 - this would just be to
09:21 - multiply the angle by some factor
09:25 - so x is going between zero and with
09:30 - and why don't i multiply that angle by
09:32 - some amount between like point one and
09:35 - 2. so i'm shrinking it or doubling it
09:38 - multiply by factor
09:41 - well i'm not really sure i knew what was
09:44 - going to happen there but we're starting
09:46 - to see the possibilities here at some
09:48 - point i would imagine it's going to put
09:51 - itself back together i'm having to
09:53 - restrain myself right now because i want
09:55 - to keep going with this i think there's
09:56 - probably more clever ways i could think
09:58 - about offsetting the different wave
10:00 - patterns
10:01 - thinking about the slices as horizontal
10:03 - rather than vertical maybe i would use
10:05 - purl and noise or some other kind of
10:07 - algorithm please explore those things
10:09 - and certainly the source image that you
10:12 - choose to work with will make a huge
10:14 - difference in what kinds of visual
10:15 - outcomes you get but the title of this
10:17 - video is slit scan and i really what i
10:19 - want to move towards doing is looking at
10:22 - what happens when i start to work with a
10:25 - moving image a video image something
10:27 - that is not static like the choo choo
10:29 - bot so let me quickly replace the loaded
10:32 - png image with live video
10:36 - i've completely forgotten how to do
10:37 - capture in processing
10:41 - there we go
10:46 - and certainly i could work with code in
10:48 - a flexible way where my the width and
10:50 - height of my canvas doesn't necessarily
10:52 - match the source image everything's
10:53 - going to be a lot easier if they do
10:55 - match so i'm going to match them
10:58 - it's not create capture
11:02 - new capture oh this this i need this
11:06 - no dot just this
11:15 - so here i am using processing so first
11:17 - of all i've got to give permission on a
11:19 - mac at least for processing to have
11:21 - access to the camera and then because i
11:23 - do all sorts of crazy things with this
11:24 - computer i'm getting the open broadcast
11:27 - studio virtual camera into processing
11:30 - which i don't want i want my webcam
11:33 - so let me look at all of the cameras
11:35 - that i have connected
11:36 - and i can see here
11:38 - zero is the obs virtual camera one is
11:41 - the facetime hd camera the built-in
11:43 - webcam
11:47 - there we go whoa
11:48 - glitchy glitchy glitchy so i was being
11:51 - lazy here i just want to put cam.read
11:53 - just read from the camera while you're
11:55 - looping through draw that's not really
11:56 - the proper way to do this
12:01 - i should be writing the actual capture
12:03 - event which is triggered whenever there
12:06 - is a new image ready from the camera
12:08 - and there we go don't ask me what all
12:10 - this red is down here i have a feeling
12:12 - i've got some weird wonky settings on my
12:13 - computer so i'm just going to ignore
12:15 - that for right now it's working now
12:17 - there's no reason why i can't just put
12:19 - in my code from before but replace the
12:21 - bot image with the live camera
12:28 - and there we go
12:30 - lots and lots of fun to be had
12:33 - i've actually done quite a bit of this
12:34 - in a video that i made years ago
12:36 - demonstrating slit scan in p5.js and in
12:39 - that video i referred to this article
12:41 - this catalog of video artworks and
12:42 - research about slit scan photography
12:44 - from goal 11. i would really encourage
12:46 - you to check it out and and look at all
12:49 - of the historical precursors to what we
12:51 - do today with computational media
12:53 - whether it's film
12:54 - photography analog video and
12:56 - additionally since i made this so long
12:58 - ago i would love to hear from you in the
13:00 - comments what are your favorite
13:02 - historical examples of slitscan
13:04 - photography current artist working with
13:06 - these kinds of techniques i would love
13:07 - to know all about them but i just want
13:09 - to take a minute to demonstrate how slit
13:12 - scan works in processing and of course
13:14 - i'll also include p5.js code as well so
13:17 - we're still working with the same core
13:19 - concept of having a source image and a
13:21 - destination image
13:27 - in this case the source image is my
13:30 - webcam and the destination image is the
13:32 - processing window the way slit scan was
13:35 - performed with real film analog film
13:38 - take that film and expose it while
13:40 - sliding it past a slit shaped aperture
13:43 - in other words
13:45 - this is our view of the camera
13:49 - here is maybe that slit we're able to
13:51 - look at just one slice of pixels in this
13:54 - digital image and then this is like our
13:56 - film but this doesn't slide rather we'll
13:58 - take those pixels and put them here and
14:01 - then the next frame will put them here
14:04 - sliding this slice essentially across
14:06 - the destination how do we do that
14:09 - the copy function
14:11 - copy the pixels from a slice put them
14:13 - here put them here put them here put
14:15 - them here put them in here put them
14:16 - right here when we get to the end go
14:18 - back to the beginning
14:20 - so let's keep that width of 10
14:23 - have a global variable called x
14:27 - and copy really i could choose any slice
14:30 - but i think it's going to be most
14:31 - convenient if i take the middle slice of
14:33 - the camera and that's what i'm always
14:35 - copying so the middle is
14:38 - width divided by 2
14:40 - minus
14:42 - the width of the slice divided by two
14:44 - and always copy it to that x position
14:47 - i don't need columns anymore so now you
14:49 - can see that's that slice of the middle
14:52 - of the camera it's just always being
14:54 - copied to the leftmost part of the
14:56 - canvas but what if every frame
15:00 - i move
15:01 - that slice over by a pixel
15:05 - well now you can see it's moving
15:08 - i forgot i'm erasing the background
15:11 - every time so i'm just actually seeing
15:13 - that slice move across and
15:16 - i think i want to match it with the
15:17 - actual width so move it by the width of
15:19 - the slice itself we'll see that again
15:21 - it'll move much more quickly now
15:24 - let's stop drawing the background
15:27 - just once in setup
15:30 - and there you go you can see i've like
15:31 - smeared myself all the way across the
15:34 - image but it got to the end and where
15:37 - did it go
15:40 - so i'm going to try if i stay very very
15:42 - still
15:44 - we see that one slice being duplicated
15:46 - of course my mouth is moving if i could
15:48 - move at the exact speed
15:51 - then i can practically get an image of
15:53 - myself i could be in it twice by moving
15:54 - back and forth
15:56 - there's a lot of possibilities here and
15:57 - of course i can reduce the width itself
15:59 - as well let's put it down to two pixels
16:03 - [Music]
16:11 - this already i think gives you a lot to
16:13 - work with but i don't want to stop here
16:15 - because i think there's two things i
16:16 - could add that will really expand the
16:19 - creative possibilities of this
16:20 - particular demonstration the first is
16:23 - what if instead of copying the source
16:25 - pixels to the destination processing
16:28 - window itself i had an interim step
16:32 - what if i had a p image object itself
16:35 - where i could take those pixels into it
16:37 - and then i could draw that p image into
16:40 - the destination what that would allow me
16:42 - to do is use things like translate and
16:45 - rotate so what if i wanted that slice to
16:48 - appear a skew what if i wanted to draw
16:51 - my slit scan slices in a radial pattern
16:55 - i'm going to create a p image called
16:57 - slice
17:00 - it's an rgb image with the dimensions of
17:02 - the slice itself we know the copy
17:04 - function can take as its first argument
17:07 - that image source
17:09 - but where do i put the destination if
17:11 - the destination is not the processing
17:13 - window itself
17:15 - well it turns out i can call copy as a
17:18 - method on a p image object a destination
17:21 - p image
17:24 - slice dot copy
17:28 - now x is no longer the location into
17:32 - where i'm copying it
17:34 - i'm always just copying it to the entire
17:36 - slice but x is the location where i'm
17:38 - drawing what i've copied
17:41 - this is exactly what i had before but
17:44 - guess what i can do now translate to the
17:46 - center of the window
17:48 - draw the image
17:50 - from that center
17:52 - and rotate by some angle
17:56 - what should that angle be
17:59 - let's take x which has a range of zero
18:02 - to the width of the image
18:05 - and map that to zero to two pi radians a
18:09 - full rotation around a circle
18:12 - oh i'm missing
18:14 - the range of angle goes from zero to two
18:16 - pi not just two pi
18:23 - and look at that there's my slits again
18:26 - now i'm getting this kind of moire
18:28 - pattern effect because you know the
18:30 - pixels in the center of that rotation
18:33 - are very close to each other and then
18:35 - they're getting further and further
18:37 - apart as the line extends out from the
18:39 - center so i actually might want to just
18:41 - kind of work with that angular rotation
18:44 - separately from this x value itself
18:51 - so i'm just going to make my own angle
18:52 - variable started at zero
18:55 - and kind of arbitrarily just pick up
18:57 - incrementation value and try to
18:59 - fine-tune it trial and error style
19:03 - that's a little bit better maybe i could
19:05 - also
19:06 - uh just have the width be much bigger of
19:09 - what i'm copying
19:12 - and there we go you can see there's no
19:14 - kind of missing pixels anymore that i
19:16 - made it wider and i can kind of have
19:18 - that spin around this rotational path so
19:21 - that's one thing that allows me a lot
19:23 - more possibilities copying the pixels
19:26 - into
19:27 - its own p image object but once i've
19:30 - copied it into a p image object
19:32 - and then i go to the next frame and copy
19:34 - it again i lost the previous one
19:37 - what would happen if i actually stored
19:42 - an array of slices what if i kept track
19:45 - of the history of slices
19:48 - and cycled them around the screen in
19:49 - various ways by doing this i'm going to
19:52 - get a time displacement like effect
19:55 - let's see what that looks like i think i
19:57 - mean i'm about to try this let me go
19:58 - back to just the slices themselves
20:01 - without being rotated but i'll make them
20:03 - horizontal this time
20:06 - don't worry i'm saving all the versions
20:08 - of the code that i'm writing and you'll
20:10 - find all of them on the webpage
20:11 - associated with this video which is
20:12 - linked in the description below
20:20 - okay i think i've got this right i've
20:22 - gone back to taking a horizontal slice
20:25 - from the camera copying it into the
20:26 - slice p image drawing that slice p image
20:29 - at a different y location going from top
20:32 - to bottom
20:34 - slice is oops
20:36 - i have to change the dimensions of the
20:38 - slice itself
20:40 - oh i did something wrong here
20:42 - ah i was copying from the bottom i need
20:45 - to copy from the middle height divided
20:46 - by two
20:49 - what is going on
20:51 - with
20:52 - h
20:54 - two zero oh no no no no no i forgot i'm
20:57 - copying to the image so we'll also have
20:59 - to copy it to zero zero
21:01 - of the image y is where i'm drawing it
21:05 - there we go
21:06 - now i have exactly what i had before i
21:08 - have a vertical
21:10 - slit scan of just the video image i now
21:15 - want to make my slice into an array of
21:19 - slices
21:22 - slices is a new
21:25 - p image array
21:27 - of height divided by h
21:31 - that's the number of images i need for
21:33 - all the slices
21:38 - each slice is a new blank p image i then
21:42 - need a counter to count through which
21:45 - slice do i want to put the new image in
21:49 - we'll call that slice index
21:53 - slices slice index dot copy
21:56 - and let's just display
21:59 - all of them
22:03 - slices index i at
22:05 - i times h
22:08 - oh well it's working but i'm not
22:10 - increasing the index
22:13 - so let's say slice index plus plus
22:17 - same as what i had before of course when
22:19 - i get to the bottom it goes out of
22:21 - bounds
22:24 - so i can use the modulo operator with
22:26 - the length of the array
22:30 - and there we go now
22:31 - you're probably asking yourself i'm
22:33 - asking myself the same question i don't
22:35 - get it you went through all this extra
22:37 - work to create this array so that you
22:40 - can copy the slice to let me draw what
22:44 - i'm doing here
22:48 - i have my source video
22:51 - where i am taking a middle section of
22:53 - pixels
22:55 - i am copying it to
22:57 - an array
22:59 - called slices
23:01 - where it goes here and then it goes here
23:04 - and then it goes here it goes here these
23:05 - this is the slice index
23:08 - which is changing every frame and then
23:12 - this entire
23:14 - array just gets drawn
23:17 - right into
23:18 - the destination image
23:21 - basically i've engineered a lot of extra
23:24 - memory to store the history of the
23:25 - images just to create the exact original
23:29 - slit scan effect however what this
23:32 - happens to be
23:33 - beyond just all the images of a current
23:36 - view of the slit scan it happens to be a
23:39 - history of the most recent slices those
23:42 - there's no reason why i couldn't start
23:44 - to play back that history in each one of
23:48 - these slices to do that i just need
23:51 - another offset
23:54 - offset is zero
23:56 - slices i plus offset where am i that's a
24:00 - time offset where am i in the history
24:03 - offset plus plus
24:06 - now this is getting a little bit wonky
24:08 - if that offset starts to increase it's
24:10 - going to also increase past the end of
24:13 - the array so i'm going to make a
24:14 - variable called current index which is i
24:17 - plus offset
24:18 - modulus
24:20 - the length of the array
24:22 - and let's see what happens
24:27 - closer to what i was thinking
24:29 - so i went off in a direction that was
24:31 - really making sense to me uh and then i
24:34 - realized this is not exactly what i'm
24:36 - looking to do i kind of like this effect
24:38 - it's sort of sliding that slit scan
24:41 - effect along and it makes it seem much
24:44 - more continuous as opposed to that it
24:46 - gets to the end and it just starts over
24:48 - so i think there actually is quite a bit
24:49 - to explore here but what i actually want
24:52 - to do is have a history
24:56 - of the full frame
24:58 - so that i can take different slices from
25:01 - different points in time
25:04 - so i'm going to double back a little bit
25:06 - and implement that
25:07 - so i'm going to call this p image array
25:10 - history
25:12 - you know it's up to me to choose how
25:14 - long i want that history to be
25:16 - but i think the total number of slices
25:18 - actually kind of makes sense
25:21 - remember it's the full image
25:25 - now i'm actually copying directly to the
25:28 - window
25:29 - the difference is i'm copying from a
25:32 - different moment in time not just the
25:34 - current video
25:36 - copy from the history itself
25:40 - from its corresponding y position
25:44 - the y position being
25:46 - i times h
25:50 - i'm still going to need that offset so
25:51 - hold on hold on to your horses
25:56 - oh wait
25:58 - i also now i've got to save that i just
26:00 - made blank images in the history i'm
26:02 - like what am i doing here aha
26:05 - history index
26:07 - is zero
26:08 - every time i get a new frame from the
26:11 - camera
26:13 - copy
26:16 - the entire image into it
26:18 - why do i only have one slice
26:21 - oh i forgot to increase the history
26:23 - index okay then i've got to copy it into
26:25 - the next spot
26:29 - now i'm back i'm back to that original
26:31 - slit scan effect but in memory is not
26:35 - just those slices but the full image so
26:38 - i can start to move through time within
26:40 - each slice
26:41 - that's where the offset comes in offset
26:43 - equals zero offset plus plus
26:47 - current index equals i plus offset
26:52 - modulus history dot length
26:55 - and there we go there's the time
26:57 - displacement i was looking for so i'm
26:59 - going to stand very very still
27:02 - and
27:03 - with standing very very still nothing's
27:05 - really changing except for my mouth if i
27:07 - just move my head to the left and the
27:09 - right
27:10 - i start to get that wiggle effect
27:13 - now you can start to imagine what
27:15 - happens if you take this effect
27:17 - and do it in a radial pattern in a
27:19 - vertical pattern in all sorts of other
27:22 - ways in a grid so many possibilities
27:25 - finally i have
27:27 - the fun house mirror animated time
27:29 - displacement sketch that i imagined
27:31 - creating at the beginning of this video
27:34 - thank you so much for sticking with me
27:36 - oh i hope you make your own version of
27:38 - this i'm so excited to see the result of
27:41 - what i couldn't possibly imagine in my
27:43 - mind right now thank you so much to tim
27:46 - rodenbroker for your generous donation
27:49 - to the processing foundation and for
27:51 - inspiring the contents of this video
27:53 - check out his website all of his courses
27:55 - he's got a new one coming up all about
27:57 - the copy function that i'm sure will
27:59 - explode the possibilities way beyond
28:01 - whatever i did in this video and i will
28:03 - see you
28:04 - once again on the coding train as we
28:06 - journey along
28:08 - through
28:09 - the creative coding landscape is that is
28:12 - that it did i almost get a catchphrase
28:15 - no
28:20 - [Music]

Cleaned transcript:

hello and welcome to a time displacement slit scan coding challenge this video is part of the support p5 campaign adopt a function series thank you to tim rodenbroker who adopted the copy function for this video if you're not familiar with tim's work he teaches all about creative coding on his website you can see beautiful examples of what he's done with the copy function on his instagram he's got an upcoming course all about the copy function and i would certainly encourage you to subscribe to his patreon to get access to all of his courses i've already finished recording this coding challenge what you're seeing here is the end result of the video i'm going to start by just what is the copy function what arguments does it take how does it work how can it be used to create a slit scan effect and from there move on to warping time and space itself enjoy i'm going to begin this exploration of the copy function with just this basic processing sketch one red circle right there in the top left corner at its core the copy function does one thing it takes a rectangle of pixels this is known as the source and copies them to another rectangle of pixels known as the destination to execute the process call the copy function with eight arguments the x y width and height of the source rectangle the x y being the top left the width and height of that rectangle and then the x y width and height of the destination rectangle once again the x y being in the top left and then the width and height let's see this in action i'm going to attempt to copy the top left quadrant of the canvas to the bottom right there we go it looks like i just called the circle function again for a different location but i have not i'm actually just copying the pixels from a rectangular portion of the canvas to another one what is especially exciting about using the copy function is the destination the dimensions of the destination rectangle do not have to match the dimensions of the source one so i also have the opportunity to stretch and skew and twist that original image here i'm just setting the width and height of the destination rectangle according to the mouse x and mouse y location this isn't a particularly engaging example if i really just wanted to draw multiple shapes and kind of skew them i would just keep using circle and ellipse and change the colors and the dimensions of the actual geometry that i'm drawing while i do think there is lots of potential for what you could do with generated graphics and the copy function what i'm going to move to demonstrating now is what happens if i start to use the copy function with an image that i'm loading or perhaps even a realtime video in this particular sketch i've got an image of the choo choo bot character in the data directory now i can load the image from the file and display the image using the image function now what happens if i put back in the copy function here we see the top left portion of the image copied and overlaid onto the image itself this admittedly though is a little bit strange here i am taking the image drawing it to the canvas so that i can copy a portion of it to also draw it to the canvas the copy function can take an additional argument right up front the source image itself so rather than draw the bot image i can just place a reference to the bot image as the first argument in copy and there we go now i'm copying just that one section of the image to the same spot in this window this immediately opens up a lot of possibilities for example what if i draw the image by copying a sequence of slices so this looks like i'm just drawing the image as it was before but i'm not i'm displaying it as 40 slices each of width of 10 pixels i'll put a rectangle overlay just so you can see it there now you can see the scale and size of each of those slices so there's really no reason why i couldn't take a different part of the image and display it in a different place shuffle up the slices here the moment i'm about to copy from the image i pick a random x location to copy from i'm still going to put them in their linear sequence but the source will be random i've added no loop so that it just does it once now you can see i've completely mixed up the image taking away that rectangular overlay and there you go here's an exercise for you could you shuffle up an image in a grid rather than instead of just horizontal slices a checkerboard pattern i would like to take this in a different direction and just explore some algorithmic visual possibilities let's start by adding a sine wave pattern to the location i'm copying from if sine waves are unfamiliar to you it's simple harmonic oscillating motion i'll refer you to my nature of code video series all about these wave patterns i'm going to use the variable name sx for the source x again if i just use x directly from the loop we get the image as is what if i were to offset the source x location by some counter variable x plus counter there is a builtin frame count variable in processing but i'm putting my own variable in here because i'm going to start to do more with it once i get to harmonic motion amazingly enough it's just sliding the image because i'm moving where i'm copying from so what if i were to introduce the modulo operator the modulo operator takes the remainder of division so numbers as they increment past the width of the window will cycle back to zero and again and again sort of little blinking accidental blinking effect as it's kind of working with those end pixels a little by little if i were to use the width itself as my incrementation variable then i will get rid of that little flickery effect of course it's moving much faster because it's going by 10 pixels each time so what if though instead of offsetting by just a counter variable that's going up by one and one and one what if i offset by some variable amount that's smoothly oscillating up and down let's change counter to angle angle plus equal some small amount i'm going to make a separate offset variable which is sine of that angle i'm going to map that value the result of the sine function is between negative one and one and i want to offset it by some amount of the width of the image now because i'm dealing with pixels it's important that i stick with integers because there's no subpixel values there's no pixel 1.5 1.6 so i will also convert that offset to an integer and let's see what we get now it's shaking back and forth i think i've really got to deal with the fact that there's a specific number of columns here even though i have the full width of pixels i only have 40 slices because each one is a width of 10. and i'll call those columns the number of columns is the total width or image divided by the width of each slice now i'm really looking to map the offset not to the total number of pixels but the total number of columns and then to find that source location i can expand by the width there we go back and forth back and forth this is getting somewhere i think i mean i haven't actually done this before i'm doing this just in real time right now as i'm recording this video let me slow it down a little bit there we go looks kind of stuttery because it's actually moving by 10 pixels each time so what's happening here i have a sine wave this motion up and down you can think of it as i'll use a train whistle here as a slider sliding back and forth across the image so right now every slice is sliding back and forth at the same speed but what if some slices slide more quickly or some slices slide more slowly then wouldn't i start to see the image break itself apart put itself back together as the slices become out of sync from each other one way to approach this would just be to multiply the angle by some factor so x is going between zero and with and why don't i multiply that angle by some amount between like point one and 2. so i'm shrinking it or doubling it multiply by factor well i'm not really sure i knew what was going to happen there but we're starting to see the possibilities here at some point i would imagine it's going to put itself back together i'm having to restrain myself right now because i want to keep going with this i think there's probably more clever ways i could think about offsetting the different wave patterns thinking about the slices as horizontal rather than vertical maybe i would use purl and noise or some other kind of algorithm please explore those things and certainly the source image that you choose to work with will make a huge difference in what kinds of visual outcomes you get but the title of this video is slit scan and i really what i want to move towards doing is looking at what happens when i start to work with a moving image a video image something that is not static like the choo choo bot so let me quickly replace the loaded png image with live video i've completely forgotten how to do capture in processing there we go and certainly i could work with code in a flexible way where my the width and height of my canvas doesn't necessarily match the source image everything's going to be a lot easier if they do match so i'm going to match them it's not create capture new capture oh this this i need this no dot just this so here i am using processing so first of all i've got to give permission on a mac at least for processing to have access to the camera and then because i do all sorts of crazy things with this computer i'm getting the open broadcast studio virtual camera into processing which i don't want i want my webcam so let me look at all of the cameras that i have connected and i can see here zero is the obs virtual camera one is the facetime hd camera the builtin webcam there we go whoa glitchy glitchy glitchy so i was being lazy here i just want to put cam.read just read from the camera while you're looping through draw that's not really the proper way to do this i should be writing the actual capture event which is triggered whenever there is a new image ready from the camera and there we go don't ask me what all this red is down here i have a feeling i've got some weird wonky settings on my computer so i'm just going to ignore that for right now it's working now there's no reason why i can't just put in my code from before but replace the bot image with the live camera and there we go lots and lots of fun to be had i've actually done quite a bit of this in a video that i made years ago demonstrating slit scan in p5.js and in that video i referred to this article this catalog of video artworks and research about slit scan photography from goal 11. i would really encourage you to check it out and and look at all of the historical precursors to what we do today with computational media whether it's film photography analog video and additionally since i made this so long ago i would love to hear from you in the comments what are your favorite historical examples of slitscan photography current artist working with these kinds of techniques i would love to know all about them but i just want to take a minute to demonstrate how slit scan works in processing and of course i'll also include p5.js code as well so we're still working with the same core concept of having a source image and a destination image in this case the source image is my webcam and the destination image is the processing window the way slit scan was performed with real film analog film take that film and expose it while sliding it past a slit shaped aperture in other words this is our view of the camera here is maybe that slit we're able to look at just one slice of pixels in this digital image and then this is like our film but this doesn't slide rather we'll take those pixels and put them here and then the next frame will put them here sliding this slice essentially across the destination how do we do that the copy function copy the pixels from a slice put them here put them here put them here put them here put them in here put them right here when we get to the end go back to the beginning so let's keep that width of 10 have a global variable called x and copy really i could choose any slice but i think it's going to be most convenient if i take the middle slice of the camera and that's what i'm always copying so the middle is width divided by 2 minus the width of the slice divided by two and always copy it to that x position i don't need columns anymore so now you can see that's that slice of the middle of the camera it's just always being copied to the leftmost part of the canvas but what if every frame i move that slice over by a pixel well now you can see it's moving i forgot i'm erasing the background every time so i'm just actually seeing that slice move across and i think i want to match it with the actual width so move it by the width of the slice itself we'll see that again it'll move much more quickly now let's stop drawing the background just once in setup and there you go you can see i've like smeared myself all the way across the image but it got to the end and where did it go so i'm going to try if i stay very very still we see that one slice being duplicated of course my mouth is moving if i could move at the exact speed then i can practically get an image of myself i could be in it twice by moving back and forth there's a lot of possibilities here and of course i can reduce the width itself as well let's put it down to two pixels this already i think gives you a lot to work with but i don't want to stop here because i think there's two things i could add that will really expand the creative possibilities of this particular demonstration the first is what if instead of copying the source pixels to the destination processing window itself i had an interim step what if i had a p image object itself where i could take those pixels into it and then i could draw that p image into the destination what that would allow me to do is use things like translate and rotate so what if i wanted that slice to appear a skew what if i wanted to draw my slit scan slices in a radial pattern i'm going to create a p image called slice it's an rgb image with the dimensions of the slice itself we know the copy function can take as its first argument that image source but where do i put the destination if the destination is not the processing window itself well it turns out i can call copy as a method on a p image object a destination p image slice dot copy now x is no longer the location into where i'm copying it i'm always just copying it to the entire slice but x is the location where i'm drawing what i've copied this is exactly what i had before but guess what i can do now translate to the center of the window draw the image from that center and rotate by some angle what should that angle be let's take x which has a range of zero to the width of the image and map that to zero to two pi radians a full rotation around a circle oh i'm missing the range of angle goes from zero to two pi not just two pi and look at that there's my slits again now i'm getting this kind of moire pattern effect because you know the pixels in the center of that rotation are very close to each other and then they're getting further and further apart as the line extends out from the center so i actually might want to just kind of work with that angular rotation separately from this x value itself so i'm just going to make my own angle variable started at zero and kind of arbitrarily just pick up incrementation value and try to finetune it trial and error style that's a little bit better maybe i could also uh just have the width be much bigger of what i'm copying and there we go you can see there's no kind of missing pixels anymore that i made it wider and i can kind of have that spin around this rotational path so that's one thing that allows me a lot more possibilities copying the pixels into its own p image object but once i've copied it into a p image object and then i go to the next frame and copy it again i lost the previous one what would happen if i actually stored an array of slices what if i kept track of the history of slices and cycled them around the screen in various ways by doing this i'm going to get a time displacement like effect let's see what that looks like i think i mean i'm about to try this let me go back to just the slices themselves without being rotated but i'll make them horizontal this time don't worry i'm saving all the versions of the code that i'm writing and you'll find all of them on the webpage associated with this video which is linked in the description below okay i think i've got this right i've gone back to taking a horizontal slice from the camera copying it into the slice p image drawing that slice p image at a different y location going from top to bottom slice is oops i have to change the dimensions of the slice itself oh i did something wrong here ah i was copying from the bottom i need to copy from the middle height divided by two what is going on with h two zero oh no no no no no i forgot i'm copying to the image so we'll also have to copy it to zero zero of the image y is where i'm drawing it there we go now i have exactly what i had before i have a vertical slit scan of just the video image i now want to make my slice into an array of slices slices is a new p image array of height divided by h that's the number of images i need for all the slices each slice is a new blank p image i then need a counter to count through which slice do i want to put the new image in we'll call that slice index slices slice index dot copy and let's just display all of them slices index i at i times h oh well it's working but i'm not increasing the index so let's say slice index plus plus same as what i had before of course when i get to the bottom it goes out of bounds so i can use the modulo operator with the length of the array and there we go now you're probably asking yourself i'm asking myself the same question i don't get it you went through all this extra work to create this array so that you can copy the slice to let me draw what i'm doing here i have my source video where i am taking a middle section of pixels i am copying it to an array called slices where it goes here and then it goes here and then it goes here it goes here these this is the slice index which is changing every frame and then this entire array just gets drawn right into the destination image basically i've engineered a lot of extra memory to store the history of the images just to create the exact original slit scan effect however what this happens to be beyond just all the images of a current view of the slit scan it happens to be a history of the most recent slices those there's no reason why i couldn't start to play back that history in each one of these slices to do that i just need another offset offset is zero slices i plus offset where am i that's a time offset where am i in the history offset plus plus now this is getting a little bit wonky if that offset starts to increase it's going to also increase past the end of the array so i'm going to make a variable called current index which is i plus offset modulus the length of the array and let's see what happens closer to what i was thinking so i went off in a direction that was really making sense to me uh and then i realized this is not exactly what i'm looking to do i kind of like this effect it's sort of sliding that slit scan effect along and it makes it seem much more continuous as opposed to that it gets to the end and it just starts over so i think there actually is quite a bit to explore here but what i actually want to do is have a history of the full frame so that i can take different slices from different points in time so i'm going to double back a little bit and implement that so i'm going to call this p image array history you know it's up to me to choose how long i want that history to be but i think the total number of slices actually kind of makes sense remember it's the full image now i'm actually copying directly to the window the difference is i'm copying from a different moment in time not just the current video copy from the history itself from its corresponding y position the y position being i times h i'm still going to need that offset so hold on hold on to your horses oh wait i also now i've got to save that i just made blank images in the history i'm like what am i doing here aha history index is zero every time i get a new frame from the camera copy the entire image into it why do i only have one slice oh i forgot to increase the history index okay then i've got to copy it into the next spot now i'm back i'm back to that original slit scan effect but in memory is not just those slices but the full image so i can start to move through time within each slice that's where the offset comes in offset equals zero offset plus plus current index equals i plus offset modulus history dot length and there we go there's the time displacement i was looking for so i'm going to stand very very still and with standing very very still nothing's really changing except for my mouth if i just move my head to the left and the right i start to get that wiggle effect now you can start to imagine what happens if you take this effect and do it in a radial pattern in a vertical pattern in all sorts of other ways in a grid so many possibilities finally i have the fun house mirror animated time displacement sketch that i imagined creating at the beginning of this video thank you so much for sticking with me oh i hope you make your own version of this i'm so excited to see the result of what i couldn't possibly imagine in my mind right now thank you so much to tim rodenbroker for your generous donation to the processing foundation and for inspiring the contents of this video check out his website all of his courses he's got a new one coming up all about the copy function that i'm sure will explode the possibilities way beyond whatever i did in this video and i will see you once again on the coding train as we journey along through the creative coding landscape is that is that it did i almost get a catchphrase no
