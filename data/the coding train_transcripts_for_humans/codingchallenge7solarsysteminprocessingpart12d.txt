With timestamps:

00:00 - Hello, and welcome to another
Coding Challenge video.
00:03 - In this video, I
am going to attempt
00:04 - to program a solar system
generator or simulator
00:07 - or system-like thing just like
the one you see over there
00:10 - in 3D.
00:11 - I'm going to do it in a bunch
of steps starting with 2D
00:13 - and moving to 3D.
00:14 - I'm going to use the Processing
Development Environment, which
00:17 - you see right here.
00:17 - Link to download Processing
will be in the description
00:20 - of this video.
00:20 - Now, you might be asking,
why are you doing this?
00:22 - Look, you did it already.
00:23 - This, in fact, is
one of my examples.
00:25 - It is called Gravitational
Attraction 3D.
00:27 - It's one of the examples
that comes with Processing.
00:29 - This is actually
doing a simulation
00:32 - of a solar system-like thing
with the actual formula
00:35 - of gravitational attraction.
00:37 - I will link to a video from
my Nature of Code series
00:39 - where how to make
this is explained,
00:41 - but I'm going to do it in a
different way, which is really,
00:43 - ultimately, a lesson about
transformations-- translate,
00:47 - rotate, push matrix, pop matrix,
how those types of things
00:51 - work in object oriented
programming in Processing.
00:53 - And so I'm going to do
it in a different way,
00:55 - and hopefully, by the end
of this somewhere between 10
00:57 - and 20 minute
video, you're going
00:58 - to see how to use all
that stuff and make
01:00 - yourself a little solar system.
01:01 - And you will be
much more creative
01:03 - and interesting at
doing it than I will be,
01:05 - and hopefully, you will share
what you do with me then, too.
01:08 - I've got to get started.
01:09 - Let's get started.
01:10 - So as always, I'm kind of
just got a blank slate here.
01:13 - I should really at least
enter this in beforehand,
01:16 - but I'm not.
01:17 - I'm going to add setup,
and I'm going to add draw.
01:19 - And I'm going to
add size, 600, 600.
01:22 - And space is a
dark, black place,
01:27 - so I'm going to just
use background zero.
01:29 - I'm going to run this code.
01:30 - I'm going to move
this over here.
01:31 - Here we go.
01:32 - This is my outer
space simulator.
01:35 - Do you like it?
01:36 - Very few lines of code.
01:39 - Now, the first thing I want
to do is create an object.
01:41 - I'm going to call it a planet.
01:43 - So I'm going to
make a planet class,
01:45 - and I really think it's
going to be useful here
01:47 - for me to use p vectors.
01:50 - So I'm going to
create a p vector--
01:56 - yeah, yeah, yeah--
called position.
02:00 - I have to think about this
while I'm doing this on the fly.
02:03 - I'm not so sure about this.
02:04 - And I'm going to say, when
I write the constructor,
02:12 - yeah, the constructor is
going to get an x and a y.
02:15 - And that position will be
a vector at that x and y.
02:22 - Now, let's think about
this for a second.
02:24 - Oh, and createVector is a
function that's in p5 JS.
02:27 - I'll just say new PVector here.
02:29 - I've got to think about
this a little bit more.
02:31 - I have a marker here.
02:32 - Let's think about this.
02:33 - So what I want is, I
have a planet object,
02:38 - and the planet object,
ultimately-- so
02:41 - let's just think.
02:41 - Let's imagine the
first planet object
02:43 - I'm going to make
is a sun or a star.
02:45 - Then I'm going to make
another planet object,
02:48 - and what are the things
I need to keep track of?
02:51 - So I'm not going to do proper
orbital mechanics, Kepler's law
02:54 - stuff.
02:55 - That's a great topic
for another video.
02:56 - Encourage me to do that.
02:57 - I would love to look into
that and do that more,
03:00 - but it's not going to be
in this particular video.
03:02 - But what I need to keep
track of is it's distance,
03:05 - I'll call r, from
the planet, and it's
03:09 - going to rotate around
in a circular orbit.
03:12 - So in order to use the rotate
function in processing,
03:15 - I need to keep
track of an angle.
03:16 - So actually, what this
planet really needs
03:19 - is not an xy location, but a
radius and an angle, or really,
03:25 - a--
03:25 - this is the idea of a polar
coordinate, by the way.
03:28 - So instead of x, y,
a radius and angle.
03:30 - And you know what?
03:30 - Forget about this
p vector stuff.
03:32 - I was really thinking along the
lines of my [INAUDIBLE] space
03:35 - simulation, which I do
have other videos that you
03:37 - could look into.
03:37 - And I think what I'm going to
do in this planet is give it
03:40 - a radius and an angle.
03:45 - And so just to start, we
can fill it with radius,
03:52 - and I'm going to say--
03:53 - sorry, I lost my train
of thought there.
03:55 - The radius equals r,
and the angle always--
03:58 - let's just say it
always starts at 0,
03:59 - or it could be a random
angle, that sort of thing.
04:01 - So I definitely need to have
a function to draw this,
04:06 - and what I'm going to do
to draw it is just draw
04:10 - an ellipse at 0, 0.
04:12 - And I'm going to
make-- oh, sorry.
04:16 - It should also have a size.
04:18 - So I wonder actually if
radius should actually
04:21 - be the size of the planet,
and I should also have
04:25 - a variable called d, which is--
04:32 - I'm going to call this distance.
04:33 - I'm just going to
make it longer winded.
04:36 - Distance-- losing steam.
04:41 - This has been a long day.
04:42 - Distance is the
distance from the sun.
04:47 - Now, what I'm trying
to do, by the way,
04:49 - is think of a generic
model because I
04:51 - might have a bunch
of planets that
04:53 - have a distance
from the sun, but I
04:56 - might have other planets,
which are essentially
04:58 - like moons, which have a
distance from their parent.
05:01 - So I might have this
tree-like structure where
05:03 - some planets rotate
around the sun,
05:05 - other planets rotate
around the planets.
05:06 - So really, this is just a body.
05:08 - This is a celestial body object.
05:09 - It's not really a planet
object, but I'll just
05:11 - call it planet for simplicity.
05:14 - So back to here, so I'm
going to draw an ellipse
05:17 - at 0, 0 with the radius--
05:21 - which is not r, whoops.
05:24 - Radius times 2.
05:27 - So let's just see--
05:32 - sorry, I'm anally
retentively getting
05:34 - rid of all the extra space.
05:36 - Here's my planet object, a
radius, an angle, a distance;
05:38 - a radius, a distance, an
angle; and a show function
05:41 - which draws it.
05:41 - So what I want to do
is create a planet,
05:44 - and I realize the
sun is not a planet.
05:48 - And I'm going to say
sun equals new planet.
05:51 - Its distance from
anything else is just
05:54 - going to be 0, because it's
going to start in the center.
05:57 - And then I'm thinking,
I'm thinking, it's size--
06:02 - that's what I need.
06:03 - It's going to be 100.
06:04 - And then I'm going
to have sun.show.
06:09 - Let's run this.
06:10 - And where is it?
06:11 - Now, I have a feeling--
06:14 - number one is I didn't give
it-- let's give it a color,
06:16 - fill 255.
06:20 - And what am I missing?
06:23 - Oh, distance should be 0.
06:26 - Radius should be 100.
06:29 - There we go.
06:29 - Now, notice where it is.
06:31 - It's in the top left.
06:32 - So I want my sun to be in
the middle of the window,
06:34 - so I'm going to start by
saying translate width divided
06:40 - by 2, height divided by 2.
06:42 - I've got a light that keeps
going on and off up there.
06:45 - It's a little disorienting.
06:46 - So here we go.
06:47 - We're getting somewhere.
06:47 - We're getting somewhere now.
06:48 - We've got the sun in the middle
of the window as an object,
06:52 - so now, clearly, I need
more data structures
06:57 - to store the information
about these planets.
06:59 - Where should those go?
07:00 - Well, I have an idea.
07:02 - You might think
that, ordinarily,
07:03 - the next step that
I would do would
07:06 - be to create a planet
array, because ultimately, I
07:10 - want to have a lot of planets.
07:12 - But really, this is
my data structure.
07:14 - I have a sun, and the sun might
have three planets rotating
07:22 - around it.
07:22 - And this planet might have
two moons rotating around it.
07:26 - This might have one moon.
07:27 - That might have no moons.
07:28 - Well, each one of these
is a planet object,
07:31 - so what are the properties
of a planet object?
07:34 - The properties are-- oh,
dramatic moment ruined--
07:37 - radius, angle, distance.
07:43 - Radius, the size; angle,
where is it in its rotation;
07:47 - and distance, how
far is it away;
07:49 - and also children
planets, things
07:52 - that are rotating around it.
07:53 - So the sun has three, this
has two, this has one,
07:56 - this has zero.
07:57 - So each planet should,
inside of itself,
08:02 - recursively, self
referentially, store a reference
08:07 - to an array of planets.
08:11 - Now, I'm going to be
very simple about this
08:15 - and just say every single
planet gets three--
08:20 - so I got an idea.
08:22 - Hold on, hold on,
hold on, hold on.
08:26 - There's lots of ways
we could approach this,
08:28 - but I think what might
be useful right now
08:30 - is for me to write a function.
08:32 - And I'm going to
call it spawnMoons,
08:37 - and in the spawnMoons function,
I'm going to create that array.
08:42 - So maybe, I can create a
certain number of moons.
08:47 - I can say planets equals a new
Planet array with sum number
08:53 - of moons, and then
for int i equals 0,
08:59 - i is less than
planets.length; i++ planets,
09:07 - index i equals a new Planet.
09:12 - And maybe each moon should be
half the size of the planet.
09:19 - This is totally arbitrary.
09:20 - This could all be
random, and I figure out
09:22 - different ways of doing it.
09:23 - And then its distance
should be sum amount,
09:26 - so I'm going to say--
09:27 - I'm also going to say distance.
09:32 - And I'm going to
say some amount.
09:36 - I think maybe we could actually
make this an argument here.
09:41 - No, let me try just doing
something random for right now.
09:43 - Let me try doing something
random right now.
09:45 - Random 100, 200.
09:48 - I got to figure out a better
way of thinking about that.
09:55 - And I kind of want to put
these as separate lines of code
10:01 - to make this easier to see.
10:10 - When a planet gets a bunch of
moons, it runs through a loop
10:14 - and creates all of them
with a smaller radius
10:17 - and some distance away from it.
10:19 - So what I want to do here
now is say sun spawnMoons,
10:25 - and I want to have five.
10:27 - So I make a sun, and then
immediately say spawnMoons
10:31 - and have five of them.
10:32 - We can just run this.
10:34 - There's no errors, but
I'm not seeing anything.
10:36 - Why am I not seeing anything?
10:37 - Because when I show
the planet, I also
10:41 - need to show its children moons.
10:45 - And remember, those
children moons--
10:50 - I should call them--
10:51 - I'm calling them planets, I'm
calling the moons, whatever.
10:54 - The children should also--
10:56 - are just planet objects.
11:00 - So when I show this particular
planet, I draw it as a circle.
11:03 - Then I loop through and
show all of its subplanets,
11:06 - so let's see that.
11:07 - And so we have a null
pointer exception.
11:11 - Why do we have a null
pointer exception?
11:13 - Let's think about this.
11:15 - So what's null here?
11:17 - Let's println planets, and
actually, let's say printArray.
11:23 - And we got to debug this here.
11:28 - So it looks like the array has--
11:29 - oh, so why did I get null for--
11:37 - that's weird.
11:38 - Hold on, 0, 1, 2, 3, 4.
11:40 - What's planets.length?
11:45 - Oh, 5.
11:46 - What's null?
11:48 - I'm losing my mind here.
11:52 - This part might get
edited out later.
11:55 - Weird how I'm getting a
null pointer exception,
11:57 - and yet it seems to be working.
12:00 - Hold on.
12:02 - No null pointer exception.
12:04 - Oh, hold on, sorry, everybody.
12:07 - Oh, I'm sure-- so
that's working.
12:10 - Planet index i
equals new Planet.
12:14 - Something must be-- is
spawnMoons not happening?
12:18 - Oh, I meant-- no,
this seems right.
12:20 - This seems right.
12:22 - Hold on.
12:23 - Hold on, everyone.
12:24 - Let's see here.
12:25 - Let's make sure this
is happening correctly.
12:28 - Println planets index i.
12:36 - Let's run this.
12:39 - Five planet objects
were generated,
12:41 - so those are not null.
12:43 - Oh, I know what happens!
12:45 - Oh, my goodness.
12:46 - Ahh!
12:47 - So because of this whole
recursive system I have--
12:50 - of course, of course.
12:51 - People watching
this, probably you've
12:53 - all been yelling at me
for the last 30 seconds.
12:55 - Because of this
recursive system I have,
12:57 - I say, hey, planet,
show yourself,
13:00 - then show your children,
boom, boom, boom.
13:02 - And each of your children, show
your children, and each of you
13:04 - children, show your children.
13:05 - Oh, you don't have any children?
13:07 - Null pointer exception.
13:08 - So at some point,
one of the planets
13:10 - will-- that array will be null.
13:13 - So I need to make sure
that I check that.
13:15 - So all I need to do here
is just essentially say,
13:18 - if planets does
not equal to null,
13:21 - meaning if this planet
does have some moons,
13:24 - if it has some children,
only then call show.
13:27 - So that's just a
quick little check.
13:29 - Everything was right.
13:29 - I was creating things
correctly, but I'm
13:31 - forgetting that the new planets
I created also have arrays.
13:35 - Let's go, and let's run this.
13:37 - Wonderful.
13:38 - So you can see, I see one
circle, and I see a bunch.
13:42 - Now, what am I missing?
13:44 - So what I'm missing
is a crucial key step,
13:47 - which is that if I have the
sun, and I have a planet,
13:51 - and it's supposed to be
at a certain distance
13:54 - from the sun, the
orbital distance,
13:57 - I need to use a function in
Processing called translate.
14:01 - What translate will
do, it will say,
14:03 - I drew the sun at this location,
then translate out this far,
14:06 - and then draw the next planet.
14:08 - So I need to add--
14:10 - everything is only just
being drawn at 0, 0.
14:13 - Oh, I'm in the wrong place.
14:14 - Everything is only
being drawn at 0,
14:16 - 0, so I need to add, before
this, translate by r comma 0,
14:23 - and I also want to
rotate by some angle.
14:29 - So I'm going to rotate
by some angle, which
14:31 - is-- and not by r, by distance.
14:35 - So now if we run this, we
should see here are the planets,
14:39 - and let's do something to make
things a little more visible
14:42 - here.
14:42 - Let's give the color some alpha,
so we can see what's going on.
14:48 - Let's also think about
how far these planets
14:52 - are from a couple of things.
14:53 - One is let's make the
sun quite a bit smaller,
14:58 - and let's make the
planets between 75 and 150
15:04 - in terms of distance.
15:05 - And you can see--
15:06 - now, how come there's
only two of them?
15:12 - There should be five.
15:14 - Now, let's think about
why I'm not seeing five.
15:21 - Let's take a look
at planets.length.
15:29 - I think they're just-- oh, I'm
being silly because they're
15:32 - getting spawned off the screen.
15:34 - So we're not seeing
five, so let's--
15:36 - sorry about that.
15:37 - That seems kind of
obvious to me now.
15:39 - So let's just randomly put
them between 75 and 100.
15:47 - Did I do the distance?
15:50 - Oh, of course!
15:53 - Oh, yay!
15:55 - The next thing that I need
to teach you guys about--
15:57 - the important concept
is, I completely
15:59 - forgot, so translations--
16:02 - doesn't matter what I do.
16:04 - Translations are cumulative.
16:09 - So I draw the sun,
then I translate by 75,
16:13 - and I draw the next planet.
16:15 - Guess what?
16:15 - Let's say the next
one got picked 85.
16:18 - What I want is to go back
to the center of the planet,
16:20 - translate by 85,
and draw the next--
16:23 - center of the sun.
16:24 - Translate by the next one.
16:25 - But actually, what I did
was I translated by 75,
16:27 - then I translated by another
85, which I don't want to do.
16:30 - So this is where object oriented
programming and push matrix
16:34 - and pop matrix come in.
16:36 - If, in my object, if,
in the show function,
16:39 - I always put at the beginning
of the show function,
16:42 - push matrix, which
is like a save,
16:45 - and at the end of the function
I put pop matrix, which
16:49 - is like a restore,
this function becomes
16:53 - sort of its own
thing, its own world.
16:56 - Whatever translations and
rotations happen inside
16:59 - of here, they get undone
the moment I say pop matrix.
17:02 - So whatever translations
happen for this object,
17:05 - they don't affect any
of the other objects.
17:07 - And you can see now that they're
all, of course, bunched up
17:10 - right there because I kept
trying to reduce the amount,
17:13 - where really what
I want is for this
17:15 - to be between, like
I said, 75 and 300.
17:19 - So now, you can see I'm
picking some random planets.
17:22 - Now, notice they're
all along the x-axis.
17:24 - Why?
17:25 - Because my angle is always 0.
17:27 - Let's change that.
17:28 - Let's make a random
angle between 0 and 2 pi.
17:31 - So wait, wait a second here.
17:34 - What is going on?
17:37 - That should not have happened.
17:40 - Let's look here.
17:42 - Angle, float angle--
that's crazy.
17:47 - Why is it picking one
angle for all of them?
17:50 - What did I do to deserve
this strange result?
17:53 - Translate, then
rotate by the angle.
17:55 - So let's hold on.
17:59 - Let's take a look at
this angle, and we
18:00 - don't need-- we can get rid of
this println planets.length.
18:06 - I have a feeling I've missed
something rather obvious.
18:10 - So it's getting different
angles for each one,
18:13 - but somehow the same
angle is being used here.
18:18 - Do I have a--
18:21 - no, hold on.
18:22 - Let's just change
the variable name
18:24 - to make sure I'm
not losing my mind.
18:29 - What did I miss here, everybody?
18:37 - Hold on, this is certainly
confounding me here.
18:40 - I've got to have to
figure this one out.
18:43 - Translate by the distance.
18:44 - Rotate by the angle.
18:46 - Ohh, oh, oh, oh.
18:49 - No, that's right.
18:50 - Oh, oh, wait a sec.
18:53 - No, that's right.
18:56 - And then come back,
translate by the distance,
18:59 - and rotate by the next angle.
19:01 - That seems to make sense.
19:05 - Hold on, let's--
19:06 - I'm going to do a
couple of things.
19:08 - I'm going to say no loop, and
I'm going to just make two.
19:12 - This is a good way
to figure this out.
19:13 - So the loop is
only running once,
19:15 - and then I'm going to
take out this println.
19:19 - And I'm going to--
19:23 - oh, guess what I did.
19:26 - So important.
19:27 - Oh, these mistakes.
19:28 - I always make these mistakes.
19:31 - Oh, my god, I'm rotating
after I translated,
19:35 - which is absolutely incorrect.
19:36 - In this case-- I mean,
you could be doing that,
19:38 - but let's think about this.
19:44 - What I want is, here's my sun.
19:48 - And I'm, right now,
my registration point
19:52 - where the world is, my point of
view is the center of the sun,
19:55 - and the angle is 0.
19:57 - So what I did is
I translated out,
19:59 - and then I rotated,
which was meaningless.
20:01 - And those things were actually
appearing in a different angle
20:03 - only because the sun also
had its own rotation.
20:05 - But what I want
to do is not that.
20:09 - What I want to do
is the following.
20:12 - I first want to rotate, and
then I want to translate out.
20:15 - And then I'm going to go back
and rotate again, and translate
20:19 - out to get them in
different spots.
20:20 - So the order of this stuff
is so unbelievably important,
20:24 - and I made a classic error.
20:25 - I want to pretend that I did
it on purpose, but I did not.
20:27 - So I put that there.
20:28 - I can get rid of
all my printlns,
20:30 - and I can run this again.
20:31 - And we can see--
20:32 - there we go.
20:33 - And there's only two, so let's
go back and give me five again.
20:36 - And let's get rid of no
loop, and let's run it.
20:38 - And we can see we've
got our solar system.
20:41 - We've got five
planets and one sun.
20:46 - Now, we should also
add a function.
20:50 - I'm going to add a
function called orbit,
20:53 - and in this function,
I'm going to say
20:57 - angle equals angle
plus orbitSpeed
21:02 - because I want the
angle to change
21:03 - so that they rotate around.
21:05 - And I'm going to
replace theta with angle
21:08 - everywhere to just use angle.
21:11 - And then I also need another
variable, orbitspeed,
21:15 - which I am going to
make random orbitspeed
21:18 - equals random some speed
between 0.1 and 0.3,
21:23 - or something like that.
21:24 - And now, let's run this.
21:26 - Angle, orbit, let's
use the camel casing--
21:30 - oops, or whatever.
21:32 - It doesn't matter.
21:33 - Just have to be consistent.
21:34 - Everything is case sensitive.
21:36 - So now, oops, float
a float distance,
21:39 - and now, I also need to add in--
21:42 - oh, interesting.
21:45 - So if I say sun.orbit, I'm
asking the sun to orbit.
21:50 - But what does it mean
for the sun to orbit?
21:52 - Well, it needs to
do this, but also--
21:55 - and why is angle now
not knowing what it is?
21:58 - Oops, I lost angle.
21:59 - Sorry, everybody.
22:00 - Angle.
22:03 - And now, what do
I need to do here?
22:06 - Whenever the sun orbits-- ah!
22:08 - Oh, come on.
22:10 - My keyboard is going crazy.
22:13 - Whenever the sun-- just
like when I show the sun,
22:17 - I have to show all
of its children,
22:21 - when I orbit a
planet, I need to say,
22:27 - as long as there are planets.
22:29 - I need this if
planets is not null,
22:35 - then I want planets
index i.orbit.
22:38 - I want all the children
planets to orbit as well.
22:41 - I don't have a timer.
22:43 - We can see something
crazy is going,
22:46 - so let's think about this.
22:47 - So first of all,
they're all kind
22:48 - of spinning out of
control, so something
22:50 - has got to be wrong here.
22:52 - Let's look at--
22:55 - I've got push matrix
and pop matrix, which
22:58 - would lead me to believe-- oh.
22:59 - So one issue is that I have
the sun spinning as well,
23:03 - and I don't want
the sun to spin.
23:05 - So I just want the
other things to spin,
23:08 - and things are spinning
kind of quickly.
23:10 - So the issue is I really
should make the sun probably
23:13 - as this static object, a
completely separate thing,
23:17 - but I can-- what I'm going
to do is add a argument here,
23:24 - which means that I can
set the orbit speed.
23:31 - And when I make
the sun, I'm going
23:33 - to set the orbit speed to 0.
23:36 - And when I make
the other planets,
23:39 - I'm going to pick a
random orbit speed.
23:44 - And now, that should fix it.
23:46 - There we go.
23:47 - So we can see, look,
everything is rotating,
23:49 - and those speeds are quite fast.
23:52 - So let's pick much
smaller random numbers.
23:59 - And you can see, so now, we have
a bunch of circles all spinning
24:03 - around the center circle.
24:05 - Pretty good.
24:06 - They could have different sizes.
24:07 - They could be more-- we could
do more variety with the speed,
24:10 - but we're getting somewhere.
24:11 - Now, to really make
this magical, nothing
24:13 - that I've done here right now
is-- the two things that I want
24:16 - to do to make this
magical is, number one,
24:18 - have planets have planets
have planets, and number two,
24:21 - make this happen in 3D.
24:22 - So let's see if we
can-- if you still
24:24 - had some-- pause this video,
go outside, take a walk.
24:27 - I don't know.
24:28 - Then come back if you
want to watch it more.
24:29 - But I'm going to
keep going with this.
24:31 - Here we go.
24:32 - So the first thing
that I need to do
24:33 - is say that, when I spawn
moons, what I want to do
24:39 - is have my planets
also spawn moons.
24:48 - So if I were to write this--
25:03 - so if I were to write this, for
example, so the sun gets made,
25:08 - and the sun spawns a moon.
25:10 - Then I make new planets.
25:11 - If each of those planets
spawn their own moons,
25:14 - and so each object has
an array of other objects
25:16 - has an array of other objects.
25:17 - So while this would
work, this would
25:19 - result in an
infinite forever loop
25:20 - because every planet would
make five more planets, which
25:22 - would make five
more planets, which
25:23 - make five more planets, which
would make five more planets.
25:25 - So I need some way of
having an exit strategy.
25:27 - Here's a way that I propose--
25:29 - which is really
dangerous, actually.
25:31 - I probably shouldn't
do this-- is, well,
25:35 - first thing I'll do is just--
25:39 - I'm trying to think
of a good way--
25:42 - there's a bunch of different
ways I could approach this.
25:44 - I could keep track of levels.
25:46 - So I could say,
after I've spawned--
25:48 - after I'm on the fifth orbiting
planet, forget about it.
25:51 - I could also, right
now, just only do
25:53 - the sun with some planets,
and those planets have moons.
25:55 - I don't need those
moons to have moons.
25:57 - But I also could randomly decide
if planets get moons or not,
26:02 - and I would, by chance,
eventually have this stop.
26:05 - Let's do the levels thing.
26:07 - So what I'm going
to do is I'm going
26:10 - to add a second
variable, spawnMoons 0,
26:14 - meaning I'm at level 0.
26:17 - So I'm going to add an
argument called level.
26:20 - This is going to be
useful, too, because level
26:22 - is going to help us determine
the size and speed of these
26:24 - maybe.
26:25 - And then I'm going
to say level minus 1,
26:29 - so when I spawn the
moon-- oh, no, plus 1.
26:33 - So the sun will call
spawnMoons with 0,
26:37 - and then it'll make a
bunch of planets that
26:40 - will call spawn moons with 1.
26:42 - And they'll make a
bunch of planets--
26:44 - I've been doing this for
half an hour, I guess.
26:47 - They will spawn a bunch
of planets with level 2,
26:53 - and so on and so forth.
26:54 - So I only want to do this
if level is less than 2.
27:00 - So let's actually only do
this if level is less than 1.
27:03 - Let's see what happens.
27:06 - Whoa!
27:10 - Level is less than 0.
27:14 - Yeah, that's interesting.
27:15 - So why did it even
do it-- oh, right,
27:17 - because I'm already spawning 1.
27:18 - So this is if level
is less than 0,
27:21 - I'm getting these five planets.
27:23 - And if level is less than 1--
27:26 - whoops.
27:27 - Whoops.
27:28 - Level is less than 1,
all of those planets
27:31 - have things orbiting it.
27:32 - Now, this is totally
out of control
27:34 - because the distances and the
sizes are all over the place.
27:37 - So what I want to do
probably is figure out--
27:39 - number one is figure
out the number of moons
27:43 - they should have, and maybe
I'll make that random.
27:46 - And it's going to
be between 0 and 4,
27:51 - and so it's going
to have that many.
27:53 - So number one, this,
right now, you're
27:55 - going to see there's a lot fewer
things, and also the distance--
28:00 - the submoons should be
much closer to those.
28:03 - So I can use this level
variable quite effectively.
28:07 - So level, so I'm picking random
distances, and what I could do
28:13 - is divide by level.
28:15 - So first of all, I'm
going to make the level 1.
28:19 - Start with 1 because I don't
ever want to divide by 0.
28:21 - And I'm going to have the
distance be divided by level.
28:25 - And also the radius, I'm
already multiplying times 0.5,
28:32 - so I could also-- oops.
28:33 - I could also say
divided by level.
28:37 - And that way, this should now be
2, and you can see here-- now,
28:47 - look what's going on here.
28:48 - It's sort of hard to
see because I don't
28:50 - have a good sense of sizes.
28:52 - So I guess divided by level--
28:53 - I started with 1, so I should
say divided by level times 2.
29:00 - There we go.
29:00 - So you can kind of see here,
if I zoom in, what's going on.
29:04 - This particular planet has its
own thing orbiting around it
29:11 - as it orbits.
29:11 - By the way, they all only
orbit in one direction.
29:15 - Not the band One Direction.
29:17 - Insert One Direction
song right now.
29:19 - That orbital speed, I
really should pick--
29:22 - where do I pick
the orbital speed?
29:24 - Right here.
29:25 - I should really pick some value
also that could be negative.
29:28 - So that they could rotate--
29:30 - spin the opposite direction.
29:32 - So you can see now--
29:34 - and it's sort of hard to tell
what's spinning around what,
29:37 - but you can massage the
values and stuff yourself
29:40 - because I've got to move to 3D.
29:41 - But I at least
want to see that I
29:43 - could have another level here.
29:47 - And can we find it?
29:49 - I think I've shrunk
stuff too much,
29:51 - so let me at least
see if I can get you--
29:54 - let's make things generally
just quite a bit closer.
29:57 - And also, let's not have
the size be that radically
30:04 - different.
30:04 - So you can see here the
multiple levels of moons.
30:08 - I'm going to try to
zoom in here so you
30:11 - can see the multiple levels
of this thing rotating
30:14 - around that thing,
with that thing
30:15 - rotating around that thing.
30:16 - And I could even
add one more level
30:18 - if I wanted to be
so crazy, like 4.
30:22 - And I'll let you
enjoy this on your own
30:25 - to try to see everything
rotating around everything.
30:27 - Now, so I would encourage
you to take this.
30:30 - Add some color.
30:31 - Think about the distances,
the values, the ratios, all
30:33 - of that much more thoughtfully.
30:34 - But this idea of nesting
systems is kind of
30:37 - interesting to play with.
30:38 - Let's at least see if
we can move this to 3D.

Cleaned transcript:

Hello, and welcome to another Coding Challenge video. In this video, I am going to attempt to program a solar system generator or simulator or systemlike thing just like the one you see over there in 3D. I'm going to do it in a bunch of steps starting with 2D and moving to 3D. I'm going to use the Processing Development Environment, which you see right here. Link to download Processing will be in the description of this video. Now, you might be asking, why are you doing this? Look, you did it already. This, in fact, is one of my examples. It is called Gravitational Attraction 3D. It's one of the examples that comes with Processing. This is actually doing a simulation of a solar systemlike thing with the actual formula of gravitational attraction. I will link to a video from my Nature of Code series where how to make this is explained, but I'm going to do it in a different way, which is really, ultimately, a lesson about transformations translate, rotate, push matrix, pop matrix, how those types of things work in object oriented programming in Processing. And so I'm going to do it in a different way, and hopefully, by the end of this somewhere between 10 and 20 minute video, you're going to see how to use all that stuff and make yourself a little solar system. And you will be much more creative and interesting at doing it than I will be, and hopefully, you will share what you do with me then, too. I've got to get started. Let's get started. So as always, I'm kind of just got a blank slate here. I should really at least enter this in beforehand, but I'm not. I'm going to add setup, and I'm going to add draw. And I'm going to add size, 600, 600. And space is a dark, black place, so I'm going to just use background zero. I'm going to run this code. I'm going to move this over here. Here we go. This is my outer space simulator. Do you like it? Very few lines of code. Now, the first thing I want to do is create an object. I'm going to call it a planet. So I'm going to make a planet class, and I really think it's going to be useful here for me to use p vectors. So I'm going to create a p vector yeah, yeah, yeah called position. I have to think about this while I'm doing this on the fly. I'm not so sure about this. And I'm going to say, when I write the constructor, yeah, the constructor is going to get an x and a y. And that position will be a vector at that x and y. Now, let's think about this for a second. Oh, and createVector is a function that's in p5 JS. I'll just say new PVector here. I've got to think about this a little bit more. I have a marker here. Let's think about this. So what I want is, I have a planet object, and the planet object, ultimately so let's just think. Let's imagine the first planet object I'm going to make is a sun or a star. Then I'm going to make another planet object, and what are the things I need to keep track of? So I'm not going to do proper orbital mechanics, Kepler's law stuff. That's a great topic for another video. Encourage me to do that. I would love to look into that and do that more, but it's not going to be in this particular video. But what I need to keep track of is it's distance, I'll call r, from the planet, and it's going to rotate around in a circular orbit. So in order to use the rotate function in processing, I need to keep track of an angle. So actually, what this planet really needs is not an xy location, but a radius and an angle, or really, a this is the idea of a polar coordinate, by the way. So instead of x, y, a radius and angle. And you know what? Forget about this p vector stuff. I was really thinking along the lines of my [INAUDIBLE] space simulation, which I do have other videos that you could look into. And I think what I'm going to do in this planet is give it a radius and an angle. And so just to start, we can fill it with radius, and I'm going to say sorry, I lost my train of thought there. The radius equals r, and the angle always let's just say it always starts at 0, or it could be a random angle, that sort of thing. So I definitely need to have a function to draw this, and what I'm going to do to draw it is just draw an ellipse at 0, 0. And I'm going to make oh, sorry. It should also have a size. So I wonder actually if radius should actually be the size of the planet, and I should also have a variable called d, which is I'm going to call this distance. I'm just going to make it longer winded. Distance losing steam. This has been a long day. Distance is the distance from the sun. Now, what I'm trying to do, by the way, is think of a generic model because I might have a bunch of planets that have a distance from the sun, but I might have other planets, which are essentially like moons, which have a distance from their parent. So I might have this treelike structure where some planets rotate around the sun, other planets rotate around the planets. So really, this is just a body. This is a celestial body object. It's not really a planet object, but I'll just call it planet for simplicity. So back to here, so I'm going to draw an ellipse at 0, 0 with the radius which is not r, whoops. Radius times 2. So let's just see sorry, I'm anally retentively getting rid of all the extra space. Here's my planet object, a radius, an angle, a distance; a radius, a distance, an angle; and a show function which draws it. So what I want to do is create a planet, and I realize the sun is not a planet. And I'm going to say sun equals new planet. Its distance from anything else is just going to be 0, because it's going to start in the center. And then I'm thinking, I'm thinking, it's size that's what I need. It's going to be 100. And then I'm going to have sun.show. Let's run this. And where is it? Now, I have a feeling number one is I didn't give it let's give it a color, fill 255. And what am I missing? Oh, distance should be 0. Radius should be 100. There we go. Now, notice where it is. It's in the top left. So I want my sun to be in the middle of the window, so I'm going to start by saying translate width divided by 2, height divided by 2. I've got a light that keeps going on and off up there. It's a little disorienting. So here we go. We're getting somewhere. We're getting somewhere now. We've got the sun in the middle of the window as an object, so now, clearly, I need more data structures to store the information about these planets. Where should those go? Well, I have an idea. You might think that, ordinarily, the next step that I would do would be to create a planet array, because ultimately, I want to have a lot of planets. But really, this is my data structure. I have a sun, and the sun might have three planets rotating around it. And this planet might have two moons rotating around it. This might have one moon. That might have no moons. Well, each one of these is a planet object, so what are the properties of a planet object? The properties are oh, dramatic moment ruined radius, angle, distance. Radius, the size; angle, where is it in its rotation; and distance, how far is it away; and also children planets, things that are rotating around it. So the sun has three, this has two, this has one, this has zero. So each planet should, inside of itself, recursively, self referentially, store a reference to an array of planets. Now, I'm going to be very simple about this and just say every single planet gets three so I got an idea. Hold on, hold on, hold on, hold on. There's lots of ways we could approach this, but I think what might be useful right now is for me to write a function. And I'm going to call it spawnMoons, and in the spawnMoons function, I'm going to create that array. So maybe, I can create a certain number of moons. I can say planets equals a new Planet array with sum number of moons, and then for int i equals 0, i is less than planets.length; i++ planets, index i equals a new Planet. And maybe each moon should be half the size of the planet. This is totally arbitrary. This could all be random, and I figure out different ways of doing it. And then its distance should be sum amount, so I'm going to say I'm also going to say distance. And I'm going to say some amount. I think maybe we could actually make this an argument here. No, let me try just doing something random for right now. Let me try doing something random right now. Random 100, 200. I got to figure out a better way of thinking about that. And I kind of want to put these as separate lines of code to make this easier to see. When a planet gets a bunch of moons, it runs through a loop and creates all of them with a smaller radius and some distance away from it. So what I want to do here now is say sun spawnMoons, and I want to have five. So I make a sun, and then immediately say spawnMoons and have five of them. We can just run this. There's no errors, but I'm not seeing anything. Why am I not seeing anything? Because when I show the planet, I also need to show its children moons. And remember, those children moons I should call them I'm calling them planets, I'm calling the moons, whatever. The children should also are just planet objects. So when I show this particular planet, I draw it as a circle. Then I loop through and show all of its subplanets, so let's see that. And so we have a null pointer exception. Why do we have a null pointer exception? Let's think about this. So what's null here? Let's println planets, and actually, let's say printArray. And we got to debug this here. So it looks like the array has oh, so why did I get null for that's weird. Hold on, 0, 1, 2, 3, 4. What's planets.length? Oh, 5. What's null? I'm losing my mind here. This part might get edited out later. Weird how I'm getting a null pointer exception, and yet it seems to be working. Hold on. No null pointer exception. Oh, hold on, sorry, everybody. Oh, I'm sure so that's working. Planet index i equals new Planet. Something must be is spawnMoons not happening? Oh, I meant no, this seems right. This seems right. Hold on. Hold on, everyone. Let's see here. Let's make sure this is happening correctly. Println planets index i. Let's run this. Five planet objects were generated, so those are not null. Oh, I know what happens! Oh, my goodness. Ahh! So because of this whole recursive system I have of course, of course. People watching this, probably you've all been yelling at me for the last 30 seconds. Because of this recursive system I have, I say, hey, planet, show yourself, then show your children, boom, boom, boom. And each of your children, show your children, and each of you children, show your children. Oh, you don't have any children? Null pointer exception. So at some point, one of the planets will that array will be null. So I need to make sure that I check that. So all I need to do here is just essentially say, if planets does not equal to null, meaning if this planet does have some moons, if it has some children, only then call show. So that's just a quick little check. Everything was right. I was creating things correctly, but I'm forgetting that the new planets I created also have arrays. Let's go, and let's run this. Wonderful. So you can see, I see one circle, and I see a bunch. Now, what am I missing? So what I'm missing is a crucial key step, which is that if I have the sun, and I have a planet, and it's supposed to be at a certain distance from the sun, the orbital distance, I need to use a function in Processing called translate. What translate will do, it will say, I drew the sun at this location, then translate out this far, and then draw the next planet. So I need to add everything is only just being drawn at 0, 0. Oh, I'm in the wrong place. Everything is only being drawn at 0, 0, so I need to add, before this, translate by r comma 0, and I also want to rotate by some angle. So I'm going to rotate by some angle, which is and not by r, by distance. So now if we run this, we should see here are the planets, and let's do something to make things a little more visible here. Let's give the color some alpha, so we can see what's going on. Let's also think about how far these planets are from a couple of things. One is let's make the sun quite a bit smaller, and let's make the planets between 75 and 150 in terms of distance. And you can see now, how come there's only two of them? There should be five. Now, let's think about why I'm not seeing five. Let's take a look at planets.length. I think they're just oh, I'm being silly because they're getting spawned off the screen. So we're not seeing five, so let's sorry about that. That seems kind of obvious to me now. So let's just randomly put them between 75 and 100. Did I do the distance? Oh, of course! Oh, yay! The next thing that I need to teach you guys about the important concept is, I completely forgot, so translations doesn't matter what I do. Translations are cumulative. So I draw the sun, then I translate by 75, and I draw the next planet. Guess what? Let's say the next one got picked 85. What I want is to go back to the center of the planet, translate by 85, and draw the next center of the sun. Translate by the next one. But actually, what I did was I translated by 75, then I translated by another 85, which I don't want to do. So this is where object oriented programming and push matrix and pop matrix come in. If, in my object, if, in the show function, I always put at the beginning of the show function, push matrix, which is like a save, and at the end of the function I put pop matrix, which is like a restore, this function becomes sort of its own thing, its own world. Whatever translations and rotations happen inside of here, they get undone the moment I say pop matrix. So whatever translations happen for this object, they don't affect any of the other objects. And you can see now that they're all, of course, bunched up right there because I kept trying to reduce the amount, where really what I want is for this to be between, like I said, 75 and 300. So now, you can see I'm picking some random planets. Now, notice they're all along the xaxis. Why? Because my angle is always 0. Let's change that. Let's make a random angle between 0 and 2 pi. So wait, wait a second here. What is going on? That should not have happened. Let's look here. Angle, float angle that's crazy. Why is it picking one angle for all of them? What did I do to deserve this strange result? Translate, then rotate by the angle. So let's hold on. Let's take a look at this angle, and we don't need we can get rid of this println planets.length. I have a feeling I've missed something rather obvious. So it's getting different angles for each one, but somehow the same angle is being used here. Do I have a no, hold on. Let's just change the variable name to make sure I'm not losing my mind. What did I miss here, everybody? Hold on, this is certainly confounding me here. I've got to have to figure this one out. Translate by the distance. Rotate by the angle. Ohh, oh, oh, oh. No, that's right. Oh, oh, wait a sec. No, that's right. And then come back, translate by the distance, and rotate by the next angle. That seems to make sense. Hold on, let's I'm going to do a couple of things. I'm going to say no loop, and I'm going to just make two. This is a good way to figure this out. So the loop is only running once, and then I'm going to take out this println. And I'm going to oh, guess what I did. So important. Oh, these mistakes. I always make these mistakes. Oh, my god, I'm rotating after I translated, which is absolutely incorrect. In this case I mean, you could be doing that, but let's think about this. What I want is, here's my sun. And I'm, right now, my registration point where the world is, my point of view is the center of the sun, and the angle is 0. So what I did is I translated out, and then I rotated, which was meaningless. And those things were actually appearing in a different angle only because the sun also had its own rotation. But what I want to do is not that. What I want to do is the following. I first want to rotate, and then I want to translate out. And then I'm going to go back and rotate again, and translate out to get them in different spots. So the order of this stuff is so unbelievably important, and I made a classic error. I want to pretend that I did it on purpose, but I did not. So I put that there. I can get rid of all my printlns, and I can run this again. And we can see there we go. And there's only two, so let's go back and give me five again. And let's get rid of no loop, and let's run it. And we can see we've got our solar system. We've got five planets and one sun. Now, we should also add a function. I'm going to add a function called orbit, and in this function, I'm going to say angle equals angle plus orbitSpeed because I want the angle to change so that they rotate around. And I'm going to replace theta with angle everywhere to just use angle. And then I also need another variable, orbitspeed, which I am going to make random orbitspeed equals random some speed between 0.1 and 0.3, or something like that. And now, let's run this. Angle, orbit, let's use the camel casing oops, or whatever. It doesn't matter. Just have to be consistent. Everything is case sensitive. So now, oops, float a float distance, and now, I also need to add in oh, interesting. So if I say sun.orbit, I'm asking the sun to orbit. But what does it mean for the sun to orbit? Well, it needs to do this, but also and why is angle now not knowing what it is? Oops, I lost angle. Sorry, everybody. Angle. And now, what do I need to do here? Whenever the sun orbits ah! Oh, come on. My keyboard is going crazy. Whenever the sun just like when I show the sun, I have to show all of its children, when I orbit a planet, I need to say, as long as there are planets. I need this if planets is not null, then I want planets index i.orbit. I want all the children planets to orbit as well. I don't have a timer. We can see something crazy is going, so let's think about this. So first of all, they're all kind of spinning out of control, so something has got to be wrong here. Let's look at I've got push matrix and pop matrix, which would lead me to believe oh. So one issue is that I have the sun spinning as well, and I don't want the sun to spin. So I just want the other things to spin, and things are spinning kind of quickly. So the issue is I really should make the sun probably as this static object, a completely separate thing, but I can what I'm going to do is add a argument here, which means that I can set the orbit speed. And when I make the sun, I'm going to set the orbit speed to 0. And when I make the other planets, I'm going to pick a random orbit speed. And now, that should fix it. There we go. So we can see, look, everything is rotating, and those speeds are quite fast. So let's pick much smaller random numbers. And you can see, so now, we have a bunch of circles all spinning around the center circle. Pretty good. They could have different sizes. They could be more we could do more variety with the speed, but we're getting somewhere. Now, to really make this magical, nothing that I've done here right now is the two things that I want to do to make this magical is, number one, have planets have planets have planets, and number two, make this happen in 3D. So let's see if we can if you still had some pause this video, go outside, take a walk. I don't know. Then come back if you want to watch it more. But I'm going to keep going with this. Here we go. So the first thing that I need to do is say that, when I spawn moons, what I want to do is have my planets also spawn moons. So if I were to write this so if I were to write this, for example, so the sun gets made, and the sun spawns a moon. Then I make new planets. If each of those planets spawn their own moons, and so each object has an array of other objects has an array of other objects. So while this would work, this would result in an infinite forever loop because every planet would make five more planets, which would make five more planets, which make five more planets, which would make five more planets. So I need some way of having an exit strategy. Here's a way that I propose which is really dangerous, actually. I probably shouldn't do this is, well, first thing I'll do is just I'm trying to think of a good way there's a bunch of different ways I could approach this. I could keep track of levels. So I could say, after I've spawned after I'm on the fifth orbiting planet, forget about it. I could also, right now, just only do the sun with some planets, and those planets have moons. I don't need those moons to have moons. But I also could randomly decide if planets get moons or not, and I would, by chance, eventually have this stop. Let's do the levels thing. So what I'm going to do is I'm going to add a second variable, spawnMoons 0, meaning I'm at level 0. So I'm going to add an argument called level. This is going to be useful, too, because level is going to help us determine the size and speed of these maybe. And then I'm going to say level minus 1, so when I spawn the moon oh, no, plus 1. So the sun will call spawnMoons with 0, and then it'll make a bunch of planets that will call spawn moons with 1. And they'll make a bunch of planets I've been doing this for half an hour, I guess. They will spawn a bunch of planets with level 2, and so on and so forth. So I only want to do this if level is less than 2. So let's actually only do this if level is less than 1. Let's see what happens. Whoa! Level is less than 0. Yeah, that's interesting. So why did it even do it oh, right, because I'm already spawning 1. So this is if level is less than 0, I'm getting these five planets. And if level is less than 1 whoops. Whoops. Level is less than 1, all of those planets have things orbiting it. Now, this is totally out of control because the distances and the sizes are all over the place. So what I want to do probably is figure out number one is figure out the number of moons they should have, and maybe I'll make that random. And it's going to be between 0 and 4, and so it's going to have that many. So number one, this, right now, you're going to see there's a lot fewer things, and also the distance the submoons should be much closer to those. So I can use this level variable quite effectively. So level, so I'm picking random distances, and what I could do is divide by level. So first of all, I'm going to make the level 1. Start with 1 because I don't ever want to divide by 0. And I'm going to have the distance be divided by level. And also the radius, I'm already multiplying times 0.5, so I could also oops. I could also say divided by level. And that way, this should now be 2, and you can see here now, look what's going on here. It's sort of hard to see because I don't have a good sense of sizes. So I guess divided by level I started with 1, so I should say divided by level times 2. There we go. So you can kind of see here, if I zoom in, what's going on. This particular planet has its own thing orbiting around it as it orbits. By the way, they all only orbit in one direction. Not the band One Direction. Insert One Direction song right now. That orbital speed, I really should pick where do I pick the orbital speed? Right here. I should really pick some value also that could be negative. So that they could rotate spin the opposite direction. So you can see now and it's sort of hard to tell what's spinning around what, but you can massage the values and stuff yourself because I've got to move to 3D. But I at least want to see that I could have another level here. And can we find it? I think I've shrunk stuff too much, so let me at least see if I can get you let's make things generally just quite a bit closer. And also, let's not have the size be that radically different. So you can see here the multiple levels of moons. I'm going to try to zoom in here so you can see the multiple levels of this thing rotating around that thing, with that thing rotating around that thing. And I could even add one more level if I wanted to be so crazy, like 4. And I'll let you enjoy this on your own to try to see everything rotating around everything. Now, so I would encourage you to take this. Add some color. Think about the distances, the values, the ratios, all of that much more thoughtfully. But this idea of nesting systems is kind of interesting to play with. Let's at least see if we can move this to 3D.
