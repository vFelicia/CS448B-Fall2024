With timestamps:

00:00 - (bell ringing)
00:01 - - Welcome to a surprise
extra coding challenge.
00:03 - I don't know if it's
surprise or it's extra.
00:05 - But it came up after I did my raycasting,
00:09 - 2D ray casting challenge
that Coding Train viewer
00:12 - Gustavo Petzi has created
a very similar project
00:16 - to this previously where
with a kind of particle
00:19 - moving around a maze and casting out rays
00:22 - and then taking those rays and rendering
00:25 - a view of the scene according
to what it's seeing.
00:28 - So, Gustavo gave me some great advice
00:31 - about his implementation
and I'm going to see
00:33 - if I can do something similar to it here
00:37 - with the version that I made
00:39 - in the previous coding challenge here.
00:41 - So, let me explain what
I'm going to try to do.
00:44 - So, in the previous coding challenge,
00:46 - if you watched it,
00:47 - I had a particle that cast
out rays in all directions,
00:52 - then there were some arbitrary
boundaries within its world
00:55 - and it would cast out the rays
00:57 - to see how far away the
closest boundary is.
01:03 - So, the modifications
that I need to make are,
01:05 - number one, is I want to
think about this agent
01:09 - as only being able to see
01:11 - within a particular cone of vision.
01:14 - Right, so, as a human being
01:16 - in a sort of like first person style game,
01:19 - you don't have eyes in
the back of your head,
01:20 - you can't see in 360 view.
01:22 - So, I'm going to make an
arbitrary decision about
01:24 - what that range of view is.
01:26 - Then what I want to do is,
assuming that range of view
01:29 - has say 400 angles (laughs)
between zero and 400
01:35 - and I have a view between zero and 400,
01:38 - each ray, the distance at
which it sees something
01:41 - will correspond to a slice,
01:44 - a pixel slice that I'll
render something in.
01:46 - So, the farther away it is,
01:48 - the smaller the slices that I'll render
01:51 - maybe the darker, the closer,
the larger and the brighter
01:54 - and that should give me the sense
01:55 - of looking out into this
maze of walls, I think.
02:00 - This is, you know, along the
lines of actual ray tracing,
02:04 - it's an over simplification
of ray tracing itself
02:08 - but this gets at that
idea of casting out rays
02:11 - from a point in space and
using what those rays see
02:15 - and the distance of what
they see as the data
02:18 - for rendering the 3D scene.
02:20 - Alright, so, one thing that I've done
02:21 - before I started this is I just hard coded
02:24 - in pixel values for width and height
02:26 - because I want to create
a canvas that's larger
02:29 - than the scene so I can see
the sort of overhead view
02:31 - of the scene and then
the view of this thing
02:34 - moving around to the right.
02:35 - So, that's what I'm going to do first.
02:36 - So, the first thing that I need to do
02:38 - with my particle is I
need to not let it see
02:42 - out in perfect 360 degrees.
02:45 - So, I'm going to pick
something really arbitrary
02:48 - and I'm going to say,
02:50 - let's actually give it a
40 degree range of view.
02:56 - So, I'll just do 320 to
360 or zero to 40 degrees.
03:00 - Let's just try that, see what happens.
03:02 - So, okay, so that's what
it's actually able to see.
03:04 - So, it's not turning,
03:06 - I am going to want to add
like maybe turning to this,
03:08 - but this is the basic idea right.
03:10 - So, it's moving around, it's
only seeing that 40 degrees.
03:14 - Let's see what happens.
03:15 - So, now, what I want to
do is I want to create,
03:19 - I'm going to create a
variable called like scene
03:23 - and it's going to be an array,
03:24 - let me just hard code it as
an array with 40 spots in it,
03:30 - because ultimately what I
want to do is fill this scene
03:35 - with 40 distance values, I can
just make it an empty array.
03:40 - So, as the particle looks at the walls,
03:46 - maybe I should have that return an array.
03:50 - So, I want it to return
the array of the scene.
03:54 - I'm not so sure about this
but I'm going to keep going.
03:56 - So, now, let me create that scene here
04:02 - and then for each ray if
assuming there's a closest,
04:09 - I want to say the scene index i
04:20 - is that record distance
04:27 - if there isn't a closest
04:29 - then that scene index i is Infinity.
04:34 - I think it would get that actually
04:35 - 'cause record starts as Infinity.
04:37 - So, I can actually just
do this right after here.
04:40 - So, all I'm doing is
detecting that distance
04:44 - and keeping it in an array.
04:46 - Derrick Woods, it's going to be
like a five minute long video,
04:48 - I'm sure I'm going to come up
with something that's wrong.
04:50 - Now, if I have that scene
here there's no reason
04:54 - why I shouldn't be able
to for let i equals zero,
04:57 - i is less than scene.length i plus plus.
05:03 - So, the width here of
each one of these slices
05:09 - is the scene width divided by scene.length
05:16 - and actually I don't
need this global array,
05:19 - this is really just giving me that array.
05:25 - So, I have a scene and I have
the width based on the length
05:30 - and now what I want to do is
I want to draw a rectangle
05:33 - at i times w comma zero, i
(laughs) with a width of w
05:42 - and a height of, right now just height.
05:44 - So, I'm going to do this.
05:45 - I'm going to say fill based
on scene the distance,
05:49 - just try something for right now.
05:52 - I'm going to say translate to the middle,
05:56 - 'cause I want to draw this
on the right hand side,
05:58 - push and pop.
06:04 - Just to revisit this.
06:05 - What am I doing?
06:06 - Basically what I'm doing
06:08 - is I'm recording all of
those distance values.
06:10 - All these rays.
06:11 - How far is the thing that it saw
06:13 - and recording every one of
those distances in an array.
06:16 - There's currently 40 elements.
06:18 - Those are in an array called scene.
06:19 - I'm going to draw a
slice with the brightness
06:22 - according to that distance.
06:27 - Okay cannot read property length
06:30 - of undefined sketch.js line 38.
06:34 - So, what's my error here.
06:36 - (bell ringing)
06:37 - I wrote this look function,
I made a scene array,
06:41 - I filled it with stuff and
then I forgot to return it.
06:44 - So, let's return that scene array.
06:47 - Great, so this makes sense right.
06:49 - I'm seeing what it's seeing.
06:51 - This is good, so this
is a good start, okay.
06:54 - Interesting, now, let's try to take this
06:56 - a little bit further (laughs).
06:58 - One thing is I'm not inverting right.
07:00 - The things that are farther
away are appearing brighter.
07:03 - So, couple things that I need to do
07:04 - to make this really look like the scene.
07:06 - Number one, let me just say noStroke.
07:12 - Okay, so, that is a little
bit better to start with.
07:15 - Now, let me invert that.
07:16 - So, basically, what I want
to do is I want to say
07:19 - the brightness should be inverted.
07:24 - So, I'm going to say b equals map,
07:28 - scene index i which has a range between
07:31 - let's just say the furthest something away
07:32 - could be like the scene width,
07:36 - it's not exactly right
but let's just do that
07:38 - and then I want to have
a brightness of 255
07:40 - all the way down to zero.
07:46 - (bell ringing)
07:47 - So, by the way, field of view is the term
07:49 - that I'm looking for
and I keep talking about
07:51 - like cone of view, range of view,
07:53 - peripheral vision and right now my field
07:56 - of view is 40 degrees
which is not very large,
07:59 - and some people in the chat
08:00 - are telling me to make it like
08:01 - at least pi divided by
two which is 90 degrees.
08:04 - So, let's actually change that
08:07 - just to sort of like see,
let's make this 90 degrees
08:11 - just to like have more stuff to look at.
08:13 - Okay, great.
08:14 - Now the question is does everything
08:16 - calculate perfectly from that?
08:18 - Do I have anything hard coded?
08:20 - I feel like I had something
hard coded but maybe not.
08:26 - (bell ringing)
08:27 - I've got a major issue here
08:28 - which is that I only
calculated this value b,
08:31 - I forgot to put it here in fill.
08:33 - So, let's add that.
08:34 - So, now I have a 90 degree view
08:36 - and I actually am putting b in fill.
08:39 - There we go, this is more
what I expected to see.
08:43 - So, you know, I'm not
controlling where the stuff is.
08:46 - So, this would be helpful for me also now
08:50 - that I could to have a little more agency
08:52 - over debugging this.
08:54 - For me to update the
particle based on the mouse.
08:58 - So, I'm going to update the particle
09:00 - based on the mouse location.
09:02 - This will also be nice for
when I want to rotate the view.
09:06 - So, this will let me do a lot more.
09:08 - So, I can sort of see, okay, look at this.
09:10 - That is what I'm seeing
and this makes as I go out,
09:14 - if I come really close to here,
09:15 - we can see it's quite bright on that side
09:18 - and then quite distant there.
09:19 - So, the other thing that I want to add now
09:22 - is objects that are further away
09:25 - appear smaller than
things that are closer.
09:28 - So, I also want the height
of these rectangles.
09:32 - So, one way that's going to be helpful
09:34 - if I just use rectMode CENTER
09:36 - and then if the location is
i times w plus w divided by 2
09:43 - and then this is just, and
this shouldn't be height,
09:46 - this should be scene height
09:48 - and this should be scene
height divided by two.
09:52 - This should give me the
same exact thing now.
09:55 - This is the same exact thing
09:56 - but now that I'm drawing the
rectangle from the center,
09:58 - it's height could also be mapped.
10:00 - So, I could say the height
is map scene index i
10:06 - with some maximum range between zero
10:10 - and sceneW to between
scene height and zero.
10:17 - So, again, so what I'm doing is I'm saying
10:21 - the further away the shorter the height,
10:25 - the closer it is, the taller the height.
10:27 - So, now, if I put h in here,
10:31 - we're sort of seeing (laughs) my 3D view.
10:36 - Now, I guess maybe 90 degrees
10:38 - is too big of a view of the scene
10:41 - but you can see look
that's what I'm seeing.
10:43 - Look, here I am, I'm looking at that wall,
10:46 - let's give me less view. (laughs)
10:50 - Let's go back to like 45 degrees.
10:54 - So, you can see there's a wall,
10:55 - there's another wall further away.
10:58 - There's a bunch of walls
further away from each other
11:01 - and now let's try turning.
11:03 - So, I want to be able to rotate,
11:05 - I want to be able to rotate my view.
11:09 - So, the particle can have maybe an offset.
11:15 - In the particle I can add
like a rotate function
11:18 - and I can rotate by some angle.
11:21 - Maybe I could call this heading,
11:23 - like the particle has a heading
11:25 - and I can say this.heading
plus equal angle
11:31 - and then I can just go
through all the rays like this
11:40 - and say this.ray and this will be
11:42 - 'cause there's 45, this is hard coded
11:44 - but let's change this to i
11:48 - and let's change this to rays.length
11:51 - and I could say this.rays index i
11:56 - setAngle the i, i plus this.heading.
12:04 - So, this would be rotating the heading
12:07 - and then setting the angle of the rays.
12:10 - Right.
12:11 - I think this is right.
12:12 - So, now, if I were to do something
12:14 - like say a function keyPressed,
12:21 - if key equals let's just say a, oops,
12:26 - key equals a particle.rotate by like 0.01,
12:36 - else if key equals z,
rotate by negative 0.01.
12:49 - Is this going to work?
12:51 - So, here I am looking here
12:53 - and now I'm going to rotate.
12:54 - Oops, no I'm in the console.
12:57 - Sorry, I'm looking over here
12:59 - and now I'm going to rotate,
13:02 - rays is not defined, this.rays.length.
13:07 - Oh, this should be radians i.
13:10 - Yikes, I'm really like, this
has gotten quite convoluted
13:14 - but I'm trying to just
get at the idea here
13:16 - so I'm sticking with what I have.
13:18 - So, if I do this now.
13:19 - If I should be able to.
13:24 - Okay, angle is not defined.
13:27 - So, first of all, it's not
registering my key strokes.
13:30 - Oh, 'cause I think, oh and I've made it z.
13:32 - This should be s (laughs)
13:35 - and then angles not
defined at ray.setAngle
13:40 - from oh, a whatever.
13:46 - Okay, so, now, yes, so let's rotate
13:52 - by a larger amount just to like.
14:00 - Yes, so now I can turn, oh, that's fun.
14:04 - A nice change I can do,
14:05 - I don't know why I was not
doing this in the first place
14:08 - is in draw I can just use key as down.
14:12 - So, I could say if keyIsDown
14:15 - and I can actually just say LEFT ARROW,
14:18 - then rotate the particle,
else if keyIsDown RIGHT ARROW,
14:31 - rotate the particle the other way.
14:33 - So, this should be, and I don't
need the key press function.
14:35 - This should make my
already really terrible
14:38 - and awkward interaction much better.
14:40 - Oh and I'm missing a
parenthesis there, there we go.
14:42 - So, let's try this,
14:43 - I was just looking at the
keyIsDown documentation.
14:46 - So, let's try this.
14:47 - So, now, I should be
able to use the arrows.
14:49 - Yeah, okay, so at least now I
can turn much more elegantly.
14:53 - Okay, this is better and it would be nice
14:55 - if I could actually just
move with forward and back.
14:59 - I don't know if my angles
are going in weird directions
15:01 - but I'll let you sort that out
15:03 - but I want to sort of
like fix the view here
15:06 - because one thing is I'm
seeing the boundaries
15:11 - and first of all I would
like it to be black
15:13 - as I look off into infinity.
15:16 - So, let's, do I have
those wall boundaries?
15:19 - That's a question.
15:21 - I can't remember if I've
left those in there.
15:23 - So, let's take out these wall boundaries
15:27 - and now, so, this I like better
15:29 - because off into infinity there's nothing.
15:33 - But I do have this kind
of like fish eye effect.
15:36 - Let's try a 60 degree field of view.
15:43 - So, I'm being told from the chat
15:45 - that I should use an inverse
square law for the brightness.
15:55 - So, I believe what that means (laughs)
15:58 - if I'm rendering it down here,
16:00 - is that I should map the scene squared.
16:04 - So, let me do s square is scene
index i times scene index i,
16:14 - and with square is sceneW times sceneW.
16:22 - So, I should change this
to map sq between zero
16:29 - and the scene with square,
to 255 down to zero.
16:35 - Let's try that.
16:38 - So, that looks better.
16:39 - I kind of now like want to
put those outer walls back in
16:42 - 'cause it looks so weird
not seeing anything,
16:45 - further away, like it
looks nice to see things
16:47 - that are further away
and also why am I getting
16:51 - this like space between those?
16:53 - I feel like this might need
to be like plus one here.
16:58 - Yeah, that's better.
16:59 - I don't know why 'cause
without this stroke
17:01 - or I could add a stroke to a,
17:04 - so, that's better in
terms of seeing the walls.
17:06 - Let's put the actual like
wall boundaries back in.
17:11 - Yeah, 'cause they're so far
away, now this is better.
17:14 - Oh, I like this.
17:17 - Let's turn around and
see this wall and move.
17:20 - This is kind of interesting
here, like this spot right here,
17:22 - like there's that wall.
17:24 - Okay, let's add the
Perlin noise moving back
17:26 - 'cause I think that'll be fun.
17:27 - I don't want to move it
with the mouse anymore.
17:29 - Let's add Perlin noise back.
17:34 - And there it is, there's
my thing walking around
17:38 - and I can turn.
17:40 - (bell ringing)
17:41 - You know, so this ability to
being able to rotate around
17:45 - with Perlin noise,
17:46 - this is like sort of very
like a weird interaction.
17:48 - So, even though the perspective
17:49 - is wrong and various things
are wrong about this,
17:51 - I think what would actually
make this most effective
17:54 - is for me to be able to actually
also move forward and back.
17:57 - So, the thing that I want to do.
17:59 - I think I really need to clean up the way
18:01 - that I'm thinking about
the angles of the rays
18:04 - and so, right now, if
I go into the particle,
18:07 - the angles that I'm starting with
18:10 - are from zero to 60 degrees.
18:13 - So, what I really want is to
be from negative 30 to 30.
18:18 - Like I want those angles
and the heading is zero.
18:21 - So, I'm starting with an object,
18:26 - the object just looking
directly to the right
18:28 - and let me turn the Perlin noise off.
18:30 - I'm going to turn the Perlin noise off,
18:34 - this is not useful
18:39 - and then what I want to do
18:40 - is I'm going to add else
if keyIsDown up arrow.
18:47 - I want to say particle.move one
18:52 - and then else if keyIsDown DOWN ARROW,
18:57 - particle.move negative one.
19:01 - And I think I have these backwards
19:03 - and they're like a different amount.
19:05 - So, I should be rotating
positive one for the right arrow
19:09 - 0.1 and negative 0.1 for the left arrow.
19:10 - Okay, so, now, I need a move
function in the particle.
19:13 - So, the move function, the
heading should also really
19:18 - be a vector but that's fine,
it's an angle, it's fine.
19:22 - The move function which is
getting moved by some length,
19:27 - some amount, I need a
vector, really it's velocity
19:35 - that's pointed in the
direction of the heading
19:41 - and that vector's magnitude
19:44 - should be the amount that I'm moving
19:46 - which is just one, so this is redundant.
19:48 - And then I should be saying,
19:50 - I should add that vector to the position.
19:53 - So, now, at least if I refresh,
19:57 - I can actually walk around in
a way that you might expect.
20:01 - Now, I'm kind of a little bit off.
20:04 - Something is a little off here.
20:06 - So, first of all, let me
see why what's off here.
20:12 - Oh here's the problem.
20:14 - So, I need to use this same loop here
20:18 - but my index
20:25 - is not going to work with the angle
20:27 - so I can just manually add an index
20:29 - that should fix that.
20:30 - And this should be the angle.
20:32 - There we go.
20:34 - There we go.
20:35 - So, now at least finally I
can drive around this scene
20:38 - which was the thing that I wanted to do.
20:41 - (bell ringing)
20:42 - So, now that I can drive around the scene,
20:43 - let's add, and I realize
the perspective is wrong
20:46 - but let's add one more
thing to this at least,
20:48 - let's add a little slider so I
can adjust that field of view
20:51 - 'cause I don't think will
be a nice thing to look at.
20:55 - So, can I adjust the field
of view in real time?
21:00 - So, I have my field of view variable,
21:05 - I could create a slider.
21:09 - So, let's say, let's have sliderFOV
21:14 - and let's say sliderFOV
equals createSlider
21:19 - and I have a range between 0 and 360
21:23 - and I'm going to start with
a 45 degree field of view.
21:26 - So, now, we should, I have this slider.
21:29 - So, in theory, I can then have
an event like sliderFOV input
21:37 - change field of view.
21:39 - So, I'm going to write a function
called change field of view
21:43 - and get the field of view from the slider
21:49 - and then say particle
update field of view FOV.
21:58 - So, now, if I go into the particle
22:01 - and I say, I write a
function called updateFOV
22:06 - then what I should be
doing is just resetting
22:10 - all of these rays.
22:12 - So, I'm going to do this again
22:13 - but I'm going to say this.rays
I'm going to empty it out.
22:17 - So, in theory now, oh, hello.
22:21 - I have got to actually update
the field of view value
22:25 - with the new value coming in
and recreate all the rays.
22:28 - So, now, I can do this.
22:31 - Fun.
22:31 - So, now, I can drive around my crazy scene
22:37 - backwards and forwards
in some nonsensical way
22:41 - and I can also adjust the field of view.
22:43 - (bell ringing)
22:44 - I'm cutting into this coding challenge
22:45 - to redo the ending a few days later
22:47 - where I just left off,
22:49 - where you just saw me
leave off was right here.
22:51 - And you'll notice while this is working,
22:53 - there's this kind of
a fish eye like effect
22:55 - in terms of the perspective,
22:57 - which is actually quite nice,
22:58 - especially once you like kind
of increase the field of view,
23:01 - you get these kind of beautiful effects.
23:02 - The other thing is all of a sudden now,
23:03 - once I change the field of view,
23:05 - my driving seems to have been broken.
23:06 - So, there's a few bugs
that I left off last week
23:09 - that I want to fix
before I finish this off
23:11 - and release the code to you.
23:12 - So, bug number one let me fix the driving.
23:14 - One of the things that is sort of key
23:16 - to the way that I've designed this,
23:18 - which is not by any means a requirement
23:20 - to how you need to do this.
23:21 - But i and the rays in the
world are always relative
23:26 - to the vehicle's velocity,
23:27 - or the direction that it's moving in,
23:29 - I don't know if vehicles the right word.
23:30 - The person, the thing that's
moving around in space
23:32 - and the angle of that is
expressed as a heading.
23:36 - So, the rays are always
assigned some direction
23:40 - relative to that heading on either side.
23:43 - So, in the code whenever
I call rotate for example,
23:45 - I set every single ray's angle
23:48 - relative to a variable a plus
that offset of it's heading.
23:52 - But I forgot when I'm updating
the field of view to do that.
23:56 - So, that's a really important thing,
23:57 - that I just need to add
this.heading right here.
23:59 - So, let's fix that and I'm
going to rerun this sketch
24:02 - and we can see now as I turn
around and move backwards,
24:06 - and then increase the field of view,
24:08 - I can still steer around and it works.
24:11 - So, I really quite love this
24:13 - in the sort of bizarre rendering thing
24:15 - that I've got here.
24:16 - But let's look at how it really works
24:19 - to kind of reduce this fish eye effect.
24:21 - One of the resources
that was suggested to me
24:23 - that I really should have
read over more carefully
24:25 - before I started the coding challenge
24:26 - is this computer graphics
tutorial on raycasting.
24:30 - It's really wonderful, I
suggest reading the whole thing.
24:33 - But if you scroll all the way down,
24:35 - you'll notice that it says,
24:36 - the distance you should calculate
24:38 - should be the distance projected
on the camera direction,
24:41 - the raw Euclidean distance
will give the fish eye effect.
24:44 - So, let's say I have this particle
24:46 - which is really the camera and its camera
24:48 - is pointing in a particular direction,
24:50 - that's the view, that's the camera's view.
24:52 - Now, I have any particular ray
24:54 - that's emanating from that camera's view
24:57 - within the field of view.
24:58 - So, let's say I have the
wall is something like this.
25:02 - So, the wall, this particular ray
25:05 - is going to hit the wall here
25:07 - and this is the distance
that I'm currently using,
25:10 - that raw Euclidean distance.
25:12 - But imagine there was a
light source above here
25:16 - casting a shadow down on to the plane,
25:19 - the direction of the camera.
25:20 - That would be this distance here.
25:25 - This projection of the ray
on to the camera's view.
25:29 - And so, this is actually the
distance that I should use
25:32 - which I can get by the
Euclidean distance times
25:35 - cosine of this angle and there's a variety
25:37 - of different ways I could calculate this
25:39 - but that's what I'm going
to apply in the code.
25:40 - So, in the code where I am calculating
25:44 - the Euclidean distance is right here.
25:46 - So, in addition to the Euclidean distance
25:48 - I could get the angle of the ray relative
25:50 - to the direction of the camera
25:51 - which would be a equals ray.heading
25:56 - minus this.heading and then
I could just multiply d
26:01 - by cosine of that angle.
26:02 - So, I'm taking the
component, the projection
26:05 - of the ray's vector on
to the camera's vector
26:08 - and now if I use that
as the distance instead
26:11 - and hit refresh, oh boy,
ray.heading is not a function.
26:17 - Okay, oh, it's the direction
vector that's part of the ray.
26:20 - So, it's the direction vector
that's part of the ray.
26:22 - If I hit refresh now, assignment
to a constant variable.
26:26 - Oh, I'm so good about
using consts these days
26:29 - but if I'm going to adjust it
26:31 - a little after the fact I have to use let
26:32 - which I think is fine here.
26:34 - And now, let me hit refresh
26:35 - and finally I think that I have gotten it.
26:38 - Here's a pretty good setup,
26:39 - you could see this looks less fisheyey.
26:42 - It looks more correct like
what you would expect.
26:45 - Just to be sure about this.
26:46 - Let me add something to just
sort of switch it on and off.
26:49 - I mean this a very, a checkbox
or something would be better
26:52 - but I'm just going to say
if not mouse is pressed.
26:56 - So, I can click the
mouse and I'll turn off
26:59 - this adjusting that distance calculation
27:01 - with cosine of the angle.
27:03 - (bell ringing)
27:04 - Alright, I found a nice
random configuration
27:06 - of walls with the camera pointing there.
27:08 - This is with cosine of the angle.
27:09 - Now, when I click the mouse,
27:11 - you'll see it's not that different.
27:14 - But let's increase the field of view.
27:16 - Let me click the mouse.
27:18 - So, you can probably see
the distance most notably
27:20 - right over here on the right edge
27:22 - with the raw Euclidean distance,
27:24 - you can see that curve around the edge
27:26 - versus the wall actually
emanating out there.
27:28 - So, that's a pretty slight difference
27:30 - and I'm sure there's a lot
more to this and this math.
27:33 - But I still, my favorite
thing is to just make it
27:35 - 360 degrees which is really
kind of crazy looking.
27:39 - And we can see what is the difference now
27:41 - with a 360 degree field of view
27:43 - with the cosine of the angle or without.
27:46 - You can see how notable different that is.
27:50 - I think I'm going to wrap this up here.
27:51 - Thanks for watching this coding challenge,
27:53 - I think there were a
rich set of possibilities
27:55 - you could explore just by building off
27:57 - of this very basic example.
27:59 - First of all, creating
an actual proper maze
28:02 - with constraints about where
28:03 - the vehicle particle camera thing
28:05 - can drive around would be
one thing to start with.
28:08 - Adding colors to the wall so each line
28:10 - could represent a different color
28:12 - and you could display
that color in the view.
28:15 - Texturing the walls would be a
really interesting challenge,
28:18 - automating how this sort of
particle moves about the space,
28:21 - multiple particles, different
kinds of boundaries.
28:23 - So many possibilities.
28:24 - Ultimately, making a
hyper-realistic raytracing engine
28:27 - is not the goal here.
28:28 - If you can take this basic idea
28:30 - and make this strange view
of the world we live in,
28:33 - that's kind of exciting and interesting.
28:34 - So, if you make something,
please share it with me.
28:36 - An instruction for how to do that
28:37 - in this video's description
28:38 - and I'll see you in a
future coding challenge.
28:40 - (whistle blowing)
28:41 - (energetic club music)
28:49 - (bell ringing)

Cleaned transcript:

(bell ringing) Welcome to a surprise extra coding challenge. I don't know if it's surprise or it's extra. But it came up after I did my raycasting, 2D ray casting challenge that Coding Train viewer Gustavo Petzi has created a very similar project to this previously where with a kind of particle moving around a maze and casting out rays and then taking those rays and rendering a view of the scene according to what it's seeing. So, Gustavo gave me some great advice about his implementation and I'm going to see if I can do something similar to it here with the version that I made in the previous coding challenge here. So, let me explain what I'm going to try to do. So, in the previous coding challenge, if you watched it, I had a particle that cast out rays in all directions, then there were some arbitrary boundaries within its world and it would cast out the rays to see how far away the closest boundary is. So, the modifications that I need to make are, number one, is I want to think about this agent as only being able to see within a particular cone of vision. Right, so, as a human being in a sort of like first person style game, you don't have eyes in the back of your head, you can't see in 360 view. So, I'm going to make an arbitrary decision about what that range of view is. Then what I want to do is, assuming that range of view has say 400 angles (laughs) between zero and 400 and I have a view between zero and 400, each ray, the distance at which it sees something will correspond to a slice, a pixel slice that I'll render something in. So, the farther away it is, the smaller the slices that I'll render maybe the darker, the closer, the larger and the brighter and that should give me the sense of looking out into this maze of walls, I think. This is, you know, along the lines of actual ray tracing, it's an over simplification of ray tracing itself but this gets at that idea of casting out rays from a point in space and using what those rays see and the distance of what they see as the data for rendering the 3D scene. Alright, so, one thing that I've done before I started this is I just hard coded in pixel values for width and height because I want to create a canvas that's larger than the scene so I can see the sort of overhead view of the scene and then the view of this thing moving around to the right. So, that's what I'm going to do first. So, the first thing that I need to do with my particle is I need to not let it see out in perfect 360 degrees. So, I'm going to pick something really arbitrary and I'm going to say, let's actually give it a 40 degree range of view. So, I'll just do 320 to 360 or zero to 40 degrees. Let's just try that, see what happens. So, okay, so that's what it's actually able to see. So, it's not turning, I am going to want to add like maybe turning to this, but this is the basic idea right. So, it's moving around, it's only seeing that 40 degrees. Let's see what happens. So, now, what I want to do is I want to create, I'm going to create a variable called like scene and it's going to be an array, let me just hard code it as an array with 40 spots in it, because ultimately what I want to do is fill this scene with 40 distance values, I can just make it an empty array. So, as the particle looks at the walls, maybe I should have that return an array. So, I want it to return the array of the scene. I'm not so sure about this but I'm going to keep going. So, now, let me create that scene here and then for each ray if assuming there's a closest, I want to say the scene index i is that record distance if there isn't a closest then that scene index i is Infinity. I think it would get that actually 'cause record starts as Infinity. So, I can actually just do this right after here. So, all I'm doing is detecting that distance and keeping it in an array. Derrick Woods, it's going to be like a five minute long video, I'm sure I'm going to come up with something that's wrong. Now, if I have that scene here there's no reason why I shouldn't be able to for let i equals zero, i is less than scene.length i plus plus. So, the width here of each one of these slices is the scene width divided by scene.length and actually I don't need this global array, this is really just giving me that array. So, I have a scene and I have the width based on the length and now what I want to do is I want to draw a rectangle at i times w comma zero, i (laughs) with a width of w and a height of, right now just height. So, I'm going to do this. I'm going to say fill based on scene the distance, just try something for right now. I'm going to say translate to the middle, 'cause I want to draw this on the right hand side, push and pop. Just to revisit this. What am I doing? Basically what I'm doing is I'm recording all of those distance values. All these rays. How far is the thing that it saw and recording every one of those distances in an array. There's currently 40 elements. Those are in an array called scene. I'm going to draw a slice with the brightness according to that distance. Okay cannot read property length of undefined sketch.js line 38. So, what's my error here. (bell ringing) I wrote this look function, I made a scene array, I filled it with stuff and then I forgot to return it. So, let's return that scene array. Great, so this makes sense right. I'm seeing what it's seeing. This is good, so this is a good start, okay. Interesting, now, let's try to take this a little bit further (laughs). One thing is I'm not inverting right. The things that are farther away are appearing brighter. So, couple things that I need to do to make this really look like the scene. Number one, let me just say noStroke. Okay, so, that is a little bit better to start with. Now, let me invert that. So, basically, what I want to do is I want to say the brightness should be inverted. So, I'm going to say b equals map, scene index i which has a range between let's just say the furthest something away could be like the scene width, it's not exactly right but let's just do that and then I want to have a brightness of 255 all the way down to zero. (bell ringing) So, by the way, field of view is the term that I'm looking for and I keep talking about like cone of view, range of view, peripheral vision and right now my field of view is 40 degrees which is not very large, and some people in the chat are telling me to make it like at least pi divided by two which is 90 degrees. So, let's actually change that just to sort of like see, let's make this 90 degrees just to like have more stuff to look at. Okay, great. Now the question is does everything calculate perfectly from that? Do I have anything hard coded? I feel like I had something hard coded but maybe not. (bell ringing) I've got a major issue here which is that I only calculated this value b, I forgot to put it here in fill. So, let's add that. So, now I have a 90 degree view and I actually am putting b in fill. There we go, this is more what I expected to see. So, you know, I'm not controlling where the stuff is. So, this would be helpful for me also now that I could to have a little more agency over debugging this. For me to update the particle based on the mouse. So, I'm going to update the particle based on the mouse location. This will also be nice for when I want to rotate the view. So, this will let me do a lot more. So, I can sort of see, okay, look at this. That is what I'm seeing and this makes as I go out, if I come really close to here, we can see it's quite bright on that side and then quite distant there. So, the other thing that I want to add now is objects that are further away appear smaller than things that are closer. So, I also want the height of these rectangles. So, one way that's going to be helpful if I just use rectMode CENTER and then if the location is i times w plus w divided by 2 and then this is just, and this shouldn't be height, this should be scene height and this should be scene height divided by two. This should give me the same exact thing now. This is the same exact thing but now that I'm drawing the rectangle from the center, it's height could also be mapped. So, I could say the height is map scene index i with some maximum range between zero and sceneW to between scene height and zero. So, again, so what I'm doing is I'm saying the further away the shorter the height, the closer it is, the taller the height. So, now, if I put h in here, we're sort of seeing (laughs) my 3D view. Now, I guess maybe 90 degrees is too big of a view of the scene but you can see look that's what I'm seeing. Look, here I am, I'm looking at that wall, let's give me less view. (laughs) Let's go back to like 45 degrees. So, you can see there's a wall, there's another wall further away. There's a bunch of walls further away from each other and now let's try turning. So, I want to be able to rotate, I want to be able to rotate my view. So, the particle can have maybe an offset. In the particle I can add like a rotate function and I can rotate by some angle. Maybe I could call this heading, like the particle has a heading and I can say this.heading plus equal angle and then I can just go through all the rays like this and say this.ray and this will be 'cause there's 45, this is hard coded but let's change this to i and let's change this to rays.length and I could say this.rays index i setAngle the i, i plus this.heading. So, this would be rotating the heading and then setting the angle of the rays. Right. I think this is right. So, now, if I were to do something like say a function keyPressed, if key equals let's just say a, oops, key equals a particle.rotate by like 0.01, else if key equals z, rotate by negative 0.01. Is this going to work? So, here I am looking here and now I'm going to rotate. Oops, no I'm in the console. Sorry, I'm looking over here and now I'm going to rotate, rays is not defined, this.rays.length. Oh, this should be radians i. Yikes, I'm really like, this has gotten quite convoluted but I'm trying to just get at the idea here so I'm sticking with what I have. So, if I do this now. If I should be able to. Okay, angle is not defined. So, first of all, it's not registering my key strokes. Oh, 'cause I think, oh and I've made it z. This should be s (laughs) and then angles not defined at ray.setAngle from oh, a whatever. Okay, so, now, yes, so let's rotate by a larger amount just to like. Yes, so now I can turn, oh, that's fun. A nice change I can do, I don't know why I was not doing this in the first place is in draw I can just use key as down. So, I could say if keyIsDown and I can actually just say LEFT ARROW, then rotate the particle, else if keyIsDown RIGHT ARROW, rotate the particle the other way. So, this should be, and I don't need the key press function. This should make my already really terrible and awkward interaction much better. Oh and I'm missing a parenthesis there, there we go. So, let's try this, I was just looking at the keyIsDown documentation. So, let's try this. So, now, I should be able to use the arrows. Yeah, okay, so at least now I can turn much more elegantly. Okay, this is better and it would be nice if I could actually just move with forward and back. I don't know if my angles are going in weird directions but I'll let you sort that out but I want to sort of like fix the view here because one thing is I'm seeing the boundaries and first of all I would like it to be black as I look off into infinity. So, let's, do I have those wall boundaries? That's a question. I can't remember if I've left those in there. So, let's take out these wall boundaries and now, so, this I like better because off into infinity there's nothing. But I do have this kind of like fish eye effect. Let's try a 60 degree field of view. So, I'm being told from the chat that I should use an inverse square law for the brightness. So, I believe what that means (laughs) if I'm rendering it down here, is that I should map the scene squared. So, let me do s square is scene index i times scene index i, and with square is sceneW times sceneW. So, I should change this to map sq between zero and the scene with square, to 255 down to zero. Let's try that. So, that looks better. I kind of now like want to put those outer walls back in 'cause it looks so weird not seeing anything, further away, like it looks nice to see things that are further away and also why am I getting this like space between those? I feel like this might need to be like plus one here. Yeah, that's better. I don't know why 'cause without this stroke or I could add a stroke to a, so, that's better in terms of seeing the walls. Let's put the actual like wall boundaries back in. Yeah, 'cause they're so far away, now this is better. Oh, I like this. Let's turn around and see this wall and move. This is kind of interesting here, like this spot right here, like there's that wall. Okay, let's add the Perlin noise moving back 'cause I think that'll be fun. I don't want to move it with the mouse anymore. Let's add Perlin noise back. And there it is, there's my thing walking around and I can turn. (bell ringing) You know, so this ability to being able to rotate around with Perlin noise, this is like sort of very like a weird interaction. So, even though the perspective is wrong and various things are wrong about this, I think what would actually make this most effective is for me to be able to actually also move forward and back. So, the thing that I want to do. I think I really need to clean up the way that I'm thinking about the angles of the rays and so, right now, if I go into the particle, the angles that I'm starting with are from zero to 60 degrees. So, what I really want is to be from negative 30 to 30. Like I want those angles and the heading is zero. So, I'm starting with an object, the object just looking directly to the right and let me turn the Perlin noise off. I'm going to turn the Perlin noise off, this is not useful and then what I want to do is I'm going to add else if keyIsDown up arrow. I want to say particle.move one and then else if keyIsDown DOWN ARROW, particle.move negative one. And I think I have these backwards and they're like a different amount. So, I should be rotating positive one for the right arrow 0.1 and negative 0.1 for the left arrow. Okay, so, now, I need a move function in the particle. So, the move function, the heading should also really be a vector but that's fine, it's an angle, it's fine. The move function which is getting moved by some length, some amount, I need a vector, really it's velocity that's pointed in the direction of the heading and that vector's magnitude should be the amount that I'm moving which is just one, so this is redundant. And then I should be saying, I should add that vector to the position. So, now, at least if I refresh, I can actually walk around in a way that you might expect. Now, I'm kind of a little bit off. Something is a little off here. So, first of all, let me see why what's off here. Oh here's the problem. So, I need to use this same loop here but my index is not going to work with the angle so I can just manually add an index that should fix that. And this should be the angle. There we go. There we go. So, now at least finally I can drive around this scene which was the thing that I wanted to do. (bell ringing) So, now that I can drive around the scene, let's add, and I realize the perspective is wrong but let's add one more thing to this at least, let's add a little slider so I can adjust that field of view 'cause I don't think will be a nice thing to look at. So, can I adjust the field of view in real time? So, I have my field of view variable, I could create a slider. So, let's say, let's have sliderFOV and let's say sliderFOV equals createSlider and I have a range between 0 and 360 and I'm going to start with a 45 degree field of view. So, now, we should, I have this slider. So, in theory, I can then have an event like sliderFOV input change field of view. So, I'm going to write a function called change field of view and get the field of view from the slider and then say particle update field of view FOV. So, now, if I go into the particle and I say, I write a function called updateFOV then what I should be doing is just resetting all of these rays. So, I'm going to do this again but I'm going to say this.rays I'm going to empty it out. So, in theory now, oh, hello. I have got to actually update the field of view value with the new value coming in and recreate all the rays. So, now, I can do this. Fun. So, now, I can drive around my crazy scene backwards and forwards in some nonsensical way and I can also adjust the field of view. (bell ringing) I'm cutting into this coding challenge to redo the ending a few days later where I just left off, where you just saw me leave off was right here. And you'll notice while this is working, there's this kind of a fish eye like effect in terms of the perspective, which is actually quite nice, especially once you like kind of increase the field of view, you get these kind of beautiful effects. The other thing is all of a sudden now, once I change the field of view, my driving seems to have been broken. So, there's a few bugs that I left off last week that I want to fix before I finish this off and release the code to you. So, bug number one let me fix the driving. One of the things that is sort of key to the way that I've designed this, which is not by any means a requirement to how you need to do this. But i and the rays in the world are always relative to the vehicle's velocity, or the direction that it's moving in, I don't know if vehicles the right word. The person, the thing that's moving around in space and the angle of that is expressed as a heading. So, the rays are always assigned some direction relative to that heading on either side. So, in the code whenever I call rotate for example, I set every single ray's angle relative to a variable a plus that offset of it's heading. But I forgot when I'm updating the field of view to do that. So, that's a really important thing, that I just need to add this.heading right here. So, let's fix that and I'm going to rerun this sketch and we can see now as I turn around and move backwards, and then increase the field of view, I can still steer around and it works. So, I really quite love this in the sort of bizarre rendering thing that I've got here. But let's look at how it really works to kind of reduce this fish eye effect. One of the resources that was suggested to me that I really should have read over more carefully before I started the coding challenge is this computer graphics tutorial on raycasting. It's really wonderful, I suggest reading the whole thing. But if you scroll all the way down, you'll notice that it says, the distance you should calculate should be the distance projected on the camera direction, the raw Euclidean distance will give the fish eye effect. So, let's say I have this particle which is really the camera and its camera is pointing in a particular direction, that's the view, that's the camera's view. Now, I have any particular ray that's emanating from that camera's view within the field of view. So, let's say I have the wall is something like this. So, the wall, this particular ray is going to hit the wall here and this is the distance that I'm currently using, that raw Euclidean distance. But imagine there was a light source above here casting a shadow down on to the plane, the direction of the camera. That would be this distance here. This projection of the ray on to the camera's view. And so, this is actually the distance that I should use which I can get by the Euclidean distance times cosine of this angle and there's a variety of different ways I could calculate this but that's what I'm going to apply in the code. So, in the code where I am calculating the Euclidean distance is right here. So, in addition to the Euclidean distance I could get the angle of the ray relative to the direction of the camera which would be a equals ray.heading minus this.heading and then I could just multiply d by cosine of that angle. So, I'm taking the component, the projection of the ray's vector on to the camera's vector and now if I use that as the distance instead and hit refresh, oh boy, ray.heading is not a function. Okay, oh, it's the direction vector that's part of the ray. So, it's the direction vector that's part of the ray. If I hit refresh now, assignment to a constant variable. Oh, I'm so good about using consts these days but if I'm going to adjust it a little after the fact I have to use let which I think is fine here. And now, let me hit refresh and finally I think that I have gotten it. Here's a pretty good setup, you could see this looks less fisheyey. It looks more correct like what you would expect. Just to be sure about this. Let me add something to just sort of switch it on and off. I mean this a very, a checkbox or something would be better but I'm just going to say if not mouse is pressed. So, I can click the mouse and I'll turn off this adjusting that distance calculation with cosine of the angle. (bell ringing) Alright, I found a nice random configuration of walls with the camera pointing there. This is with cosine of the angle. Now, when I click the mouse, you'll see it's not that different. But let's increase the field of view. Let me click the mouse. So, you can probably see the distance most notably right over here on the right edge with the raw Euclidean distance, you can see that curve around the edge versus the wall actually emanating out there. So, that's a pretty slight difference and I'm sure there's a lot more to this and this math. But I still, my favorite thing is to just make it 360 degrees which is really kind of crazy looking. And we can see what is the difference now with a 360 degree field of view with the cosine of the angle or without. You can see how notable different that is. I think I'm going to wrap this up here. Thanks for watching this coding challenge, I think there were a rich set of possibilities you could explore just by building off of this very basic example. First of all, creating an actual proper maze with constraints about where the vehicle particle camera thing can drive around would be one thing to start with. Adding colors to the wall so each line could represent a different color and you could display that color in the view. Texturing the walls would be a really interesting challenge, automating how this sort of particle moves about the space, multiple particles, different kinds of boundaries. So many possibilities. Ultimately, making a hyperrealistic raytracing engine is not the goal here. If you can take this basic idea and make this strange view of the world we live in, that's kind of exciting and interesting. So, if you make something, please share it with me. An instruction for how to do that in this video's description and I'll see you in a future coding challenge. (whistle blowing) (energetic club music) (bell ringing)
