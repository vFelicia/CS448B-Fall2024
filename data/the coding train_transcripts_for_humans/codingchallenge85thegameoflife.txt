With timestamps:

00:01 - [TRAIN WHISTLE]
00:02 - Hello, welcome to
today's coding challenge.
00:04 - In today's coding
challenge, I'm going
00:06 - to attempt to program this, the
game of life cellular automaton
00:12 - in JavaScript.
00:12 - Going to use the
P5.js framework.
00:14 - What's running
right here right now
00:16 - is a processing example using
the Java programming language
00:19 - that I made several
years ago as part
00:21 - of The Nature of Code book.
00:23 - Now, if you're
interested in that,
00:24 - you can also look at my whole
playlist about this thing
00:27 - that I can't pronounce
called cellular automata,
00:30 - the plural of automaton.
00:32 - And I do have some
videos that give you
00:33 - some historical
background, and looking
00:36 - at different Wolfram's
elementary CA,
00:39 - and some exercises and things.
00:41 - But I'm really just
showing examples
00:43 - and talking about the
systems in those videos.
00:46 - In this video, I'm going to
try to start from no code
00:49 - and finish with the simulation.
00:51 - Hopefully it's going to work.
00:52 - It generally doesn't.
00:53 - So don't get your hopes up.
00:56 - But I do want to say that
I would encourage you
00:58 - to do some background reading.
01:00 - This is the first public
appearance of the game of life
01:06 - as created by John
Conway, a mathematician,
01:09 - from an article in
Scientific American in 1970
01:12 - by Martin Gardner.
01:13 - Of course, you can always
refer to the Wikipedia page.
01:16 - I'm going to need this,
which is going to--
01:18 - which outlines the rules
for how the system behaves.
01:21 - And you can also
see that there's
01:22 - a lot of possible stuff.
01:24 - There's all these kinds of
interesting repeating patterns
01:27 - and different types of things
that you could create and do
01:30 - with the Game of
Life simulation.
01:32 - But I'm going to program
a simple version of it.
01:35 - Hopefully that will happen.
01:36 - Then at the end, we'll
talk about some variations
01:38 - that you might think about.
01:39 - And maybe someday I'll
try to make one in 3D
01:41 - or something like that
OK, so let's get started.
01:45 - Here's what we need.
01:48 - A cellular automaton is a system
of cells that exist in a grid.
01:53 - It could be in one dimension,
two dimensions, three
01:55 - dimensions.
01:56 - The Game of Life system is one
that exists in two dimensions.
02:03 - And the idea is that
you have generations.
02:07 - So if this is
generation 0, I'm going
02:09 - to run some computation on
this system of cells on a grid.
02:13 - And then I'm going to have a
new set of cells on that grid.
02:19 - And that's going
to be generation 1.
02:23 - So the cells that exist on
that grid all have a state.
02:28 - That's part of a CA system.
02:30 - So that state could be
a floating point number.
02:32 - It could be a kind of animal.
02:34 - You could really imagine
a lot of different ways.
02:36 - I'm going to do something
very simple with the game,
02:39 - of The Game of Life is a simple
system of discrete states,
02:41 - two states, 0 or 1, on
or off, alive or dead.
02:45 - So you can imagine
a configuration
02:47 - of this being
something like this.
02:52 - And for each time, each
tick, each generation,
02:56 - each frame of animation, I
evaluate each cell one by one
03:02 - and get a new state based
on the previous state.
03:06 - So once I'm trying
to do this cell,
03:08 - I need this cell's
new state, I'm
03:10 - going to get a new state
based on this state
03:13 - and its neighbors.
03:14 - So what are its neighbors?
03:16 - That's up to us to define.
03:17 - It could be its left
neighbor, its right neighbor,
03:19 - only its neighbors to its left.
03:21 - But in The Game of Life
system, its neighborhood area
03:25 - are the eight cells
surrounding it.
03:27 - So it's this 3 by 3 area,
1, 2, 3, 4, 5, 6, 7, 8.
03:31 - So I need to evaluate
all of those cells
03:34 - and decide whether it should
stay as the 0 or turn into a 1.
03:39 - And the reason why it's called
The Game of Life is the rules.
03:44 - The rules for how we move
from one generation to another
03:48 - resembles some type
of biological process
03:52 - that you might think about,
population or bacterial growth.
03:55 - And the idea is that a cell that
is surrounded by neighbors that
04:00 - aren't alive cannot stay alive.
04:02 - A cell surrounded by neighbors
that are alive can come to life
04:06 - or stay alive.
04:07 - And a cell that's surrounded by
too many neighbors cannot stay
04:11 - alive due to overpopulation.
04:12 - And we can go back
to the Wikipedia page
04:14 - and read those rules
precisely right here.
04:17 - So any live cell with
fewer than two neighbors
04:21 - dies, as if caused
by underpopulation.
04:24 - Any live cell with
two or three neighbors
04:26 - lives onto the next generation.
04:28 - Any cell with more
than three neighbors
04:29 - dies by overpopulation.
04:31 - And any dead cell
with exactly three
04:34 - live neighbors
becomes a live cell.
04:35 - So this is written as
if by reproduction.
04:37 - So this is written in
somewhat of a confusing way.
04:40 - I think I could
simplify this, I think.
04:42 - We could say let's
say the cell is dead.
04:46 - It's a 0.
04:48 - It's only going to change to a 1
if it has three live neighbors.
04:54 - Then it changes to a 1.
04:55 - Otherwise, it stays a 0.
04:58 - A 1 is going to stay a 1
unless it has less than two,
05:05 - less than two live and
greater than three live.
05:10 - Then it dies.
05:13 - So birth, reproduction, happens
with exactly three neighbors.
05:18 - Death happens with fewer
than 2 or greater than 3.
05:22 - Now, I don't know if I
got those numbers right.
05:24 - Let's go check the
Wikipedia page again.
05:27 - [FANFARE]
05:29 - Thank you, thank you, I hit
the sound effect by accident.
05:35 - Live cell with fewer than
two live neighbors dies.
05:38 - Yes, less than two dies.
05:41 - Live cell with two or
three neighbors lives.
05:43 - I don't care about that.
05:44 - I'm not going to kind of
not care about change--
05:46 - that it stays the same.
05:47 - I can kind of ignore that.
05:48 - Live cell with more than
three neighbors dies.
05:51 - Yep, that's what
I've got over there.
05:53 - And then, any dead
cell with exactly three
05:55 - live neighbors becomes alive.
05:58 - OK, so I've got
those rules correct.
06:00 - So now, what do I need?
06:01 - You're over there.
06:02 - I'm going to go back over here.
06:03 - I need something.
06:04 - I need a-- all I need to
make this program work
06:07 - is a data structure
to store this grid.
06:10 - And this is where I'm
having a bit of a headache.
06:13 - I'm really not sure what to do.
06:16 - The way that I've always done
this in previous examples
06:18 - is by using something called
a two dimensional array.
06:20 - I think I have a video
tutorial about that
06:22 - somewhere, which I will link
to in this video's description.
06:25 - But two dimensional arrays
are kind of not so much fun
06:29 - in JavaScript.
06:30 - They can become a
little bit weird.
06:31 - And there really
is no such thing
06:32 - as a two-dimensional array.
06:33 - A two-dimensional
array is a construct
06:36 - of our own human mind, saying
it's really just an array
06:39 - of arrays, which makes sense.
06:41 - This is an array.
06:43 - Each row is an array.
06:44 - And then the grid
is an array of rows.
06:46 - Or each column is an array.
06:47 - And the grid is an
array of columns.
06:49 - So I think I'm going
to do it that way
06:50 - with the two-dimensional array.
06:51 - I just should say
that it's a little bit
06:53 - awkward, two-dimensional
arrays in JavaScript.
06:55 - But I'm going to
go ahead anyway.
06:56 - So the first thing that I
want to do in this program
06:58 - is just make a
two-dimensional array
07:02 - that stores a random
collection of 0s and 1s.
07:05 - So let's go to that.
07:08 - I'm going to go to the code.
07:09 - And you know what
I'm going to do?
07:12 - I'm going to actually
just write a function.
07:14 - I'm having weird deja vu.
07:15 - I probably did this in
another video somewhere.
07:17 - I'm going to just write a
function called make2Darray.
07:20 - And I want a certain
number of columns and rows.
07:23 - Because that way,
I can just say,
07:26 - I can have a global
variable called the grid.
07:29 - I'll call it grid.
07:30 - And I could just say
grid equals make2Darray.
07:34 - And I could say, I
want a 10 by 10 grid.
07:36 - So this is kind of
what I want to do.
07:38 - I'm going to just farm out
the making of the array
07:40 - to another function.
07:42 - And now I do
remember doing this.
07:44 - Because I'm going to
write this in a kind of--
07:46 - oh, there's a whole
coding challenge or video.
07:48 - I'm going to do this
in kind of horrific way
07:50 - and then everyone's going to
give me all these like amazing
07:53 - ES6 JavaScript fancy ways
of doing this whole function
07:56 - in one line of code.
07:57 - Someday, I'll come
back and do that.
07:58 - OK, so now, let me see here.
08:05 - So what I need to
do first is I need
08:07 - to have some sort of array.
08:09 - And it's going to be--
08:13 - this is always where
I get confused, too.
08:15 - Do I want the columns--
08:20 - the point of using a 2D array
is that eventually at some point
08:23 - I would be able to say something
like, grid know index 2,
08:28 - index 3.
08:30 - And I guess I usually think
of this as x and y and x
08:33 - being the columns.
08:35 - So I want this, the outer
array, if I think about arrays
08:38 - of arrays, to be every single
column, every single-- no, no,
08:45 - that's--
08:46 - x is column.
08:47 - And then the y is
every single row.
08:51 - So I'm going to do that.
08:52 - So I'm going to make a
new array of columns.
08:57 - And then, I am going to
say for let i equal 0,
09:04 - i is less than that
arr.length, i plus plus.
09:09 - Make array index i is
a new array of rows.
09:15 - Again, I know there are all
sorts of shorter and fancier
09:19 - automatic functions for
generating and configuring
09:21 - arrays, like fill,
and map, and reduce,
09:23 - and all that kind
of stuff, even more.
09:26 - So I'm going to do this.
09:28 - And then I am going to--
09:31 - what I want to do here now is
also want to fill them with--
09:37 - I guess I could fill
with values down here.
09:43 - So maybe I won't.
09:44 - Maybe I'll actually
just do that.
09:46 - So this is going to make me
an empty 2D array with nothing
09:49 - in it.
09:50 - And then I think what I
want is I probably want
09:55 - to have these global variables.
10:00 - I know this is a little bit
goofy that I'm doing this.
10:04 - And then what I'm going
to do, I could make an--
10:09 - and I'm going to
say let i equal 0.
10:13 - i is less than
columns, i plus plus.
10:17 - And then I'm going
to do j is less
10:20 - than 0. j is less than rows.
10:23 - I'm going to do a nested loop.
10:25 - So that I can say grid i
j equals floor random 2.
10:35 - This is going to give
me a nested loop.
10:38 - This is a nested loop.
10:39 - So I make this sort of 2D
array structure that's empty.
10:42 - And then I integrate
over every single column
10:45 - in every single row.
10:46 - And I fill each one with
a random number, 0 or 1.
10:52 - And I'm just-- now
I'm going to run this.
10:55 - And I'm going to go back to--
10:56 - I'm going to go to my code.
10:58 - OK, cannot read
property 0 of undefined.
11:01 - Well, you know it would be nice?
11:03 - If I actually
returned that array.
11:06 - So the make 2D function
array, it's making this array.
11:09 - It's also got to return it.
11:10 - So that I can get it back here.
11:14 - And then now, if I look
at grid, I'm going to see,
11:17 - it's an array of arrays.
11:18 - And I forgot, there's this
wonderful thing you can do,
11:20 - console.table grid,
which shows me.
11:25 - Now I can see it here.
11:26 - So we can see this is that
two-dimensional array.
11:30 - That's what it looks like.
11:31 - It's a two-dimensional
array with rows and columns,
11:33 - filled with 0s and 1s.
11:35 - So
11:35 - Step one is finished.
11:39 - Now, what I need to do is
I need some mechanism to,
11:44 - every frame of animation,
iterate over every single spot
11:47 - and set a new spot.
11:49 - Actually, you know what
I need to do first?
11:51 - I need to render this thing.
11:52 - I want to be able to see it as
a grid of red and blue squares,
11:57 - or black and white squares,
or 0s and 1s on the screen.
12:00 - There's any number of ways
you could render this.
12:02 - I'm going to do it in
the traditional way
12:04 - of a grid, the square, the
cell of the grid is black.
12:08 - If the value of 0, is white with
a value of 1, or vice versa.
12:11 - OK, what I want to do now is I'm
going to add a draw function.
12:17 - And I'm going to be using
this loop over and over again.
12:21 - I'm going to add this loop.
12:24 - Because I'm always
going to-- any time
12:26 - I want to look at
everything, I'm
12:27 - going to go through all the
columns and all the rows.
12:29 - It's been pointed
out in the chat
12:31 - that there are some JavaScript
libraries and packages that
12:34 - manage grid systems
and neighbors for you.
12:36 - Would be great to use those.
12:37 - I'm going to just do it
all without that right
12:39 - now, just to kind
of figure it out.
12:42 - I'm going to say background 0.
12:45 - And I'm going to
create a canvas.
12:47 - I think, to make my life
easier for the moment,
12:49 - I'm going to make the
canvas also a square.
12:54 - And then what I need to
do is I need to draw--
12:56 - I want to draw a
rectangle at an x and y
12:59 - with some width and height.
13:01 - And it's going to-- they're
going to be squares, so
13:03 - some width and width.
13:07 - And that value is going
to be the width of the--
13:15 - I should probably calculate
the number of columns and rows.
13:18 - Here's the thing.
13:18 - I'm going to redo the
way that I'm doing this.
13:21 - So I'm not going to
actually have a fixed
13:23 - number of columns and rows.
13:25 - I'm actually going
to do like a scale.
13:27 - I'm going to just have a
variable called resolution.
13:29 - And say that's 10, or 40.
13:33 - I'm going to say that's 40.
13:34 - So that'll be 10 by 10.
13:36 - And what I'm going
to do is I'm going
13:39 - to say columns equals the
width of the canvas divided
13:44 - by resolution.
13:45 - Rows equals the height of the
canvas divided by resolution.
13:50 - This way, I can kind of
dynamically-- you'll see what--
13:52 - I can dynamically
make a 2D array
13:55 - based on how big I
want the squares to be.
13:57 - So the columns and rows
are being calculated
13:59 - based on how big I
want the squares to be
14:01 - and the canvas size.
14:03 - And then I have that
global variable resolution,
14:05 - which is probably too long of a
name, which I can just use down
14:08 - here.
14:08 - And now, x equals i
times resolution and y
14:15 - equals j times resolution.
14:18 - And I'm going to now say if
grid i j equals 1, fill 255.
14:30 - And you know what, since
I made the background
14:32 - 0, I can actually,
in this case, I
14:35 - can just draw white rectangles
only for the values of 1.
14:39 - So let's see, I probably
got something wrong here.
14:41 - But let's try to run this.
14:42 - No, I didn't.
14:43 - So we can see there we go.
14:44 - There's some goofiness,
oh, it's sort
14:47 - of like my math is a little off.
14:48 - And what's this weird nonsense
over here, flickering?
14:54 - I kind of feel the
need to fix that.
14:58 - And the other thing that I can
do that this is going to help
15:00 - is if I make this 600 by
400, and I make this 20,
15:08 - it still works.
15:09 - Now, this is driving me crazy.
15:11 - I think what I want
to do is there's
15:14 - an issue with the stroke.
15:15 - So I could say, I could
also say stroke 255.
15:20 - And then I'm getting
something like this.
15:22 - But I don't know, design
wise, I'm not going
15:24 - to worry about that too much.
15:25 - Actually, I kind of like
being able to see the grid.
15:27 - So let me actually
put in stroke 0.
15:31 - And then I'm going to do
something kind of goofy, which
15:33 - is, I think if I say just
draw all the rectangles one
15:37 - pixel less, I think I'm going
to get the look that I want.
15:42 - Yeah, so whatever,
there's countless ways
15:45 - I could deal with this.
15:46 - But now I have the grid.
15:48 - I have all the cells.
15:49 - So now it's up to me to
simply implement these rules.
15:54 - I need to, for
every single cell,
15:57 - count the number
of live neighbors,
15:59 - look at its own state, and
have these rules play out.
16:04 - Here's the thing, this
is really important.
16:07 - While I'm checking each cell,
I check this cell first,
16:11 - let's say, I cannot change its
value and then go on and check
16:16 - the next cell.
16:17 - Because the next cell's
new state should not
16:20 - be dependent on this cell's new
state, but its previous state.
16:23 - And if I change the state,
I have lost its old state.
16:25 - So this is where
what I actually need
16:28 - is I need two
two-dimensional arrays.
16:31 - One is the sort of old one.
16:33 - And one is the new one.
16:35 - Now, probably the simplest
thing for me to do
16:38 - is just make a new
one every frame.
16:41 - That's sort of
like, in some ways,
16:43 - a bad idea in terms
of memory management.
16:45 - And if you look at
my processing example
16:48 - that I referenced at the
beginning of this video, what
16:49 - I actually do in that
example is I just
16:51 - have two different arrays.
16:52 - I have an old one and
then I have a new one.
16:54 - Then the new one is
then the old one.
16:56 - And I write the
new one over here.
16:57 - I just keep swapping them.
16:58 - So I could maybe add that in at
some point during this video.
17:00 - But for right now, at
the beginning of draw,
17:02 - I'm just always going to
make a new generation.
17:04 - At the beginning,
what I can do here--
17:07 - [FANFARE]
17:08 - Why's that keep happening when
I press the button to change
17:12 - the camera?
17:13 - At the beginning
of draw, I can say
17:17 - let next, for next generation,
equal make2Darray columns
17:23 - and rows.
17:26 - Now, I'm going to leave
this here for the rendering.
17:30 - And what I'm
actually going to do
17:32 - is at the end, what I'm going
to do is I'm going to say--
17:39 - I guess it doesn't
really matter.
17:40 - Do I want to render first?
17:43 - This is like a deep
philosophical question.
17:46 - Do I want to compute and then
render or render then compute?
17:50 - Kind of could matter
in some situations.
17:51 - In this situation
doesn't really matter.
17:53 - But the reason why
is I'm never going
17:55 - to see the first generation.
17:56 - Because what I want to do
is say grid equals next.
18:00 - So basically, the algorithm here
is compute next based on grid.
18:07 - Because draw is looping.
18:09 - So I want to compute the next
generation based on the grid,
18:12 - make grid that, render.
18:15 - And then compute the next
generation based on grid,
18:17 - make grid, render.
18:18 - So I don't know,
that's bothering me.
18:20 - I'm going to do this--
18:22 - I'm going to do this after.
18:23 - So at least I draw
the first one.
18:24 - And I'm going to do some
computation for the next frame.
18:28 - OK, so now, what do I
need to do once again?
18:31 - Loop through all of these,
loop through all of these.
18:38 - Now, what I need to do
is count live neighbors.
18:46 - I need to count the
number of live neighbors,
18:48 - the neighbors that have 1.
18:50 - So I could do a kind
of internal loop here.
18:55 - And that would probably
be a smart thing to do.
18:57 - Maybe I will do that.
18:59 - Where basically what I do
is I say I have a certain--
19:03 - I'm at a certain
cell, let me look
19:05 - at the cells between negative
1 and 1, negative 1 and 1,
19:08 - offset from where I am.
19:09 - I could also just do
something really silly.
19:14 - Let me do the really
silly thing first.
19:17 - I could say let sum equal 0.
19:19 - Then I could say sum plus
equal grid i minus 1 j.
19:26 - That would be the
neighbor to the--
19:29 - so right, if this is i,
j, i minus 1, j is there.
19:35 - i minus 1, j minus 1, i, j
minus 1, that sort of thing.
19:39 - So if I'm thinking about
this, I might add--
19:43 - I could manually put
in all the neighbors,
19:47 - just add them all up.
19:50 - This is like going
around the horn here.
19:55 - Plus i plus 1, j plus 1, i--
20:01 - sometimes I like doing
ridiculous things like this
20:03 - just to figure this stuff out.
20:06 - Now, I got to go i
minus 1, j plus 1.
20:11 - And then what's the
last one? i minus 1, j.
20:14 - This should be eight neighbors.
20:22 - This is eight neighbors, 1, 2,
3, 4, oh, wait, 1, 2, 3, 4, 5,
20:28 - 6, 7.
20:29 - What did I forget?
20:31 - i minus 1, j minus 1, i, j
minus 1, i plus 1, j minus 1.
20:40 - I forgot to do
that whole top row.
20:42 - And then i plus 1, j,
i plus 1, j plus 1, i.
20:50 - Yeah, so this
should now be eight.
20:52 - 1, 2, 3, 4, 1, 2, 3, 4.
20:55 - I kind of hate that I did this.
20:57 - You're all throwing your
tomatoes at your television
21:00 - screen, because of course,
you're all watching
21:02 - this on the television screen.
21:04 - So this is the idea.
21:05 - I need to add up
all those neighbors.
21:06 - Let's do this in a loop.
21:08 - So another way I could
do it is I could say.
21:11 - I have a better idea.
21:16 - Neighbors, I have a
better idea, let's
21:18 - write a function to do this,
neighbors equals count.
21:22 - I'm going to give it the grid.
21:23 - And I'm going to give
it the i and the j.
21:27 - So I'm going to
write a function,
21:30 - I'll put it all at the
bottom of my code, that
21:32 - receives I'm going
to call it count,
21:35 - countNeighbors, let's call it.
21:37 - And it's going to
receive some 2D array.
21:41 - And it's going to receive
an x and y location.
21:45 - And then what I'm
going to do is I'm
21:47 - going to say i equals
negative 1, i is less than 2 i
21:53 - plus plus.
21:55 - Then so I'm going to do a
little nested loop using i
21:58 - and j around that spot.
22:03 - And I'm going to say
let sum equals 0.
22:06 - And then I'm going to say
sum plus equals grid i, j.
22:12 - However, here's a problem.
22:14 - I don't want to count
myself as a neighbor.
22:19 - So there's a few different
ways I could do this.
22:21 - But it's a little bit silly.
22:22 - I'm just going to
subtract it at the end.
22:25 - I'll just subtract it out.
22:26 - I could have put an
if statement here,
22:28 - ignore it if i equals
x and j equals x,
22:32 - but I'm just going to
subtract it out at the end.
22:34 - And then I'm going
to return that sum.
22:36 - So this is-- you could see
a couple different ways
22:38 - of doing this right now.
22:40 - This is one way to
kind of do this.
22:42 - What this is doing
is it's saying
22:43 - let me do a little loop
around here, negative 1, 0,
22:47 - positive 1, negative
1, 0, positive 1.
22:49 - So let me check
this, this, this,
22:50 - and then subtract this
out, because I don't really
22:52 - want to count that one.
22:55 - So now, I should be able to--
22:57 - I'm going to just delete this.
22:59 - I've now counted all
of the neighbors.
23:02 - I've got a big problem.
23:05 - What do I do with the fact
that if I'm on the edge,
23:09 - there's no neighbor to the left?
23:12 - If I'm on the bottom,
there's no neighbor below.
23:15 - From the top, there's no
neighbor to the above.
23:16 - On the right there's no--
23:17 - if I'm on the edge, there's
no neighbor to the right.
23:19 - So what I could do, there's
a bunch of things I could do.
23:22 - I could consider this like
an infinite wraparound world,
23:25 - where this neighbor
to the right is this.
23:27 - This neighbor to
the left is this.
23:29 - I could-- there's other ways
that I could approach it.
23:31 - What I'm going to
do is I'm going
23:33 - to leave the edges
as fixed values
23:36 - and just not bother
to check them.
23:40 - So what I'm going to do
here is I am going to--
23:49 - I wanted to do, I was going
to do this loop like this.
23:53 - You know what?
23:54 - Let's do the wraparound.
23:55 - Do I-- no, no, no let's do
it the simple way first.
23:58 - I was like, oh, I'm just going
to add the wraparound code.
24:00 - Because I could add the
wraparound code here.
24:04 - But let me-- maybe I'll
leave that as an exercise
24:07 - or do that later.
24:08 - The issue is you know
what I really want?
24:11 - I think then-- the problem
is if I change this loop.
24:17 - So I have to--
24:17 - I have to treat the
edges differently.
24:19 - Oh, so much heartache here.
24:22 - But I can say, what I'm going
to do here is I'm going to say,
24:27 - oh this is the drawing.
24:31 - Oh, right, this is
the computation.
24:33 - So I'm going to say if i
equals 0 or i equals columns
24:39 - minus 1, minus 1, or j equals
0 or j equals rows minus 1,
24:52 - this is all of the edges.
24:54 - Just going to treat
them differently.
24:59 - I'm going to say next
i j equals grid i j.
25:08 - So I'm just going to keep
the same values from before.
25:11 - This is not a great solution.
25:13 - But it's a quick one
that I can do right now.
25:15 - So if I'm on an edge, I'm just
going to use the same value.
25:20 - Because now, what I can
do is say, look at this,
25:24 - my state is grid i j.
25:30 - Now it's time for me to
implement those rules.
25:33 - OK if my state is 0, and
3 neighbors are alive,
25:39 - change my state to 1.
25:43 - If state equals 0 and
neighbors equals 0,
25:50 - then next i j equals 1.
25:58 - That's rule number one.
26:02 - Not 0, equals 3.
26:04 - Now, what else?
26:06 - If I'm alive and less than 2
or greater than 3, are alive,
26:12 - then change my state to 0.
26:17 - Else if my state is 1 and
neighbors is less than 2
26:24 - or neighbors is greater
than 3, and I probably
26:28 - should put a little
parentheses around that one,
26:31 - and again, I'm sure there are
some nicer ways I could write
26:34 - this in a more concise way.
26:35 - But you can see,
this is the rule.
26:37 - If I'm alive, and
I have less than 2
26:39 - or greater than 3 neighbors,
then the new state is 0.
26:47 - In all other cases,
the next state
26:52 - is just the current-- is
just the current state.
26:58 - So this makes me want to
put this up here at the top.
27:02 - So that I can also
just use this here.
27:04 - So that's the state.
27:05 - The state, this is
the current state.
27:07 - If I'm an edge, just ignore me.
27:09 - I'm the same state.
27:11 - If I'm not an edge,
count all the neighbors.
27:13 - Check if I should change
my state or say the same.
27:16 - I'm seeing in the chat
there's a typo at neighbors
27:18 - in the first if.
27:20 - Thank you, neighbors.
27:24 - What's the chance I've
actually finished this?
27:28 - So there we go.
27:29 - I think I have mostly
all the code for it.
27:32 - OK, count is not defined.
27:35 - sketch.js, line 55,
oh right, because I
27:39 - called it countNeighbors,
which is a better name
27:41 - for the function than count.
27:42 - Try that.
27:45 - Cannot read property negative 1
of undefined at countNeighbors.
27:49 - So what is undefined?
27:52 - Oh, no, no, no, no, look at
this, this is a big mistake?
27:57 - What was I doing here?
27:58 - This loop-- negative,
this loop, which goes,
28:02 - which is basically a loop
for a little subsection,
28:07 - if this is x and y, i
is an offset negative 1
28:13 - to positive 1.
28:15 - j is an offset negative
1 to positive 1.
28:18 - The cells I'm looking at are not
i j, but x plus i and y plus j,
28:25 - because I'm just looking
relative to where that x, y
28:28 - point is.
28:29 - So that was a big mistake here.
28:31 - This should be x
plus i, y plus j.
28:41 - Oh, so close.
28:42 - countNeighbors at
draw sketch line 55.
28:47 - Line 55, countNeighbors,
wait, whoa,
28:51 - cannot read property
negative 1 of undefined.
28:53 - What's undefined?
28:54 - Grid?
28:56 - Neighbors?
28:57 - OK, hold on.
28:58 - Let's look at some stuff here.
28:59 - Or if j 0.
29:01 - Oh, look at this.
29:03 - I just keep going anyway,
so this, I really,
29:05 - I need to break out of the loop.
29:07 - So this is really like I'm done.
29:10 - Leave the loop, or
continue, or something.
29:14 - I don't know.
29:14 - I'm going to--
29:15 - I'm just going to put an elf in
here, as much as I hate that.
29:19 - Because I shouldn't be--
29:20 - I'm basically doing the
edges or the neighbors.
29:22 - Boy this would be much nicer
if I just, in this function,
29:26 - add some code to deal with
wraparound, which is not
29:28 - going to be that hard to do.
29:30 - So now, it should be good.
29:34 - There we go, the game of life.
29:35 - Now, it looks weird.
29:37 - Because the edges
aren't ever changing.
29:41 - But this is actually now
the game of life working.
29:47 - I really got to implement
this wraparound thing.
29:49 - So let's do that now.
29:51 - Let's fix it so that
the edges consider
29:53 - the other sides as neighbors.
29:56 - So how do I do that?
29:58 - Well, one way to do that is
with something called modulus.
30:02 - This is really, this is great.
30:03 - And I can refer you to Golan
Levin's guest tutorial video
30:07 - on modulus, which was made
as part of this channel.
30:09 - So I will link to that.
30:11 - But basically what
I'm saying here
30:15 - is if I have 10 columns,
0 through 9, what could--
30:24 - and I'm always looking
for the neighbor plus 1.
30:28 - So 0 plus 1 is 1, 1
plus 1 is 2, et cetera,
30:31 - et cetera, et cetera.
30:32 - 9 plus 1 is 10.
30:35 - But I want the neighbor to be 0.
30:37 - Well, guess what?
30:38 - 9 plus 1 modulus 10 equals 0,
because modulus is the operator
30:44 - gives you the
remainder of division.
30:47 - 10 divided by 10
is one remainder 0.
30:49 - So I encourage you to
watch that modulus video,
30:51 - if you're not
familiar with modulus.
30:53 - So this will actually
work, almost,
30:56 - getting closer, if I say,
I'm going to just say,
31:02 - I'm going to have a new--
31:04 - I need a new variable
name for x plus i--
31:07 - I guess I could say column.
31:10 - I don't-- column.
31:12 - And I'm going to say x
plus i modulus columns.
31:19 - And row equals y
plus j modulus rows.
31:24 - So this gets me close.
31:25 - It doesn't get me
all the way there.
31:26 - But it gets me close.
31:28 - So now I'm adding
it up like this.
31:31 - And I'm going to get rid
of this whole edges thing,
31:36 - because no longer.
31:39 - So I've got to get this--
31:40 - Now, I'm going to
have an error here.
31:42 - Right, I'm still getting
an out of bounds area,
31:44 - because I'm going to negative 1.
31:45 - Why?
31:46 - Because what if in the
case of i equal negative 1?
31:53 - So what if-- if i is 0, so let
me come to the console here.
32:02 - 10 modulus 10 is 0.
32:07 - But let's say I'm looking
for the left neighbors.
32:10 - So I'm going through negative
1, negative 1 modulus 10
32:15 - is negative 1.
32:17 - But I need that to be 9.
32:20 - I need negative 1 to the 9.
32:21 - Well guess what?
32:23 - If I actually just add
the number of columns
32:26 - to everything, if I'm actually
working with the numbers,
32:29 - instead of the number 0 through
9, the numbers 10 through 19,
32:35 - 10 minus 1 is 9,
modulus 10 is 9.
32:40 - So the formula is negative 1--
32:43 - is negative 1 plus
the number of columns
32:46 - modulus the number of columns.
32:51 - Oh but there's not 10.
32:52 - There's different
numbers in my system.
32:55 - So let's try to
confirm this again.
32:58 - The idea is that I have
an x and a y point.
33:02 - So that point might be,
let's say if it's on an edge,
33:05 - for example, might be like
0, it's on the left edge,
33:10 - might be something like
0, whatever the y is, 5.
33:15 - So this is the x value.
33:18 - And I want to take x plus i
plus the number of columns
33:26 - modulus the number of columns.
33:28 - I said it was
going to be simple.
33:29 - But it's kind of.
33:30 - It's really kind of
a crazy thing to do.
33:32 - But you might write this out,
practice it a bit on your own.
33:35 - It will make sense
to you eventually.
33:37 - So when this is going
to work, basically,
33:40 - let's say, i is going to be the
values negative 1, 0, and 1.
33:49 - x is going to be the
values 0 through 9
33:52 - if I'm thinking about
all the possible, all
33:55 - the possible columns.
33:56 - So let's just take 0 and
negative 1, for example.
34:00 - 0 minus 1 plus,
and in this case,
34:04 - I have 10 columns,
plus 10 modulus
34:08 - 10 is actually 9 modulus
10, which equals 9.
34:13 - So 0 negative 1,
to the left of it,
34:16 - that wraps it around to get
the neighbor on the right.
34:20 - Doesn't work for just any
arbitrary thing in the middle.
34:23 - If I take i to be 3--
34:27 - sorry, if I take, sorry, x
to be 3, 3 minus 1 plus 10
34:34 - modulus 10.
34:36 - well see how this 10 and 10
kind of cancels itself out?
34:38 - Can you see that?
34:39 - Am I off the whiteboard?
34:41 - I'm close to being
off the whiteboard.
34:43 - That equals 2.
34:46 - Because this is 12
modulus 10 is 2.
34:49 - So this actually works.
34:50 - And then what if
I'm on the edge?
34:51 - If I'm at 9, right,
if x is 9, 9 plus 1
34:58 - is 10, plus the number
of columns is 10,
35:01 - is 20, modulus columns, 20
divided by 10 is 2 remainder 0,
35:06 - so 9 to the right
gets neighbors 0.
35:09 - So this is kind of goofy.
35:10 - It shifts everything
over, so it can kind of
35:13 - look across the edge.
35:14 - So this is going to work.
35:16 - You can believe me
or not believe me.
35:17 - But it's going to work.
35:19 - And I'm going to put this in.
35:21 - So now what I want is
x plus i plus columns,
35:26 - modulus columns, y plus
j plus rows modulus rows,
35:33 - add those all up.
35:34 - And the game of life.
35:39 - [FANFARE]
35:41 - Thank you, thank you for
watching this coding challenge.
35:44 - Thank you, thank you.
35:45 - So let's try and make-- let's
try doing a couple of things,
35:48 - just to get a
little further here.
35:53 - I don't know, no,
I'm not going to--
35:55 - you do all the next stuff.
35:58 - I'm just curious let me
make the resolution 10,
36:01 - so we can see that's with a 10.
36:02 - So we can see it's running
pretty fast in the browser.
36:05 - I have a pretty low resolution.
36:09 - So here's what
you should do now.
36:10 - I'm going to stop.
36:11 - This is a perfect opportunity
for people watching this video
36:14 - to make some variations.
36:16 - Some things you can think about.
36:17 - Well, one thing is what
if you make each one
36:19 - of these cells an object?
36:21 - So its state might
not actually just be--
36:23 - it can keep track of more
than just its state 0 or 1.
36:26 - It could keep track of
whether it's changed state,
36:29 - or stayed the same, or how
long it stayed the same.
36:31 - What if you visualize those?
36:32 - What if you visualize
with different colors
36:34 - based on the history
of the system?
36:37 - What if you allow a user to draw
with the mouse, set cells on?
36:42 - What if you look up
some of these repeating,
36:44 - special repeating patterns
that you can create
36:46 - certain kinds of patterns?
36:48 - What if you-- you're
going to think of more.
36:52 - And what if you did the
edges in a different way?
36:54 - What if you used
a floating point
36:55 - numbers instead of 0s and 1s
and did an average or something?
36:59 - There are so many ways
you can create a system,
37:02 - lowering the resolution.
37:03 - What if you drew--
didn't draw squares,
37:04 - but circles, used images.
37:06 - How can you visualize
this system?
37:08 - How can you change the
rules or how can you
37:10 - visualize the system
in a different way
37:13 - to create a piece of art
or for some other purpose?
37:16 - I look forward to-- share
what you make in the comments.
37:18 - There will be the
code link from here
37:20 - and a Read Me where you
can submit your versions.
37:22 - And I'll come back in
a future livestream.
37:23 - I'll share some of the
community made versions.
37:25 - Run this again.
37:27 - There's one other thing.
37:28 - But I do think that making
cell objects is a path.
37:33 - Right now, I just have--
37:35 - oh, and you should probably
do the swapping thing.
37:37 - Maybe that's one other
thing you could do is maybe
37:40 - don't make a new 2D
array every time.
37:42 - But what I'm thinking
about here is
37:44 - what if instead of each one
of these being a random value,
37:48 - you said something
like new cell, i, j.
37:52 - And this cell
object can animate.
37:55 - It can move around.
37:56 - The cells could move, they
could grow, they could shrink.
37:58 - They could keep track
of their history.
37:59 - There's so many
possibilities there
38:01 - if you make an
object for the cell.
38:03 - OK, Thanks for watching.
38:05 - I hope you enjoyed
this coding challenge
38:06 - and you share with
me what you make.
38:08 - Goodbye.
38:09 - [MUSIC PLAYING]

Cleaned transcript:

[TRAIN WHISTLE] Hello, welcome to today's coding challenge. In today's coding challenge, I'm going to attempt to program this, the game of life cellular automaton in JavaScript. Going to use the P5.js framework. What's running right here right now is a processing example using the Java programming language that I made several years ago as part of The Nature of Code book. Now, if you're interested in that, you can also look at my whole playlist about this thing that I can't pronounce called cellular automata, the plural of automaton. And I do have some videos that give you some historical background, and looking at different Wolfram's elementary CA, and some exercises and things. But I'm really just showing examples and talking about the systems in those videos. In this video, I'm going to try to start from no code and finish with the simulation. Hopefully it's going to work. It generally doesn't. So don't get your hopes up. But I do want to say that I would encourage you to do some background reading. This is the first public appearance of the game of life as created by John Conway, a mathematician, from an article in Scientific American in 1970 by Martin Gardner. Of course, you can always refer to the Wikipedia page. I'm going to need this, which is going to which outlines the rules for how the system behaves. And you can also see that there's a lot of possible stuff. There's all these kinds of interesting repeating patterns and different types of things that you could create and do with the Game of Life simulation. But I'm going to program a simple version of it. Hopefully that will happen. Then at the end, we'll talk about some variations that you might think about. And maybe someday I'll try to make one in 3D or something like that OK, so let's get started. Here's what we need. A cellular automaton is a system of cells that exist in a grid. It could be in one dimension, two dimensions, three dimensions. The Game of Life system is one that exists in two dimensions. And the idea is that you have generations. So if this is generation 0, I'm going to run some computation on this system of cells on a grid. And then I'm going to have a new set of cells on that grid. And that's going to be generation 1. So the cells that exist on that grid all have a state. That's part of a CA system. So that state could be a floating point number. It could be a kind of animal. You could really imagine a lot of different ways. I'm going to do something very simple with the game, of The Game of Life is a simple system of discrete states, two states, 0 or 1, on or off, alive or dead. So you can imagine a configuration of this being something like this. And for each time, each tick, each generation, each frame of animation, I evaluate each cell one by one and get a new state based on the previous state. So once I'm trying to do this cell, I need this cell's new state, I'm going to get a new state based on this state and its neighbors. So what are its neighbors? That's up to us to define. It could be its left neighbor, its right neighbor, only its neighbors to its left. But in The Game of Life system, its neighborhood area are the eight cells surrounding it. So it's this 3 by 3 area, 1, 2, 3, 4, 5, 6, 7, 8. So I need to evaluate all of those cells and decide whether it should stay as the 0 or turn into a 1. And the reason why it's called The Game of Life is the rules. The rules for how we move from one generation to another resembles some type of biological process that you might think about, population or bacterial growth. And the idea is that a cell that is surrounded by neighbors that aren't alive cannot stay alive. A cell surrounded by neighbors that are alive can come to life or stay alive. And a cell that's surrounded by too many neighbors cannot stay alive due to overpopulation. And we can go back to the Wikipedia page and read those rules precisely right here. So any live cell with fewer than two neighbors dies, as if caused by underpopulation. Any live cell with two or three neighbors lives onto the next generation. Any cell with more than three neighbors dies by overpopulation. And any dead cell with exactly three live neighbors becomes a live cell. So this is written as if by reproduction. So this is written in somewhat of a confusing way. I think I could simplify this, I think. We could say let's say the cell is dead. It's a 0. It's only going to change to a 1 if it has three live neighbors. Then it changes to a 1. Otherwise, it stays a 0. A 1 is going to stay a 1 unless it has less than two, less than two live and greater than three live. Then it dies. So birth, reproduction, happens with exactly three neighbors. Death happens with fewer than 2 or greater than 3. Now, I don't know if I got those numbers right. Let's go check the Wikipedia page again. [FANFARE] Thank you, thank you, I hit the sound effect by accident. Live cell with fewer than two live neighbors dies. Yes, less than two dies. Live cell with two or three neighbors lives. I don't care about that. I'm not going to kind of not care about change that it stays the same. I can kind of ignore that. Live cell with more than three neighbors dies. Yep, that's what I've got over there. And then, any dead cell with exactly three live neighbors becomes alive. OK, so I've got those rules correct. So now, what do I need? You're over there. I'm going to go back over here. I need something. I need a all I need to make this program work is a data structure to store this grid. And this is where I'm having a bit of a headache. I'm really not sure what to do. The way that I've always done this in previous examples is by using something called a two dimensional array. I think I have a video tutorial about that somewhere, which I will link to in this video's description. But two dimensional arrays are kind of not so much fun in JavaScript. They can become a little bit weird. And there really is no such thing as a twodimensional array. A twodimensional array is a construct of our own human mind, saying it's really just an array of arrays, which makes sense. This is an array. Each row is an array. And then the grid is an array of rows. Or each column is an array. And the grid is an array of columns. So I think I'm going to do it that way with the twodimensional array. I just should say that it's a little bit awkward, twodimensional arrays in JavaScript. But I'm going to go ahead anyway. So the first thing that I want to do in this program is just make a twodimensional array that stores a random collection of 0s and 1s. So let's go to that. I'm going to go to the code. And you know what I'm going to do? I'm going to actually just write a function. I'm having weird deja vu. I probably did this in another video somewhere. I'm going to just write a function called make2Darray. And I want a certain number of columns and rows. Because that way, I can just say, I can have a global variable called the grid. I'll call it grid. And I could just say grid equals make2Darray. And I could say, I want a 10 by 10 grid. So this is kind of what I want to do. I'm going to just farm out the making of the array to another function. And now I do remember doing this. Because I'm going to write this in a kind of oh, there's a whole coding challenge or video. I'm going to do this in kind of horrific way and then everyone's going to give me all these like amazing ES6 JavaScript fancy ways of doing this whole function in one line of code. Someday, I'll come back and do that. OK, so now, let me see here. So what I need to do first is I need to have some sort of array. And it's going to be this is always where I get confused, too. Do I want the columns the point of using a 2D array is that eventually at some point I would be able to say something like, grid know index 2, index 3. And I guess I usually think of this as x and y and x being the columns. So I want this, the outer array, if I think about arrays of arrays, to be every single column, every single no, no, that's x is column. And then the y is every single row. So I'm going to do that. So I'm going to make a new array of columns. And then, I am going to say for let i equal 0, i is less than that arr.length, i plus plus. Make array index i is a new array of rows. Again, I know there are all sorts of shorter and fancier automatic functions for generating and configuring arrays, like fill, and map, and reduce, and all that kind of stuff, even more. So I'm going to do this. And then I am going to what I want to do here now is also want to fill them with I guess I could fill with values down here. So maybe I won't. Maybe I'll actually just do that. So this is going to make me an empty 2D array with nothing in it. And then I think what I want is I probably want to have these global variables. I know this is a little bit goofy that I'm doing this. And then what I'm going to do, I could make an and I'm going to say let i equal 0. i is less than columns, i plus plus. And then I'm going to do j is less than 0. j is less than rows. I'm going to do a nested loop. So that I can say grid i j equals floor random 2. This is going to give me a nested loop. This is a nested loop. So I make this sort of 2D array structure that's empty. And then I integrate over every single column in every single row. And I fill each one with a random number, 0 or 1. And I'm just now I'm going to run this. And I'm going to go back to I'm going to go to my code. OK, cannot read property 0 of undefined. Well, you know it would be nice? If I actually returned that array. So the make 2D function array, it's making this array. It's also got to return it. So that I can get it back here. And then now, if I look at grid, I'm going to see, it's an array of arrays. And I forgot, there's this wonderful thing you can do, console.table grid, which shows me. Now I can see it here. So we can see this is that twodimensional array. That's what it looks like. It's a twodimensional array with rows and columns, filled with 0s and 1s. So Step one is finished. Now, what I need to do is I need some mechanism to, every frame of animation, iterate over every single spot and set a new spot. Actually, you know what I need to do first? I need to render this thing. I want to be able to see it as a grid of red and blue squares, or black and white squares, or 0s and 1s on the screen. There's any number of ways you could render this. I'm going to do it in the traditional way of a grid, the square, the cell of the grid is black. If the value of 0, is white with a value of 1, or vice versa. OK, what I want to do now is I'm going to add a draw function. And I'm going to be using this loop over and over again. I'm going to add this loop. Because I'm always going to any time I want to look at everything, I'm going to go through all the columns and all the rows. It's been pointed out in the chat that there are some JavaScript libraries and packages that manage grid systems and neighbors for you. Would be great to use those. I'm going to just do it all without that right now, just to kind of figure it out. I'm going to say background 0. And I'm going to create a canvas. I think, to make my life easier for the moment, I'm going to make the canvas also a square. And then what I need to do is I need to draw I want to draw a rectangle at an x and y with some width and height. And it's going to they're going to be squares, so some width and width. And that value is going to be the width of the I should probably calculate the number of columns and rows. Here's the thing. I'm going to redo the way that I'm doing this. So I'm not going to actually have a fixed number of columns and rows. I'm actually going to do like a scale. I'm going to just have a variable called resolution. And say that's 10, or 40. I'm going to say that's 40. So that'll be 10 by 10. And what I'm going to do is I'm going to say columns equals the width of the canvas divided by resolution. Rows equals the height of the canvas divided by resolution. This way, I can kind of dynamically you'll see what I can dynamically make a 2D array based on how big I want the squares to be. So the columns and rows are being calculated based on how big I want the squares to be and the canvas size. And then I have that global variable resolution, which is probably too long of a name, which I can just use down here. And now, x equals i times resolution and y equals j times resolution. And I'm going to now say if grid i j equals 1, fill 255. And you know what, since I made the background 0, I can actually, in this case, I can just draw white rectangles only for the values of 1. So let's see, I probably got something wrong here. But let's try to run this. No, I didn't. So we can see there we go. There's some goofiness, oh, it's sort of like my math is a little off. And what's this weird nonsense over here, flickering? I kind of feel the need to fix that. And the other thing that I can do that this is going to help is if I make this 600 by 400, and I make this 20, it still works. Now, this is driving me crazy. I think what I want to do is there's an issue with the stroke. So I could say, I could also say stroke 255. And then I'm getting something like this. But I don't know, design wise, I'm not going to worry about that too much. Actually, I kind of like being able to see the grid. So let me actually put in stroke 0. And then I'm going to do something kind of goofy, which is, I think if I say just draw all the rectangles one pixel less, I think I'm going to get the look that I want. Yeah, so whatever, there's countless ways I could deal with this. But now I have the grid. I have all the cells. So now it's up to me to simply implement these rules. I need to, for every single cell, count the number of live neighbors, look at its own state, and have these rules play out. Here's the thing, this is really important. While I'm checking each cell, I check this cell first, let's say, I cannot change its value and then go on and check the next cell. Because the next cell's new state should not be dependent on this cell's new state, but its previous state. And if I change the state, I have lost its old state. So this is where what I actually need is I need two twodimensional arrays. One is the sort of old one. And one is the new one. Now, probably the simplest thing for me to do is just make a new one every frame. That's sort of like, in some ways, a bad idea in terms of memory management. And if you look at my processing example that I referenced at the beginning of this video, what I actually do in that example is I just have two different arrays. I have an old one and then I have a new one. Then the new one is then the old one. And I write the new one over here. I just keep swapping them. So I could maybe add that in at some point during this video. But for right now, at the beginning of draw, I'm just always going to make a new generation. At the beginning, what I can do here [FANFARE] Why's that keep happening when I press the button to change the camera? At the beginning of draw, I can say let next, for next generation, equal make2Darray columns and rows. Now, I'm going to leave this here for the rendering. And what I'm actually going to do is at the end, what I'm going to do is I'm going to say I guess it doesn't really matter. Do I want to render first? This is like a deep philosophical question. Do I want to compute and then render or render then compute? Kind of could matter in some situations. In this situation doesn't really matter. But the reason why is I'm never going to see the first generation. Because what I want to do is say grid equals next. So basically, the algorithm here is compute next based on grid. Because draw is looping. So I want to compute the next generation based on the grid, make grid that, render. And then compute the next generation based on grid, make grid, render. So I don't know, that's bothering me. I'm going to do this I'm going to do this after. So at least I draw the first one. And I'm going to do some computation for the next frame. OK, so now, what do I need to do once again? Loop through all of these, loop through all of these. Now, what I need to do is count live neighbors. I need to count the number of live neighbors, the neighbors that have 1. So I could do a kind of internal loop here. And that would probably be a smart thing to do. Maybe I will do that. Where basically what I do is I say I have a certain I'm at a certain cell, let me look at the cells between negative 1 and 1, negative 1 and 1, offset from where I am. I could also just do something really silly. Let me do the really silly thing first. I could say let sum equal 0. Then I could say sum plus equal grid i minus 1 j. That would be the neighbor to the so right, if this is i, j, i minus 1, j is there. i minus 1, j minus 1, i, j minus 1, that sort of thing. So if I'm thinking about this, I might add I could manually put in all the neighbors, just add them all up. This is like going around the horn here. Plus i plus 1, j plus 1, i sometimes I like doing ridiculous things like this just to figure this stuff out. Now, I got to go i minus 1, j plus 1. And then what's the last one? i minus 1, j. This should be eight neighbors. This is eight neighbors, 1, 2, 3, 4, oh, wait, 1, 2, 3, 4, 5, 6, 7. What did I forget? i minus 1, j minus 1, i, j minus 1, i plus 1, j minus 1. I forgot to do that whole top row. And then i plus 1, j, i plus 1, j plus 1, i. Yeah, so this should now be eight. 1, 2, 3, 4, 1, 2, 3, 4. I kind of hate that I did this. You're all throwing your tomatoes at your television screen, because of course, you're all watching this on the television screen. So this is the idea. I need to add up all those neighbors. Let's do this in a loop. So another way I could do it is I could say. I have a better idea. Neighbors, I have a better idea, let's write a function to do this, neighbors equals count. I'm going to give it the grid. And I'm going to give it the i and the j. So I'm going to write a function, I'll put it all at the bottom of my code, that receives I'm going to call it count, countNeighbors, let's call it. And it's going to receive some 2D array. And it's going to receive an x and y location. And then what I'm going to do is I'm going to say i equals negative 1, i is less than 2 i plus plus. Then so I'm going to do a little nested loop using i and j around that spot. And I'm going to say let sum equals 0. And then I'm going to say sum plus equals grid i, j. However, here's a problem. I don't want to count myself as a neighbor. So there's a few different ways I could do this. But it's a little bit silly. I'm just going to subtract it at the end. I'll just subtract it out. I could have put an if statement here, ignore it if i equals x and j equals x, but I'm just going to subtract it out at the end. And then I'm going to return that sum. So this is you could see a couple different ways of doing this right now. This is one way to kind of do this. What this is doing is it's saying let me do a little loop around here, negative 1, 0, positive 1, negative 1, 0, positive 1. So let me check this, this, this, and then subtract this out, because I don't really want to count that one. So now, I should be able to I'm going to just delete this. I've now counted all of the neighbors. I've got a big problem. What do I do with the fact that if I'm on the edge, there's no neighbor to the left? If I'm on the bottom, there's no neighbor below. From the top, there's no neighbor to the above. On the right there's no if I'm on the edge, there's no neighbor to the right. So what I could do, there's a bunch of things I could do. I could consider this like an infinite wraparound world, where this neighbor to the right is this. This neighbor to the left is this. I could there's other ways that I could approach it. What I'm going to do is I'm going to leave the edges as fixed values and just not bother to check them. So what I'm going to do here is I am going to I wanted to do, I was going to do this loop like this. You know what? Let's do the wraparound. Do I no, no, no let's do it the simple way first. I was like, oh, I'm just going to add the wraparound code. Because I could add the wraparound code here. But let me maybe I'll leave that as an exercise or do that later. The issue is you know what I really want? I think then the problem is if I change this loop. So I have to I have to treat the edges differently. Oh, so much heartache here. But I can say, what I'm going to do here is I'm going to say, oh this is the drawing. Oh, right, this is the computation. So I'm going to say if i equals 0 or i equals columns minus 1, minus 1, or j equals 0 or j equals rows minus 1, this is all of the edges. Just going to treat them differently. I'm going to say next i j equals grid i j. So I'm just going to keep the same values from before. This is not a great solution. But it's a quick one that I can do right now. So if I'm on an edge, I'm just going to use the same value. Because now, what I can do is say, look at this, my state is grid i j. Now it's time for me to implement those rules. OK if my state is 0, and 3 neighbors are alive, change my state to 1. If state equals 0 and neighbors equals 0, then next i j equals 1. That's rule number one. Not 0, equals 3. Now, what else? If I'm alive and less than 2 or greater than 3, are alive, then change my state to 0. Else if my state is 1 and neighbors is less than 2 or neighbors is greater than 3, and I probably should put a little parentheses around that one, and again, I'm sure there are some nicer ways I could write this in a more concise way. But you can see, this is the rule. If I'm alive, and I have less than 2 or greater than 3 neighbors, then the new state is 0. In all other cases, the next state is just the current is just the current state. So this makes me want to put this up here at the top. So that I can also just use this here. So that's the state. The state, this is the current state. If I'm an edge, just ignore me. I'm the same state. If I'm not an edge, count all the neighbors. Check if I should change my state or say the same. I'm seeing in the chat there's a typo at neighbors in the first if. Thank you, neighbors. What's the chance I've actually finished this? So there we go. I think I have mostly all the code for it. OK, count is not defined. sketch.js, line 55, oh right, because I called it countNeighbors, which is a better name for the function than count. Try that. Cannot read property negative 1 of undefined at countNeighbors. So what is undefined? Oh, no, no, no, no, look at this, this is a big mistake? What was I doing here? This loop negative, this loop, which goes, which is basically a loop for a little subsection, if this is x and y, i is an offset negative 1 to positive 1. j is an offset negative 1 to positive 1. The cells I'm looking at are not i j, but x plus i and y plus j, because I'm just looking relative to where that x, y point is. So that was a big mistake here. This should be x plus i, y plus j. Oh, so close. countNeighbors at draw sketch line 55. Line 55, countNeighbors, wait, whoa, cannot read property negative 1 of undefined. What's undefined? Grid? Neighbors? OK, hold on. Let's look at some stuff here. Or if j 0. Oh, look at this. I just keep going anyway, so this, I really, I need to break out of the loop. So this is really like I'm done. Leave the loop, or continue, or something. I don't know. I'm going to I'm just going to put an elf in here, as much as I hate that. Because I shouldn't be I'm basically doing the edges or the neighbors. Boy this would be much nicer if I just, in this function, add some code to deal with wraparound, which is not going to be that hard to do. So now, it should be good. There we go, the game of life. Now, it looks weird. Because the edges aren't ever changing. But this is actually now the game of life working. I really got to implement this wraparound thing. So let's do that now. Let's fix it so that the edges consider the other sides as neighbors. So how do I do that? Well, one way to do that is with something called modulus. This is really, this is great. And I can refer you to Golan Levin's guest tutorial video on modulus, which was made as part of this channel. So I will link to that. But basically what I'm saying here is if I have 10 columns, 0 through 9, what could and I'm always looking for the neighbor plus 1. So 0 plus 1 is 1, 1 plus 1 is 2, et cetera, et cetera, et cetera. 9 plus 1 is 10. But I want the neighbor to be 0. Well, guess what? 9 plus 1 modulus 10 equals 0, because modulus is the operator gives you the remainder of division. 10 divided by 10 is one remainder 0. So I encourage you to watch that modulus video, if you're not familiar with modulus. So this will actually work, almost, getting closer, if I say, I'm going to just say, I'm going to have a new I need a new variable name for x plus i I guess I could say column. I don't column. And I'm going to say x plus i modulus columns. And row equals y plus j modulus rows. So this gets me close. It doesn't get me all the way there. But it gets me close. So now I'm adding it up like this. And I'm going to get rid of this whole edges thing, because no longer. So I've got to get this Now, I'm going to have an error here. Right, I'm still getting an out of bounds area, because I'm going to negative 1. Why? Because what if in the case of i equal negative 1? So what if if i is 0, so let me come to the console here. 10 modulus 10 is 0. But let's say I'm looking for the left neighbors. So I'm going through negative 1, negative 1 modulus 10 is negative 1. But I need that to be 9. I need negative 1 to the 9. Well guess what? If I actually just add the number of columns to everything, if I'm actually working with the numbers, instead of the number 0 through 9, the numbers 10 through 19, 10 minus 1 is 9, modulus 10 is 9. So the formula is negative 1 is negative 1 plus the number of columns modulus the number of columns. Oh but there's not 10. There's different numbers in my system. So let's try to confirm this again. The idea is that I have an x and a y point. So that point might be, let's say if it's on an edge, for example, might be like 0, it's on the left edge, might be something like 0, whatever the y is, 5. So this is the x value. And I want to take x plus i plus the number of columns modulus the number of columns. I said it was going to be simple. But it's kind of. It's really kind of a crazy thing to do. But you might write this out, practice it a bit on your own. It will make sense to you eventually. So when this is going to work, basically, let's say, i is going to be the values negative 1, 0, and 1. x is going to be the values 0 through 9 if I'm thinking about all the possible, all the possible columns. So let's just take 0 and negative 1, for example. 0 minus 1 plus, and in this case, I have 10 columns, plus 10 modulus 10 is actually 9 modulus 10, which equals 9. So 0 negative 1, to the left of it, that wraps it around to get the neighbor on the right. Doesn't work for just any arbitrary thing in the middle. If I take i to be 3 sorry, if I take, sorry, x to be 3, 3 minus 1 plus 10 modulus 10. well see how this 10 and 10 kind of cancels itself out? Can you see that? Am I off the whiteboard? I'm close to being off the whiteboard. That equals 2. Because this is 12 modulus 10 is 2. So this actually works. And then what if I'm on the edge? If I'm at 9, right, if x is 9, 9 plus 1 is 10, plus the number of columns is 10, is 20, modulus columns, 20 divided by 10 is 2 remainder 0, so 9 to the right gets neighbors 0. So this is kind of goofy. It shifts everything over, so it can kind of look across the edge. So this is going to work. You can believe me or not believe me. But it's going to work. And I'm going to put this in. So now what I want is x plus i plus columns, modulus columns, y plus j plus rows modulus rows, add those all up. And the game of life. [FANFARE] Thank you, thank you for watching this coding challenge. Thank you, thank you. So let's try and make let's try doing a couple of things, just to get a little further here. I don't know, no, I'm not going to you do all the next stuff. I'm just curious let me make the resolution 10, so we can see that's with a 10. So we can see it's running pretty fast in the browser. I have a pretty low resolution. So here's what you should do now. I'm going to stop. This is a perfect opportunity for people watching this video to make some variations. Some things you can think about. Well, one thing is what if you make each one of these cells an object? So its state might not actually just be it can keep track of more than just its state 0 or 1. It could keep track of whether it's changed state, or stayed the same, or how long it stayed the same. What if you visualize those? What if you visualize with different colors based on the history of the system? What if you allow a user to draw with the mouse, set cells on? What if you look up some of these repeating, special repeating patterns that you can create certain kinds of patterns? What if you you're going to think of more. And what if you did the edges in a different way? What if you used a floating point numbers instead of 0s and 1s and did an average or something? There are so many ways you can create a system, lowering the resolution. What if you drew didn't draw squares, but circles, used images. How can you visualize this system? How can you change the rules or how can you visualize the system in a different way to create a piece of art or for some other purpose? I look forward to share what you make in the comments. There will be the code link from here and a Read Me where you can submit your versions. And I'll come back in a future livestream. I'll share some of the community made versions. Run this again. There's one other thing. But I do think that making cell objects is a path. Right now, I just have oh, and you should probably do the swapping thing. Maybe that's one other thing you could do is maybe don't make a new 2D array every time. But what I'm thinking about here is what if instead of each one of these being a random value, you said something like new cell, i, j. And this cell object can animate. It can move around. The cells could move, they could grow, they could shrink. They could keep track of their history. There's so many possibilities there if you make an object for the cell. OK, Thanks for watching. I hope you enjoyed this coding challenge and you share with me what you make. Goodbye. [MUSIC PLAYING]
