With timestamps:

00:00 - It's frozen.
00:01 - No.
00:01 - No.
00:02 - No.
00:02 - No, wait.
00:03 - Please, I don't want
to lose all my code.
00:04 - [SOMBER MUSIC]
00:06 - Oh, god.
00:07 - [MUSIC PLAYING]
00:12 - Hi, everyone.
00:13 - It's Pi Day.
00:14 - I've been making videos
to celebrate the number
00:16 - pi on March 14 for quite
a number of years now.
00:19 - Typically, I'll
do something where
00:21 - I'm trying to approximate
the number of pi,
00:24 - or even do some kind
of visualization
00:26 - of the digits of pi itself.
00:29 - This year, I'd like
to just celebrate
00:31 - the circle for Pi Day.
00:34 - I've been working very hard on
the new version of The Nature
00:39 - of Code book, published
by No Starch Press,
00:42 - coming out this summer.
00:43 - Pre-order today.
00:44 - Read the whole thing online
today for free as well.
00:48 - And my coding challenges in
2024 have been extensions
00:53 - of topics in that book.
00:55 - So I thought for
today I'd like to take
00:58 - a look at a particular fractal
pattern called the Apollonian
01:02 - gasket.
01:03 - When I first saw this,
I thought, great,
01:05 - this could be a nice extension,
exercise, additional example
01:09 - for chapter 7 in The Nature Of
Code book, all about fractals.
01:12 - It'll be easy.
01:13 - See now, you draw a circle in
P5 and do a little recursion.
01:16 - You put some other circles.
01:17 - I've also done videos on
circle packing before.
01:20 - Easy peasy, lemon squeezy.
01:22 - No problem.
01:23 - I like to not try to do
too much before I come here
01:26 - and record the coding challenge.
01:28 - But you know, I should do a
little reading, reading up
01:31 - on what the
Apollonian gasket is,
01:33 - its history, what's
the math behind it.
01:36 - There's a wonderful article
here by Dana Mackenzie
01:39 - in American Scientist that
was a terrific reference.
01:43 - This set of blog posts
from the Math Less Traveled
01:47 - from 2016 on the Apollonian
gasket was very helpful.
01:52 - I wandered into this paper
called Beyond the Descartes
01:55 - Circle theorem.
01:57 - And then I started to realize--
02:00 - oh, no-- oh, no--
02:03 - this is going to be a lot
harder than I thought.
02:06 - But guess what?
02:07 - Bonus for you.
02:09 - In this video, you will learn
about not just the position
02:12 - and radius of a
circle, but something
02:14 - called the curvature
or the bend and how
02:17 - that relates to something
called the Descartes theorem.
02:21 - And then I might even wander
into using the Descartes
02:25 - theorem, but applying
it not just with numbers
02:28 - but with complex numbers,
imaginary numbers.
02:31 - And so we're going to have to
solve/use the complex number
02:36 - Descartes theorem.
02:37 - This is probably going
to go off the rails.
02:40 - But if I can make that
Apollonian gasket fractal,
02:44 - hopefully you'll have learned
something new about math.
02:47 - And you might be inspired to
make your own artistic version
02:50 - of this fractal,
varying it with color
02:52 - or some other kind of shape, or
tweaking the algorithm however
02:54 - you want.
02:55 - And muah, won't that be
a wonderful celebration
02:58 - of Pi Day.
02:59 - Strangely enough, this all
begins with a poem, a poem
03:04 - by Frederick Soddy, an English
radiochemist who won the Nobel
03:09 - Prize for chemistry in 1921.
03:12 - Frederick Soddy was
fascinated with something
03:15 - called Apollonius' problem,
named for Apollonius of Perga,
03:20 - the Greek astronomer.
03:21 - Let's say you have three
circles, any three circles,
03:26 - non-overlapping.
03:29 - How could you find
a fourth circle
03:33 - that is tangent to all
three of these circles?
03:37 - Two circles are tangent if
they meet at a single point
03:41 - along their edges.
03:44 - And that tangent can
be expressed as a line.
03:47 - This is actually referred
to as a kissing circle
03:51 - because they're like,
[KISSING SOUNDS]
03:52 - I love you circle.
03:54 - And there typically
isn't just one solution
03:57 - to the Apollonian problem.
03:58 - Let me try to draw one in here.
04:01 - No I can't.
04:02 - I'm not really drawing
this correctly,
04:04 - but you get the idea.
04:05 - Maybe I could also--
04:06 - could I get a circle
that kind of like--
04:10 - This is also tangent to
this circle, this circle,
04:15 - and this circle.
04:16 - The solution to this
problem lies in something
04:19 - called Descartes' theorem.
04:24 - Soddy rediscovered Descartes'
theorem independently in 1936.
04:29 - Found it so beautiful, he
wrote an entire poem about it.
04:33 - The Kiss Precise.
04:35 - For pairs of lips to kiss
maybe involves no trigonometry.
04:41 - 'Tis not so when four circles
kiss, each one the other three.
04:46 - To bring this off the four
must be as three in one or one
04:51 - in three.
04:52 - Since zeros bend's a dead
straight line and concave bends
04:57 - have minus sign, the sum of
the squares of all four bends
05:02 - is half the square of their sum.
05:05 - Kiss the other four the square
of the sum of all five bends
05:10 - is thrice the sum
of their squares.
05:16 - So the problem of Apollonius
is for any three circles.
05:20 - But Descartes's theorem, and
as it relates to the Apollonian
05:24 - gasket, is actually
a problem that's
05:26 - for a more specific scenario,
where the original three
05:30 - circles are mutually tangent.
05:34 - I'm going to begin by drawing
a kind of classic example
05:36 - of three mutually tangent
circles that is symmetrical.
05:40 - And this is going
to be terrible,
05:41 - but I'm going to do my best.
05:45 - The first thing that I need to
define for Descartes' theorem
05:49 - is this idea of the
curvature of a circle.
05:54 - Now the curvature is the
inverse of the radius.
05:58 - A smaller circle is going to
have a much tighter curvature,
06:02 - whereas a bigger circle has
a much wider curvature to it.
06:06 - So curvature,
typically written as K,
06:10 - is equal to 1 divided by
the radius, and vice versa.
06:15 - The radius is equal to 1
divided by the curvature.
06:18 - Now the curvature,
however, is signed.
06:22 - It can be positive or negative.
06:25 - The radius, of course,
is always positive.
06:28 - So we might say, the radius
is equal to the absolute value
06:33 - of 1 over the curvature.
06:35 - Now what makes the curvature
positive or negative?
06:38 - I mean, all the circles,
they bend the same direction.
06:41 - Well, this particular circle,
which is an outer circle--
06:46 - it is enclosing
these two circles--
06:49 - has a negative curvature,
whereas these two circles here
06:54 - have a positive curvature.
06:58 - If I were to draw three
mutually tangent circles where
07:02 - none of them enclose each
other, they would all
07:04 - have a positive curvature.
07:07 - Here are three mutually
tangent circles,
07:10 - all with a positive curvature.
07:13 - So what is Descartes' theorem?
07:15 - And how does it relate
to the Apollonian gasket?
07:19 - The process for drawing
the Apollonian gasket
07:22 - is to start with your three
mutually tangent circles
07:27 - and find their fourth,
the kissing circle.
07:31 - What is the fourth
circle that is mutually
07:34 - tangent to all three of these?
07:36 - Well, once again, there's
more than one possibility.
07:40 - Now if I found
those two, what if I
07:44 - took all the triplets that
are available to me here
07:48 - and found the fourth
mutually tangent circle that
07:51 - goes with those?
07:53 - Maybe I'd find one here, and
here, and here, and here.
07:58 - And then I might find one here,
and here, and here, and here.
08:04 - So I've done a rather poor
job at drawing the Apollonian
08:08 - gasket.
08:09 - But you see how
you are recursively
08:11 - finding the next circle
and the next circle that
08:14 - is mutually tangent to
triplets, the triplets
08:18 - that you're creating through
this recursive process.
08:20 - Descartes' theorem is
expressed in the poem
08:23 - as the sum of the
squares of all four bends
08:27 - is half the square of their sum.
08:32 - So if this is
circle 1, 2, 3, how
08:37 - do I find circle 4
that's inside there?
08:42 - The sum of the squares
of all the bends
08:49 - is equal to 1/2 of the
square of the sums.
08:56 - So if I could somehow
take this equation,
08:59 - knowing the curvature
for circles 1, 2, and 3,
09:05 - could I solve for curvature 4?
09:08 - K4 equals what?
09:11 - This is a quadratic equation.
09:13 - It can be solved.
09:14 - It will, as you see,
have multiple solutions.
09:17 - I'm not going to
derive the solution.
09:19 - But I will put a
reference-- hopefully
09:22 - I can find one-- that shows
the derivation of the solution.
09:25 - Let me show you what it is.
09:27 - Curvature 1 plus curvature 2
plus curvature 3 plus or minus
09:33 - multiple solutions the square
root of K1 times K2 plus K2
09:40 - times K3 plus K1 times K3.
09:44 - No more question mark.
09:46 - So this is now something
we can actually
09:50 - start to implement in our code.
09:53 - Whoops, I forgot
about the 1/2 here.
09:56 - So plus or minus 2 times the
square root of this summation.
10:02 - How long has it been
in this video and I
10:03 - haven't written any code yet?
10:05 - Don't worry.
10:06 - Now's the time.
10:07 - The first thing that
I want to do for this
10:09 - is create a circle class.
10:11 - The circle class will hold on
to the position of the circle,
10:14 - its radius, and its curvature.
10:20 - So if I'm giving it a bend, its
radius is the inverse of that,
10:25 - or the absolute value
of the inverse of that.
10:28 - Let's write a function
for the circle
10:30 - to draw itself, make sure
I add it to the HTML file.
10:37 - And let's create three circles.
10:40 - What should their curvatures be?
10:43 - Well, on this diagram of
the Apollonian gasket,
10:46 - this is one of my circles,
this is one of my circles,
10:50 - and the big circle
is one of my circles.
10:53 - So if the radius of this
circle was something like 200,
10:57 - the curvature would
be 1 divided by 200.
11:00 - But remember, the
outer one is negative.
11:03 - And then the inner
ones would have
11:04 - a curvature of 1 divided by
100, 1 divided by 100 if they're
11:08 - half and they're positive.
11:10 - So the curvature is
negative 1 divided by 200.
11:14 - And it's x, y is at 200, 200.
11:16 - And I'm just hard
coding this now.
11:18 - Later, it's my goal to create
a random arrangement of three
11:22 - mutually tangent circles.
11:24 - We'll see how well that goes.
11:26 - But I'm just going to hard
code an initial location that
11:28 - is kind of a classic version
of the Apollonian gasket.
11:36 - Where are those circles?
11:38 - Oh, I have the
background in draw.
11:41 - Let's get rid of that.
11:43 - There we go.
11:44 - There are those three circles.
11:46 - Now let's see if I can
write a function that
11:50 - will calculate that fourth
curvature, passing in the three
11:55 - circles.
11:58 - And eventually I
might want to work
11:59 - with arrays and kind of store
the circles in different ways.
12:02 - But this should be good
enough to get me started.
12:04 - Now it's time for me to take
that formula on the whiteboard
12:07 - and implement it here.
12:09 - So first, let's get K1, K2, K3.
12:15 - Let's divide the
formula into two parts.
12:18 - First, the sum.
12:21 - Let's call the second part--
12:23 - I don't know-- the
root because it's
12:25 - the square root of the products
of the different curvatures.
12:31 - And I need to multiply it by 2.
12:33 - And now I need to return the
sum plus or minus the root.
12:38 - How do I return a
value plus or minus?
12:40 - Well, I could just
return both values.
12:43 - Let's at least see if
the radius that I'm
12:47 - getting back from
the function is
12:49 - approximately the right side.
12:50 - I mean, the really
complicated part here,
12:52 - that I'm going to
get to soon enough,
12:54 - is to figure out
where the circle goes.
12:57 - But for right now, all I need
to do is check the radius.
13:00 - So radius 4 is
the absolute value
13:03 - of 1 divided by the
fourth curvature.
13:06 - And if I were to just
draw a circle at mouse x,
13:09 - mouse y with radius 4 times 2--
13:12 - and I guess I need to
put this into draw.
13:17 - And these circles will need
to be global variables.
13:24 - What am I missing here?
13:27 - Not a number.
13:30 - Oh, right, of course.
13:33 - I've got to pick one of them.
13:34 - I went through this
whole thing about how
13:36 - I'm returning two values.
13:37 - And I need to have two r4s.
13:40 - So r4 could be--
13:42 - let's just pick 0.
13:43 - Let's just pick
that first value.
13:45 - And we can see, does
this circle fit there?
13:47 - Look, it fits there.
13:49 - So I definitely got
the radius right.
13:50 - Let's look at the second value.
13:53 - Second value is also the same.
13:55 - So that's good to see
that I'm getting both.
13:59 - The correct values,
probably one is
14:01 - going to go down here somehow.
14:03 - And one is going to go up here.
14:06 - So if I have a function--
it's called Descartes here--
14:08 - and it returns the curvature
for all possible fourth circles,
14:14 - all I need next
is a function that
14:18 - returns the position
of that fourth circle
14:21 - or all possible fourth circles.
14:23 - This is where things get
a little bit extra hairy.
14:27 - The solution to finding the
centers of those circles
14:31 - is in this paper Beyond the
Descartes Circle theorem.
14:36 - Right here at the
beginning, you can
14:37 - see how the authors are
referencing the Descartes
14:40 - theorem.
14:41 - The bends, the curvatures,
satisfy the relationship
14:45 - where the sum squared equals 2
times the sum of the squares.
14:50 - In this paper, they
show if you take
14:53 - the centers of those
circles, express them
14:57 - as complex numbers, they also
have the same relationship,
15:03 - essentially yielding what could
be called the complex Descartes
15:08 - theorem.
15:09 - Now I'm not going to
prove this or derive this.
15:12 - If you want to go
deeper into the math,
15:14 - this paper will
have that for you.
15:16 - But let me just explain to
you what a complex number is
15:20 - and how I can take
the Descartes theorem
15:24 - and solve for an x-y pair
instead of a single curvature
15:29 - value.
15:30 - A complex number
is a number that
15:32 - has a real component and
an imaginary component.
15:36 - What do I mean by imaginary?
15:38 - Well, hold that thought.
15:39 - It's written in
the form a plus bi.
15:44 - And "i," like imaginary,
is a representation
15:48 - of the square root
of negative 1.
15:52 - Now the last time I probably
referenced complex numbers was
15:56 - maybe in my Mandelbrot set
coding challenge or perhaps
16:00 - the Julia set coding challenge.
16:02 - And remember how I
was really in love
16:04 - with talking about
imaginary numbers
16:06 - and playing around with the
idea of them being imaginary.
16:08 - But it's a little
bit of a misnomer.
16:11 - This is very much a
number, a kind of number
16:15 - incredibly important
in all sorts
16:18 - of applications of mathematics.
16:20 - And it is necessary when
solving certain kinds
16:26 - of polynomial
equations, especially
16:29 - if you've got something like
x squared equals negative 1.
16:33 - How do we express the solution
for an equation like that?
16:37 - What is kind of magical here
is because a complex number
16:42 - has two components, A and bi.
16:46 - This a and this b can
be mapped to what's
16:50 - called the complex plane.
16:53 - This might be a-axis.
16:55 - This might be the b-axis.
16:57 - So if I put a point over here,
maybe it's the point 5 plus 4i.
17:05 - Well, this might look
kind of similar to you.
17:08 - I mean, aren't we
in a p5 canvas?
17:11 - And maybe I have
this point here,
17:14 - which is the x-y
point, 200, 200.
17:18 - Why not express that
as a complex number
17:21 - where x is the real
component and y
17:25 - is the imaginary component?
17:26 - So this point could be
expressed as 200 plus 200 i.
17:33 - So this is the
Descartes theorem,
17:37 - which expresses the relationship
between the curvatures of four
17:42 - mutually tangent circles.
17:43 - Well, it so happens, if I
think of the centers of all
17:49 - of those circles expressed
as a complex number--
17:53 - maybe I'll call
them z1, z2, z3, z4,
17:58 - each of these being of the
format x plus yi, x plus yi.
18:05 - This would be x1 plus
y1i, x2 plus y2i.
18:08 - The same equation applies if
I take those complex numbers
18:14 - and multiply them
with the bends.
18:17 - So in other words, the product
of the bends and the centers
18:21 - satisfy this exact equation.
18:24 - Let me try to write this out.
18:26 - Z1 squared times K1 squared.
18:37 - This is the new equation.
18:38 - So what's known?
18:40 - I know z1, z2, z3.
18:44 - I know all of the curvatures.
18:46 - I even know k4 because
I was able to solve
18:49 - for the fourth curvature through
the regular, old-fashioned
18:52 - Descartes theorem.
18:53 - So now all I need to
do is somehow solve
18:57 - this equation for z4.
19:00 - Again, not going to
derive the solution.
19:03 - I'm just going to
write it out for you.
19:05 - Here we go.
19:07 - I just spent some time
staring at the Wikipedia page.
19:10 - We'll see if I remember it.
19:11 - z4 equals the sum of the
bends times the circle
19:18 - centers plus or minus the square
root of the products of all
19:27 - that stuff, like before.
19:29 - [LAUGHS] I got to
go look at it again.
19:31 - The curvatures times the
centers plus the curve--
19:35 - all the configurations.
19:37 - Plus or minus 2 times the
square root of z1k1 times z2k2.
19:44 - I'm just going to write it
this way k1 times k2 times
19:47 - z1 times z2 plus--
19:50 - oh, no, I'm going
to run out of room--
19:53 - plus k2k3.
19:59 - Oh, no, no plus there.
20:00 - These are all multiplied.
20:02 - Then the whole thing divided
by the fourth curvature
20:08 - because, remember, we're kind
of solving for what's over here.
20:11 - So this whole thing
divided by k4.
20:15 - So all we got to do is put
this formula into our code.
20:21 - Easy peasy, lemon squeezy.
20:24 - We've got a bit of
a problem, though.
20:26 - Look at my beautiful function
for the Descartes theorem.
20:30 - It uses the plus operator,
and the multiply operator,
20:34 - and the minus operator, because
I'm just taking a number
20:38 - and multiplying it by a
number, and another number,
20:40 - and adding it to a number.
20:41 - You can't do that so easily
with complex numbers.
20:45 - In fact, I'm using the
square root operator.
20:50 - How do you take the square
root of a complex number?
20:53 - This is going to
require at least 5
20:56 - to 10 minutes of this video,
just to implement that math.
20:59 - And the way that
I'm going to do it
21:01 - is much like there's a
p5 vector class in p5,
21:06 - which stores an x
and a y and performs
21:08 - all sorts of vector math.
21:10 - I'm going to create a
complex number class.
21:12 - And I'm sure I could
use one-- like get one
21:14 - from some JavaScript library.
21:16 - But I think it's
worth just quickly,
21:18 - "quickly" implementing my own.
21:25 - So this is the core idea
of a complex number.
21:28 - I need to have both
the real component
21:31 - and the imaginary
component, a and b.
21:33 - The first thing that I might
do is write an Add function.
21:37 - And I think what
I'll do for ease
21:38 - is every single
one of my functions
21:40 - will return a new
object instance.
21:43 - So let's start with
the Add function.
21:45 - That's the easiest one.
21:47 - And I'll use the word "other"
for another complex number.
21:51 - So what do I need to do?
21:52 - Return a new complex
number, which
21:55 - is this dot a plus
other dot a and this
21:59 - dot b plus other dot b.
22:02 - This is adding two
complex numbers together.
22:05 - Let's do a subtract.
22:07 - Let's do a scale, which is
different than multiply.
22:11 - I'll get to that in a second.
22:13 - But let's say I want to just
take a complex number and--
22:16 - I don't know-- multiply it by 2?
22:18 - So I'm scaling it by a value.
22:21 - And that is a new complex
number with this dot a times
22:25 - that value and this
dot b times that value.
22:29 - I'm doing the easy ones first.
22:31 - OK.
22:32 - Let's do multiply.
22:34 - This is where things
get a little bit tricky.
22:36 - And we need to return
back to the whiteboard.
22:38 - Now you might be wondering, why
can't you just use p5 vector?
22:41 - After all, you're
storing a complex number,
22:43 - like you're storing a vector.
22:45 - And p5 vector
already has functions
22:47 - like multiply and add.
22:48 - And this is why.
22:50 - It's this pesky little square
root of negative 1 thing.
22:54 - So let's work out the math.
22:55 - And I've done this before, I
think, in the Mandelbrot video.
22:57 - But let's do it again.
22:59 - A1 plus b1i times a2 plus b2i.
23:07 - This would be multiplying
two complex numbers together.
23:10 - So a1 times a2 plus a1
times b2i plus b1 times a2y.
23:23 - So I'll say a2b1i.
23:27 - Did I say "y" when
I meant to say "i?"
23:29 - And this is b1--
23:31 - oh, this is hard--
23:32 - plus b1b2i squared.
23:37 - Remember, i is the square
root of negative 1.
23:39 - So what's i squared?
23:41 - Negative 1.
23:42 - So this is actually a1a2 minus--
23:47 - this turns into a minus
because I take i squared--
23:52 - minus b1b2 plus-- look at this--
23:57 - a1b2, a2b1i-- a1b2 plus a2b1i.
24:06 - So this is my new
complex number.
24:10 - This is the real component.
24:12 - And this is the
imaginary component.
24:15 - This is how I multiply two
complex numbers together.
24:19 - Now when I go back to
the code, remember,
24:21 - it's not a1, b1, a2, b2.
24:24 - It's this dot a, this dot
b, other dot a, other dot b.
24:29 - Let's see if we can
make that happen.
24:30 - Now let's do multiply other.
24:33 - So let's just say the
a is this dot a times
24:39 - other dot a minus this
dot b times other dot b.
24:45 - And then the b is this dot a
times other dot b plus other
24:57 - dot a times this dot b.
25:00 - Then I'm returning
a new complex number
25:02 - with those a and b values.
25:04 - I have a plus for
complex numbers.
25:07 - I have a scale for
complex numbers,
25:08 - for a complex number
times a scalar.
25:10 - I have a multiply now.
25:12 - I don't have a square root.
25:14 - How do I do the square
root of a complex number?
25:17 - I think that since this
is a video for Pi Day,
25:20 - we should use this
formula because it's
25:24 - taking the complex
number and converting it
25:26 - from rectangular
form to polar form.
25:30 - So the idea here for
taking the square root
25:33 - is if this complex
number, instead
25:37 - of thinking of it
as a comma b, I
25:40 - think of it in its polar form,
where I have some magnitude--
25:44 - I'll call that m--
and some angle--
25:46 - I'll call that theta.
25:47 - Well, if I take this, I
can find the square root
25:51 - by taking the square root of
the magnitude and then half
25:56 - the angle.
25:57 - That works out.
25:59 - So in my code, square root.
26:02 - I first need to convert
the complex number
26:06 - to its polar form.
26:07 - So in that sense, I would
say let m, its magnitude,
26:12 - equal the square root of
a times a plus b times b.
26:16 - Then its angle-- and
this, by the way,
26:17 - is where I could use p5 vector.
26:19 - Its angle is equal to a tan
2, the inverse tangent--
26:24 - this function is beautiful--
26:26 - I've explained it in Chapter
3 of Nature of Code--
26:28 - happy Pi Day, everybody--
26:30 - of b comma a.
26:32 - That would be the angle.
26:34 - Then I need to say,
the new magnitude
26:40 - is the square root
of that magnitude.
26:43 - The new angle is that
angle divided by 2.
26:46 - And then I can just say,
return a new complex number
26:52 - with m times cosine of
that angle, m times sine
26:57 - of that angle, converting it
back to its nonpolar form.
27:03 - If you don't want
to rely on my code,
27:05 - you could use this
Complex.js library,
27:09 - which has a lot of
complex number arithmetic
27:11 - already done and
completed in JavaScript.
27:13 - I should probably be using it.
27:14 - But, you know, I like
to learn this stuff,
27:16 - like get my hands in
as much as possible.
27:18 - Now that I have a fully
functional complex number
27:22 - class, I can adjust
my circle class
27:26 - to store the x-y center
in a complex number.
27:30 - I'll call that center.
27:34 - What broke here?
27:35 - Oh, it's a and b.
27:38 - There we go.
27:38 - OK.
27:39 - I am ready to implement
the complex Descartes
27:44 - function, which
will take in three
27:47 - circles plus the curvature
for the fourth circle
27:52 - and calculate the x-y position
of that fourth circle.
27:59 - And I'll use that
same notation with z.
28:04 - All right.
28:05 - I need the sum and
the root again.
28:09 - But I have to use the
complex number math.
28:13 - And actually, if I'm looking
at this formula, z1 through z3
28:17 - are only ever used
in combination
28:20 - with multiplying it by their
corresponding curvature.
28:25 - I'll call it zk1.
28:26 - So zk1 is equal
to z1 scale by k1.
28:31 - OK, so let's do that.
28:33 - Zk2, zk3.
28:36 - Then the sum is equal
to zk1 add zk2--
28:43 - and I can chain these--
28:45 - add zk3.
28:46 - So this right here should be
now this part of the formula.
28:54 - Next, I want to do this
part of the formula.
28:58 - So the root is equal to
zk1 multiply zk2 add--
29:06 - oh, god-- zk2 multiply
zk3 add zk1 multiply zk3.
29:23 - OK?
29:24 - I think that's right.
29:25 - So this-- I know
it's a little bit
29:27 - hard to look at--
but this should
29:30 - be everything that's in here.
29:33 - Now I just need to take
the square root of that
29:36 - and multiply it by 2.
29:37 - So I should say root
equals root square root.
29:44 - And then I need to
multiply that by 2.
29:47 - And then I need to
get the plus or minus.
29:52 - So I have two options.
29:53 - Remember down here when
life was so simple,
29:56 - I just said some plus
root or some minus root.
29:59 - So those are my two options.
30:01 - I have some add root
or some subtract root.
30:07 - But then I also need to
divide both of those by k4.
30:11 - So that would be, scale
those by 1 divided by k4.
30:15 - These are my two
possible complex numbers.
30:20 - All right.
30:21 - One issue right now is that
k4 is actually two values.
30:26 - So let's pick one of them.
30:29 - I need the center
for the new circle.
30:32 - We'll call that z4, should
equal complexDescartes
30:36 - c1, c2, c3, k4 index 0.
30:41 - So I'm just going
to pick it with one.
30:43 - And then I should be able
to say z4 dot a, z4 dot b.
30:48 - Oh, what's the chance?
30:49 - What's the chance that works?
30:51 - Darn.
30:52 - Oh, well, that needs an s.
30:56 - Oh, this dot.
30:57 - This dot.
30:58 - It's been a while since I
made a good this-dot mistake.
31:03 - OK, I still have
an error down here.
31:06 - OK, console.log z4.
31:09 - Let's see what we got here.
31:10 - oh, because I got two of them.
31:12 - I forgot that I'm getting
two for everything.
31:15 - And let's look at both of them.
31:17 - Let's put in no loop.
31:19 - Not a number, not a number.
31:22 - OK, so something
went wrong somewhere
31:24 - with my complex number math.
31:26 - Probably, this is
a good reason why
31:27 - I should have just used
an existing complex number
31:29 - JavaScript library.
31:31 - But let's see what
I can figure out.
31:33 - Oh, mult, mult. It's scale by 2.
31:36 - It's not multiply by 2.
31:38 - It's scale by 2.
31:40 - There we go.
31:41 - Look.
31:41 - Look.
31:42 - There's a circle
in the right place.
31:44 - I've never been so happy
to see that before.
31:47 - Woo, that was exciting.
31:48 - OK, we're getting somewhere.
31:50 - It was just a simple error.
31:51 - I used multiply instead
of scale because it's
31:53 - scaling by a scalar
not multiplying
31:55 - by a complex number.
31:56 - I really should be now
finding both circles.
32:01 - I guess I could return
two complex numbers.
32:04 - What if I give it k4 that's
an array with two options.
32:09 - And then my complex--
32:11 - oh, my god. oh, but I'm
already getting two back.
32:15 - Wow, so there's actually
four possibilities.
32:17 - Let's just do it twice.
32:19 - So let's get z4.
32:21 - I'll call it z40.
32:23 - And I'm going to send in k4 0.
32:25 - Oh, look at this.
32:26 - Look at this.
32:27 - I had a mistake there.
32:29 - I put a 4 instead of the k4.
32:31 - But now that I'm
realizing it, it
32:33 - would make more sense to
just return all four of them
32:37 - as an array.
32:38 - Let's see.
32:39 - So now I can put this one in
here with add and this one
32:43 - in here.
32:44 - So I can get all
four in this way.
32:48 - So I think this is going
to make more sense,
32:50 - that basically I'm getting the
two components of the formula,
32:54 - the sum and the root.
32:56 - Then I'm going to
plus and minus those.
32:59 - So I have two possibilities.
33:00 - And then divide it by
both k4 0 and k4 1.
33:03 - This is much better because
this is just giving me all four.
33:07 - And now I can actually
just say this.
33:09 - And this is kind of
like all centers.
33:12 - All centers is the result
of the complex Descartes
33:16 - function with all three circles
and both possible bends.
33:20 - And I wonder if what I can
do is like unpack those.
33:25 - I've got an idea.
33:26 - I want it an array
because I'm going to say,
33:28 - let c of allCenters.
33:30 - And then what am I going to do?
33:32 - I'm going to make a new
circle, equals a new circle
33:37 - with k4 index 0.
33:40 - Do I do all the [INAUDIBLE]?
33:42 - I'm so lost here.
33:43 - This isn't going to work.
33:44 - You know what I should do?
33:46 - Let's actually make the circles
in the complex Descartes
33:50 - function because I
need to know which
33:53 - bends go with which circles.
33:55 - So if I go back here.
33:57 - What I'm actually doing
is I have four centers.
34:03 - I'll call those c1.
34:07 - Those are all my centers.
34:10 - Oh, I already used
that variable.
34:12 - OK.
34:13 - Now I need to return an
array of four circles.
34:19 - New Circle k4 0 with
cente1.a, center1.b.
34:27 - So k4 0 goes with
these first two.
34:32 - And these go with one.
34:36 - These are all the possibilities.
34:38 - So now I'm actually
returning the four circles.
34:41 - Where I got them-- now I should
be able to say, allCircles--
34:44 - I could obviously
loop through it.
34:46 - But I just want to look
at them one at a time.
34:48 - 0 dot show.
34:50 - That one.
34:52 - All circles one dot show.
34:54 - That one.
34:55 - Hey, those are the
right two circles.
34:58 - So then-- I don't
want the other two.
35:02 - Oh, that one's maybe
one of the same ones?
35:05 - Oh, actually, maybe I'm fine.
35:06 - They're just duplicates.
35:09 - Good work, everybody.
35:10 - They're duplicates.
35:11 - I think that I am through with
the hardest part of this video,
35:15 - which was all of this math.
35:17 - And now the problem
becomes, once I have the two
35:22 - new circles, I just
need to look at all
35:25 - of the new triplets of three
mutually tangential circles
35:30 - and get the next new circles,
and so on and so forth.
35:35 - This is where the
recursion comes in.
35:37 - This is where I'm more
connected to chapter
35:40 - 7 of The Nature of Code.
35:41 - Now recursion can be done
with a recursive function.
35:45 - And that's what I use in many
of the fractal designs that
35:48 - are outlined in that chapter.
35:50 - What I think I'd like
to do here instead,
35:53 - though, is use an array as
the kind of foundational data
35:57 - structure for the recursion.
35:58 - So if I somehow
had an array acting
36:01 - as like a queue of all
of the possible triplets
36:04 - that I need to evaluate, then
I could run through all those,
36:08 - throw it away, make a new
queue, and keep going.
36:12 - So essentially the
array is the recursion.
36:15 - Everything in the array
will get processed,
36:17 - which will make a new array,
which will get processed,
36:19 - which will make a new array,
which will get processed.
36:21 - So that means, what
I actually want to do
36:24 - is create an array
called allCircles.
36:28 - And I'm going to push these
circles into that array.
36:35 - You know what?
36:36 - I'm going to keep the c1,
c2, and c3 because I'm
36:40 - going to need to make
the queue as well.
36:42 - But I'm going to make
those local variables.
36:44 - So all circles should get
c1, c2, and c3 to start.
36:51 - And then the queue--
36:53 - I need a queue.
36:54 - This is where it's
connected to more to things
36:56 - that I've actually done before.
36:57 - The queue should have in
it all the triplets, which
37:01 - is only this right now.
37:03 - So it's going to be
an array of arrays.
37:05 - And let's just comment
this out for a second.
37:10 - The same math is
going to apply, but I
37:12 - need to figure out how
to process that array.
37:14 - So the first thing
I'll do is just in draw
37:17 - I'm always going to just
show all the circles.
37:20 - Let's get rid of no loop.
37:21 - And let's go from
generation to generation
37:25 - by clicking the mouse.
37:26 - So I'm going to add the
mouse-pressed function.
37:29 - I could use a button or some
other form of interaction
37:31 - or do this automatically,
but I think this
37:33 - will help me figure this out.
37:35 - So what do I want to do
when I click the mouse?
37:37 - I want to process the queue.
37:41 - I'll call it a triplet of queue.
37:43 - So I want to go through every
triplet that's in queue.
37:47 - I'm going to need this.
37:49 - And can I do something like,
say, let c1, c2, c3 equal
37:54 - that triplet?
37:55 - So I would get those three
circles out of the thing that's
37:58 - in the queue.
37:59 - I would calculate k4.
38:02 - Then I would get
all of the circles.
38:06 - I know that this
[INAUDIBLE] allCircles
38:08 - returns four circles.
38:10 - But let's just use the
first circle for a second.
38:13 - Let me think about
what I'm doing.
38:14 - Oh, I don't want to
call this allCircles.
38:16 - NewCircles, this is
called newCircles.
38:19 - And what I want to do is
say like, allCircles push,
38:23 - newCircles 0.
38:25 - So let's just first
put in the new one.
38:28 - So if I click the mouse, I
get that new circle going in.
38:32 - This is good.
38:34 - Now with that new circle,
I need to make a new queue.
38:37 - So I need to have a new queue.
38:39 - Our nextQueue, I'll call
it, is an empty array.
38:43 - And newTriplet is equal to
c1, c2 with new circles 0.
38:54 - Basically, this new
circle is mutually
38:57 - tangent to those first three.
38:58 - So I have three new triplets.
39:01 - I have it with c1 and c2.
39:04 - I have it with c1 and c3.
39:06 - So newTriplet1, newTriplet2.
39:08 - I might not need all
these separate variables.
39:10 - And newTriplet3 is
with the new circle.
39:14 - And c2 and c3.
39:16 - So these are all
the possibilities.
39:18 - And then the queue should get
nextQueue equals nextQueue
39:27 - concatenated with--
39:29 - and let's just call
this t1, t2, and t3.
39:33 - Those are my triplets that I'm
getting from there, t1, t2, t3.
39:37 - And then the queue
should equal next Queue.
39:42 - So again, I'm only doing this
with that first new circle.
39:46 - But in theory, it should
now get that new circle,
39:50 - make all the new triplets.
39:51 - Process them.
39:52 - Process them.
39:54 - Process them.
39:54 - OK, this is working.
39:56 - This is very exciting.
39:57 - One thing I need to do.
39:58 - There's two things I need to do.
39:59 - I need to make sure
that the circles--
40:02 - I mean, they're going
to get infinitely small.
40:04 - First of all, one
thing I can do is
40:05 - I can say-- and let me
hit-- you can already see,
40:08 - it's really slowing down-- for
let newCircle of newCircles.
40:12 - So don't even need
that index anymore.
40:14 - I'm going to do it
with all of them.
40:17 - There we go.
40:18 - For all the new circles,
put them in the array,
40:21 - and make the new triplets,
and add them into the queue.
40:24 - Great.
40:25 - But before I do that, I
need to check some stuff.
40:28 - Like, if newCircle dot
radius is greater than--
40:33 - I'm going to give it a
big number-- like 10.
40:36 - But you can see I'm
getting some bad circles.
40:39 - So I'm pretty sure that--
40:42 - and I don't know exactly
why this is the case.
40:44 - But in all of the possible
combinations of curvatures
40:48 - and centers that I'm getting
out of these equations,
40:51 - not all of them are valid.
40:52 - So I think what I need
to do is check for that,
40:56 - throw away circles
that aren't valid.
40:59 - So let's validate the circles.
41:03 - There's two aspects to
validating the circles.
41:05 - One is a lot of times
these equations will
41:08 - produce the same circle twice.
41:09 - And I don't want to add it
again because that's just
41:11 - going to compound itself.
41:12 - Let me work on that first.
41:14 - Let me write a function
that's like called
41:17 - if validate newCircle.
41:20 - So I'm going to write
this function, function
41:23 - validate and--
41:25 - I'll just call it c for circle.
41:27 - So the first thing I want to do
is check if it already exists.
41:32 - So let's look at the distance
between this circle's center
41:38 - and the other circle's center.
41:42 - If that distance is less
than like 0.1 pixels,
41:47 - that's how I'm going to
know that they're the same.
41:49 - Return false.
41:51 - OK, it's invalid if it's
distance to another circle
41:54 - is too close to it.
41:57 - And we'll just put a
return true at the end.
42:01 - So that's good.
42:02 - You can see this is working.
42:03 - But I'm still getting a
bunch of invalid circles.
42:05 - I need to make sure
that it is actually
42:08 - mutually tangent to c1, c2, c3.
42:12 - So I can actually
add these here.
42:15 - So basically, this
function, first,
42:18 - is going to check to make
sure it doesn't exist already.
42:23 - And I could call it c4.
42:25 - That's really what it is.
42:27 - It's the fourth circle.
42:29 - And now I need to
write a new algorithm.
42:32 - Check if all four circles
are mutually tangential.
42:38 - So how do I know if two
circles are mutually tangent?
42:42 - I think I have an
idea how to do this.
42:44 - OK.
42:45 - There are two ways
for two circles
42:47 - to be tangent to each other.
42:49 - One is for one circle
to be inside another.
42:53 - The other is for them to
be next to each other.
42:57 - Now let's think about the
radii, the two radius values,
43:02 - for each of these scenarios.
43:04 - And I didn't mean for this
to be right in the center.
43:07 - So I'm just going to pretend
the center is over here.
43:09 - So this is r1.
43:10 - And this is r2.
43:12 - This would be r1.
43:14 - And this would be r2 here.
43:16 - Now the important
value is to look
43:18 - at the distance, the distance
between the two circles.
43:22 - So in this case, if they're
tangent to each other,
43:26 - the distance should
equal r1 plus r2.
43:30 - And in this case, the distance
should equal the absolute value
43:35 - of r2 minus r1.
43:38 - Look at that.
43:38 - You can see how--
43:40 - I think I drew this in a weird
way that's making me unsure.
43:45 - And that's the distance.
43:47 - This is r1.
43:49 - That's r2.
43:50 - So if I were to take r1 minus
r2, I would have the distance.
43:56 - That was right.
43:56 - I was right.
43:57 - I just had to look at
it a different way.
43:59 - Now it's going to
be very hard again
44:01 - with this sort of
precision of floating point
44:03 - numbers in JavaScript.
44:04 - Basically, I want to look
at the absolute value
44:06 - of the difference between
d minus r1 plus r2
44:10 - and make sure that's less
than some epsilon value.
44:14 - And the same thing for this.
44:16 - I basically would say d minus
the absolute value of r2 minus
44:21 - r1 and make sure that's less
than some epsilon value.
44:25 - So if either of these is true,
then the circles are tangent.
44:32 - So let's write a function.
44:34 - IsTangent c1 and c2.
44:37 - And I'm basically
saying, first I
44:40 - need to check
difference one is--
44:43 - I should really write a function
inside of the circle class
44:46 - for distance.
44:50 - So now I have a function
here in the circle class
44:53 - that will calculate the
distance between two circles.
44:58 - That makes life much
easier in this code.
45:01 - And I need to do the same thing.
45:03 - The distance equals
c1 distance c2.
45:07 - And r1 equals c1 dot radius.
45:11 - R2 equals dot radius.
45:16 - And I need like
an epsilon value.
45:19 - So now I'm going to say,
return d minus r1 plus r2
45:27 - is less than epsilon, or d minus
the absolute value of r2 minus
45:33 - r1 is less than epsilon.
45:36 - Let's put these as
separate booleans,
45:38 - just because I think it'll make
it easier to read the code.
45:41 - So these are the two booleans
that I need to check.
45:44 - And I'm basically saying, if
either one of these is true,
45:47 - then the circles are
mutually tangent.
45:51 - If isTangent-- this is
a terrible way to do it.
45:54 - But I'm going to
do it right now.
45:56 - If it's not tangent, c4
and c1, return false.
46:02 - And I'm going to do that against
all the other possible ones.
46:06 - And then return true
if I get to the end.
46:09 - I'm not 100% sure about this.
46:10 - So first I'm checking, is it
a circle that already exists?
46:14 - It's invalid, return false.
46:16 - Then if it's not tangent
to those other circles--
46:19 - I don't know where it came from.
46:20 - It's wrong.
46:21 - That one, throw it away.
46:24 - I'm not getting any circles now.
46:25 - Let's just say it's
always going to be true.
46:28 - Every two circles are tangent.
46:31 - Let's now look at this.
46:35 - Is my distance-- let me
check my distance function.
46:38 - Oh, look at this.
46:39 - My distance function is wrong.
46:41 - It's a and b.
46:42 - It's a and b, not x and y.
46:44 - That's how I named my
complex number naming.
46:47 - Oh, so that's not going to give
me results that make any sense.
46:51 - OK.
46:54 - Look at that.
46:55 - Invalid circles are gone.
46:58 - Look, we have the
Apollonian gasket.
47:01 - All right.
47:02 - Before we move on,
one thing I did forget
47:03 - is these distance checks should
really have the absolute value
47:08 - because I could be getting some
weird stray negative numbers.
47:11 - So these should be absolute
value, is less than epsilon.
47:17 - And then here I had
this old calculation
47:20 - for the fourth radius,
which is no longer needed,
47:22 - because the circles
are calculating
47:24 - their own radii in this
new algorithm down here.
47:27 - And also, you can see that
at some point I'm clicking,
47:30 - and it stops.
47:31 - So I'm not getting
any more new circles
47:34 - once I get to a maximum.
47:37 - Or maybe I am.
47:39 - Oh, no, did I just
freeze things?
47:41 - Everybody just hold on.
47:43 - It's frozen.
47:43 - No.
47:44 - No.
47:44 - No.
47:44 - No.
47:44 - Wait.
47:45 - No.
47:46 - No, please, please, I don't
want to lose all my code.
47:48 - Oh, god.
47:49 - Just keep waiting.
47:50 - It's fine.
47:51 - Keep waiting.
47:52 - I mean, I probably had
saved somewhat recently.
47:54 - I had it saved, so
actually I'm fine.
47:57 - Oh, you know what?
47:58 - I didn't check to see
if the circles got
48:01 - too small, below a threshold.
48:02 - Oh, so also, invalidate if
c4 radius is less than 2--
48:10 - let's just stop at two pixels--
48:12 - return false.
48:14 - So that's also an invalid--
48:15 - and actually, let me just
make it 10 just to be sure.
48:21 - Now it stops.
48:22 - Aha.
48:23 - I feel much better
about everything now.
48:26 - So I think I'm actually good.
48:27 - Let's put that at 2.
48:30 - I suppose, yes, there
are arrangements
48:33 - where two circles-- like
if there were a circle that
48:37 - were smaller in the center.
48:39 - So let's check
radiusDiff equals--
48:42 - I mean, there's no reason
not to just check this--
48:46 - c4 dot radius minus
other dot radius.
48:51 - So if the delta, the distance,
is less than epsilon,
48:57 - and the radius difference
is less than epsilon,
49:02 - then they're the same circle.
49:05 - I think now I have a fully
functioning Apollonian gasket
49:10 - algorithm visualization.
49:12 - And the exciting
part is now here,
49:15 - where I believe I should be
able to start with any arbitrary
49:21 - arrangement of three
mutually tangent circles
49:24 - and get a new pattern.
49:27 - How do I get three random
mutually tangent circles?
49:34 - Let's start actually with the
first circle being the larger
49:40 - one.
49:40 - And then now the second circle,
I'll pick a random radius
49:45 - between, let's say, like 20
and c1's radius divided by 2.
49:52 - And then c2 would
be 1 divided by r2.
49:57 - Its position would
be 200 minus--
50:02 - I need to get to the edge of
the circle, which would be
50:05 - c1's radius, plus this new r2.
50:11 - So this is now a random
circle like this.
50:14 - But I would love to position
it at a random vector.
50:17 - So let's use some vector math.
50:19 - And let me get an angle--
50:22 - you know what?
50:23 - I'm going to make a vector.
50:24 - V equals p5 vector random 2D.
50:28 - And v should have the magnitude
of c1's radius minus r2.
50:36 - And then c2 is just at 200 plus
v dot x and 200 plus v dot y.
50:46 - So every time I
do this, I'm going
50:48 - to get a random circle somewhere
tangent to the outside.
50:53 - Now I need to get the other one.
50:55 - So the next radius--
50:59 - I'm just making
this up on the fly.
51:00 - The next radius is
c1's radius minus
51:06 - radius 2, the magnitude of v1.
51:09 - It's actually the
magnitude of that vector.
51:13 - And then where is it positioned?
51:16 - I would basically position
it on the other side.
51:19 - So I would rotate the vector by
pi and then set its magnitude--
51:26 - how far away should it be--
51:28 - by c1's radius minus--
51:32 - Oh, that's the same thing.
51:33 - What if I just rotated it?
51:34 - And then just said, is
this really going to work?
51:38 - The next circle is--
51:39 - no, this doesn't make sense.
51:40 - Something is wrong here.
51:41 - But let's just try it.
51:44 - Oh, and I need to
put it in here.
51:48 - That's kind of right.
51:49 - But it's not in the right place.
51:51 - You can see that's
the right circle.
51:53 - It's just not in
the right place.
51:54 - So where does it go?
51:57 - I need to rotate it.
51:58 - And then it just
needs to go out--
52:01 - I think I need the whiteboard.
52:03 - I have a circle.
52:04 - It's radius is r1.
52:06 - I have another
circle right here.
52:09 - Its radius is r2.
52:11 - And then I made another
circle like this.
52:15 - Its radius is r3.
52:19 - So r1 should equal r2 plus r3.
52:23 - So how do I find
this center point?
52:26 - I just have to go from
wherever this is, r2 plus r3.
52:30 - OK, that's its magnitude,
r2 plus r3, or r1.
52:35 - The vector rotates.
52:37 - And then its magnitude
should be c1 dot radius.
52:42 - Oh, but I'm doing
it from the center.
52:45 - c1 dot radius-- oh, of course--
52:47 - minus r3, of course.
52:49 - There we go.
52:51 - So now I'm always going to get
three mutually tangent circles.
52:57 - Let's pick this one.
52:59 - Oh, no.
53:00 - Where's my gasket?
53:02 - Oh, there we go.
53:05 - I'm trying to figure out
why some starting points,
53:09 - I don't get any circles.
53:11 - So let's try to debug this.
53:14 - Let's see if I can reproduce
arrangement that doesn't work.
53:18 - And I can use
randomSeed to do that.
53:20 - So if I put randomSeed
in setup, and I'll just
53:23 - pick the number 5--
53:24 - well, that one actually works.
53:26 - Let's try the number 4.
53:28 - So with this one--
53:30 - interestingly enough,
it's different each time
53:33 - because my p5 vector--
53:36 - it doesn't really matter.
53:37 - But let's just use from,
Angle random TWO PI.
53:40 - The p5 vector is somehow
not taking my randomSeed.
53:43 - I don't know if that's a bug in
p5 or if I've made a mistake.
53:45 - But now it's going to
be the same every time.
53:47 - Let's console.log k4.
53:51 - Not a number.
53:52 - So something's going wrong
in that initial Descartes
53:54 - calculation, which is here.
53:56 - I have a feeling that this
value here is a negative number.
54:01 - So you can't take the square
root of a negative number.
54:03 - It is negative.
54:05 - I mean, can I just make
it the absolute value?
54:08 - Can I call that product and
take the absolute value of it?
54:11 - I don't know if that would work.
54:13 - That wasn't in any of the pages
I read to understand this.
54:18 - Oh, there we go.
54:19 - Look at that.
54:21 - So now I can go back to
getting rid of randomSeed.
54:25 - Let's give ourselves a
bigger space to work with.
54:32 - And let's have it automatically
create the gasket.
54:36 - So what do I do now?
54:38 - So I'll just call this
like nextGeneration.
54:42 - And if I call in
draw nextGeneration,
54:48 - it should automatically
make the gasket.
54:51 - There we go.
54:52 - Eventually it'll stop.
54:53 - Look at all of these
possible Apollonian gaskets.
54:56 - I feel like I should probably
have the first circle allowed
55:00 - to be a little bit bigger.
55:02 - So let's have it be
at minimum 100 pixels.
55:07 - Challenge complete.
55:09 - Let's think about what
you could do next.
55:10 - First of all, I have
a feeling that I'm
55:13 - kind of fudging some
math stuff here.
55:16 - So if you happen to be a
mathematician or somebody who's
55:20 - gone deeper and
read these papers,
55:21 - please let me in the comments.
55:23 - What did I miss?
55:24 - What did I get wrong?
55:24 - What are some ways
I could optimize
55:26 - the way that I'm doing this?
55:28 - But for you, the
creative coder, I'm
55:30 - wondering, what kind of visual
possibilities can you make?
55:34 - What if you think about color?
55:37 - What if, instead
of using circles,
55:40 - you use a different
kind of origin shape?
55:43 - You could also
recursively put gaskets
55:45 - inside of other gaskets.
55:49 - So I hope that you've learned
something from watching this.
55:53 - I hope that maybe
you can take my code.
55:55 - I certainly need to
clean it up and improve
55:57 - it, make it a little bit easier
for you to build on top of.
56:01 - I will do that to the
best of my ability
56:03 - and include that
in all of the links
56:05 - to all the references
and resources that
56:07 - are in this video description.
56:09 - So Happy Pi Day.
56:11 - If for some strange
reason, the way
56:13 - you spent your day was
watching this incredibly
56:16 - long and convoluted
video, trying
56:18 - to make the Apollonian gasket
in p5.js, then thank you.
56:23 - I appreciate you.
56:24 - I'm glad that you are here.
56:25 - I really want to see some
creative Apollonian gaskets.
56:28 - So share them with me in
the passenger showcase.
56:30 - And I'll see you next
time on The Coding Train.
56:33 - [BLOWS WHISTLE]
56:34 - [MUSIC PLAYING]

Cleaned transcript:

It's frozen. No. No. No. No, wait. Please, I don't want to lose all my code. [SOMBER MUSIC] Oh, god. [MUSIC PLAYING] Hi, everyone. It's Pi Day. I've been making videos to celebrate the number pi on March 14 for quite a number of years now. Typically, I'll do something where I'm trying to approximate the number of pi, or even do some kind of visualization of the digits of pi itself. This year, I'd like to just celebrate the circle for Pi Day. I've been working very hard on the new version of The Nature of Code book, published by No Starch Press, coming out this summer. Preorder today. Read the whole thing online today for free as well. And my coding challenges in 2024 have been extensions of topics in that book. So I thought for today I'd like to take a look at a particular fractal pattern called the Apollonian gasket. When I first saw this, I thought, great, this could be a nice extension, exercise, additional example for chapter 7 in The Nature Of Code book, all about fractals. It'll be easy. See now, you draw a circle in P5 and do a little recursion. You put some other circles. I've also done videos on circle packing before. Easy peasy, lemon squeezy. No problem. I like to not try to do too much before I come here and record the coding challenge. But you know, I should do a little reading, reading up on what the Apollonian gasket is, its history, what's the math behind it. There's a wonderful article here by Dana Mackenzie in American Scientist that was a terrific reference. This set of blog posts from the Math Less Traveled from 2016 on the Apollonian gasket was very helpful. I wandered into this paper called Beyond the Descartes Circle theorem. And then I started to realize oh, no oh, no this is going to be a lot harder than I thought. But guess what? Bonus for you. In this video, you will learn about not just the position and radius of a circle, but something called the curvature or the bend and how that relates to something called the Descartes theorem. And then I might even wander into using the Descartes theorem, but applying it not just with numbers but with complex numbers, imaginary numbers. And so we're going to have to solve/use the complex number Descartes theorem. This is probably going to go off the rails. But if I can make that Apollonian gasket fractal, hopefully you'll have learned something new about math. And you might be inspired to make your own artistic version of this fractal, varying it with color or some other kind of shape, or tweaking the algorithm however you want. And muah, won't that be a wonderful celebration of Pi Day. Strangely enough, this all begins with a poem, a poem by Frederick Soddy, an English radiochemist who won the Nobel Prize for chemistry in 1921. Frederick Soddy was fascinated with something called Apollonius' problem, named for Apollonius of Perga, the Greek astronomer. Let's say you have three circles, any three circles, nonoverlapping. How could you find a fourth circle that is tangent to all three of these circles? Two circles are tangent if they meet at a single point along their edges. And that tangent can be expressed as a line. This is actually referred to as a kissing circle because they're like, [KISSING SOUNDS] I love you circle. And there typically isn't just one solution to the Apollonian problem. Let me try to draw one in here. No I can't. I'm not really drawing this correctly, but you get the idea. Maybe I could also could I get a circle that kind of like This is also tangent to this circle, this circle, and this circle. The solution to this problem lies in something called Descartes' theorem. Soddy rediscovered Descartes' theorem independently in 1936. Found it so beautiful, he wrote an entire poem about it. The Kiss Precise. For pairs of lips to kiss maybe involves no trigonometry. 'Tis not so when four circles kiss, each one the other three. To bring this off the four must be as three in one or one in three. Since zeros bend's a dead straight line and concave bends have minus sign, the sum of the squares of all four bends is half the square of their sum. Kiss the other four the square of the sum of all five bends is thrice the sum of their squares. So the problem of Apollonius is for any three circles. But Descartes's theorem, and as it relates to the Apollonian gasket, is actually a problem that's for a more specific scenario, where the original three circles are mutually tangent. I'm going to begin by drawing a kind of classic example of three mutually tangent circles that is symmetrical. And this is going to be terrible, but I'm going to do my best. The first thing that I need to define for Descartes' theorem is this idea of the curvature of a circle. Now the curvature is the inverse of the radius. A smaller circle is going to have a much tighter curvature, whereas a bigger circle has a much wider curvature to it. So curvature, typically written as K, is equal to 1 divided by the radius, and vice versa. The radius is equal to 1 divided by the curvature. Now the curvature, however, is signed. It can be positive or negative. The radius, of course, is always positive. So we might say, the radius is equal to the absolute value of 1 over the curvature. Now what makes the curvature positive or negative? I mean, all the circles, they bend the same direction. Well, this particular circle, which is an outer circle it is enclosing these two circles has a negative curvature, whereas these two circles here have a positive curvature. If I were to draw three mutually tangent circles where none of them enclose each other, they would all have a positive curvature. Here are three mutually tangent circles, all with a positive curvature. So what is Descartes' theorem? And how does it relate to the Apollonian gasket? The process for drawing the Apollonian gasket is to start with your three mutually tangent circles and find their fourth, the kissing circle. What is the fourth circle that is mutually tangent to all three of these? Well, once again, there's more than one possibility. Now if I found those two, what if I took all the triplets that are available to me here and found the fourth mutually tangent circle that goes with those? Maybe I'd find one here, and here, and here, and here. And then I might find one here, and here, and here, and here. So I've done a rather poor job at drawing the Apollonian gasket. But you see how you are recursively finding the next circle and the next circle that is mutually tangent to triplets, the triplets that you're creating through this recursive process. Descartes' theorem is expressed in the poem as the sum of the squares of all four bends is half the square of their sum. So if this is circle 1, 2, 3, how do I find circle 4 that's inside there? The sum of the squares of all the bends is equal to 1/2 of the square of the sums. So if I could somehow take this equation, knowing the curvature for circles 1, 2, and 3, could I solve for curvature 4? K4 equals what? This is a quadratic equation. It can be solved. It will, as you see, have multiple solutions. I'm not going to derive the solution. But I will put a reference hopefully I can find one that shows the derivation of the solution. Let me show you what it is. Curvature 1 plus curvature 2 plus curvature 3 plus or minus multiple solutions the square root of K1 times K2 plus K2 times K3 plus K1 times K3. No more question mark. So this is now something we can actually start to implement in our code. Whoops, I forgot about the 1/2 here. So plus or minus 2 times the square root of this summation. How long has it been in this video and I haven't written any code yet? Don't worry. Now's the time. The first thing that I want to do for this is create a circle class. The circle class will hold on to the position of the circle, its radius, and its curvature. So if I'm giving it a bend, its radius is the inverse of that, or the absolute value of the inverse of that. Let's write a function for the circle to draw itself, make sure I add it to the HTML file. And let's create three circles. What should their curvatures be? Well, on this diagram of the Apollonian gasket, this is one of my circles, this is one of my circles, and the big circle is one of my circles. So if the radius of this circle was something like 200, the curvature would be 1 divided by 200. But remember, the outer one is negative. And then the inner ones would have a curvature of 1 divided by 100, 1 divided by 100 if they're half and they're positive. So the curvature is negative 1 divided by 200. And it's x, y is at 200, 200. And I'm just hard coding this now. Later, it's my goal to create a random arrangement of three mutually tangent circles. We'll see how well that goes. But I'm just going to hard code an initial location that is kind of a classic version of the Apollonian gasket. Where are those circles? Oh, I have the background in draw. Let's get rid of that. There we go. There are those three circles. Now let's see if I can write a function that will calculate that fourth curvature, passing in the three circles. And eventually I might want to work with arrays and kind of store the circles in different ways. But this should be good enough to get me started. Now it's time for me to take that formula on the whiteboard and implement it here. So first, let's get K1, K2, K3. Let's divide the formula into two parts. First, the sum. Let's call the second part I don't know the root because it's the square root of the products of the different curvatures. And I need to multiply it by 2. And now I need to return the sum plus or minus the root. How do I return a value plus or minus? Well, I could just return both values. Let's at least see if the radius that I'm getting back from the function is approximately the right side. I mean, the really complicated part here, that I'm going to get to soon enough, is to figure out where the circle goes. But for right now, all I need to do is check the radius. So radius 4 is the absolute value of 1 divided by the fourth curvature. And if I were to just draw a circle at mouse x, mouse y with radius 4 times 2 and I guess I need to put this into draw. And these circles will need to be global variables. What am I missing here? Not a number. Oh, right, of course. I've got to pick one of them. I went through this whole thing about how I'm returning two values. And I need to have two r4s. So r4 could be let's just pick 0. Let's just pick that first value. And we can see, does this circle fit there? Look, it fits there. So I definitely got the radius right. Let's look at the second value. Second value is also the same. So that's good to see that I'm getting both. The correct values, probably one is going to go down here somehow. And one is going to go up here. So if I have a function it's called Descartes here and it returns the curvature for all possible fourth circles, all I need next is a function that returns the position of that fourth circle or all possible fourth circles. This is where things get a little bit extra hairy. The solution to finding the centers of those circles is in this paper Beyond the Descartes Circle theorem. Right here at the beginning, you can see how the authors are referencing the Descartes theorem. The bends, the curvatures, satisfy the relationship where the sum squared equals 2 times the sum of the squares. In this paper, they show if you take the centers of those circles, express them as complex numbers, they also have the same relationship, essentially yielding what could be called the complex Descartes theorem. Now I'm not going to prove this or derive this. If you want to go deeper into the math, this paper will have that for you. But let me just explain to you what a complex number is and how I can take the Descartes theorem and solve for an xy pair instead of a single curvature value. A complex number is a number that has a real component and an imaginary component. What do I mean by imaginary? Well, hold that thought. It's written in the form a plus bi. And "i," like imaginary, is a representation of the square root of negative 1. Now the last time I probably referenced complex numbers was maybe in my Mandelbrot set coding challenge or perhaps the Julia set coding challenge. And remember how I was really in love with talking about imaginary numbers and playing around with the idea of them being imaginary. But it's a little bit of a misnomer. This is very much a number, a kind of number incredibly important in all sorts of applications of mathematics. And it is necessary when solving certain kinds of polynomial equations, especially if you've got something like x squared equals negative 1. How do we express the solution for an equation like that? What is kind of magical here is because a complex number has two components, A and bi. This a and this b can be mapped to what's called the complex plane. This might be aaxis. This might be the baxis. So if I put a point over here, maybe it's the point 5 plus 4i. Well, this might look kind of similar to you. I mean, aren't we in a p5 canvas? And maybe I have this point here, which is the xy point, 200, 200. Why not express that as a complex number where x is the real component and y is the imaginary component? So this point could be expressed as 200 plus 200 i. So this is the Descartes theorem, which expresses the relationship between the curvatures of four mutually tangent circles. Well, it so happens, if I think of the centers of all of those circles expressed as a complex number maybe I'll call them z1, z2, z3, z4, each of these being of the format x plus yi, x plus yi. This would be x1 plus y1i, x2 plus y2i. The same equation applies if I take those complex numbers and multiply them with the bends. So in other words, the product of the bends and the centers satisfy this exact equation. Let me try to write this out. Z1 squared times K1 squared. This is the new equation. So what's known? I know z1, z2, z3. I know all of the curvatures. I even know k4 because I was able to solve for the fourth curvature through the regular, oldfashioned Descartes theorem. So now all I need to do is somehow solve this equation for z4. Again, not going to derive the solution. I'm just going to write it out for you. Here we go. I just spent some time staring at the Wikipedia page. We'll see if I remember it. z4 equals the sum of the bends times the circle centers plus or minus the square root of the products of all that stuff, like before. [LAUGHS] I got to go look at it again. The curvatures times the centers plus the curve all the configurations. Plus or minus 2 times the square root of z1k1 times z2k2. I'm just going to write it this way k1 times k2 times z1 times z2 plus oh, no, I'm going to run out of room plus k2k3. Oh, no, no plus there. These are all multiplied. Then the whole thing divided by the fourth curvature because, remember, we're kind of solving for what's over here. So this whole thing divided by k4. So all we got to do is put this formula into our code. Easy peasy, lemon squeezy. We've got a bit of a problem, though. Look at my beautiful function for the Descartes theorem. It uses the plus operator, and the multiply operator, and the minus operator, because I'm just taking a number and multiplying it by a number, and another number, and adding it to a number. You can't do that so easily with complex numbers. In fact, I'm using the square root operator. How do you take the square root of a complex number? This is going to require at least 5 to 10 minutes of this video, just to implement that math. And the way that I'm going to do it is much like there's a p5 vector class in p5, which stores an x and a y and performs all sorts of vector math. I'm going to create a complex number class. And I'm sure I could use one like get one from some JavaScript library. But I think it's worth just quickly, "quickly" implementing my own. So this is the core idea of a complex number. I need to have both the real component and the imaginary component, a and b. The first thing that I might do is write an Add function. And I think what I'll do for ease is every single one of my functions will return a new object instance. So let's start with the Add function. That's the easiest one. And I'll use the word "other" for another complex number. So what do I need to do? Return a new complex number, which is this dot a plus other dot a and this dot b plus other dot b. This is adding two complex numbers together. Let's do a subtract. Let's do a scale, which is different than multiply. I'll get to that in a second. But let's say I want to just take a complex number and I don't know multiply it by 2? So I'm scaling it by a value. And that is a new complex number with this dot a times that value and this dot b times that value. I'm doing the easy ones first. OK. Let's do multiply. This is where things get a little bit tricky. And we need to return back to the whiteboard. Now you might be wondering, why can't you just use p5 vector? After all, you're storing a complex number, like you're storing a vector. And p5 vector already has functions like multiply and add. And this is why. It's this pesky little square root of negative 1 thing. So let's work out the math. And I've done this before, I think, in the Mandelbrot video. But let's do it again. A1 plus b1i times a2 plus b2i. This would be multiplying two complex numbers together. So a1 times a2 plus a1 times b2i plus b1 times a2y. So I'll say a2b1i. Did I say "y" when I meant to say "i?" And this is b1 oh, this is hard plus b1b2i squared. Remember, i is the square root of negative 1. So what's i squared? Negative 1. So this is actually a1a2 minus this turns into a minus because I take i squared minus b1b2 plus look at this a1b2, a2b1i a1b2 plus a2b1i. So this is my new complex number. This is the real component. And this is the imaginary component. This is how I multiply two complex numbers together. Now when I go back to the code, remember, it's not a1, b1, a2, b2. It's this dot a, this dot b, other dot a, other dot b. Let's see if we can make that happen. Now let's do multiply other. So let's just say the a is this dot a times other dot a minus this dot b times other dot b. And then the b is this dot a times other dot b plus other dot a times this dot b. Then I'm returning a new complex number with those a and b values. I have a plus for complex numbers. I have a scale for complex numbers, for a complex number times a scalar. I have a multiply now. I don't have a square root. How do I do the square root of a complex number? I think that since this is a video for Pi Day, we should use this formula because it's taking the complex number and converting it from rectangular form to polar form. So the idea here for taking the square root is if this complex number, instead of thinking of it as a comma b, I think of it in its polar form, where I have some magnitude I'll call that m and some angle I'll call that theta. Well, if I take this, I can find the square root by taking the square root of the magnitude and then half the angle. That works out. So in my code, square root. I first need to convert the complex number to its polar form. So in that sense, I would say let m, its magnitude, equal the square root of a times a plus b times b. Then its angle and this, by the way, is where I could use p5 vector. Its angle is equal to a tan 2, the inverse tangent this function is beautiful I've explained it in Chapter 3 of Nature of Code happy Pi Day, everybody of b comma a. That would be the angle. Then I need to say, the new magnitude is the square root of that magnitude. The new angle is that angle divided by 2. And then I can just say, return a new complex number with m times cosine of that angle, m times sine of that angle, converting it back to its nonpolar form. If you don't want to rely on my code, you could use this Complex.js library, which has a lot of complex number arithmetic already done and completed in JavaScript. I should probably be using it. But, you know, I like to learn this stuff, like get my hands in as much as possible. Now that I have a fully functional complex number class, I can adjust my circle class to store the xy center in a complex number. I'll call that center. What broke here? Oh, it's a and b. There we go. OK. I am ready to implement the complex Descartes function, which will take in three circles plus the curvature for the fourth circle and calculate the xy position of that fourth circle. And I'll use that same notation with z. All right. I need the sum and the root again. But I have to use the complex number math. And actually, if I'm looking at this formula, z1 through z3 are only ever used in combination with multiplying it by their corresponding curvature. I'll call it zk1. So zk1 is equal to z1 scale by k1. OK, so let's do that. Zk2, zk3. Then the sum is equal to zk1 add zk2 and I can chain these add zk3. So this right here should be now this part of the formula. Next, I want to do this part of the formula. So the root is equal to zk1 multiply zk2 add oh, god zk2 multiply zk3 add zk1 multiply zk3. OK? I think that's right. So this I know it's a little bit hard to look at but this should be everything that's in here. Now I just need to take the square root of that and multiply it by 2. So I should say root equals root square root. And then I need to multiply that by 2. And then I need to get the plus or minus. So I have two options. Remember down here when life was so simple, I just said some plus root or some minus root. So those are my two options. I have some add root or some subtract root. But then I also need to divide both of those by k4. So that would be, scale those by 1 divided by k4. These are my two possible complex numbers. All right. One issue right now is that k4 is actually two values. So let's pick one of them. I need the center for the new circle. We'll call that z4, should equal complexDescartes c1, c2, c3, k4 index 0. So I'm just going to pick it with one. And then I should be able to say z4 dot a, z4 dot b. Oh, what's the chance? What's the chance that works? Darn. Oh, well, that needs an s. Oh, this dot. This dot. It's been a while since I made a good thisdot mistake. OK, I still have an error down here. OK, console.log z4. Let's see what we got here. oh, because I got two of them. I forgot that I'm getting two for everything. And let's look at both of them. Let's put in no loop. Not a number, not a number. OK, so something went wrong somewhere with my complex number math. Probably, this is a good reason why I should have just used an existing complex number JavaScript library. But let's see what I can figure out. Oh, mult, mult. It's scale by 2. It's not multiply by 2. It's scale by 2. There we go. Look. Look. There's a circle in the right place. I've never been so happy to see that before. Woo, that was exciting. OK, we're getting somewhere. It was just a simple error. I used multiply instead of scale because it's scaling by a scalar not multiplying by a complex number. I really should be now finding both circles. I guess I could return two complex numbers. What if I give it k4 that's an array with two options. And then my complex oh, my god. oh, but I'm already getting two back. Wow, so there's actually four possibilities. Let's just do it twice. So let's get z4. I'll call it z40. And I'm going to send in k4 0. Oh, look at this. Look at this. I had a mistake there. I put a 4 instead of the k4. But now that I'm realizing it, it would make more sense to just return all four of them as an array. Let's see. So now I can put this one in here with add and this one in here. So I can get all four in this way. So I think this is going to make more sense, that basically I'm getting the two components of the formula, the sum and the root. Then I'm going to plus and minus those. So I have two possibilities. And then divide it by both k4 0 and k4 1. This is much better because this is just giving me all four. And now I can actually just say this. And this is kind of like all centers. All centers is the result of the complex Descartes function with all three circles and both possible bends. And I wonder if what I can do is like unpack those. I've got an idea. I want it an array because I'm going to say, let c of allCenters. And then what am I going to do? I'm going to make a new circle, equals a new circle with k4 index 0. Do I do all the [INAUDIBLE]? I'm so lost here. This isn't going to work. You know what I should do? Let's actually make the circles in the complex Descartes function because I need to know which bends go with which circles. So if I go back here. What I'm actually doing is I have four centers. I'll call those c1. Those are all my centers. Oh, I already used that variable. OK. Now I need to return an array of four circles. New Circle k4 0 with cente1.a, center1.b. So k4 0 goes with these first two. And these go with one. These are all the possibilities. So now I'm actually returning the four circles. Where I got them now I should be able to say, allCircles I could obviously loop through it. But I just want to look at them one at a time. 0 dot show. That one. All circles one dot show. That one. Hey, those are the right two circles. So then I don't want the other two. Oh, that one's maybe one of the same ones? Oh, actually, maybe I'm fine. They're just duplicates. Good work, everybody. They're duplicates. I think that I am through with the hardest part of this video, which was all of this math. And now the problem becomes, once I have the two new circles, I just need to look at all of the new triplets of three mutually tangential circles and get the next new circles, and so on and so forth. This is where the recursion comes in. This is where I'm more connected to chapter 7 of The Nature of Code. Now recursion can be done with a recursive function. And that's what I use in many of the fractal designs that are outlined in that chapter. What I think I'd like to do here instead, though, is use an array as the kind of foundational data structure for the recursion. So if I somehow had an array acting as like a queue of all of the possible triplets that I need to evaluate, then I could run through all those, throw it away, make a new queue, and keep going. So essentially the array is the recursion. Everything in the array will get processed, which will make a new array, which will get processed, which will make a new array, which will get processed. So that means, what I actually want to do is create an array called allCircles. And I'm going to push these circles into that array. You know what? I'm going to keep the c1, c2, and c3 because I'm going to need to make the queue as well. But I'm going to make those local variables. So all circles should get c1, c2, and c3 to start. And then the queue I need a queue. This is where it's connected to more to things that I've actually done before. The queue should have in it all the triplets, which is only this right now. So it's going to be an array of arrays. And let's just comment this out for a second. The same math is going to apply, but I need to figure out how to process that array. So the first thing I'll do is just in draw I'm always going to just show all the circles. Let's get rid of no loop. And let's go from generation to generation by clicking the mouse. So I'm going to add the mousepressed function. I could use a button or some other form of interaction or do this automatically, but I think this will help me figure this out. So what do I want to do when I click the mouse? I want to process the queue. I'll call it a triplet of queue. So I want to go through every triplet that's in queue. I'm going to need this. And can I do something like, say, let c1, c2, c3 equal that triplet? So I would get those three circles out of the thing that's in the queue. I would calculate k4. Then I would get all of the circles. I know that this [INAUDIBLE] allCircles returns four circles. But let's just use the first circle for a second. Let me think about what I'm doing. Oh, I don't want to call this allCircles. NewCircles, this is called newCircles. And what I want to do is say like, allCircles push, newCircles 0. So let's just first put in the new one. So if I click the mouse, I get that new circle going in. This is good. Now with that new circle, I need to make a new queue. So I need to have a new queue. Our nextQueue, I'll call it, is an empty array. And newTriplet is equal to c1, c2 with new circles 0. Basically, this new circle is mutually tangent to those first three. So I have three new triplets. I have it with c1 and c2. I have it with c1 and c3. So newTriplet1, newTriplet2. I might not need all these separate variables. And newTriplet3 is with the new circle. And c2 and c3. So these are all the possibilities. And then the queue should get nextQueue equals nextQueue concatenated with and let's just call this t1, t2, and t3. Those are my triplets that I'm getting from there, t1, t2, t3. And then the queue should equal next Queue. So again, I'm only doing this with that first new circle. But in theory, it should now get that new circle, make all the new triplets. Process them. Process them. Process them. OK, this is working. This is very exciting. One thing I need to do. There's two things I need to do. I need to make sure that the circles I mean, they're going to get infinitely small. First of all, one thing I can do is I can say and let me hit you can already see, it's really slowing down for let newCircle of newCircles. So don't even need that index anymore. I'm going to do it with all of them. There we go. For all the new circles, put them in the array, and make the new triplets, and add them into the queue. Great. But before I do that, I need to check some stuff. Like, if newCircle dot radius is greater than I'm going to give it a big number like 10. But you can see I'm getting some bad circles. So I'm pretty sure that and I don't know exactly why this is the case. But in all of the possible combinations of curvatures and centers that I'm getting out of these equations, not all of them are valid. So I think what I need to do is check for that, throw away circles that aren't valid. So let's validate the circles. There's two aspects to validating the circles. One is a lot of times these equations will produce the same circle twice. And I don't want to add it again because that's just going to compound itself. Let me work on that first. Let me write a function that's like called if validate newCircle. So I'm going to write this function, function validate and I'll just call it c for circle. So the first thing I want to do is check if it already exists. So let's look at the distance between this circle's center and the other circle's center. If that distance is less than like 0.1 pixels, that's how I'm going to know that they're the same. Return false. OK, it's invalid if it's distance to another circle is too close to it. And we'll just put a return true at the end. So that's good. You can see this is working. But I'm still getting a bunch of invalid circles. I need to make sure that it is actually mutually tangent to c1, c2, c3. So I can actually add these here. So basically, this function, first, is going to check to make sure it doesn't exist already. And I could call it c4. That's really what it is. It's the fourth circle. And now I need to write a new algorithm. Check if all four circles are mutually tangential. So how do I know if two circles are mutually tangent? I think I have an idea how to do this. OK. There are two ways for two circles to be tangent to each other. One is for one circle to be inside another. The other is for them to be next to each other. Now let's think about the radii, the two radius values, for each of these scenarios. And I didn't mean for this to be right in the center. So I'm just going to pretend the center is over here. So this is r1. And this is r2. This would be r1. And this would be r2 here. Now the important value is to look at the distance, the distance between the two circles. So in this case, if they're tangent to each other, the distance should equal r1 plus r2. And in this case, the distance should equal the absolute value of r2 minus r1. Look at that. You can see how I think I drew this in a weird way that's making me unsure. And that's the distance. This is r1. That's r2. So if I were to take r1 minus r2, I would have the distance. That was right. I was right. I just had to look at it a different way. Now it's going to be very hard again with this sort of precision of floating point numbers in JavaScript. Basically, I want to look at the absolute value of the difference between d minus r1 plus r2 and make sure that's less than some epsilon value. And the same thing for this. I basically would say d minus the absolute value of r2 minus r1 and make sure that's less than some epsilon value. So if either of these is true, then the circles are tangent. So let's write a function. IsTangent c1 and c2. And I'm basically saying, first I need to check difference one is I should really write a function inside of the circle class for distance. So now I have a function here in the circle class that will calculate the distance between two circles. That makes life much easier in this code. And I need to do the same thing. The distance equals c1 distance c2. And r1 equals c1 dot radius. R2 equals dot radius. And I need like an epsilon value. So now I'm going to say, return d minus r1 plus r2 is less than epsilon, or d minus the absolute value of r2 minus r1 is less than epsilon. Let's put these as separate booleans, just because I think it'll make it easier to read the code. So these are the two booleans that I need to check. And I'm basically saying, if either one of these is true, then the circles are mutually tangent. If isTangent this is a terrible way to do it. But I'm going to do it right now. If it's not tangent, c4 and c1, return false. And I'm going to do that against all the other possible ones. And then return true if I get to the end. I'm not 100% sure about this. So first I'm checking, is it a circle that already exists? It's invalid, return false. Then if it's not tangent to those other circles I don't know where it came from. It's wrong. That one, throw it away. I'm not getting any circles now. Let's just say it's always going to be true. Every two circles are tangent. Let's now look at this. Is my distance let me check my distance function. Oh, look at this. My distance function is wrong. It's a and b. It's a and b, not x and y. That's how I named my complex number naming. Oh, so that's not going to give me results that make any sense. OK. Look at that. Invalid circles are gone. Look, we have the Apollonian gasket. All right. Before we move on, one thing I did forget is these distance checks should really have the absolute value because I could be getting some weird stray negative numbers. So these should be absolute value, is less than epsilon. And then here I had this old calculation for the fourth radius, which is no longer needed, because the circles are calculating their own radii in this new algorithm down here. And also, you can see that at some point I'm clicking, and it stops. So I'm not getting any more new circles once I get to a maximum. Or maybe I am. Oh, no, did I just freeze things? Everybody just hold on. It's frozen. No. No. No. No. Wait. No. No, please, please, I don't want to lose all my code. Oh, god. Just keep waiting. It's fine. Keep waiting. I mean, I probably had saved somewhat recently. I had it saved, so actually I'm fine. Oh, you know what? I didn't check to see if the circles got too small, below a threshold. Oh, so also, invalidate if c4 radius is less than 2 let's just stop at two pixels return false. So that's also an invalid and actually, let me just make it 10 just to be sure. Now it stops. Aha. I feel much better about everything now. So I think I'm actually good. Let's put that at 2. I suppose, yes, there are arrangements where two circles like if there were a circle that were smaller in the center. So let's check radiusDiff equals I mean, there's no reason not to just check this c4 dot radius minus other dot radius. So if the delta, the distance, is less than epsilon, and the radius difference is less than epsilon, then they're the same circle. I think now I have a fully functioning Apollonian gasket algorithm visualization. And the exciting part is now here, where I believe I should be able to start with any arbitrary arrangement of three mutually tangent circles and get a new pattern. How do I get three random mutually tangent circles? Let's start actually with the first circle being the larger one. And then now the second circle, I'll pick a random radius between, let's say, like 20 and c1's radius divided by 2. And then c2 would be 1 divided by r2. Its position would be 200 minus I need to get to the edge of the circle, which would be c1's radius, plus this new r2. So this is now a random circle like this. But I would love to position it at a random vector. So let's use some vector math. And let me get an angle you know what? I'm going to make a vector. V equals p5 vector random 2D. And v should have the magnitude of c1's radius minus r2. And then c2 is just at 200 plus v dot x and 200 plus v dot y. So every time I do this, I'm going to get a random circle somewhere tangent to the outside. Now I need to get the other one. So the next radius I'm just making this up on the fly. The next radius is c1's radius minus radius 2, the magnitude of v1. It's actually the magnitude of that vector. And then where is it positioned? I would basically position it on the other side. So I would rotate the vector by pi and then set its magnitude how far away should it be by c1's radius minus Oh, that's the same thing. What if I just rotated it? And then just said, is this really going to work? The next circle is no, this doesn't make sense. Something is wrong here. But let's just try it. Oh, and I need to put it in here. That's kind of right. But it's not in the right place. You can see that's the right circle. It's just not in the right place. So where does it go? I need to rotate it. And then it just needs to go out I think I need the whiteboard. I have a circle. It's radius is r1. I have another circle right here. Its radius is r2. And then I made another circle like this. Its radius is r3. So r1 should equal r2 plus r3. So how do I find this center point? I just have to go from wherever this is, r2 plus r3. OK, that's its magnitude, r2 plus r3, or r1. The vector rotates. And then its magnitude should be c1 dot radius. Oh, but I'm doing it from the center. c1 dot radius oh, of course minus r3, of course. There we go. So now I'm always going to get three mutually tangent circles. Let's pick this one. Oh, no. Where's my gasket? Oh, there we go. I'm trying to figure out why some starting points, I don't get any circles. So let's try to debug this. Let's see if I can reproduce arrangement that doesn't work. And I can use randomSeed to do that. So if I put randomSeed in setup, and I'll just pick the number 5 well, that one actually works. Let's try the number 4. So with this one interestingly enough, it's different each time because my p5 vector it doesn't really matter. But let's just use from, Angle random TWO PI. The p5 vector is somehow not taking my randomSeed. I don't know if that's a bug in p5 or if I've made a mistake. But now it's going to be the same every time. Let's console.log k4. Not a number. So something's going wrong in that initial Descartes calculation, which is here. I have a feeling that this value here is a negative number. So you can't take the square root of a negative number. It is negative. I mean, can I just make it the absolute value? Can I call that product and take the absolute value of it? I don't know if that would work. That wasn't in any of the pages I read to understand this. Oh, there we go. Look at that. So now I can go back to getting rid of randomSeed. Let's give ourselves a bigger space to work with. And let's have it automatically create the gasket. So what do I do now? So I'll just call this like nextGeneration. And if I call in draw nextGeneration, it should automatically make the gasket. There we go. Eventually it'll stop. Look at all of these possible Apollonian gaskets. I feel like I should probably have the first circle allowed to be a little bit bigger. So let's have it be at minimum 100 pixels. Challenge complete. Let's think about what you could do next. First of all, I have a feeling that I'm kind of fudging some math stuff here. So if you happen to be a mathematician or somebody who's gone deeper and read these papers, please let me in the comments. What did I miss? What did I get wrong? What are some ways I could optimize the way that I'm doing this? But for you, the creative coder, I'm wondering, what kind of visual possibilities can you make? What if you think about color? What if, instead of using circles, you use a different kind of origin shape? You could also recursively put gaskets inside of other gaskets. So I hope that you've learned something from watching this. I hope that maybe you can take my code. I certainly need to clean it up and improve it, make it a little bit easier for you to build on top of. I will do that to the best of my ability and include that in all of the links to all the references and resources that are in this video description. So Happy Pi Day. If for some strange reason, the way you spent your day was watching this incredibly long and convoluted video, trying to make the Apollonian gasket in p5.js, then thank you. I appreciate you. I'm glad that you are here. I really want to see some creative Apollonian gaskets. So share them with me in the passenger showcase. And I'll see you next time on The Coding Train. [BLOWS WHISTLE] [MUSIC PLAYING]
