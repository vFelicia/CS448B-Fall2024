With timestamps:

00:01 - hello welcome to a this is a coding
00:03 - challenge this is this is a coding
00:05 - challenge the coding challenge today
00:06 - right now is binary
00:09 - tree okay that's what I'm doing it's
00:12 - actually kind of an interesting thing so
00:13 - first of all what I've been reading this
00:15 - book recently I just finished it called
00:16 - grocking algorithms it's great uh by ADI
00:19 - I I'll put a link to it in the it's by
00:22 - Adara sorry I pronounced that wrong I'll
00:24 - put a link to it in the um uh this
00:26 - video's description and I it's been
00:28 - refreshing my brain about all these
00:30 - algorithms that I may have once learned
00:32 - and then never really bothered to use
00:33 - again even though they are vital and
00:35 - important and but what I really want to
00:37 - ask in this series because I'm going to
00:38 - have a bunch more related to this sort
00:40 - of similar topic is what kind of
00:41 - creative outcomes can you have with this
00:43 - so I'm going to come at this from a
00:45 - very uh a no no point of view approach
00:48 - let's just look at the literal binary
00:49 - tree algorithm let's make a version of
00:51 - it I'm actually not going to include any
00:53 - visuals I'm just going to show you the
00:54 - results in the console and I'm going to
00:56 - ask you the viewer to make some type of
00:59 - visual out of it or to do something more
01:00 - interesting with it so maybe when I get
01:02 - to the end I'll have some ideas for you
01:03 - CU I don't have them right now so look I
01:06 - have all these pictures of binary trees
01:07 - behind me and and let's go over here to
01:09 - the Whiteboard and let's make a diagram
01:11 - so so why would you need a binary tree
01:13 - first of all and and actually this is
01:15 - this is the example that's in this book
01:16 - so I'm going to borrow it Pretend This
01:18 - was a phone book it's not a phone book
01:21 - um but it's a big book it's a book of
01:22 - random numbers that's another story for
01:24 - another time and let's say I wanted to
01:27 - find where I am in this book by the way
01:29 - do you even know what a phone book is I
01:32 - just said Pretend This is a phone book
01:34 - people of the future aliens of the
01:36 - future a phone book is a book I'm
01:39 - speaking to you up there not you hold on
01:41 - people of the future a phone book is a
01:44 - book with people's names in it and
01:47 - everybody's phone number oh my God a
01:48 - phone number is a sequence of digits
01:51 - that you use to call somebody on a phone
01:54 - a phone let's just I don't know how far
01:55 - into the future you are hopefully you
01:57 - still know what a phone is anyway it's a
01:59 - let's say this book was a list of people
02:02 - dictionary maybe dictionary it's a
02:03 - dictionary a dictionary is a book I
02:06 - don't know list of words and I want to
02:08 - look up the word rainbow or train pick
02:11 - your word one way I could do is I could
02:13 - go to the first page and I could say oh
02:16 - apple and I could look at every single
02:18 - word on the first page it's not there
02:20 - and I could look at every single word on
02:21 - the next page it's not there I could
02:22 - look at every single word on the next
02:23 - page it's not there but I know rainbow
02:25 - is R which is going to be you know
02:27 - somewhere around in 2/3 so I have a
02:30 - sense of where it is but another way I
02:31 - could look is I could just go straight
02:32 - to the middle and I could say ah is um
02:38 - is the word that I'm seeing here now
02:41 - does it come before or after rainbow in
02:43 - the alphabet if it becomes
02:45 - before you can um if it becomes
02:49 - before then I'm going to go halfway
02:51 - towards the end then I can go halfway
02:52 - back then I can go halfway again so I
02:53 - could keep finding by dividing all the
02:55 - words up in half this is I play this
02:57 - with my kids all the time let's guess a
02:59 - number between zero and a th and I'll
03:01 - always guess 500 and they say well it's
03:03 - too small so I'll guess 750 well that's
03:05 - too big so I'll guess you know
03:06 - whatever's in between those two 625 I
03:08 - don't know 67 oh my God I can't do the
03:10 - math um so so that the point is a binary
03:14 - tree is a data structure that allows you
03:17 - to move through sorted data by dividing
03:22 - it in half now there's a lot more to the
03:26 - efficiency of of the of how of the
03:28 - binary tree beyond that let's just start
03:30 - by designing one and come back to some
03:32 - of these questions later so first of all
03:34 - what what do I mean by data structure
03:36 - here's a data structure VAR xals 10 my
03:41 - data structure is a single number here's
03:44 - another data structure far nums equals
03:48 - you know 10 10 11 12 this is an array
03:53 - it's a list of information there are uh
03:57 - I could have an object in JavaScript
03:59 - which is a mapping of keys and
04:04 - values um you know favorite color
04:08 - whatever
04:09 - purple so these are different kinds of
04:12 - data structures that are familiar with
04:13 - it's a structure where you store data
04:16 - and we could get fancy about it there's
04:17 - things like linked lists which each
04:21 - object each thing points to the next
04:23 - thing so you can only get to it from the
04:24 - beginning by going through all of them
04:26 - and boy I should make some other videos
04:27 - about all these things and there's
04:28 - stacks and cues and all this stuff a
04:31 - binary tree is a data structure that
04:33 - works like
04:35 - this there is a this idea of a node this
04:39 - is a node and I'm going to call this
04:40 - node the root of the
04:43 - tree and it and it has maybe a child two
04:47 - children two children nodes one the left
04:51 - one and one the right one it's a binary
04:53 - tree because each node can only have two
04:57 - connections two children other kinds of
04:59 - trees
05:00 - can have all sorts of variable
05:02 - amounts here
05:05 - here here so it looks like this now this
05:08 - is the way the data is organized but I
05:11 - said the data is
05:13 - sorted what do you mean that doesn't
05:15 - look very sorted I mean I could imagine
05:18 - this being
05:19 - sorted well strangely enough it's s it's
05:22 - it's sorted in quite a remarkable
05:25 - way and the way that you build a tree is
05:29 - by add adding nodes to it one at a time
05:31 - so let's use let's use
05:33 - numbers somebody shout out a
05:37 - number there's nobody there's nobody
05:39 - around I can't get anybody to give me a
05:41 - number oh well I'll have to think of one
05:43 - there's a chat going on but I can't see
05:44 - that far from here so let's say I have
05:48 - uh the number 10 I'm going to add these
05:50 - numbers 10 5 15 7 2
05:54 - 931 this is a list of numbers that I
05:57 - just sort of thought of in my head that
05:58 - I'm going to add so I'm going to add add
05:59 - to the tree first 10 so 10 the tree is
06:02 - empty so the root note gets the number
06:05 - 10 now I want to add five into this tree
06:08 - and right now the root node has
06:11 - two empty spots as soon as I make a node
06:15 - it gets two empty spots now five is
06:18 - coming in here and I believe if five is
06:21 - less than it should go to the left and
06:23 - if it's greater than it should go to the
06:24 - right Bo I hope I'm doing this correctly
06:25 - there's you know obviously it could work
06:27 - either way but there's a standard so
06:28 - five is less than 10 so it's going to go
06:31 - here and now this has a left and a
06:35 - right with nothing 15 15 is more than 10
06:41 - it's going to go over here and this
06:44 - has a
06:46 - left and a
06:48 - right uh seven seven is less than 10 so
06:53 - it goes over here oh five it's greater
06:55 - than five so it goes over here and now
06:57 - this has a left
07:00 - and a right two two is less than 10 two
07:04 - is less than five two goes over
07:08 - here I'm I can't keep track of the way
07:11 - that I'm using dotted lines or not so
07:13 - this okay we got to get through the
07:14 - whole thing nine N9 is less than 10 it's
07:16 - greater than five it's greater than
07:18 - seven nine goes down here 31 31 is
07:21 - greater than 10 31 is greater than 15 so
07:24 - 31 goes here so actually I don't to just
07:26 - sort of erase these these are all the
07:28 - empty spots
07:31 - so this is the tree so how is this
07:34 - sorted let me tell you something this is
07:37 - most certainly sorted it's sorted
07:39 - because if I go all the way to the
07:43 - left watch this let's go to the left
07:47 - five let's go to the left two let's go
07:49 - to the left oh nothing left let's put
07:52 - out two now let's go back okay five oh
07:56 - now let's try oh sorry go to the left go
07:59 - back now we try to go to the right sorry
08:00 - go to the right nope so let's come back
08:03 - go up here five now can we go to the
08:05 - right yes
08:07 - seven go to the right
08:09 - nine oh actually Sorry Seven we should
08:11 - try to go to the left but we weren't
08:14 - able to go to the left um so we came
08:17 - back seven and now we go to the oh oh oh
08:20 - this is so hard let me do this again I
08:23 - don't know if I should edit this and
08:24 - come back but the algorithm of how we
08:27 - Traverse this tree is we want to visit
08:31 - every
08:33 - node visit a node and when we do that we
08:37 - want to go to the
08:42 - left which means that means visit the
08:44 - node to the left so we're going to
08:46 - implement a recursive algorithm a
08:49 - recursive function a function that
08:51 - references itself visit a
08:53 - node go to the visit the and so I should
08:56 - say start with the root and then visit
09:01 - left so we keep visiting left all the
09:04 - way as far as we can eventually we can't
09:06 - visit left anymore so then we might say
09:10 - you know uh print I'm just going to say
09:12 - print the
09:14 - value so we come up and print the value
09:17 - two what's the next thing we do is we
09:20 - visit the
09:22 - right so now we go down here there's
09:25 - nothing
09:26 - there so we come up here
09:30 - uh and then these are finishing where
09:32 - were we here now we we've finished
09:36 - visiting five so now we print out the
09:38 - value five and then we visit right seven
09:41 - what do we do when we visit seven we
09:43 - then go to the left nothing there so we
09:45 - come back and print out seven then we
09:47 - visit the right then we go to the left
09:49 - nothing there print out nine go to the
09:51 - right nothing there back back
09:55 - back here then we print out 10 then we
09:58 - go to the right and we try to go left
10:00 - nothing there 15 then we go to the right
10:03 - nothing there and nothing there 31 and
10:06 - we're done so this
10:09 - tree magically the way that the things
10:12 - are added to the tree end up in sorted
10:15 - order because what we're doing is we're
10:17 - basically saying I want to look here
10:19 - this is how it ties back to that phone
10:21 - book example oh my goodness can't
10:23 - believe I missed
10:24 - this if I want to find the number nine
10:29 - right let me find the number nine
10:31 - somewhere like I want to find this name
10:33 - in the phone book because the number
10:35 - nine might be associated with some
10:36 - actual important piece of information we
10:37 - need the nine just being like a
10:41 - key I can say is nine less than or
10:44 - greater than 10 and if this tree is
10:46 - balanced nicely meaning there's the same
10:48 - numbers on the left and the right I now
10:49 - have eliminated I don't have to search
10:51 - through half of the data whereas if I
10:53 - have an array and I need to try to find
10:55 - look through the array to find something
10:57 - in in unordered uh in an unordered array
11:00 - I have to check every single option so
11:01 - this is the structure how do we program
11:04 - this this is the next step okay so back
11:07 - over here we can see all of these nice
11:09 - visualizations of trees maybe I'll try
11:12 - to add a little visual something just so
11:13 - you can get how to would you get started
11:15 - with visualizing it but um but um
11:18 - hopefully that gives you an idea of what
11:20 - it's could be useful
11:23 - for talk about that okay um so now let's
11:27 - start to program this so what do I need
11:29 - how how would I even get started
11:31 - programming this well think about this I
11:33 - think I'm definitely going to need a
11:34 - node
11:36 - object so I'm going to write a
11:38 - Constructor function called node and
11:40 - it's going to have a left and a right
11:44 - and I'm going to set those equal to null
11:46 - just to sort of explicitly say when I
11:47 - make a node and the node should have
11:49 - some kind of value or label I guess I'll
11:52 - just use numbers maybe I should use text
11:54 - I don't know what's better but let's
11:56 - call it a label so I'm going to make
11:58 - it's like this sort of data at that node
12:01 - I'll call it
12:03 - value right so when you make a node it
12:06 - has a value and it has a left and a
12:08 - right which have no nothing connected so
12:10 - far let's make I think let's make a tree
12:15 - object to I don't know if the tree is
12:16 - really going to need anything but a tree
12:19 - is going to have a root
12:21 - node um and then also so that when the
12:25 - tree starts this do root equals null so
12:27 - the only thing when the things that's
12:29 - interesting about this data structure is
12:32 - I only ever need a reference to the root
12:34 - if I have a reference to the root by
12:36 - moving throughout the tree I can find
12:38 - any
12:41 - element okay so um uh what happens if
12:45 - two numbers are equal well we'll get to
12:46 - that that's a great
12:48 - question um okay so what I want to do I
12:51 - need a function I'm going to use
12:53 - prototype to attach functions so I want
12:56 - the tree object to have a function
12:59 - called add
13:02 - node and it gets a node as the argument
13:06 - and we first thing I'll do is just say
13:07 - if this. root is is equal to
13:11 - null then uh this. root equals n great
13:16 - so then let's say uh node n equals a new
13:21 - node well let's use numbers for right
13:24 - now because I think that'll be a little
13:25 - easier to see five and uh
13:30 - let's let's make a global variable just
13:34 - tree tree this should probably be called
13:36 - binary tree but tree equals a new tree
13:41 - and I have this node and tree. add node
13:45 - n okay so and then let me just say
13:48 - console.log
13:51 - tree so let's see so this should be um
13:56 - so by the way I'm using P5 here but
13:58 - there's actually nothing about this that
14:00 - I'm using there's nothing here that am I
14:02 - using P5 other than the setup function I
14:04 - have no canvas in there so it doesn't
14:06 - draw a canvas but I'm actually G to uh
14:08 - probably out and I have an error someone
14:10 - just pointed out if this do root equals
14:13 - null if I want to test if it's null I
14:15 - need a double equals and if I really
14:17 - really really want to test I could use
14:18 - triple equals someday I just want to
14:20 - make a video only about double equals
14:21 - versus Triple equals just such a funny
14:23 - little concept maybe I should do that
14:24 - before I leave today okay
14:27 - um so
14:29 - um there we go so now uh let's just take
14:32 - let's run this
14:33 - program uh where am I
14:36 - here uh oh I have an error error sketch
14:39 - touchs line one oh my goodness I've been
14:41 - programming in too much Java today this
14:43 - should be VAR tree right I don't need to
14:45 - give it a
14:47 - type and get this should be Varn boy I
14:51 - was programming in Java earlier today
14:53 - you can tell right okay oops wrong thing
14:57 - console.log
14:59 - not Capital tree tree that particular
15:01 - object there we go so we can see the
15:03 - tree has a root and has a node the root
15:06 - is a node with a left and right being
15:08 - null perfect okay here we go so we're in
15:12 - pretty good shape now what
15:15 - happens if I create another note and you
15:17 - know what you're I don't really need
15:19 - this variable here I can just do this I
15:21 - don't need a separate variable I could
15:22 - just say add a new node I could also if
15:25 - I really wanted to what if I just just
15:27 - to make things a little simpler I'm just
15:29 - say add a value five and I'm going to
15:32 - have this
15:35 - function create a node from
15:40 - it and uh and so this is really the same
15:43 - sort of thing but I this is just a
15:44 - little simpler now because I can have
15:46 - that function take care of that okay so
15:48 - what happens
15:50 - now if I say add value uh three now
15:54 - first of all was I write that things
15:55 - that are less than go to the left let's
15:58 - go back to the browser that binary tree
16:01 - yeah it looks like these examples
16:03 - uhoh whoa I don't know what this is oh
16:06 - boy I don't know what these what's going
16:08 - on with these binary
16:10 - trees
16:13 - what yeah this looks right so less than
16:16 - goes to the left uh some of these images
16:18 - are doing something slightly different
16:19 - than what I'm doing not should not rely
16:21 - on Google image search okay let's go
16:23 - back to my code so let's say I want to
16:26 - uh add node okay so I have another error
16:30 - this needs to be add I Chang this to add
16:32 - value I could just maybe I should just
16:34 - call it add but whatever so now what do
16:36 - I
16:40 - do
16:42 - if root is null it should be the root is
16:47 - that node so what if root is not
16:49 - null so what I need to do is
16:54 - say this do
16:57 - root
16:59 - add value so really what I should do
17:01 - this is interesting this. root add
17:05 - value
17:07 - um okay okay okay okay listen to this
17:10 - this is crazy so I
17:12 - actually
17:14 - um I'm losing my mind here ah uh
17:19 - okay otherwise here's what I want to do
17:23 - otherwise I got it this. root
17:27 - add
17:29 - add
17:31 - node sorry do add
17:34 - node n so okay what am I doing here so
17:39 - what I'm doing is I want to say if the
17:41 - root is empty tell to um just set it
17:45 - equal but what is this function this.
17:47 - root add node this means I need a
17:49 - function as part of the node that knows
17:51 - how to add something to itself oh this
17:53 - is
17:54 - great right so I need a node function
17:57 - node. protot
17:59 - type. add node equals
18:03 - function n so that's the node that's
18:05 - coming in now what happens if I'm a node
18:07 - and this comes in well I want to compare
18:11 - the value of n if n's value is less than
18:15 - my value if n's value is less than my
18:18 - value then this do left equals that node
18:24 - right it should be so if I'm adding it
18:27 - to myself if it's less it should go
18:28 - there
18:30 - otherwise this do right equals n but
18:33 - this isn't correct this is a nice idea
18:36 - right and it will work for just the root
18:40 - because when these two things are empty
18:41 - it will get added here but what if it
18:43 - goes to added to the left but there's
18:45 - something already there well needs to
18:47 - check against that one and that one it
18:48 - should then go to the left or and it
18:50 - should check against that one and then
18:51 - maybe that one it should go to the right
18:52 - so here's where I need recursion what I
18:55 - actually want to do is say this
18:59 - left add
19:02 - node um n or this. right add node n
19:09 - right
19:10 - because I want to just say keep going
19:13 - but what if this left is is null so if
19:18 - this there's probably more elegant way
19:20 - to write this if this left is null then
19:24 - it should be that value
19:27 - otherwise
19:28 - keep
19:30 - going same thing
19:33 - here if uh
19:37 - oh if this dot uh I'm I'm sure I I see a
19:41 - lot of chat messages telling me I'm
19:43 - doing something wrong so I'm sure I'll
19:45 - discover that in a second if this right
19:47 - equals null this. right uh this do write
19:52 - equals
19:55 - n uh else add no note line
20:02 - 17 uh oh Varn okay okay big deal that
20:06 - was all it was that was all it was
20:07 - because I keep writing note okay so I
20:08 - don't think I have anything hopefully I
20:09 - don't have anything majorly wrong now
20:11 - I'm sure there is I'm sure there's a way
20:13 - we could write this we could refactor
20:15 - this to be a little nicer but it is
20:16 - saying exactly what it's doing right if
20:18 - this value should go to the left if the
20:20 - left is empty perfect put it there
20:21 - otherwise recursively go and call that
20:24 - function again otherwise if um otherwise
20:27 - if it's um
20:28 - go to the right now here's the thing if
20:31 - it's equal I kind of want to do nothing
20:33 - right now so I think what I'm going to
20:34 - do with equal if the node is equal it
20:37 - just shouldn't go anywhere and so in
20:39 - that case I can say if else if this dot
20:44 - else if n.v value is is greater than
20:47 - this Dov value so actually in the case
20:49 - of those two values being equal nothing
20:51 - will happen so an equal value won't get
20:53 - added to the
20:55 - tree okay so let's take a look at this
21:01 - okay let's run this what am I what let's
21:03 - run this so the tree has a root which
21:07 - has a value of five and to the left of
21:10 - it has the value of three boy this is a
21:12 - really awkward way to look at it so
21:14 - we're definitely going to want to
21:15 - visualize this in some way to see if
21:17 - what we're doing makes sense but we can
21:19 - see that this is
21:21 - correct now if I were to then
21:25 - say add the value
21:30 - it's weird that I console logged it
21:32 - later and it was there add the value
21:34 - seven let's try
21:36 - that the tree has a root and the root
21:40 - has if I zoom into this a left the
21:42 - Root's value is five the left's value is
21:46 - three and the right's value is seven
21:49 - that's exactly right let's just try one
21:51 - more thing let's just I don't know let's
21:54 - add six that's a little bit tricky right
21:57 - but it should be
21:58 - six should go to the right of five to
22:00 - the left of seven so let me refresh this
22:03 - again the tree has a value of no the
22:06 - root has a value of five left is
22:11 - um whoops has a value of three sorry
22:14 - right has a value of seven and to the
22:17 - left of that has a value of six so this
22:20 - is no way to understand or see this is
22:23 - like I'm kind of used to this weird
22:25 - JavaScript console but the tree is there
22:27 - right and only thing I need to know is
22:29 - the root so
22:31 - remember remember how I said okay well
22:33 - what if I want to then look at all of
22:35 - the values or what if I want to search
22:37 - for I mean the whole thing was this is
22:39 - like a binary search tree the idea is
22:40 - we're storing all this information in
22:42 - this tree I could search for something
22:45 - in it so how do I Traverse the
22:48 - tree how do I Traverse the tree so let's
22:51 - just look at how we would Traverse the
22:52 - entire tree and this is exactly it to I
22:55 - want to start by visiting the root and
22:57 - when I visit the root I visit the left
23:00 - then I then I print out its value but
23:02 - and visit the right but that's done
23:04 - recursively so visiting the left means
23:06 - visit this left means visit this left
23:08 - until there's no left then come back
23:09 - then print out the value then visit the
23:11 - right Etc so this algorithm we worked
23:13 - out it's very hard to hold this into
23:14 - your head so recursion is new to you I
23:17 - think I have a video where I go over and
23:18 - look at like factorial fact the M make
23:21 - drawing some like recursive trees and
23:23 - fractal patterns you might look for some
23:25 - of those videos but this is a tricky
23:27 - thing to get but let's create a function
23:29 - now that's part of the
23:34 - tree prototype I'll call it Traverse and
23:39 - it is a function that says
23:43 - root. uh oh root. visit wait is this
23:47 - right so what I want to do is first
23:49 - visit the root node
23:51 - okay uh and then in the no you know what
23:56 - I need to do now I need to make some
23:58 - separate um separate files tree I'm
24:01 - going to make a file called tree. JS and
24:03 - I'm going to make a file called node
24:06 - node.js oh boy is that a problem uh
24:10 - node.js so if I go to sketch I just want
24:13 - to be able to pull this code out and
24:15 - look at it on its own so tree just has
24:18 - these three functions now the add value
24:21 - the're Traverse and the tree so the tree
24:23 - is just really a wrapper for the root
24:26 - that's all it kind of does the node is
24:28 - where all the sort of guts of the
24:30 - algorithm is is so I want to take all
24:33 - this node
24:34 - stuff and put it here in this
24:37 - file and here we go so now all I have is
24:41 - so far as the Constructor to create the
24:44 - node which has a value and a null left
24:46 - and right and then this add node
24:47 - function which recursively figures out
24:50 - where to to keep going through more and
24:52 - more nodes to where to add it now what I
24:54 - want to add is a function called visit
25:00 - and what does it mean to
25:03 - visit uh this. left
25:08 - dovisit this. right dovisit so I always
25:12 - want to go to the left first because I
25:13 - want the lower values first so that was
25:15 - definitely right and then I want to
25:17 - visit to the right but in between if I
25:19 - go all the way down to the left I if I
25:21 - want to actually do something I want to
25:23 - process the value or check what it is
25:24 - here's where I would say
25:26 - console.log this.v value so here's the
25:30 - problem is though I don't want to say
25:32 - this. left do this. left. visit if it's
25:35 - null so only if this. left is not equal
25:39 - to
25:40 - null and I know I could in JavaScript I
25:43 - could just say um as long as this left
25:47 - exists but just in Cas it could have the
25:49 - value of zero which is going to cause me
25:50 - a problem so um I'm going to I'm going
25:52 - to stick with checking to make sure it's
25:54 - null and if this dot right does not not
25:57 - equal to
25:59 - null uh this.right dovisit
26:03 - okay look at this so simple beautiful
26:05 - elegant I love this kind of stuff line
26:08 - seven I have something wrong in line
26:10 - seven no node. prototype thank you I
26:13 - love having a chat that debugs this
26:15 - stuff okay so here we go I think I just
26:18 - sort of typed this from scratch could
26:19 - this possibly really
26:21 - work so let's now
26:24 - um let's go here and see if in the
26:29 - sketch uh I'm going to now say tree.
26:33 - Traverse and I should just see all the
26:36 - values in sorted
26:38 - order okay tree is not huh tree is not
26:43 - defined oh of
26:45 - course I always do this I forgot to add
26:48 - a reference to these two new
26:51 - files I just invented a whole new
26:53 - JavaScript library called no. JS not
26:55 - really tree. JS there's a whole big
26:58 - serers side JavaScript programming
26:59 - framework called node so I feel like it
27:01 - maybe a little bit weird that I called
27:02 - my file node.js but we'll live uh okay
27:06 - root is not
27:07 - defined
27:12 - [Music]
27:13 - um
27:15 - do I forgot this dot clearly uh did I
27:18 - forget it anywhere else I don't think so
27:21 - let's run this again there we go look at
27:23 - those values
27:25 - 3567 okay let's try this in a crazy
27:28 - Funtime way because hasn't this already
27:31 - been so much fun let's say for VAR I
27:34 - equals zero I is less than uh 10
27:40 - i++ Let's uh add a random number between
27:44 - zero and 100 and I'm going to floor it
27:46 - just so it's integers even though I
27:47 - don't really need to and I'm going to
27:50 - console log the tree and say tree. so
27:52 - I'm instead of hard coding the numbers
27:54 - I'm going to pick random ones and let's
27:56 - run it these look s sorted these look
27:58 - sorted these look sorted it's great and
28:01 - uh let's add a
28:03 - th that happened pretty quickly so I
28:07 - mean you know would have to now here's
28:10 - the thing let's let's go back to just
28:11 - doing this with
28:13 - 10 let's look at the actual tree the
28:16 - root has a node to the left which is
28:19 - 68 no the the root is 89 to the left is
28:23 - 68 to the right is 93 see again this is
28:26 - no way to look at it so we're done with
28:28 - the binary tree I didn't actually add a
28:30 - function that is
28:33 - um that involves searching the tree um
28:36 - which I probably should that would kind
28:38 - of make
28:39 - sense um but um so we could search so we
28:44 - could add that let's add
28:46 - that let's add a function that searches
28:49 - the
28:50 - tree and it's going to be very similar
28:52 - to Traverse so we're going to say tree.
28:56 - prototype do search equals function I'm
29:00 - GNA search for a
29:03 - value and we're actually just going to
29:05 - do the exact same thing oh sort
29:09 - of uh we're going to
29:14 - say this. root. search for Val so again
29:20 - the tree object is just a wrapper for
29:22 - the root and we're going to say search
29:24 - the root so now this visit function is
29:27 - going to be very useful because we're
29:29 - essentially doing the same
29:31 - thing um but what we're first doing is
29:35 - we're first saying does this. value
29:38 - equal Val right I first then I want to
29:41 - say console log
29:45 - found
29:48 - uh plus
29:50 - Val and then
29:55 - otherwise uh otherwise if this do value
30:00 - is less
30:02 - than no sorry if Val is less than this.v
30:07 - value then
30:10 - and and this. left is not equal to
30:15 - null then I want to and that's then I
30:19 - want to uh go and search for that value
30:22 - here and then I'm going to do the same
30:24 - exact thing for uh the
30:29 - right and I'm G to search for the value
30:32 - to the right so this is how I could just
30:34 - say hey is the root the value no but I'm
30:37 - less than it so just let's look at
30:38 - everything to the left so I don't need
30:41 - to this I'm not traversing the whole
30:42 - tree I only know need to go the One
30:44 - Direction that I need to go so um insert
30:47 - One Direction music right now okay so
30:50 - let's see if let's do this um let's see
30:53 - if this works so this what's in the tree
30:56 - right now
30:57 - all these numbers so if I say tree.
31:01 - search uh
31:05 - 53 this root search is not a function
31:08 - what did I do wrong uh oh I called it
31:11 - sorry I called it visit again this
31:13 - should be search let's do this again so
31:16 - I want to say tree. search um let's look
31:20 - for
31:20 - 61 found 61 can you guys see this
31:25 - refresh this again um
31:27 - well you can't see at the bottom there
31:29 - because it's cut off uh so let's do this
31:32 - ah sorry hold
31:35 - on um so let's do a tree.
31:40 - search and let's look for something
31:42 - that's not there so nine is not there
31:45 - undefined so that's pretty good I
31:46 - probably should have something where I
31:49 - mean that's fine I might want to
31:50 - explicitly somewhere say at the end
31:53 - return
31:55 - um return undefined or returned not
31:58 - found but I can basically say here now
32:01 - in my uh wherever
32:05 - I oh you know what I should just return
32:07 - so that's what I should do sorry when
32:09 - right when I found it what that's what I
32:11 - should do to make more sense right here
32:12 - I should say return uh I might as well
32:16 - return the
32:17 - node um return this so that's I found it
32:21 - at this node so I'm going to return the
32:23 - node and then at the end I believe if I
32:26 - just say return
32:27 - you know uh
32:29 - null so if it never finds it eventually
32:32 - it's going to recursively percolate
32:34 - through all these functions to get to
32:35 - the end and return null uh I think
32:38 - that's right so let's do this again so
32:41 - now let's say tree.
32:44 - search for 20 which I know is in there
32:48 - somewhere and oh I got undefined
32:53 - H uh uh oh you know what this is not the
32:57 - right place for
32:58 - this
33:02 - because right because it could be oh
33:05 - because it's equal
33:09 - no vertical bow TI mod wait wait let me
33:12 - take this out for a
33:14 - second I have to think about that tree.
33:19 - search uh four undefined what's wrong
33:22 - here what did I
33:25 - miss return this
33:31 - console.log
33:33 - found
33:37 - vow
33:39 - uh
33:45 - oh whoa this should say VAR found I
33:49 - don't know why I didn't have this in I
33:51 - didn't add the part I'm really sorry
33:53 - everybody my brain must have just melted
33:55 - uh I VAR found found equals this so if
33:59 - found is not equal to
34:02 - null
34:04 - console.log you know
34:06 - found and then I could
34:10 - uh I could put that object
34:12 - out otherwise
34:15 - console.log not not found I I don't know
34:18 - why I missed that so we're searching uh
34:22 - okay uh okay
34:25 - um so now I should say say tree. search
34:29 - uh
34:30 - 10 found 10 not found so why does that
34:36 - happen why does that oh oh oh no it
34:40 - didn't it found it but it said not found
34:42 - what am I oh oh oh oh oh my my returns
34:46 - is all my my return is all messed up
34:50 - let's think about this boy this is
34:52 - hard um search found oh no I'm in the
34:57 - wrong place oh I'm in the I'm I'm in the
35:00 - wrong
35:02 - place this is
35:07 - where I need I I just haven't really
35:10 - think thought about what I'm
35:12 - doing it helps to think about what
35:14 - you're doing what am I doing I want the
35:18 - tree this is the function I'm calling I
35:20 - want this function to return something
35:22 - it's printing out the right thing the
35:24 - whole point of this is not to print
35:25 - something out but to return the thing
35:27 - that's
35:28 - found return found that's all I need to
35:31 - do forget about all this I want to
35:34 - return found because I want to see it in
35:35 - the console somewhere else I might call
35:37 - it so that's I just kind of like got
35:39 - confused because I'm typing everything
35:40 - into the console which is a little bit
35:42 - confusing um so let's run this again and
35:45 - say tree.
35:47 - search
35:49 - 19
35:51 - and uh hold on did I not save
35:54 - everything ah okay
35:57 - of course the problem is uh I need if I
36:01 - want to return a value you know one of
36:03 - the nice things about this visit thing
36:04 - is I I was just going through everything
36:07 - I wasn't worrying about returning a
36:08 - value so I would just call the next
36:10 - function but if I want to I I need to
36:13 - return the results of the recursive
36:15 - calls so I need this return and I need
36:19 - this return so this should really fix it
36:22 - so I'm going to refresh this now I'm
36:23 - going to say tree. search 12 and now
36:27 - I've got 12 but as I changed it to but I
36:29 - want to Let's return a reference to the
36:31 - full object doesn't really matter but uh
36:33 - tree.
36:34 - search Five and we can see I got the
36:37 - node now which has the value five I know
36:39 - what this laptop is kind of uh covering
36:41 - it so um so okay so that's how you
36:44 - search the tree and if by the way I
36:45 - search for something that's not in there
36:48 - I'm going to get undefined however I can
36:50 - put this back in just to be sure and I
36:53 - can get null so if what I want to do is
36:56 - is um you know now actually here I could
37:00 - say you know tree.
37:02 - search you know 10 let's just see if
37:05 - this tree has 10 in it and
37:08 - um and I could say now if result equals
37:12 - null
37:15 - console.log not
37:19 - found else uh
37:23 - console.log you know result so now I'm
37:26 - going to run this and 10 is not in there
37:29 - 10 is not in there 10 is not in there
37:31 - How likely is it it's going to put 10 in
37:32 - there oh it had one that found 10 so you
37:35 - know about one out of every 10 times
37:37 - there I can't can't stop Hing refresh
37:39 - stop find it find it find it find it
37:41 - please find it oh come
37:44 - on oh no what's wrong with me okay you
37:48 - guys get the
37:50 - point okay so this is a binary tree um
37:53 - hopefully what you've seen now just to
37:55 - summarize I think I'm going to in a
37:56 - separate video make a part two where I
37:58 - just add some visuals to it so that but
38:00 - that's what I want you to be thinking
38:01 - about well why would you this is an
38:03 - important data structure um that you can
38:05 - use to store information for binary
38:08 - search for sorting uh for dictionary of
38:11 - words there's so many possibilities but
38:13 - the key thing is what what kind of
38:16 - creative outcomes could you have here
38:18 - could you create some type of game which
38:21 - involves a binary tree and you have to
38:22 - add things and find things sort there's
38:24 - the sort of Plinko thing I made before
38:26 - make a binary tree we added some Physics
38:28 - to it just visualizing it is there
38:30 - something beautiful in the way that the
38:32 - binary tree you Traverse the binary tree
38:34 - recursively could you do some kind of
38:35 - nice animation I think there might be
38:37 - some unique possibilities there so I'm
38:40 - not very good at this kind of stuff any
38:42 - of it really but especially the visual
38:44 - stuff but in the next video I'm going to
38:47 - at least try to draw some of the tree so
38:49 - we can see um how it looks if we if we
38:52 - draw the sort of basic elements okay
38:53 - I'll see you
38:55 - there
38:58 - [Music]

Cleaned transcript:

hello welcome to a this is a coding challenge this is this is a coding challenge the coding challenge today right now is binary tree okay that's what I'm doing it's actually kind of an interesting thing so first of all what I've been reading this book recently I just finished it called grocking algorithms it's great uh by ADI I I'll put a link to it in the it's by Adara sorry I pronounced that wrong I'll put a link to it in the um uh this video's description and I it's been refreshing my brain about all these algorithms that I may have once learned and then never really bothered to use again even though they are vital and important and but what I really want to ask in this series because I'm going to have a bunch more related to this sort of similar topic is what kind of creative outcomes can you have with this so I'm going to come at this from a very uh a no no point of view approach let's just look at the literal binary tree algorithm let's make a version of it I'm actually not going to include any visuals I'm just going to show you the results in the console and I'm going to ask you the viewer to make some type of visual out of it or to do something more interesting with it so maybe when I get to the end I'll have some ideas for you CU I don't have them right now so look I have all these pictures of binary trees behind me and and let's go over here to the Whiteboard and let's make a diagram so so why would you need a binary tree first of all and and actually this is this is the example that's in this book so I'm going to borrow it Pretend This was a phone book it's not a phone book um but it's a big book it's a book of random numbers that's another story for another time and let's say I wanted to find where I am in this book by the way do you even know what a phone book is I just said Pretend This is a phone book people of the future aliens of the future a phone book is a book I'm speaking to you up there not you hold on people of the future a phone book is a book with people's names in it and everybody's phone number oh my God a phone number is a sequence of digits that you use to call somebody on a phone a phone let's just I don't know how far into the future you are hopefully you still know what a phone is anyway it's a let's say this book was a list of people dictionary maybe dictionary it's a dictionary a dictionary is a book I don't know list of words and I want to look up the word rainbow or train pick your word one way I could do is I could go to the first page and I could say oh apple and I could look at every single word on the first page it's not there and I could look at every single word on the next page it's not there I could look at every single word on the next page it's not there but I know rainbow is R which is going to be you know somewhere around in 2/3 so I have a sense of where it is but another way I could look is I could just go straight to the middle and I could say ah is um is the word that I'm seeing here now does it come before or after rainbow in the alphabet if it becomes before you can um if it becomes before then I'm going to go halfway towards the end then I can go halfway back then I can go halfway again so I could keep finding by dividing all the words up in half this is I play this with my kids all the time let's guess a number between zero and a th and I'll always guess 500 and they say well it's too small so I'll guess 750 well that's too big so I'll guess you know whatever's in between those two 625 I don't know 67 oh my God I can't do the math um so so that the point is a binary tree is a data structure that allows you to move through sorted data by dividing it in half now there's a lot more to the efficiency of of the of how of the binary tree beyond that let's just start by designing one and come back to some of these questions later so first of all what what do I mean by data structure here's a data structure VAR xals 10 my data structure is a single number here's another data structure far nums equals you know 10 10 11 12 this is an array it's a list of information there are uh I could have an object in JavaScript which is a mapping of keys and values um you know favorite color whatever purple so these are different kinds of data structures that are familiar with it's a structure where you store data and we could get fancy about it there's things like linked lists which each object each thing points to the next thing so you can only get to it from the beginning by going through all of them and boy I should make some other videos about all these things and there's stacks and cues and all this stuff a binary tree is a data structure that works like this there is a this idea of a node this is a node and I'm going to call this node the root of the tree and it and it has maybe a child two children two children nodes one the left one and one the right one it's a binary tree because each node can only have two connections two children other kinds of trees can have all sorts of variable amounts here here here so it looks like this now this is the way the data is organized but I said the data is sorted what do you mean that doesn't look very sorted I mean I could imagine this being sorted well strangely enough it's s it's it's sorted in quite a remarkable way and the way that you build a tree is by add adding nodes to it one at a time so let's use let's use numbers somebody shout out a number there's nobody there's nobody around I can't get anybody to give me a number oh well I'll have to think of one there's a chat going on but I can't see that far from here so let's say I have uh the number 10 I'm going to add these numbers 10 5 15 7 2 931 this is a list of numbers that I just sort of thought of in my head that I'm going to add so I'm going to add add to the tree first 10 so 10 the tree is empty so the root note gets the number 10 now I want to add five into this tree and right now the root node has two empty spots as soon as I make a node it gets two empty spots now five is coming in here and I believe if five is less than it should go to the left and if it's greater than it should go to the right Bo I hope I'm doing this correctly there's you know obviously it could work either way but there's a standard so five is less than 10 so it's going to go here and now this has a left and a right with nothing 15 15 is more than 10 it's going to go over here and this has a left and a right uh seven seven is less than 10 so it goes over here oh five it's greater than five so it goes over here and now this has a left and a right two two is less than 10 two is less than five two goes over here I'm I can't keep track of the way that I'm using dotted lines or not so this okay we got to get through the whole thing nine N9 is less than 10 it's greater than five it's greater than seven nine goes down here 31 31 is greater than 10 31 is greater than 15 so 31 goes here so actually I don't to just sort of erase these these are all the empty spots so this is the tree so how is this sorted let me tell you something this is most certainly sorted it's sorted because if I go all the way to the left watch this let's go to the left five let's go to the left two let's go to the left oh nothing left let's put out two now let's go back okay five oh now let's try oh sorry go to the left go back now we try to go to the right sorry go to the right nope so let's come back go up here five now can we go to the right yes seven go to the right nine oh actually Sorry Seven we should try to go to the left but we weren't able to go to the left um so we came back seven and now we go to the oh oh oh this is so hard let me do this again I don't know if I should edit this and come back but the algorithm of how we Traverse this tree is we want to visit every node visit a node and when we do that we want to go to the left which means that means visit the node to the left so we're going to implement a recursive algorithm a recursive function a function that references itself visit a node go to the visit the and so I should say start with the root and then visit left so we keep visiting left all the way as far as we can eventually we can't visit left anymore so then we might say you know uh print I'm just going to say print the value so we come up and print the value two what's the next thing we do is we visit the right so now we go down here there's nothing there so we come up here uh and then these are finishing where were we here now we we've finished visiting five so now we print out the value five and then we visit right seven what do we do when we visit seven we then go to the left nothing there so we come back and print out seven then we visit the right then we go to the left nothing there print out nine go to the right nothing there back back back here then we print out 10 then we go to the right and we try to go left nothing there 15 then we go to the right nothing there and nothing there 31 and we're done so this tree magically the way that the things are added to the tree end up in sorted order because what we're doing is we're basically saying I want to look here this is how it ties back to that phone book example oh my goodness can't believe I missed this if I want to find the number nine right let me find the number nine somewhere like I want to find this name in the phone book because the number nine might be associated with some actual important piece of information we need the nine just being like a key I can say is nine less than or greater than 10 and if this tree is balanced nicely meaning there's the same numbers on the left and the right I now have eliminated I don't have to search through half of the data whereas if I have an array and I need to try to find look through the array to find something in in unordered uh in an unordered array I have to check every single option so this is the structure how do we program this this is the next step okay so back over here we can see all of these nice visualizations of trees maybe I'll try to add a little visual something just so you can get how to would you get started with visualizing it but um but um hopefully that gives you an idea of what it's could be useful for talk about that okay um so now let's start to program this so what do I need how how would I even get started programming this well think about this I think I'm definitely going to need a node object so I'm going to write a Constructor function called node and it's going to have a left and a right and I'm going to set those equal to null just to sort of explicitly say when I make a node and the node should have some kind of value or label I guess I'll just use numbers maybe I should use text I don't know what's better but let's call it a label so I'm going to make it's like this sort of data at that node I'll call it value right so when you make a node it has a value and it has a left and a right which have no nothing connected so far let's make I think let's make a tree object to I don't know if the tree is really going to need anything but a tree is going to have a root node um and then also so that when the tree starts this do root equals null so the only thing when the things that's interesting about this data structure is I only ever need a reference to the root if I have a reference to the root by moving throughout the tree I can find any element okay so um uh what happens if two numbers are equal well we'll get to that that's a great question um okay so what I want to do I need a function I'm going to use prototype to attach functions so I want the tree object to have a function called add node and it gets a node as the argument and we first thing I'll do is just say if this. root is is equal to null then uh this. root equals n great so then let's say uh node n equals a new node well let's use numbers for right now because I think that'll be a little easier to see five and uh let's let's make a global variable just tree tree this should probably be called binary tree but tree equals a new tree and I have this node and tree. add node n okay so and then let me just say console.log tree so let's see so this should be um so by the way I'm using P5 here but there's actually nothing about this that I'm using there's nothing here that am I using P5 other than the setup function I have no canvas in there so it doesn't draw a canvas but I'm actually G to uh probably out and I have an error someone just pointed out if this do root equals null if I want to test if it's null I need a double equals and if I really really really want to test I could use triple equals someday I just want to make a video only about double equals versus Triple equals just such a funny little concept maybe I should do that before I leave today okay um so um there we go so now uh let's just take let's run this program uh where am I here uh oh I have an error error sketch touchs line one oh my goodness I've been programming in too much Java today this should be VAR tree right I don't need to give it a type and get this should be Varn boy I was programming in Java earlier today you can tell right okay oops wrong thing console.log not Capital tree tree that particular object there we go so we can see the tree has a root and has a node the root is a node with a left and right being null perfect okay here we go so we're in pretty good shape now what happens if I create another note and you know what you're I don't really need this variable here I can just do this I don't need a separate variable I could just say add a new node I could also if I really wanted to what if I just just to make things a little simpler I'm just say add a value five and I'm going to have this function create a node from it and uh and so this is really the same sort of thing but I this is just a little simpler now because I can have that function take care of that okay so what happens now if I say add value uh three now first of all was I write that things that are less than go to the left let's go back to the browser that binary tree yeah it looks like these examples uhoh whoa I don't know what this is oh boy I don't know what these what's going on with these binary trees what yeah this looks right so less than goes to the left uh some of these images are doing something slightly different than what I'm doing not should not rely on Google image search okay let's go back to my code so let's say I want to uh add node okay so I have another error this needs to be add I Chang this to add value I could just maybe I should just call it add but whatever so now what do I do if root is null it should be the root is that node so what if root is not null so what I need to do is say this do root add value so really what I should do this is interesting this. root add value um okay okay okay okay listen to this this is crazy so I actually um I'm losing my mind here ah uh okay otherwise here's what I want to do otherwise I got it this. root add add node sorry do add node n so okay what am I doing here so what I'm doing is I want to say if the root is empty tell to um just set it equal but what is this function this. root add node this means I need a function as part of the node that knows how to add something to itself oh this is great right so I need a node function node. protot type. add node equals function n so that's the node that's coming in now what happens if I'm a node and this comes in well I want to compare the value of n if n's value is less than my value if n's value is less than my value then this do left equals that node right it should be so if I'm adding it to myself if it's less it should go there otherwise this do right equals n but this isn't correct this is a nice idea right and it will work for just the root because when these two things are empty it will get added here but what if it goes to added to the left but there's something already there well needs to check against that one and that one it should then go to the left or and it should check against that one and then maybe that one it should go to the right so here's where I need recursion what I actually want to do is say this left add node um n or this. right add node n right because I want to just say keep going but what if this left is is null so if this there's probably more elegant way to write this if this left is null then it should be that value otherwise keep going same thing here if uh oh if this dot uh I'm I'm sure I I see a lot of chat messages telling me I'm doing something wrong so I'm sure I'll discover that in a second if this right equals null this. right uh this do write equals n uh else add no note line 17 uh oh Varn okay okay big deal that was all it was that was all it was because I keep writing note okay so I don't think I have anything hopefully I don't have anything majorly wrong now I'm sure there is I'm sure there's a way we could write this we could refactor this to be a little nicer but it is saying exactly what it's doing right if this value should go to the left if the left is empty perfect put it there otherwise recursively go and call that function again otherwise if um otherwise if it's um go to the right now here's the thing if it's equal I kind of want to do nothing right now so I think what I'm going to do with equal if the node is equal it just shouldn't go anywhere and so in that case I can say if else if this dot else if n.v value is is greater than this Dov value so actually in the case of those two values being equal nothing will happen so an equal value won't get added to the tree okay so let's take a look at this okay let's run this what am I what let's run this so the tree has a root which has a value of five and to the left of it has the value of three boy this is a really awkward way to look at it so we're definitely going to want to visualize this in some way to see if what we're doing makes sense but we can see that this is correct now if I were to then say add the value it's weird that I console logged it later and it was there add the value seven let's try that the tree has a root and the root has if I zoom into this a left the Root's value is five the left's value is three and the right's value is seven that's exactly right let's just try one more thing let's just I don't know let's add six that's a little bit tricky right but it should be six should go to the right of five to the left of seven so let me refresh this again the tree has a value of no the root has a value of five left is um whoops has a value of three sorry right has a value of seven and to the left of that has a value of six so this is no way to understand or see this is like I'm kind of used to this weird JavaScript console but the tree is there right and only thing I need to know is the root so remember remember how I said okay well what if I want to then look at all of the values or what if I want to search for I mean the whole thing was this is like a binary search tree the idea is we're storing all this information in this tree I could search for something in it so how do I Traverse the tree how do I Traverse the tree so let's just look at how we would Traverse the entire tree and this is exactly it to I want to start by visiting the root and when I visit the root I visit the left then I then I print out its value but and visit the right but that's done recursively so visiting the left means visit this left means visit this left until there's no left then come back then print out the value then visit the right Etc so this algorithm we worked out it's very hard to hold this into your head so recursion is new to you I think I have a video where I go over and look at like factorial fact the M make drawing some like recursive trees and fractal patterns you might look for some of those videos but this is a tricky thing to get but let's create a function now that's part of the tree prototype I'll call it Traverse and it is a function that says root. uh oh root. visit wait is this right so what I want to do is first visit the root node okay uh and then in the no you know what I need to do now I need to make some separate um separate files tree I'm going to make a file called tree. JS and I'm going to make a file called node node.js oh boy is that a problem uh node.js so if I go to sketch I just want to be able to pull this code out and look at it on its own so tree just has these three functions now the add value the're Traverse and the tree so the tree is just really a wrapper for the root that's all it kind of does the node is where all the sort of guts of the algorithm is is so I want to take all this node stuff and put it here in this file and here we go so now all I have is so far as the Constructor to create the node which has a value and a null left and right and then this add node function which recursively figures out where to to keep going through more and more nodes to where to add it now what I want to add is a function called visit and what does it mean to visit uh this. left dovisit this. right dovisit so I always want to go to the left first because I want the lower values first so that was definitely right and then I want to visit to the right but in between if I go all the way down to the left I if I want to actually do something I want to process the value or check what it is here's where I would say console.log this.v value so here's the problem is though I don't want to say this. left do this. left. visit if it's null so only if this. left is not equal to null and I know I could in JavaScript I could just say um as long as this left exists but just in Cas it could have the value of zero which is going to cause me a problem so um I'm going to I'm going to stick with checking to make sure it's null and if this dot right does not not equal to null uh this.right dovisit okay look at this so simple beautiful elegant I love this kind of stuff line seven I have something wrong in line seven no node. prototype thank you I love having a chat that debugs this stuff okay so here we go I think I just sort of typed this from scratch could this possibly really work so let's now um let's go here and see if in the sketch uh I'm going to now say tree. Traverse and I should just see all the values in sorted order okay tree is not huh tree is not defined oh of course I always do this I forgot to add a reference to these two new files I just invented a whole new JavaScript library called no. JS not really tree. JS there's a whole big serers side JavaScript programming framework called node so I feel like it maybe a little bit weird that I called my file node.js but we'll live uh okay root is not defined um do I forgot this dot clearly uh did I forget it anywhere else I don't think so let's run this again there we go look at those values 3567 okay let's try this in a crazy Funtime way because hasn't this already been so much fun let's say for VAR I equals zero I is less than uh 10 i++ Let's uh add a random number between zero and 100 and I'm going to floor it just so it's integers even though I don't really need to and I'm going to console log the tree and say tree. so I'm instead of hard coding the numbers I'm going to pick random ones and let's run it these look s sorted these look sorted these look sorted it's great and uh let's add a th that happened pretty quickly so I mean you know would have to now here's the thing let's let's go back to just doing this with 10 let's look at the actual tree the root has a node to the left which is 68 no the the root is 89 to the left is 68 to the right is 93 see again this is no way to look at it so we're done with the binary tree I didn't actually add a function that is um that involves searching the tree um which I probably should that would kind of make sense um but um so we could search so we could add that let's add that let's add a function that searches the tree and it's going to be very similar to Traverse so we're going to say tree. prototype do search equals function I'm GNA search for a value and we're actually just going to do the exact same thing oh sort of uh we're going to say this. root. search for Val so again the tree object is just a wrapper for the root and we're going to say search the root so now this visit function is going to be very useful because we're essentially doing the same thing um but what we're first doing is we're first saying does this. value equal Val right I first then I want to say console log found uh plus Val and then otherwise uh otherwise if this do value is less than no sorry if Val is less than this.v value then and and this. left is not equal to null then I want to and that's then I want to uh go and search for that value here and then I'm going to do the same exact thing for uh the right and I'm G to search for the value to the right so this is how I could just say hey is the root the value no but I'm less than it so just let's look at everything to the left so I don't need to this I'm not traversing the whole tree I only know need to go the One Direction that I need to go so um insert One Direction music right now okay so let's see if let's do this um let's see if this works so this what's in the tree right now all these numbers so if I say tree. search uh 53 this root search is not a function what did I do wrong uh oh I called it sorry I called it visit again this should be search let's do this again so I want to say tree. search um let's look for 61 found 61 can you guys see this refresh this again um well you can't see at the bottom there because it's cut off uh so let's do this ah sorry hold on um so let's do a tree. search and let's look for something that's not there so nine is not there undefined so that's pretty good I probably should have something where I mean that's fine I might want to explicitly somewhere say at the end return um return undefined or returned not found but I can basically say here now in my uh wherever I oh you know what I should just return so that's what I should do sorry when right when I found it what that's what I should do to make more sense right here I should say return uh I might as well return the node um return this so that's I found it at this node so I'm going to return the node and then at the end I believe if I just say return you know uh null so if it never finds it eventually it's going to recursively percolate through all these functions to get to the end and return null uh I think that's right so let's do this again so now let's say tree. search for 20 which I know is in there somewhere and oh I got undefined H uh uh oh you know what this is not the right place for this because right because it could be oh because it's equal no vertical bow TI mod wait wait let me take this out for a second I have to think about that tree. search uh four undefined what's wrong here what did I miss return this console.log found vow uh oh whoa this should say VAR found I don't know why I didn't have this in I didn't add the part I'm really sorry everybody my brain must have just melted uh I VAR found found equals this so if found is not equal to null console.log you know found and then I could uh I could put that object out otherwise console.log not not found I I don't know why I missed that so we're searching uh okay uh okay um so now I should say say tree. search uh 10 found 10 not found so why does that happen why does that oh oh oh no it didn't it found it but it said not found what am I oh oh oh oh oh my my returns is all my my return is all messed up let's think about this boy this is hard um search found oh no I'm in the wrong place oh I'm in the I'm I'm in the wrong place this is where I need I I just haven't really think thought about what I'm doing it helps to think about what you're doing what am I doing I want the tree this is the function I'm calling I want this function to return something it's printing out the right thing the whole point of this is not to print something out but to return the thing that's found return found that's all I need to do forget about all this I want to return found because I want to see it in the console somewhere else I might call it so that's I just kind of like got confused because I'm typing everything into the console which is a little bit confusing um so let's run this again and say tree. search 19 and uh hold on did I not save everything ah okay of course the problem is uh I need if I want to return a value you know one of the nice things about this visit thing is I I was just going through everything I wasn't worrying about returning a value so I would just call the next function but if I want to I I need to return the results of the recursive calls so I need this return and I need this return so this should really fix it so I'm going to refresh this now I'm going to say tree. search 12 and now I've got 12 but as I changed it to but I want to Let's return a reference to the full object doesn't really matter but uh tree. search Five and we can see I got the node now which has the value five I know what this laptop is kind of uh covering it so um so okay so that's how you search the tree and if by the way I search for something that's not in there I'm going to get undefined however I can put this back in just to be sure and I can get null so if what I want to do is is um you know now actually here I could say you know tree. search you know 10 let's just see if this tree has 10 in it and um and I could say now if result equals null console.log not found else uh console.log you know result so now I'm going to run this and 10 is not in there 10 is not in there 10 is not in there How likely is it it's going to put 10 in there oh it had one that found 10 so you know about one out of every 10 times there I can't can't stop Hing refresh stop find it find it find it find it please find it oh come on oh no what's wrong with me okay you guys get the point okay so this is a binary tree um hopefully what you've seen now just to summarize I think I'm going to in a separate video make a part two where I just add some visuals to it so that but that's what I want you to be thinking about well why would you this is an important data structure um that you can use to store information for binary search for sorting uh for dictionary of words there's so many possibilities but the key thing is what what kind of creative outcomes could you have here could you create some type of game which involves a binary tree and you have to add things and find things sort there's the sort of Plinko thing I made before make a binary tree we added some Physics to it just visualizing it is there something beautiful in the way that the binary tree you Traverse the binary tree recursively could you do some kind of nice animation I think there might be some unique possibilities there so I'm not very good at this kind of stuff any of it really but especially the visual stuff but in the next video I'm going to at least try to draw some of the tree so we can see um how it looks if we if we draw the sort of basic elements okay I'll see you there
