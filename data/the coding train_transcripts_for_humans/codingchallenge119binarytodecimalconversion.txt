With timestamps:

00:00 - (train whistle)
00:00 - - Hello and welcome to
what will undoubtedly be
00:03 - the longest video you've ever
watched about binary numbers.
00:07 - So why am I making this challenge here?
00:09 - So I made a coding
challenge number 117 called
00:13 - the Seven Segment Display
and what I was doing
00:16 - was creating a visual, a
JavaScript, HTML, canvas version
00:20 - of the Seven Segment
Display and to do that,
00:22 - I had some weird code in there.
00:24 - Val >> shift & 1
00:27 - and that code, that code right up there
00:30 - made no sense to anybody
and I tried to explain it
00:33 - but I got a lot of comments
saying I didn't get
00:34 - what this was so this is bit
shipping and bit masking.
00:37 - So before I can even get into
that, I thought let's take
00:40 - a deep breath and let's
just enjoy and go back,
00:43 - backwards in a time days of yore
00:46 - when we didn't have
anything but binary numbers
00:48 - and we had to program
everything in binary,
00:51 - I don't know, this never happened for me
00:52 - but I can imagine there was a
time when this really happened
00:54 - so this is a coding challenge
where I will explain
00:57 - what binary numbers are and
then I will create a sketch,
01:01 - p5.js sketch in JavaScript that converts
01:05 - a binary number to a decimal number.
01:08 - Okay so maybe you're even asking right now
01:10 - what is a binary number,
what is a decimal number?
01:13 - So before I can even answer that,
01:15 - we have to talk about this idea of base.
01:19 - Base is
01:22 - a term that refers to the
number of possibilities
01:26 - in a counting system, in a number system.
01:30 - So base 2 or binary, there
are only two possibilities,
01:35 - a zero or a one.
01:37 - Base 10,
01:39 - ten, dec, deca,
01:42 - or decimal has 10 possibilities,
zero through nine.
01:47 - There are other well-known
numbering systems
01:49 - that get used often,
probably the one you see
01:52 - in computing the most is
base 16 or hexadecimal
01:57 - and this actually has 16 possible digits,
02:01 - zero through nine and also A through F
02:04 - so when you see something like this in CSS
02:08 - like FF
02:10 - 00
02:11 - FF,
02:12 - this is hexadecimal in coding.
02:15 - This FF in decimal
02:17 - is 255,
02:19 - this 00 in decimal is zero,
02:22 - this FF is 255 so this is the color,
02:26 - this is a representation
of the color red of 255,
02:30 - zero of green and blue 255 so anyway,
02:32 - so this kind of encoding
of information exists
02:35 - and by the way in my
seven segment display,
02:38 - there were hexadecimal representations
02:41 - of what should be displayed
on the seven segment display.
02:44 - Okay so hexadecimal is interesting,
02:46 - I'm not going to do hexadecimal
conversion in this video
02:49 - but you know, it's important to realize,
02:51 - these are maybe something that you see,
02:53 - I think base 8 is used
for some file systems
02:56 - but you can make up anything.
02:58 - If you have base 4, you just
have four possibilities,
03:02 - maybe zero, one, two or three.
03:04 - And when I say possibilities,
this defines how you count.
03:09 - And by the way, historically
there are all sorts
03:11 - of alternative ways of counting.
03:13 - I believe, I was looking,
Aztecs used maybe units of zero
03:19 - then 20, then 40, then 800, then 8000
03:23 - and instead of digits,
they were actually drawings
03:27 - of what, so anyway, so
you can look that up,
03:29 - somebody will make a nice
explainer YouTube video
03:31 - of counting systems but if we have base 2,
03:35 - this means there are
only two possibilities.
03:40 - Let's use base 10 decimal
'cause we understand that.
03:43 - 10 fingers, 10 toes, that's
why base 10 is the convention.
03:47 - Zero, one, two, three, four,
five, six, seven, eight, nine,
03:51 - 10, 11, 12, right 'cause
once we get to nine,
03:54 - we've run out of possibilities
in a single digit
03:58 - so we switch to zero and
then the next digit over,
04:02 - the tens unit becomes a one.
04:06 - This is what kids learn
in elementary school
04:08 - in counting in groups of 10,
hundreds units, et cetera.
04:12 - All right but if I were
doing this in binary,
04:15 - I would say zero, then I would say one
04:17 - and then I have run out of digits,
04:20 - I have no more digits left,
so I have to say one zero
04:25 - and then one one and then,
uh oh, one zero, zero,
04:29 - then one zero one,
04:33 - one one one, I'm totally,
04:36 - this is the worst drawing ever,
04:39 - and then one zero zero
zero, did I get that right?
04:43 - No, I totally did not.
04:45 - One zero zero, one zero one, one one zero,
04:49 - then one one one and
then one zero zero zero.
04:53 - Oh this is hard.
04:55 - Okay let me match up some things for you.
04:57 - So something that's
really interesting here
04:59 - is one matches up with one.
05:01 - One zero matches up with
two, one zero zero matches up
05:05 - with four, five, six,
seven, one zero zero zero
05:10 - matches up with eight.
05:12 - Notice that when there is
only the leading digit one
05:15 - and everything else is a
zero, there's a pattern here.
05:19 - One,
05:21 - two,
05:22 - four,
05:23 - eight, maybe now you could imagine
05:25 - what one zero zero zero
zero is going to be.
05:29 - How about
05:31 - 16?
05:32 - Oops, sorry, 16, I should
put that over here.
05:35 - One, two, four, eight, 16.
05:37 - These numbers are doubling so in fact,
05:41 - each one of these digits
in binary represents
05:45 - not the tens, the twos.
05:48 - So with a one, this is actually one,
05:50 - this is actually two to the zero power.
05:53 - Two, this is two to the one power.
05:55 - This is two squared,
two to the third power,
05:58 - we're doubling so this is by the way
06:00 - the algorithm that I
need to write in my code
06:03 - to convert from binary representation
06:06 - to decimal representation.
06:08 - Are you ready to do that?
06:09 - I'm ready.
06:11 - So one thing I want to show you first
06:13 - is you can can actually, you don't need
06:16 - to write your own algorithm
to do this conversion,
06:18 - this is built in to the
way that computers work
06:20 - and actually JavaScript has
several helper functions
06:23 - that'll do this for you. I
think if I say for example,
06:28 - =0b, if I have a variable that's
=0b, I can put any encoding
06:32 - so what if I put one one
one one one one one one,
06:37 - now actually the value
of, that's actually 255.
06:40 - So this is, I can actually hard code
06:43 - a number in binary by saying 0b.
06:45 - I can also use this parseInt function
06:49 - so if I say parseInt and
give it a string like 255,
06:54 - just converts it, the string, to a number.
06:57 - But I could do things like say parseInt
07:00 - one one zero and then give it a radix or,
07:05 - that's another word for base,
and say what is the value,
07:09 - the integer value, the
decimal integer value
07:12 - of one one zero in base
2, right, it's six.
07:15 - If it were base 10, obviously it's 110.
07:19 - So this will actually be
done for you just through
07:23 - that parseInt function but
let's go and actually write
07:26 - our own algorithm for this,
yes, there is a bell ringing.
07:31 - (bell ringing) And let's
go to the web editor.
07:36 - So let's just assume
for the sake of argument
07:37 - that the binary numbers
that I want to work with
07:39 - are going to be strings.
07:41 - So I am going to make a number
and I'm going to make it
07:46 - a binary number and there's a thing about
07:49 - when you have 8 bits, that's
kind of important here,
07:53 - right, each one of these
is referred to as a bit,
07:57 - each spot in a binary number is a bit.
08:00 - When you have eight of
them, that's a byte.
08:03 - And so this has to do
with how things are stored
08:05 - in the computer's memory,
right, everything ultimately
08:07 - in the depths of your computer
is stored in binary format
08:11 - and the amount of space it
takes up is the number of bytes
08:13 - or kilobytes or gigabytes,
et cetera, terabytes.
08:19 - But I'm going to waste a
lot of space and encode
08:23 - my binary number as a
string so let's just say,
08:26 - let's just try something really simple
08:28 - like one zero zero and we know
that should be four, right?
08:33 - Zero one one zero, no that's not four.
08:40 - Yeah it is four, (chuckles) I lost my mind
08:43 - for a second there, right?
08:45 - This is zero, this is one,
this is two, this is three,
08:48 - this is four but we should,
yeah, if we do this right,
08:51 - we'll get four.
08:52 - Okay now I want to write a
function, I'm going to call it
08:57 - bin, binaryToDecimal, it'll
take in any arbitrary value
09:03 - which is a string and we could
make this much more generic.
09:06 - By the way, as a challenge
to you, what if you made
09:08 - a function like this which
is just number convertor,
09:11 - it takes a number and two
base, a base and a second base.
09:16 - So here's the number in a given base,
09:17 - give it back to me in another base.
09:19 - It'll be generic, that's
a challenge for you to do
09:22 - now or later or whenever you want.
09:24 - Okay, so the thing that
I need to do is I need
09:26 - to loop through
09:29 - the...
09:30 - Sorry, i = 0, i < val.length
so if it's a string,
09:34 - I'm going to loop through the
string one character at a time.
09:38 - So for each character,
the way to convert it
09:42 - is to add up all of the
twos so for example,
09:48 - one zero one is five
because it is one zero zero
09:53 - plus zero zero one is one
zero one and this is four
09:58 - and this is one so one zero one is five.
10:01 - So if I just start here
and take the first digit
10:05 - multiplied by two and
take the second digit
10:08 - multiplied by, sorry multiplied by one,
10:11 - the second digit multiplied by two,
10:13 - the third digit multiplied by four,
10:14 - add all those things
together and by the way,
10:18 - it's not just one two
four, it's two to the zero,
10:21 - two to the one, two to
the two, two to the three.
10:26 - So it's the exponent that's counting up.
10:30 - So I'm going to say sum += pow,
10:34 - now I need to get this value.
10:37 - So I need to get the zero or
the one so I'm going to say
10:42 - the bit =
10:46 - val.charAt(i).
10:48 - Now here's the thing, hmm, hmm.
10:52 - This is an interesting question here.
10:54 - What is i when it starts at zero?
10:58 - i is actually a string representation,
11:03 - this is the zero index
so even though I want
11:06 - to do the conversion
by starting over here,
11:08 - I'm actually over here
so I actually want to get
11:11 - to the end of the, I want
to start from the end
11:14 - of the array, or not the
array, the end of the string
11:16 - and a quick way that I
can do that is by saying
11:20 - val.,
11:22 - val.length-i-1,
11:25 - right, if there are three digits,
11:29 - I have
11:31 - two one zero, not zero
one two, two one zero.
11:34 - So three minus i minus one.
11:37 - So sum = pow(2, bit)
11:42 - and I need to make this a number,
11:45 - I'll just use parseInt
'cause it's a string
11:47 - and then let's just say console.log(sum)
11:53 - and I think we're done sort of (chuckles).
11:57 - Console.log(sum), let's see,
12:02 - let's do binary,
12:05 - binaryToDecimal(val) and
actually so this should return
12:11 - a num, sorry,
12:14 - and oh, there we go, four.
12:16 - Let's test some other ones out.
12:18 - Let's add another one.
12:20 - Six.
12:22 - Let's try one zero zero,
this is a byte, right,
12:25 - if all the ones are on in a byte, right,
12:29 - everything is on, eight bits is a byte
12:32 - and everything is a one, what do we get?
12:34 - Okay I need one more.
12:36 - Wait, what's going on?
12:37 - Something is wrong.
12:39 - No, this isn't right, I've made a mistake.
12:42 - This code is not correct
at all (chuckles).
12:45 - So remember, I am each
digit represents a one,
12:51 - a two, a four, two to the (i)th power,
12:53 - I actually even said that somewhere,
12:55 - sometime earlier I said
two to the (i)th power,
12:58 - maybe only in my head.
13:00 - So what I'm actually
doing is taking that bit
13:01 - and multiplying it.
13:03 - Now of course it's a string
so I have to convert it,
13:07 - the string value.
13:08 - Now this is what I'm looking to do and now
13:12 - 255, there we go, boy I
had, somehow I was getting
13:16 - some right answers by accident.
13:18 - So that should be four.
13:20 - This should be five, yeah.
13:25 - Whoops, we can't have
twos there (chuckles).
13:27 - That should be 18.
13:29 - So I should probably write
some error handling, right,
13:30 - because actually, this would actually work
13:33 - if I put a three in there,
it's going to give me a number
13:35 - but it makes no sense at all.
13:36 - So and once again, what I wanted to show
13:39 - was that eight bits all on gives me
13:43 - 255.
13:44 - And in fact, this is why
we see again the range,
13:49 - you can store 256
possibilities in a single byte,
13:53 - a byte being eight bits, 256 in decimal
13:57 - or two digits in hexadecimal.
14:02 - I'm getting some messages from the chat
14:04 - saying that maybe it
would be more intuitive
14:05 - to run the loop backwards.
14:08 - So yes, but then I have,
so it's six of one,
14:11 - half dozen of the other
as far as I'm concerned
14:12 - because I either have to invert it here
14:15 - or I have to invert it
here so I don't know
14:18 - which would be more, I
mean I could have a counter
14:20 - so you know I could do this, counter = 0
14:23 - and I could run the loop
backwards and then increase
14:26 - the counter but I don't
know, I'm going to stick
14:27 - with what I have, all right,
now, I said this was going to
14:31 - be along one and I'm going
to let it just be a long one.
14:34 - You want to stick around
and keep watching?
14:35 - You can go do something else
14:37 - but what I'm going to do is
now make this interactive.
14:39 - So I want to make something
where I can actually click here
14:42 - and I can turn on and off bits
and see the conversion live.
14:48 - So let's figure out how
we're going to do that.
14:51 - So I think I want to use some
object oriented programming
14:53 - and I am going to make a class.
14:57 - I'm going to add another
JavaScript file called bit.js
15:01 - and I am going to make a bit class
15:06 - and the bit class is going to have a,
15:10 - and let me take off this
auto refresh for right now,
15:12 - it's going to have an X.
15:17 - It's going to have an X and a Y
15:23 - and a width, like a size,
maybe I'll make it a circle
15:27 - so it's going to have a diameter.
15:29 - I'll use a circle to represent each bit
15:32 - and then it's going to have a state,
15:34 - right, it's state is
going to be on or off.
15:37 - Then I'm going to have a
show function or render
15:41 - I could call it where I'm
going to say a stroke 255,
15:45 - let's make the outline
white and should it be,
15:50 - I can never figure this
out, is black on, white on,
15:54 - I don't know, maybe I
should make it red and blue,
15:56 - we'll figure it out,
we'll see how it looks.
15:58 - So I'm going to say draw an ellipse
16:02 - at this.x,
16:05 - this.y, this.diameter
16:10 - and
16:12 - its fill is going to be
255 times this.state.
16:18 - So in this case, it would
be white if it's on.
16:21 - So what I want to do now is make an array.
16:26 - And let's just use eight.
16:29 - We'll do a byte so I can call this a byte,
16:31 - oh that's probably a
bad word for me to use
16:34 - 'cause maybe that's reserved
somewhere in JavaScript
16:36 - but let's say i = 0; i < 8; i ++
16:41 - and let's make
16:44 - a bit = new Bit(i, so
let's say I want to fit
16:49 - all eight across in my, and
I could use dom elements
16:52 - or something that's going to
be easier to interact with
16:54 - but I'm just going to
draw them as circles.
16:57 - So I am going to say, I
need to calculate a width
17:00 - which is the width of
the canvas divided by
17:05 - eight.
17:07 - So I'm going to say its
x value is i * width,
17:12 - its y value will be 50
17:15 - and its diameter will be w
17:18 - and I'm going to say byte[i]
17:23 - = that bit
17:24 - and I guess I don't need
a separate variable here,
17:26 - I'll just do this.
17:28 - And then I want to say here,
17:33 - I want to say byte[i].show.
17:38 - So what do we got?
17:39 - Oh, let me turn back on auto refresh
17:43 - and I've got some errors.
17:44 - Show is undefined.
17:47 - I see a show function.
17:52 - Oh wait, whoops, I put
these in the wrong place.
17:55 - The creation of them has to be in setup
17:58 - and
18:01 - this should go in draw,
ah, no, stop, don't, ah.
18:05 - All right, bit is not
defined, oh of course,
18:07 - I forgot that if I'm adding
another JavaScript class,
18:10 - I need to make sure I
reference it from my HTML file
18:15 - and now we're seeing and
if all of them have a state
18:19 - of on, hmm, I'm not seeing
anything, so let's see,
18:24 - oh, I've got to pass in
the arguments, x,y,d.
18:28 - So right now I want to set the arguments
18:31 - based on this, there
we go, there they are,
18:33 - there's all my bits and
maybe I want to offset them
18:36 - a little bit.
18:40 - And maybe I actually want this to be,
18:44 - their diameter to be, have
a little buffer in it.
18:50 - Whoops.
18:51 - There we go, so this is looking nice.
18:54 - There are my bits, thank you very much,
18:56 - oh I'm excited about this,
this is going to be good.
18:59 - And now if I take this
state and state zero,
19:03 - there we go, so now let's make this state,
19:05 - let's actually also initialize the state,
19:09 - I'm just going to write
that in a separate,
19:13 - I'm going to set state and
I'm going to actually say
19:17 - num.charAt(i).
19:23 - So I'm going to use the character,
19:26 - sorry I'm going to use the
individual character there
19:30 - to set the state of the particular bit.
19:34 - Now, set state is not a function
'cause I need to add that
19:36 - in here and I'm going
to say setState(state)
19:41 - and I'm going to say this.state
= and I'll add parseInt
19:43 - in here just to make sure it's a number
19:47 - and now,
19:49 - what's going on?
19:50 - Set state is not a function,
oh byte is not, of course,
19:56 - byte[i].setState, there we go.
19:59 - So now,
20:04 - as I change values in here,
20:07 - it turns those bits on and off.
20:09 - Okay, we're gettin' somewhere.
20:11 - Now what I want to do
is I'm going to add a
20:16 - decimal, I'm going to say decimalP,
20:19 - decimalP = createP,
20:23 - (vocalizing)
20:26 - What is, what am I doing?
20:28 - createP and then in the
draw loop and it's silly
20:31 - that I have a draw loop here,
I don't need to continue
20:33 - to draw but that's something
that we can revise later.
20:36 - I'm going to say, where's
that function binaryToDecimal?
20:44 - binaryToDecimal, I'm going to say...
20:52 - decimalP.html(binaryToDecimal(num)
20:59 - and so now we should
see it says undefined,
21:02 - ooh, oh, 'cause it's console logging it.
21:05 - I want to return sum, okay 182,
now you can barely see that
21:08 - so let me go to my CSS for
a second and add a color
21:13 - and guess what?
21:14 - I'm going to use hexadecimal.
21:17 - Will it actually do it?
21:19 - No I can use three F's 'cause
it'll but let's use six
21:23 - to do RGB and let's also make
the font size much bigger.
21:29 - Okay so now and let's
actually make this a,
21:32 - it's got this extra, 'cause
it's a paragraph element,
21:36 - actually this is so silly but
I'm going to make it a div
21:38 - just so it shows up up here, okay, so now,
21:41 - this is not interactive but I can do this
21:46 - and it does feel, it does
look inverted, right,
21:49 - this really looks like on, off, on, on,
21:52 - the way that I've kind of drawn this.
21:55 - Somehow the black color
looks like I've turned it on
21:57 - so I could probably make
the background much darker.
22:01 - If I made the background
51, yeah, so maybe this,
22:05 - I still, I don't know, it's so confusing.
22:07 - What if I made?
22:09 - I don't know which is which, you tell me,
22:11 - my visual design skills
are kind of a disaster
22:13 - but if I go back to this, but anyway,
22:17 - whichever way I think it is,
I could actually just say
22:19 - 255 minus this and now,
right, now it is colored black
22:24 - when it is on and I could
say one zero one zero
22:27 - one zero zero one, we can see 169, okay.
22:31 - Should I make this interactive?
22:33 - I mean I've gone on for
way too long already.
22:35 - Let's make, 'cause I need
to make this interactive,
22:37 - do you know why?
22:39 - Because the whole point of doing this was
22:40 - to talk about bit
shifting and bit masking,
22:41 - I'm going to get to that, that
I'll do in a separate video.
22:44 - Let's make this interactive.
22:46 - So what do I need here?
22:48 - I need some sort of function
to see if this bit contains
22:53 - a point so if, so what I
need to do is calculate
22:57 - the distance between this
point and its X and Y
23:02 - and then if the distance
is less than the radius
23:08 - which is the diameter divided by two
23:10 - and it's this dot diameter.
23:12 - And I'm going to call this toggle,
I'm actually just going to,
23:16 - I could return this,
I'm going to make this
23:18 - the toggle function, then I'm going to say
23:20 - this.state =, now if the state is a zero,
23:26 - I want it to be a one, if it's a one,
23:29 - I want it to be a zero.
23:30 - What's a nice way of doing that?
23:32 - I mean I could write an if statement.
23:34 - People are giving me great
suggestions like +1 module
23:38 - is 2 to the power of -1, I
think I'm just going to admit
23:40 - to myself that really
what I meant was for this
23:42 - to be true or false
(chuckling) so I'm going to,
23:46 - the state's going to be false
and when I say set state,
23:50 - I'm going to do parseBoolean, is
that a function in JavaScript?
23:53 - Let's see if it is and then
I can say not this.state.
23:59 - parseBoolean is not defined (chuckling).
24:03 - There's no parseBoolean?
24:05 - What if I do Boolean?
24:07 - Ah, there we go, okay so
boolean is a function I guess
24:12 - that will convert that to this
24:16 - and then here, what I want
to do is I could just say
24:19 - if this.state fill(0) and of
course this is rather awkward
24:24 - but I don't care, this is
how I like to write code,
24:26 - there we go, mm, mm this is no good.
24:31 - Oh you know what?
24:33 - Those are strings.
24:35 - So this needs actually to say parseInt.
24:38 - There we go, okay, we're
back, we're back baby.
24:42 - Okay, now this, boy,
there's lots of things
24:45 - you can improve, right?
24:47 - All right now what I can do
is make these interactive.
24:50 - So I can now add the
mouse pressed function
24:55 - and I can just say for and
I can loop through again.
24:59 - Once again, I can loop through
25:01 - and this should really be byte.length.
25:06 - I can do this and I can
loop through all of them
25:08 - and I can say toggle, oops,
no, and I can just call toggle
25:13 - with the mouse coordinates.
25:15 - So it's toggling, the toggling is working
25:17 - but it's not updated.
25:19 - Ooh, why is it not updating?
25:21 - Because, oh, I am converting the string.
25:26 - My function converts a string
so I could do something
25:29 - like make that, I could
make the decimal version
25:33 - of the number out of
the array of bit objects
25:35 - but I think what might
actually work nicely here
25:39 - is for to make the string out of it
25:42 - so what if what I do now is I say in here,
25:47 - I'm going to say, I'm just
going to use that same variable,
25:51 - num = an empty string
and then I'm going to say
25:55 - num +=...
26:00 - Oh this is in setup, sorry, in draw,
26:04 - +=, now I want to have a zero or a one
26:07 - because if I say this dots, byte[i].state.
26:12 - So this is where I have to use
26:14 - but I have to embrace
the ternary operator,
26:16 - it's something that I have never
natively really understood.
26:20 - It's never fit into my
brain but this thing
26:23 - called ternary operator
and it looks like this.
26:27 - The condition and if
the condition is true,
26:31 - this is the result, if it's
false, this is the result.
26:34 - We can make this happen right now.
26:36 - We can use that ternary operator.
26:39 - The condition is actually
just byte[i].state.
26:44 - Then I need the question
mark and this is so nice,
26:48 - I just need to have if it's true a one
26:51 - or a zero, it's false.
26:55 - Oh I need to say
27:00 - recreate that string, whoa,
look, it's going crazy.
27:05 - There we go.
27:06 - Look at this.
27:08 - Now, ooh so lovely, let's go, we did it.
27:12 - (bell ringing)
27:15 - Everybody, we did it,
I made a binary thing
27:19 - that you can click on bits and convert it
27:22 - to a binary number.
27:24 - Now here's the thing, oh boy, you,
27:25 - the creative person
watching, if you made it
27:27 - to the end of this video,
wow, you really are something.
27:30 - Thank you, I can't believe it
27:32 - because this was ridiculously long winded
27:35 - to just explain binary numbers
27:37 - but you now have the opportunity
27:40 - to make something creative here.
27:41 - What if you made, you could make a clock
27:43 - that displays the time in binary.
27:45 - Maybe you could actually also
show the hexadecimal value.
27:48 - You could actually make
this a form content editable
27:52 - that you can convert
backwards, how you convert,
27:54 - this is a thought experiment for you,
27:55 - I can come back and do another video,
27:57 - but how do you convert not
form binary to decimal,
28:00 - how would you convert
from decimal to binary?
28:03 - I'll give you a hint, it
has to do with division
28:05 - and the remainder, I think,
so there's so many things
28:09 - you could do, you can make
a more interactive version,
28:12 - you can make a counter that's sort of...
28:15 - Ooh this would be fun to
have this count up in binary.
28:17 - That's kind of like the clock.
28:19 - You'll be in color, other
ways of visualizing it,
28:21 - you'll come up with
something, I know you will.
28:23 - You always do.
28:24 - Thank you so much for
watching this coding challenge
28:27 - and I will, remember at
the beginning when I said
28:29 - the whole point of this was
talking about bit shifting
28:31 - and bit masking, I will come
back and I will do that.
28:35 - So that will be in a separate challenge.
28:36 - I'm going to add some buttons
for shifting and masking.
28:40 - (train whistle)
28:42 - (upbeat music)

Cleaned transcript:

(train whistle) Hello and welcome to what will undoubtedly be the longest video you've ever watched about binary numbers. So why am I making this challenge here? So I made a coding challenge number 117 called the Seven Segment Display and what I was doing was creating a visual, a JavaScript, HTML, canvas version of the Seven Segment Display and to do that, I had some weird code in there. Val >> shift & 1 and that code, that code right up there made no sense to anybody and I tried to explain it but I got a lot of comments saying I didn't get what this was so this is bit shipping and bit masking. So before I can even get into that, I thought let's take a deep breath and let's just enjoy and go back, backwards in a time days of yore when we didn't have anything but binary numbers and we had to program everything in binary, I don't know, this never happened for me but I can imagine there was a time when this really happened so this is a coding challenge where I will explain what binary numbers are and then I will create a sketch, p5.js sketch in JavaScript that converts a binary number to a decimal number. Okay so maybe you're even asking right now what is a binary number, what is a decimal number? So before I can even answer that, we have to talk about this idea of base. Base is a term that refers to the number of possibilities in a counting system, in a number system. So base 2 or binary, there are only two possibilities, a zero or a one. Base 10, ten, dec, deca, or decimal has 10 possibilities, zero through nine. There are other wellknown numbering systems that get used often, probably the one you see in computing the most is base 16 or hexadecimal and this actually has 16 possible digits, zero through nine and also A through F so when you see something like this in CSS like FF 00 FF, this is hexadecimal in coding. This FF in decimal is 255, this 00 in decimal is zero, this FF is 255 so this is the color, this is a representation of the color red of 255, zero of green and blue 255 so anyway, so this kind of encoding of information exists and by the way in my seven segment display, there were hexadecimal representations of what should be displayed on the seven segment display. Okay so hexadecimal is interesting, I'm not going to do hexadecimal conversion in this video but you know, it's important to realize, these are maybe something that you see, I think base 8 is used for some file systems but you can make up anything. If you have base 4, you just have four possibilities, maybe zero, one, two or three. And when I say possibilities, this defines how you count. And by the way, historically there are all sorts of alternative ways of counting. I believe, I was looking, Aztecs used maybe units of zero then 20, then 40, then 800, then 8000 and instead of digits, they were actually drawings of what, so anyway, so you can look that up, somebody will make a nice explainer YouTube video of counting systems but if we have base 2, this means there are only two possibilities. Let's use base 10 decimal 'cause we understand that. 10 fingers, 10 toes, that's why base 10 is the convention. Zero, one, two, three, four, five, six, seven, eight, nine, 10, 11, 12, right 'cause once we get to nine, we've run out of possibilities in a single digit so we switch to zero and then the next digit over, the tens unit becomes a one. This is what kids learn in elementary school in counting in groups of 10, hundreds units, et cetera. All right but if I were doing this in binary, I would say zero, then I would say one and then I have run out of digits, I have no more digits left, so I have to say one zero and then one one and then, uh oh, one zero, zero, then one zero one, one one one, I'm totally, this is the worst drawing ever, and then one zero zero zero, did I get that right? No, I totally did not. One zero zero, one zero one, one one zero, then one one one and then one zero zero zero. Oh this is hard. Okay let me match up some things for you. So something that's really interesting here is one matches up with one. One zero matches up with two, one zero zero matches up with four, five, six, seven, one zero zero zero matches up with eight. Notice that when there is only the leading digit one and everything else is a zero, there's a pattern here. One, two, four, eight, maybe now you could imagine what one zero zero zero zero is going to be. How about 16? Oops, sorry, 16, I should put that over here. One, two, four, eight, 16. These numbers are doubling so in fact, each one of these digits in binary represents not the tens, the twos. So with a one, this is actually one, this is actually two to the zero power. Two, this is two to the one power. This is two squared, two to the third power, we're doubling so this is by the way the algorithm that I need to write in my code to convert from binary representation to decimal representation. Are you ready to do that? I'm ready. So one thing I want to show you first is you can can actually, you don't need to write your own algorithm to do this conversion, this is built in to the way that computers work and actually JavaScript has several helper functions that'll do this for you. I think if I say for example, =0b, if I have a variable that's =0b, I can put any encoding so what if I put one one one one one one one one, now actually the value of, that's actually 255. So this is, I can actually hard code a number in binary by saying 0b. I can also use this parseInt function so if I say parseInt and give it a string like 255, just converts it, the string, to a number. But I could do things like say parseInt one one zero and then give it a radix or, that's another word for base, and say what is the value, the integer value, the decimal integer value of one one zero in base 2, right, it's six. If it were base 10, obviously it's 110. So this will actually be done for you just through that parseInt function but let's go and actually write our own algorithm for this, yes, there is a bell ringing. (bell ringing) And let's go to the web editor. So let's just assume for the sake of argument that the binary numbers that I want to work with are going to be strings. So I am going to make a number and I'm going to make it a binary number and there's a thing about when you have 8 bits, that's kind of important here, right, each one of these is referred to as a bit, each spot in a binary number is a bit. When you have eight of them, that's a byte. And so this has to do with how things are stored in the computer's memory, right, everything ultimately in the depths of your computer is stored in binary format and the amount of space it takes up is the number of bytes or kilobytes or gigabytes, et cetera, terabytes. But I'm going to waste a lot of space and encode my binary number as a string so let's just say, let's just try something really simple like one zero zero and we know that should be four, right? Zero one one zero, no that's not four. Yeah it is four, (chuckles) I lost my mind for a second there, right? This is zero, this is one, this is two, this is three, this is four but we should, yeah, if we do this right, we'll get four. Okay now I want to write a function, I'm going to call it bin, binaryToDecimal, it'll take in any arbitrary value which is a string and we could make this much more generic. By the way, as a challenge to you, what if you made a function like this which is just number convertor, it takes a number and two base, a base and a second base. So here's the number in a given base, give it back to me in another base. It'll be generic, that's a challenge for you to do now or later or whenever you want. Okay, so the thing that I need to do is I need to loop through the... Sorry, i = 0, i < val.length so if it's a string, I'm going to loop through the string one character at a time. So for each character, the way to convert it is to add up all of the twos so for example, one zero one is five because it is one zero zero plus zero zero one is one zero one and this is four and this is one so one zero one is five. So if I just start here and take the first digit multiplied by two and take the second digit multiplied by, sorry multiplied by one, the second digit multiplied by two, the third digit multiplied by four, add all those things together and by the way, it's not just one two four, it's two to the zero, two to the one, two to the two, two to the three. So it's the exponent that's counting up. So I'm going to say sum += pow, now I need to get this value. So I need to get the zero or the one so I'm going to say the bit = val.charAt(i). Now here's the thing, hmm, hmm. This is an interesting question here. What is i when it starts at zero? i is actually a string representation, this is the zero index so even though I want to do the conversion by starting over here, I'm actually over here so I actually want to get to the end of the, I want to start from the end of the array, or not the array, the end of the string and a quick way that I can do that is by saying val., val.lengthi1, right, if there are three digits, I have two one zero, not zero one two, two one zero. So three minus i minus one. So sum = pow(2, bit) and I need to make this a number, I'll just use parseInt 'cause it's a string and then let's just say console.log(sum) and I think we're done sort of (chuckles). Console.log(sum), let's see, let's do binary, binaryToDecimal(val) and actually so this should return a num, sorry, and oh, there we go, four. Let's test some other ones out. Let's add another one. Six. Let's try one zero zero, this is a byte, right, if all the ones are on in a byte, right, everything is on, eight bits is a byte and everything is a one, what do we get? Okay I need one more. Wait, what's going on? Something is wrong. No, this isn't right, I've made a mistake. This code is not correct at all (chuckles). So remember, I am each digit represents a one, a two, a four, two to the (i)th power, I actually even said that somewhere, sometime earlier I said two to the (i)th power, maybe only in my head. So what I'm actually doing is taking that bit and multiplying it. Now of course it's a string so I have to convert it, the string value. Now this is what I'm looking to do and now 255, there we go, boy I had, somehow I was getting some right answers by accident. So that should be four. This should be five, yeah. Whoops, we can't have twos there (chuckles). That should be 18. So I should probably write some error handling, right, because actually, this would actually work if I put a three in there, it's going to give me a number but it makes no sense at all. So and once again, what I wanted to show was that eight bits all on gives me 255. And in fact, this is why we see again the range, you can store 256 possibilities in a single byte, a byte being eight bits, 256 in decimal or two digits in hexadecimal. I'm getting some messages from the chat saying that maybe it would be more intuitive to run the loop backwards. So yes, but then I have, so it's six of one, half dozen of the other as far as I'm concerned because I either have to invert it here or I have to invert it here so I don't know which would be more, I mean I could have a counter so you know I could do this, counter = 0 and I could run the loop backwards and then increase the counter but I don't know, I'm going to stick with what I have, all right, now, I said this was going to be along one and I'm going to let it just be a long one. You want to stick around and keep watching? You can go do something else but what I'm going to do is now make this interactive. So I want to make something where I can actually click here and I can turn on and off bits and see the conversion live. So let's figure out how we're going to do that. So I think I want to use some object oriented programming and I am going to make a class. I'm going to add another JavaScript file called bit.js and I am going to make a bit class and the bit class is going to have a, and let me take off this auto refresh for right now, it's going to have an X. It's going to have an X and a Y and a width, like a size, maybe I'll make it a circle so it's going to have a diameter. I'll use a circle to represent each bit and then it's going to have a state, right, it's state is going to be on or off. Then I'm going to have a show function or render I could call it where I'm going to say a stroke 255, let's make the outline white and should it be, I can never figure this out, is black on, white on, I don't know, maybe I should make it red and blue, we'll figure it out, we'll see how it looks. So I'm going to say draw an ellipse at this.x, this.y, this.diameter and its fill is going to be 255 times this.state. So in this case, it would be white if it's on. So what I want to do now is make an array. And let's just use eight. We'll do a byte so I can call this a byte, oh that's probably a bad word for me to use 'cause maybe that's reserved somewhere in JavaScript but let's say i = 0; i < 8; i ++ and let's make a bit = new Bit(i, so let's say I want to fit all eight across in my, and I could use dom elements or something that's going to be easier to interact with but I'm just going to draw them as circles. So I am going to say, I need to calculate a width which is the width of the canvas divided by eight. So I'm going to say its x value is i * width, its y value will be 50 and its diameter will be w and I'm going to say byte[i] = that bit and I guess I don't need a separate variable here, I'll just do this. And then I want to say here, I want to say byte[i].show. So what do we got? Oh, let me turn back on auto refresh and I've got some errors. Show is undefined. I see a show function. Oh wait, whoops, I put these in the wrong place. The creation of them has to be in setup and this should go in draw, ah, no, stop, don't, ah. All right, bit is not defined, oh of course, I forgot that if I'm adding another JavaScript class, I need to make sure I reference it from my HTML file and now we're seeing and if all of them have a state of on, hmm, I'm not seeing anything, so let's see, oh, I've got to pass in the arguments, x,y,d. So right now I want to set the arguments based on this, there we go, there they are, there's all my bits and maybe I want to offset them a little bit. And maybe I actually want this to be, their diameter to be, have a little buffer in it. Whoops. There we go, so this is looking nice. There are my bits, thank you very much, oh I'm excited about this, this is going to be good. And now if I take this state and state zero, there we go, so now let's make this state, let's actually also initialize the state, I'm just going to write that in a separate, I'm going to set state and I'm going to actually say num.charAt(i). So I'm going to use the character, sorry I'm going to use the individual character there to set the state of the particular bit. Now, set state is not a function 'cause I need to add that in here and I'm going to say setState(state) and I'm going to say this.state = and I'll add parseInt in here just to make sure it's a number and now, what's going on? Set state is not a function, oh byte is not, of course, byte[i].setState, there we go. So now, as I change values in here, it turns those bits on and off. Okay, we're gettin' somewhere. Now what I want to do is I'm going to add a decimal, I'm going to say decimalP, decimalP = createP, (vocalizing) What is, what am I doing? createP and then in the draw loop and it's silly that I have a draw loop here, I don't need to continue to draw but that's something that we can revise later. I'm going to say, where's that function binaryToDecimal? binaryToDecimal, I'm going to say... decimalP.html(binaryToDecimal(num) and so now we should see it says undefined, ooh, oh, 'cause it's console logging it. I want to return sum, okay 182, now you can barely see that so let me go to my CSS for a second and add a color and guess what? I'm going to use hexadecimal. Will it actually do it? No I can use three F's 'cause it'll but let's use six to do RGB and let's also make the font size much bigger. Okay so now and let's actually make this a, it's got this extra, 'cause it's a paragraph element, actually this is so silly but I'm going to make it a div just so it shows up up here, okay, so now, this is not interactive but I can do this and it does feel, it does look inverted, right, this really looks like on, off, on, on, the way that I've kind of drawn this. Somehow the black color looks like I've turned it on so I could probably make the background much darker. If I made the background 51, yeah, so maybe this, I still, I don't know, it's so confusing. What if I made? I don't know which is which, you tell me, my visual design skills are kind of a disaster but if I go back to this, but anyway, whichever way I think it is, I could actually just say 255 minus this and now, right, now it is colored black when it is on and I could say one zero one zero one zero zero one, we can see 169, okay. Should I make this interactive? I mean I've gone on for way too long already. Let's make, 'cause I need to make this interactive, do you know why? Because the whole point of doing this was to talk about bit shifting and bit masking, I'm going to get to that, that I'll do in a separate video. Let's make this interactive. So what do I need here? I need some sort of function to see if this bit contains a point so if, so what I need to do is calculate the distance between this point and its X and Y and then if the distance is less than the radius which is the diameter divided by two and it's this dot diameter. And I'm going to call this toggle, I'm actually just going to, I could return this, I'm going to make this the toggle function, then I'm going to say this.state =, now if the state is a zero, I want it to be a one, if it's a one, I want it to be a zero. What's a nice way of doing that? I mean I could write an if statement. People are giving me great suggestions like +1 module is 2 to the power of 1, I think I'm just going to admit to myself that really what I meant was for this to be true or false (chuckling) so I'm going to, the state's going to be false and when I say set state, I'm going to do parseBoolean, is that a function in JavaScript? Let's see if it is and then I can say not this.state. parseBoolean is not defined (chuckling). There's no parseBoolean? What if I do Boolean? Ah, there we go, okay so boolean is a function I guess that will convert that to this and then here, what I want to do is I could just say if this.state fill(0) and of course this is rather awkward but I don't care, this is how I like to write code, there we go, mm, mm this is no good. Oh you know what? Those are strings. So this needs actually to say parseInt. There we go, okay, we're back, we're back baby. Okay, now this, boy, there's lots of things you can improve, right? All right now what I can do is make these interactive. So I can now add the mouse pressed function and I can just say for and I can loop through again. Once again, I can loop through and this should really be byte.length. I can do this and I can loop through all of them and I can say toggle, oops, no, and I can just call toggle with the mouse coordinates. So it's toggling, the toggling is working but it's not updated. Ooh, why is it not updating? Because, oh, I am converting the string. My function converts a string so I could do something like make that, I could make the decimal version of the number out of the array of bit objects but I think what might actually work nicely here is for to make the string out of it so what if what I do now is I say in here, I'm going to say, I'm just going to use that same variable, num = an empty string and then I'm going to say num +=... Oh this is in setup, sorry, in draw, +=, now I want to have a zero or a one because if I say this dots, byte[i].state. So this is where I have to use but I have to embrace the ternary operator, it's something that I have never natively really understood. It's never fit into my brain but this thing called ternary operator and it looks like this. The condition and if the condition is true, this is the result, if it's false, this is the result. We can make this happen right now. We can use that ternary operator. The condition is actually just byte[i].state. Then I need the question mark and this is so nice, I just need to have if it's true a one or a zero, it's false. Oh I need to say recreate that string, whoa, look, it's going crazy. There we go. Look at this. Now, ooh so lovely, let's go, we did it. (bell ringing) Everybody, we did it, I made a binary thing that you can click on bits and convert it to a binary number. Now here's the thing, oh boy, you, the creative person watching, if you made it to the end of this video, wow, you really are something. Thank you, I can't believe it because this was ridiculously long winded to just explain binary numbers but you now have the opportunity to make something creative here. What if you made, you could make a clock that displays the time in binary. Maybe you could actually also show the hexadecimal value. You could actually make this a form content editable that you can convert backwards, how you convert, this is a thought experiment for you, I can come back and do another video, but how do you convert not form binary to decimal, how would you convert from decimal to binary? I'll give you a hint, it has to do with division and the remainder, I think, so there's so many things you could do, you can make a more interactive version, you can make a counter that's sort of... Ooh this would be fun to have this count up in binary. That's kind of like the clock. You'll be in color, other ways of visualizing it, you'll come up with something, I know you will. You always do. Thank you so much for watching this coding challenge and I will, remember at the beginning when I said the whole point of this was talking about bit shifting and bit masking, I will come back and I will do that. So that will be in a separate challenge. I'm going to add some buttons for shifting and masking. (train whistle) (upbeat music)
