introduce some Concepts and talk about what we mean about computer security and network security because we're going to focus this topic more on network security we'll try and explain the difference what is security or here's a definition of computer security the protection afforded to an automated information system in order to attain the applicable objectives in preserving Integrity availability and confidentiality of information system resources so here's one definition coming from the National Institute of Standards nists an organization in the U.S that among other things creates a lot of Standards about security protocols and techniques and their view of what they mean by computer security so an automated information system think of a computer system whether it's one computer or many computers connected together some computer system we want to protect it to achieve some objectives and their objectives are preserving Integrity availability and confidentiality of some resources okay so protect our system to uh make sure well we preserve Integrity availability and confidentiality we need to define those three objectives and we'll do that on the next slide talk about what they mean here's another definition actually from the textbook by Stallings about network security measures to deter prevent detect correct security violations that involve the transmission of information so network security is about when we're sending information across some Network some computer network computer security is more General computer security includes network security but computer security also includes the security of the actual PC or computer itself okay so we can have computer security issues without having a network at all I need my own laptop I need to protect uh the files on it I may want to encrypt they are issues of computer security but not network security network security is when we want to send data between two computers or between many computers so we're going to focus in this course mainly on network security so some aspects of computer security will skip over or not cover and what's the main Network that we use every day the internet so sometimes referred to as net internet security but the first definition mentioned these three things confidentiality integrity and availability CIA the trial Triad of CIA as some people refers to it the most important objectives in securing a system we'll see some definitions a little bit later of those three again but confidentiality keeping things secret keeping information Secret a common objective is if I send information from one computer to another and that information is authorized for use only by that other computer or the user of the other computer I don't want someone else as I send it across the network to be able to intercept and read that information I want to keep that information confidential okay so that's the idea of confidentiality Keep information private or secret or confidential Integrity is making sure the information is not changed so it's related to confidentiality but we also want to make sure if I send information from one computer to another then the information received by the destination computer is exactly the same as what was sent by The Source computer it would be bad if I have an email message and I'm saying sending an email to someone uh what's an example I'm sending an email to the secretary saying change this student's grade from A to B no no that's a bad example change your student's grade from B to C okay I made a mistake with marking so I sent an email to the secretary saying this student needs their grade change from B to C but one of the students and that one uh that the email is about somehow intercepts the message on the network and modifies the message and changes the message to say change the grade from B to a it's received by the secretary the secretary thinks it came from me it did originally but it's been modified along the way that's what we don't want Integrity is about not allowing that to happen maintain the Integrity of the data that's a common requirement or objective of security and availability is the other common objective of security we have a network and we have a computer system which has normal users we want to make sure that Network and computer system is available to those normal users it would be bad if that Network becomes unavailable due to some malicious actions so an example is a web server web server is part of our Network or an entity in our Network it has the role of say the Amazon web server right it's just spread across many web servers but think of Amazon the company they sell many things via their web server they make billions of dollars by people going to their website and ordering products what if the Amazon web server was not available for 24 hours something happened there was an attack on the web server which mean it was down well I'm sure the company Amazon would lose millions of dollars in Lost sales if the web server was down for a day if no one could access access Amazon for a day then that would be a financial loss to the company so some security attacks try to make the service unavailable availability is the objective okay our system must be available to the intended users we shouldn't allow it to become unavailable another three key objectives of securing Networks some related ones or other ones which are also considered important this was one of the earlier um Concepts that people arrived at these three but they later added talking about authenticity make sure that the data you receive is authentic is genuine it's coming from a genuine user it's not coming from someone who's pretending to be someone else and accountability make sure that if something goes wrong we can track what went wrong and make someone accountable for what went wrong for example a student breaks into the ICT server and gets all the answers to the quizzes for this course so you can do the quizzes on Moodle and get 100 all the time okay if that happens what I would like to be able to do is to detect that it happened and even better Trace back to which student did it and then I can take action on that student outside of the network I can take other action like give them some penalty so accountability is the ability to uh detect things going wrong keep traces and logs of what happens so that later on you can respond and take action if things do go wrong in a network so some of the objectives of securing computer systems and computer networks what happens if something does go wrong what if we have a security breach how does it impact upon the users or an organization there are different different classifications to look at okay when we're planning this the security for our organization we'd like to predict in advance what if this goes wrong what are the consequences here's some of the most common impacts of security breaches the effectiveness of primary operations are reduced that means if you think of an organization a company a university sit what happens if someone breaks the security of our network of our databases of our service well one thing that can go wrong is that we have to spend a lot of time fixing and we waste time fixing what went wrong as opposed to providing the normal service to students and others that is the organization does not work as well if things go wrong a simple example I create an exam for this course I store it on my office computer before the exam you take before you take a midterm exam I created a week before and I've prepared it it's stored on my office computer what happens if a student accesses that exam one week before the time for the exam if I detect that what happens well it means I have to recreate the exam I must rewrite the exam because I know if some students got the exam most likely every student will have the answers by the time you sit the exam that reduces my Effectiveness that is I have to now rewrite the exam wasting my time rewriting a second exam I can spend less time doing other things that I should be doing so the effective effectiveness of my operations are reduced in that case other impacts may be a financial loss we lose money the example for Amazon if the Amazon web server goes down for a day because of some attack on the Amazon web server the company will lose money okay so that's a potential breach a potential impact damage to assets damage to hardware damage to software for example someone gets access to uh the source code of Microsoft Windows they break into the Microsoft network and gets access to the original source code and they make changes to the source code without people detecting so we can think that that's going to potentially damage the the software product that's produced you can have damage to computer hardware and the example I was recent is uh the stuff stuxnet worm was a worm one or two years ago which was distributed by usually by USB keys and it was a worm and we talk about worms in one of our topics actually no I've removed that course we may mention it I've removed the topic but some malicious software such that it was carried on a USB key and when people plugged it into the computer it distributed onto the network and the target of this malicious software was the I think the centrifuges in a nuclear power reactor okay and people think the target was one in Iran where this malicious software made this the hardware the centrifuge operate in an uh abnormal way for example make it go fast faster than it should go and which caused the hardware to break down which had the effect of then they cannot process the material that they wanted to process so that was a case of a soft malicious software which is part of a security attack that damaged some Assets in this case Hardware assets you've seen on movies or TV shows maybe that people can break into the heart monitors and the the uh the heart right controllers that people wear and in theory if you could attack that and make it do something that it's not supposed to do you could have a impact on someone and harm individuals okay so the impacts of security breaches may be very small I have to rewrite an exam to be very serious Financial human loss of life and damage to assets there are different approaches to from an organization's perspective to think okay in advance what are the potential breaches that can occur what are the likely impacts and to give some ratings to look at well what actions should I take to make sure those impacts are minimized and there are some standards that we won't go through that talk about that we need to treat security uh importantly we need to consider it carefully because the impacts may be large okay let's look at a a view of or a perspective of network security and the components of securing computer networks and this perspective comes from itu the international telecommunications Union they create standards about telecommunications including securing computer networks we don't care so much about that they created it and how the standard is uh there's some document that describes security aspects from their perspective we're going to use the notation and terminology that they introduce to talk about what we require for computer security and the main things that they introduced that we'll we'll use is that they talk about security aspects attacks mechanisms and services so we'll Define those three over the next few slides different types of security attacks mechanisms and services and some terminology we'll use as we'll talk about a threat and an attack we have some desire for operating our organization Network or computer system in some way and we usually Define some policy that we'd like for example a policy should be no student can access the exam on my computer okay that's obvious a simple policy from my perspective of who can access that information a threat is a potential violation of some security policy so my policy or my aim no student can access the exam on my computer there are some threats one threat is that a student walks into my office and takes my computer and then they can access the exam another threat potentially is that they can get remote access over a network to my computer okay so there are multiple threats that are potential violations of my policy in that case an attack is an assault on a system that comes from a threat in simple terms an attack is a threat carried out so the threat is that someone takes my computer and reads the exam well an attack would be if someone actually comes and grabs my computer and reads the exam so an attack is an actual implementation of a threat who performs attacks I'm not sure if there's a slide about this maybe later but some terminology for what do we call someone who performs an attack sometimes we'll talk about an attacker maybe a malicious user uh an adversary is another word used sometimes you'll hear a hacker someone hacks into the network okay I'll usually use malicious user or an attacker but when we talk about all the techniques through this course when we talk about the attacker or malicious user they don't necessarily have to be a bad person sometimes the attack may be coming from someone who's doing something good or something legal okay uh law enforcement agencies may use legal techniques to intercept other people's messages and read other people's messages from the perspective of the security technique they are the attacker or malicious user but they may be doing something good or legal so when I say malicious user I don't always mean someone who's bad often the case let's look at those three aspects what is a security attack mechanism and service an attack an action that attempts to compromise the security of information or facilities information or facilities so information data facilities think of Hardware or software or even communication lines compromise them to get access to information that they shouldn't be allowed to to modify information to make the system unavailable for example a threat is a potential violation of security an attack is an actual violation we usually analyze the threats look at what are the possible threats and try and Implement measures so that the attacks cannot occur or successful attacks cannot occur a security mechanism is a method for preventing detecting or recovering from an attack right I'd like to prevent attacks so if I know of some threat I would apply some mechanism to prevent an attack from being successful I know the threat for someone accessing the exam on my computer one threat is they take the laptop and then just read the file from my computer well what mechanism could I use in that case to prevent that attack what could I use sorry guessing yeah okay all right physical locks on the on the laptop what else yeah correct I I can't I can't uh secure my computer all the time physically what else could I do such that even if someone steals my laptop they cannot read the exam on my laptop encrypted password I hear okay some some basic techniques and we'll through this course we'll look at how effective they may be but okay if I have a password to log into my laptop such that if I leave it for five minutes I need to type a password again then that may provide some primitive protection we may see how effective it is later or I could make sure the file is encrypted so that to unencrypt to decrypt I need again some password or special key to read it more generally encrypt the hard disk even if someone can steal my hard disk access the computer log into the computer they still need some password to decrypt the hard disks so there may be ways to prevent or to they may be mechanisms there's a threat and we can apply mechanisms to try and prevent an attack but sometimes we cannot prevent an attack so the next best thing is try and detect if an attack has or is occurring uh maybe hard on the laptop but in some other cases we can detect that something's uh some attack is occurring and if we can detect either we can quickly try and respond or we can take other means to try and recover again if I detect if I could detect that if someone got hold of the exam I could trace it back to you then that acts as a good deterrence from you trying to access the exam because if you know it's very easy to steal my laptop but if you steal a laptop and read the exam if you knew I could trace that back to you as an individual then unlikely you're going to do it through that I know no one's going to steal my laptop anyway but if we had a malicious user there's active or the deterrence is also a good mechanism because if I can trace back to you I can take other action so there are different mechanisms for doing this for detecting preventing recovering and in fact this course is about those mechanisms we'll look at those mechanisms in this course security service we use the mechanisms to improve or enhance the security of our information and Facilities so we stop attacks we can think of the services as some requirements what we'd like to achieve so the next few slides go through services tax then Services let's go through a tax first now my example of the laptop is maybe not the best one for this course because we're going to focus on network communication so we're not going to deal with okay what if someone should uh steals my laptop but we're going to deal with the cases all right what if I send the exam in an email to the secretary to print can someone intercept across the network and steal the exam that way let's look at Security tax and classify them first classification of security attacks on networks passive and active a passive attack makes use of some information to perform the attack but it doesn't affect the system resources so the system consists of the users the computers and the network a passive attack doesn't modify how the system operates it just observes but still performs an attack uh all right we'll Define active and then we'll compare them in a moment an active attack somehow modifies or Alters how the system works the resources are operations yeah let's come back and talk about them after we go through some specific instances so with passive attack there are two types we'll talk about releasing the message contents and traffic analysis and then with active four types so I'm going to go through those six specific attacks and then we'll come back and explain again what we mean by passive and active you'll become clearer and we'll compare them so now let's go through six attacks and these nice pictures from the textbook I'm going to use to illustrate so we have a Communications network with some users this picture shows okay as the blue cloud as the network whether it's some link where it's the entire internet but some Network that users use to communicate with each other and in this example we have Alice and Bob to normal users of the network they're not malicious they're just normal users and Bob sends information to Alice that's the normal operation it sends emails or messages to Alice for example um Bob and Alice work in the same company and Bob is sending some secrets of the company to Alice some Secret Designs of their new product that they're going to build and sell okay now an attack where we release the message contents is one of the most obvious ones the one that most people think about when we talk about cryptography is that we have some malicious user da in this example that somehow as Bob sends messages to Alice's to Alice gets gets that message and is able to read the contents of that message so we show it as the message going to Alice and also going to Darth and Darth can read the contents of the message if the message is some Secret Designs of their up and coming product and if Darth is a competitor then he can go and build the product and sell it first so this is the case of an attack where we release the message contents same as of I send the exam to the secretary to print I'm Bob Alice is the secretary and some student intercepts somehow on the network and reads the exam then that's an attack that releases the message contents okay this is the case where we'd like to keep that message confidential note that and let's try and explain an active and passive this is an example of a passive attack imagine there's no attack Darth is not there then what happens Bob has a message and sends it across the network to Alice that is Bob sends one message Alice receives that same message no identical message if there was no attack in that case now we introduced the attack Bob sends the same message Alice receives that message but with the attack Darth also receives the message but from the perspective of Bob and Alice nothing has changed whether there's an attack or no attack from the normal user's perspective from the system's perspective nothing's changed and that's why it's called a passive attack nothing has been altered from the normal system operation but still one attackers occurred here's another passive attack traffic analysis Bob sends messages to Alice in the normal operation in this attack while Bob is sending messages to Alice Darth a malicious user somehow intercepts those messages may not be able to read the contents of those messages but can make some conclusions based upon observing the messages being sent the time when they're sent the frequency that they're saying for example so by analyzing the messages being sent by analyzing the traffic on the network the attacker the malicious user may be able to make some conclusions which they couldn't make without analyzing them an example uh uh Bob is let's say Bob is a a known terrorist okay law enforcement agency uh know that Bob is some terrorist there's some done some illegal things in the past and they're monitoring what Bob is sending and it turns out they also know Alice is at some potential terrorist and malicious user Darth here is the law enforcement agency that monitors how these two entities are communicating and by monitoring as to how many messages are sent at what time of day uh from what computer addresses they're being sent from they may be able to make observations about what potentially may happen for example they see that over a period of one month there are no messages and then on one day there's a lot of messages from Bob to Alice and they make the conclusion or they infer that that may mean that some attack is about to occur so by analyzing the frequency of communication the malicious user can make some observations even without seeing the contents of the messages even if they cannot see what's inside the messages just seeing that there are messages sent can be an attack and I think most of you heard about Snowden and the NSA and and what's happening with uh the the Revelation the NSA are monitoring many U.S citizens well it was revealed that they are monitoring not the actual phone calls not the contents of what people are saying on the phones but just monitoring who you're calling and when you're calling so that would be considered a traffic analysis attack to be able to make observations not based on the contents of the message but just off on who the messages are going to how often when they're going to people is some form of an attack it's still a passive attack with no attack Bob sends messages to Alice with the attack from Bob and Alice's perspective nothing changes so the system resources have not been modified going back to the first one how do we protect protect what's a security mechanism to stop the release of message contacts what's a mechanism we can use I send the exam to the secretary across the WiFi network and SRT I wanted to print it how can I stop someone from receiving the message and reading the exam contents what's a mechanism we can use I'm sure you know of of something you've probably used it in many cases anyone I could encrypt the message encrypt the file what I do is I take the exam file I encrypt it using some software and I don't send the original exam file I send the encrypted form of that exam across the network from Bob to Alice it's encrypted and what happens even though the malicious user may receive that message the encrypt encryption should be done such that without having some special secret a key or a password if you receive the message you cannot get the original contents back okay so even though the malicious user receives the message they cannot see the contents of the message so encryption is a common mechanism used to prevent such attacks and in a lot of this course we'll talk about well what is encryption and and what are the algorithms that can be used for encryption what about traffic analysis how do I stop some malicious user from analyzing the patterns of communications between Bob and Alice does encryption help encryption doesn't help in this case because Darth is not cat does not care necessarily about the contents of the messages even if they are encrypted he still sees that Bob is sending messages to Alice still knows the time of day how often how could I stop that attack stop someone from analyzing the traffic any ideas send send some flight messages change the pattern of communication so let's say normally Bob sends uh was is going to send three messages to Alice so I won every minute then and from that pattern of one every minute Darth makes some observations then what Bob can do is change the pattern in which they communicate by sending some fake messages in there uh standing at different times at different frequencies so by changing the pattern you may be able to hide your communication patterns not easy though okay and changing your patterns or Communications is a inconvenience as well it introduce introduces some overhead and some inconvenience for the users keep going another attack an active attack masquerade masquerade means pretend to be someone else Bob and Alice normal users Alice is the the finance officer for the organization Bob is the the CEO or the director of sit and normally what happens is that the end of the financial year Bob sends a message to Alice saying potentially about increasing or decreasing the salary of employees and when Alice receives a message from Bob she changes the the salaries in in the database well what happens in this case is Darth a malicious user pretends to be Bob sends Alice an email saying from Bob I am Bob please increase the salary of Steve by 10 000 baht okay so or in salary of Darth in this case one user pretends to be another user to do something malicious how do we stop that foreign how how can we stop some malicious user from sending messages pretended pretending to be from ball use some kind of digital signature signature all right correct and let's step back oh first we cannot stop Darth from sending messages to Alice normally okay so we cannot stop Darth from sending him to Alice what we want to do is make sure Alice can detect if it's from Bob or if it's from someone pretending to be for involved that's what we need to do the receiver needs to be able to verify the message that they receive who did it really come from and the concept is called Authentication the receiver wants to be able to authenticate who is the original source and one mechanism is using digital signatures will see other mechanisms in this course and that's related to this one of these famous comic on the internet nobody knows you're a dog because when someone posts something on the Internet or you visit a website you don't know what's at the other endpoint in the internet there's no inbuilt mechanism for authenticating users so it's very hard to trust what you receive on the internet a replay attack here Bob the director or the the boss normally no attack normally sends a message to Alice please increase the salary of Da by ten thousand baht okay that's the typical message because Darth did some good work celery rise one month later no when that normal message was sent Darth intercepted and took a copy of that message it was from Bob it had Bob's signature one month later Darth replays that same message sends it to Alice Alice receives a message from Bob signed by Bob increased the salary of Darth by ten thousand baht so now she's received two messages saying increase the salary of Darth by ten thousand Baht so it's now up twenty thousand Baht okay the first month and the second month so in this case the malicious user intercepts a message a normal message and at some time later resends or replays that message to achieve some outcome so a replay attack how do we stop that same message yes replay exact same message not modified and we need to keep track of time okay in the first message that Bob sends he dates this the message saying this is on the the 12th of November 2013. please increase the the salary by ten thousand if Darth replays that exact same message one month later Alice receives it in December but it says it's in November hopefully Alice is smart enough to realize that okay this something's gone wrong here let's take some action okay and of course this is just a simplistic example in Network protocols we can automate those techniques use timestamps still not easy modification attack Darth intercepts a message Bob sends a message please decrease the salary of Darth by 10 000 Baht that's what Bob sends to Alice but Darth intercepts changes decrease to increase and folds on the Alice Alice receives the message and it has increased the salary so here the malicious user modifies the message along the way replay the message is not modified it's an exact copy of a previous one another one which is different than the others denial of service attack we have some web server uh Bob normally accesses that web server to get his job done okay he needs access to the web server every day if you can't access the server then he cannot do his normal job and we start to lose money in the company what Darth does is sends many packets a lot of data to the server to overload the server once the server is overloaded no one else can access the server including Bob and Bob has been denied service the normal user is denied access to the the server in this case so a denial of service attack there are the six main classifications of attacks there are some other exceptions but these are common ones that we'll see the first two we were classified as passive attacks and the last four active attacks active because the best way to think is if there was no attack versus if there is an attack from the normal user's perspective does something change if yes then it's an active attack if no passive so in this case if there's no attack then Bob sends nothing and the server receives nothing but with an attack Darth sends something and importantly the server receives something so something's changed from the service perspective when the attack has taken place so we consider that active similar here modification attack Bob sends message a in the normal operation and Alice would receive message a in the normal operation but with an attack Bob sends message a Darth changes that to message B and Alice receives message B so from the perspective of Alice and Bob something has changed because with no attack Alice receives message a but with an attack Alice receives message B it's changed it's an active attack and you can look at replay and masquerade and see that they are active attacks as well so passive attacks don't modify the system resources the messages sent the contents of those messages an active attack does passive attacks are relatively hard to detect because they don't modify anything it's hard to detect that they're taking place but they're relatively easy to prevent by using encryption and time stamps we can see compared to the others easy to prevent those attacks active attacks harder to prevent it's harder to stop someone from sending the message you can't in fact normally but easy to detect even though I cannot stop I cannot stop Darth sending messages to Alice I can detect it using security mechanisms I can usually detect something's happening here using some of the security mechanisms we'll go through so six types of attacks and classification into active and passive so we said there are three aspects of security services are tax mechanisms we've gone through attacks let's look at services and different people have tried to to list the main Services needed in network security and itu is one organization ietf is another they've given definitions of what is a security service but let's go straight to a list which is one of the most common lists there are some variations some people divide it into six Services some more or less or use different names but you'll see that these are common Security Services in most Network systems authentication so these are the things that we want to achieve in a network to prevent the attacks Authentication make sure that the communicating entity is the one that it claims to be someone sends you a message you want to authenticate that message you want to make sure that the message you receive came from the person who claims to be the sender this was uh going back the Masquerade attack for example what we want is a server such that Alice when she receives a message can verify that that message came from Bob or not so that if we had such a service if she receives from Darth saying it's from Bob she can verify and see ah there's something wrong here this message didn't come from Bob so authentication is this service to make sure that we can verify where did the message really come from such that a masquerade attack cannot be performed or can can be detected at least sometimes we split authentication into peer entity authentication and data origin an example peer entities like making sure the person that send it is the the right person data origin Authentication uh make sure the data comes from a valid origin a valid entity not necessarily carrying which one in that case Access Control another service it's common that we want to control who can access particular resources on our Network in our computer system okay I sit has a as a network covering the the campus here we want to control who from outside in the internet can access the servers can access the WiFi can access the data in our Network so we need some Access Control mechanisms so the service is to prevent unauthorized use of some resource software resource Hardware resource data or some Communications Network an example of an access control mechanism is a firewall so sit has a firewall that sits between our intern our internal Network and the rest of the world and it has the role of stopping what data comes into our Network and also what goes out so it controls the access to resources inside our Network so that's another desired service in security systems data confidentiality this is one of the more obvious ones protect data from unauthorized disclosure okay I want to keep my data secret confidential it's a common service is I have my exam I don't want others to read it who are not authorized to read it so the service of providing confidentiality of the data data integrity make sure that the data received is the same as what was sent so I send a message the receiver should be able to confirm that what's received is exactly the same as what was sent it hasn't been modified along the way so if a modification attack is successful then it means we don't have the data Integrity service maintain the Integrity of the data being communicated availability skip five availability make sure the system is accessible for the normal users so think of the denial of service attack one of the last attacks there the service which we usually want is to make sure the servers the data the resources in general are available to the users as they're intended and the one we skipped actually let's go back to the other five some of the others first we'll come back to five in a moment availability is the desired service an example of an attack on that service is denial of service okay if Darth can perform a denial of service attack then we haven't got the availability service modification attack is an attack on data integrity because if a modification attack is successful then the data received is not the same as what was sent masquerade is an attack on authentication we should not be able to pretend to be someone else if we can we don't have authentication Service and confidentiality is an attack on releasing the message contents oh sorry another way around releasing the message contents is an attack on confidentiality what about nonrepudiation nonrepudiation to repudiate something is to deny something so the nonrepudiation service is we need to have the ability such that entities cannot deny something happening and the most common things is denying that we've sent or received a message let's say a oh Bob sends a message to Alice Alice receives that later Bob denies that he sent the message I didn't send it that can be a problem in some cases nonrepudiation is about making sure that Bob can't do that making sure that if Bob sends a message to Alice then later Bob will not be able to deny that he sent that message if he could that could cause problems and same from the other end point Alice should not be able to deny that she received the message that's the feature of nonrepudiation the sender cannot deny that they sent the message the receiver cannot deny that they receive the message we need that in a number of services financial transactions are important okay when we're buying something we'd like to be able to have some confirmation some proof that we've sent the money proof that we sent and proof that they received it such that no one can come back later and say I didn't receive it when they actually did so nonrepudiation is providing that service so that no one can deny something that happened these are the main things that we look for in securing computer networks we don't necessarily want all of them depending upon the goal of our network but we often want one or more of these services for my sending the exam from me to the secretary to print I want confidentiality I want to make sure that no one can intercept and read the exam and maybe I also want data Integrity I want to make sure that no one can intercept and modify somehow the exam and potentially we also want authentication that is the secretary wants to be able to be sure that the exam she just received came from me not from some student pretending to be me okay the other services are not so important for that application but for other applications we may choose different services so these are the things that we want in our computer network yeah to implement the services we use security mechanisms we've already mentioned some we've mentioned for confidentiality use encryption maybe use some time stamps some digital signatures these are mechanisms the techniques to prevent detect and recover from attacks there's no single technique that does everything okay so we usually combine there are multiple mechanisms and we use one or more to achieve some service and the most common mechanisms are built around crypto cryptography cryptographic techniques and that's what a lot of this course is about talking about what are these cryptographic techniques some examples are listed here but we'll go through these in the course encryption or incitement digital signatures Excel Access Control firewalls authentication exchange so there are protocols for authenticating users for hiding from traffic analysis traffic padding sending extra messages notarization have some thirdparty verify that two entities just communicated to avoid nonrepudiation so we'll look at some of these techniques in this course and another view of those techniques the services listed and some techniques and sorry some mechanisms and which Services those mechanisms are used to implement for example to provide confidentiality we normally use incipherment or we'll call it encryption to avoid non or to provide nonrepudiation we use digital signatures and data Integrity techniques what we're going to do in this course is look at encryption and then a fair bit of time looking at digital signatures data Integrity Authentication some of the others we'll touch upon and that's our introduction to security the next topic and the next several topics are about encryption how do we encrypt data and we'll look at it from different perspectives starting with some very very simple encryption techniques simple insecure but demonstrate the concepts that's finishes for today Thursday next topic classical encryption techniques between now and Thursday I'll assume that you've browse the website you have any questions you ask me Thursday or or before next week and then we'll continue with how do we do encryption foreign go into block ciphers and and uh and the main example of the Box hyper death we'll just recap on what we know or some parts what we know from classical Cycles we went through several example very simple ciphers starting from 2000 years old the Caesar Cipher and they were transposition techniques we Sorry Wrong Way Around substitution techniques we substitute one element with another we use English characters so we were substituting a h with a J for example and then there were transposition techniques where we take the plain text set of characters and rearrange them transpose you change the position of the characters uh did we finish actually I think we've got we can go back to that one last transposition techniques we got to rail fence uh we still have one more thing to do we got through some examples of the two transposition techniques just two basic ones Trend rail fence where we write the plain text in a set of rows writing the first letter in the first row the second letter in the second row and so on so that the key impact was the depth the number of rows and then we finished with an example of Rose columns transposition where again we write our plain text in rows and then the key determines which columns we read first to get our plain text sorry to get our ciphertext so we we write security and cryptography in a set of rows and then the key is a set of integers that says the second column is read first because the one is in the second position of the key the fifth column is red second and we read column by column to get our cycle Tech so we had an example of that both of them simply rearrange the letters this tries to this example tries to illustrate the case that when we repeatedly apply the same algorithm we can improve the security of their resulting ciphertext and this simple case uses a Rose column Cipher so we're not do it on the I've got the answers here we start with some plain text attack postponed until 2 am XYZ the XYZ we're going to use to to pad out so we've got a a correct number of characters because our key four three one two five six seven tells us that we're going to have to write this plain text in seven columns and with seven columns I think the if you count the characters how many are there anyone count for me how many characters 28 I think I hope so how many characters in the plain text yeah 28 characters we'll see here I've got numbers okay 28 characters seven columns so we write our plain text in four rows 28 divided by seven and then so attack posts so the first seven letters and in the first row the next seven letters in the second row and so on and then to get the ciphertext we read the third column because the one in the key is in the third position read the third column so down and that produces ttna so if you look at the third column you'll see TT and a under each other and then we read the fourth column because that's where the 2 is in the fourth position and we'd get this ciphertext so you can try that in your own time we're not going through it now what we show and we'll do it again in a moment but what we show here is let's not worry about the individual letters let's look at the ordering and see how the transposition rearranges the let these letters and see the patterns let's say we number these 28 letters from 1 through to 28. and I can't fit it all on one line so I've wrapped across two lines so a t t a c k p and so on that's how we interpret so one two three Twenty Eight that is character 28 in our plaintiffs so just number them one through to 28. and we get these then we apply the rows columns transposition Cipher and we get this ciphertext but remember transposition transposition we just rearrange so if we follow where do the letters end up where does the first letter a end up in the ciphertext that's what this set of numbers tell us the first letter 0 1 here ends up in which position it's here the 13th letter I think it's this a here if you follow through the cipher you'll see that this a ends up here or if we look at it numbers the first letter in the plain text ends up in the 13th position in the ciphertext after that uh rearrangement after the transposition the third letter in the plain text which was a T ends up in the first position of the Cyber text actually moves to here when we apply this out so that's all these numbers are showing us how did we rearrange them because we want to do some analysis and see how good this rearrangement this transposition is so if we start with some plain text after applying our Cipher we get this arrangement of the letters now look at these numbers on your on the screen on the print out in front of you look at this set of numbers what pattern do you see look at this set of numbers describe the pattern you see if you just tell me if you see any pattern if so what is the pattern just look at the numbers yep foreign I will check that later okay all right thank you someone made a point that maybe there's a mistake in one of these uh and you good chance of being correct maybe a mistake in one of these but we'll survive with this mistake until later okay I don't know uh but I think it won't make any difference maybe once one letter has shifted but I'll check that later looking at the coming back to these numbers this is let's say it's all correct this is the output uh after the first encryption what pattern do you see in these numbers just looking at the numbers does anyone see a pattern so look at those 28 numbers do you see some ordering of the numbers that make some uh some pattern make some sense was it all random these numbers random what's the pattern we see what do you see there plus seven okay look at the numbers easy I don't ask complex questions okay look at these numbers 3 10 17 24. there's a difference of seven between these four numbers just incrementing all right 24 to 4. oh that's strange that's not a difference of seven but four 11 18 25 a difference of seven okay if I ask you does this sequence of numbers look random yes or no hands up for Yes do they look random so they look random this sequence of numbers if I tell you here's a random sequence 3 4 3 10 17 24. I think you'll start to see a pattern a random sequence should not have any pattern there should be no structure in a random sequence this has some structure that we can obviously see 4 11 18 25 a difference of seven 2 9 16 23 a difference of seven so every four digits every four numbers have a difference of seven why or the way that the rows column Works in that we have seven columns every four numbers because we have 28 characters seven columns groups of four the point is when we apply a cipher we take some structured plain text we'd like to get random looking ciphertext ciphertext should be hard to work out what the plaintext is so it should be we say simply random looking this is obviously not random we can easily see the pattern so it's not very secure this this Cipher on its own but if we take this ciphertext and apply the exact same Cipher with the same key again on the ciphertext we and you can check we get this cytotext as an output and instead of looking at letters we look at where do the original plain text letters end up after the first transposition the first letter ended up in the 13th position but after the second application of our Cipher the first letter ends up in wherever the 20something position here similar the third letter of plain text the T after the first time we applied the cipher went to the first position of the output but then we apply the cipher again on this and that third letter moves to here the 13th position now look at these numbers sequence of numbers 17 9 5. 27 24. tell me the pattern you see so in the in the previous sequence we saw this difference of seven what do you see in the next sequence try and find it look at those numbers at the bottom of the slide and see what pattern you see between the numbers if any these ones of course I think you'll quickly see our difference of seven has disappeared we don't have a difference of seven between uh the neighbor numbers 17 down to nine some difference of eight down to five minus four but up to 27 plus 12. okay there's uh some differences in how they differ between those numbers anyone else anyone want to guess not so obvious to see any pattern in these numbers to me and I hopefully to most of you that are following these sequence of numbers look more random than this sequence of numbers this one we can see a pattern plus seven plus seven plus seven and then plus seven seven and this one there's no similar pattern no obvious pattern at least now going down and then up the point is that the second output of applying a cipher is more random if we can say that then the first application and less of an obvious pattern in this case using the same Cipher and leads to a more secure ciphertext what we'd like is a cycle text which is completely random that is there's no pattern that can be observed by the uh by the attacker the point is here that by applying the transposition twice we've improved the security of the output cytotext and it's a concept that's applied in most ciphers today take some simple operation rearrange these letters and repeat it multiple times so after the first application maybe the output is not very secure but after you apply it again it's better and again and again and again it keeps mixing things up and the more mixed up it is that the harder it is for the attacker to take the resulting ciphertext and work back and find the original plain text so this is an important concept that we use in in real Cycles apply simple operations multiple times and similar with substitutions not just in transpositions so we've covered the two main techniques substitution transposition last one what's the message for those who haven't sat in my lecture before what's the plain text give you one or two minutes here's a message you receive it has a hidden message what is it and then we'll come back and explain what we're doing in this one there's a hidden message in there it's in fact a real message but there's um secret hidden it's some real message between two professors or two two people at a university someone sending a greeting to George you don't want to have an attempt what the first word second word okay he has election Nights from last year he's got it anyone else what's the message we'll come back give you a chance let's explain what we're doing this is another uh a different thing than what we're going to cover in this course steganography this is the process of hiding a real message inside a fake but meaningful message so what we do is I send some message that makes sense not encrypted so I send this letter to someone but inside that real message that inside that message that makes sense I hide another secret message one that I don't want other people to know this is the process of steganography and this assumes that the person who receives this message knows the method I'm using to hide the secret and there are different examples of how to hide a secret in some other message in the old days for example a Written Letter you write a letter and you put small pinholes above the characters that make up your secret message and if you hold it up with a light or you hold it so you can see the pinholes then you identify the characters and read off the secret message or some form of invisible ink where you write a normal message but something's marked such that there's some secret identified in there as well we'll see in the next slide our secret message in a moment today more practical you send an image or a video across a network say a jpeg and you modify that jpeg a little bit such that some bits in the binary representation of that that image make up some hidden message the output is that from the user's perspective it doesn't look like the image is any different from some original image some bits are changed meaning maybe some pixels change in color but from the human eye it's hard to detect but in fact there's some coded message included and similar can be done with videos this is not encryption but we can use it for a similar purpose of hiding a secret and communicating between two entities and the advantage of this compared to encryption is it doesn't look like you're hiding anything I send someone a normal message from an attackers or an observer's perspective they cannot doesn't look like I'm communicating a secret to the other person and that can be a benefit sometimes for example to avoid traffic analysis the problem with steganography is that once the attacker knows how I'm hiding the message message they can find everything that I've sent in those messages and it can be inefficient in that I need to send a large amount of information to get a short message from A to B we're not going to cover steganography in this course but it's an interesting thing for you to do outside of the course I will finish anyone else have the message what's the secret well George knows the procedure in this case George knows when he receives this message from an attacker's perspective it just looks like a normal message or email or letter someone would send someone in a university but George the receiver knows the method is to read the last word of each line try the last word of each line your package ready Friday 21st room three please destroy this immediately chaos yours okay so here's the secret message included inside this fake message of course it once you know that method read the last word of each line it's very easy to see and it's very easy for the attacker to find it but if you don't know the method it's hard to find what that secret is but again steganography will not cover that anymore in this course what's the best Cipher we've got so far which Cipher is the most secure I've gone through Caesar mono alphabetic uh play fair visionaire onetime pad rail fence Rose columns they'll all be in your quiz online and all be in your quiz next week in the lecture which one's the best of those seven one time pad is the best in terms of security okay so it's the most secure and in fact it's the most secure Cipher that we know of we saw the onetime pad we applied the Caesar Cipher changing the assuming we had a random key as long as the input plain text thank you can implement the onetime pad in practice as an exclusive ore let's move from English to computing and instead of A to Z we'll look at zeros and ones binary I don't think you have this one sorry but uh let's you don't need it it's just an example no need to copy it down let's just have a quick look and just demonstrate that okay I want to send a message so this is actually an example of a Brute Force attack but that's not so important I have a message hello I want to send that to someone well we represent that in binary so how do we do that we can use an ASCII conversion where we do a look up and see the upper the letter uppercase H converts to some seven bit value and I've done that and it turns out that uppercase H corresponds to one zero zero one zero zero zero you look up in an ASCII table and it'll tell you that and similar to the other so we can treat any messages binary and we'll do so when we look at our cyclists from now on zeros and ones and a second example okay let's say we have the message Steve is what we want to send then here's the binary form of of the four letters and of course e is repeated at the end so in decimal from the ASCII table and the binary form so Steve can be represented as a seven by five 35 bit sine text value so now from now on we're going to deal in binary for our Cyprus not with English characters one operation that we you can use to encrypt and it becomes in fact a onetime pad is to take our plain text and apply the exclusive or operation take the plain text input and exclusive or with a key and it's the same as the onetime ad that we saw where we take our plain text as a set of letters and apply the Caesar Cipher where our key is as long as the plain text if our key is as long as the plain text and random just applying the exclusive or between the plain text and the uh key and I I would not show the example yet the plain text and a key is the same length as the plain text will give us ciphertext which is perfectly secure there'll be no way for the attacker to take that cycle text and determine the correct key nor uh do a Brute Force attack so exclusive war is a way to implement a onetime hat hey remember exclusive or zero X or zero zero xor one One X or zero One X or one when they are different one is the answer when they are the same zero as the answer zero X or zero is zero for example we're going to see xor used and some other operations used when we look at our real sites so just a warning let's treat everything as binary from now on so let's look at some real or a real Cipher and the first generally the concepts of block ciphers the principles so we're going to talk about block ciphers but first we need to Define what do we mean by block Cipher well there's an alternative a stream Cipher and we distinguish sometimes between stream ciphers and block ciphers and the main difference is on how much of plain text that they operate on at a time stream Cipher typically operates and encrypts one bit or more commonly one byte at a time block Cipher usually encrypts say 64bits or 128 bits at a time see some examples we will not cover much of stream ciphers yet we'll see an example later uh stream ciphers normally use some plane take some plain taxes input and generate some random sequence of bits and apply the xor operation exclusive ore between that random sequence of bits and the plaintiffs and get our type so stream ciphers usually use exclusive ore and the complexity of stream ciphers is in generating a random sequence of bits so we'll return to that later when we look at random numbers how do we generate them the onetime pad is an example of a stream cycle assuming we have a random a long random sequence of bits that's our key simply xor with the plain text and you get your side effects block ciphers operate on some block of plain text at a time typically 64 or 128 bits in most ciphers will see we take the input bits and apply some encryption algorithm and we'll see that usually much more complex than just an exclusive ore and we get our site protects as output and of course that encryption algorithm takes a key as input we're going to focus on block cycles for now we'll return to stream Cycles later and discuss the differences so some characteristics of block Cycles in fact this is a characteristic of any site but we need uh reversible mappings what a cipher does is take some plain text and produces ciphertext so it Maps the plain text bits to a set of ciphertext bits perform some mapping these bits become these other bits reversible means that we must be able to successfully decrypt if we have some mapping as defined in this table where we have two bits of plain text at a time a block size of two bits and we Define the mapping that if we encrypt 0 0 we get one one as an output if we encrypt 0 1 we get one zero one zero maps to zero zero one one mapped to zero one then this mapping is reversible because if we take our ciphertext we can get the original plain text back if my plane ciphertext if my ciphertext is one one then I know for sure the plain text is zero zero because we have a onetoone mapping the table on the right here is an example of an irreversible mapping if I encrypt plain text 0 0 I get one one zero one maps to one zero one zero to zero one one one zero one now I received some psychotics I received the psychotex zero one what's the plain text if I receive 0 1 I need to decrypt and get the original plain text back but I cannot do it because if I have cytotec zero one I don't know whether the original plain text was 1 0 or 1 1. so it's not a reversible mapping we cannot do the opposite mapping so we must have a onetoone mapping between plain text and scientists the plane text cannot map to a different plane tanks cannot map to the same value cycle text that's the principle otherwise we cannot decrypt so let's look at let's look at a cipher and and then talk about a block ideal block Simon uh you have the one I'm about to show it's an example of an ideal block cycle you have this in your lecture notes we'll start with a very simple block Cipher that will treat it as a mapping and it Maps two bits of plaintiffs to a set of possible ciphertext values so if you find this one I'll show just the mapping and explain it on screen let's say our block size is two bits that means what we do when we we have a plain text message to send let's assume we have a cipher that encrypts two bits at a time okay we take two bits of plain text encrypt and get two bits of ciphertext then we take the next two bits of plain text and get two more bits of ciphert X and we keep doing so that's our encryption approach so we can think of the cipher as mapping two bits of plain text to two bits of ciphertext what this diagram and it's from the printout you have it shows all possible mappings for every two bits of plain text given 24 different keys so we have a twobit Block in this example that means our plain text and our ciphertext will be two bits long if our plain text is longer we separate it into blocks so what this diagram is showing is that if we just look at the Top If my plain text is zero zero and if I use key one then the ciphertext will be zero zero as an output that's one mapping using the same key key one plaintext01 output is zero one and one zero goes to one zero one one one one there's one mapping using a particular key so how many possible plain text values do we have we see there are 2 to the power of two possible input Playtex this is I think on your handout with a 2bit block Cipher there's a set of plain text values we can have is four to the power of two and we've listed them in the first column and our Cipher Maps plain text bits to ciphertext bits how many possible mappings do we have and the answers in front of you it's on the screen or there are 24 possible mappings all listed here so the first 12 are on the top and the second twelve underneath that there are 24 possible mappings from those four plain text values just reversible mappings to ciphertens values y24 what's the equation how do we get 24 4 factorial there are four factorials 24 in this case we have four inputs we can rearrange them in how many ways well you can check and see that this this all 24 possible rearrangements of that four by three by two by one our 24 or 4 factorial arrangements or combinations so if you look at the first column at the top you'll see that's a one arrangement of those four values and so this is one of the arrangements and with K2 that's a different Arrangement and so on so we have a total of 24 possible different Arrangements of those four values and they are our possible mappings from plain text disciples what arrangement do we use to encrypt well that is the key that is the key for our Cipher so this is a definition or this is an example of a ideal block Cipher so how it works is we take some plain text as input and we encrypt and producer ciphertex as output where the input the encryption is also a key that's our normal operation for example plain text zero one the encryption is defined by this all of this data here plain text zero one okay we find the plaintext value and then the key determines which mapping do we use of those 24 possible mappings so if for example we have a key of if we choose a key of k17 for example key 17. mapping 17 in our list what's the ciphertext well plain text01 plain text 01 the third row key 17 mapping number 17 the output will be zero zero as a cycle text plain text sorry line text is zero one let's try that again plain text is the second row zero one key seventeen output 0 1. p17 plain text zero one output 0 1 for this case so here's a cipher what we do is we take all possible plain text values and Define all possible mappings or all possible Arrangements of those plain text values and the key determines which arrangement we use to determine the ciphertext this is what we call an ideal block cycle we can Implement any block cycle alignments how big is the key what is the key length in this case what is the key I said key k17 well the key tells us which mapping to use so k17 means use mapping number 17. so what the the source does the sauce that has the plain text they have this table these tables they Define the mappings all possible mappings and they take their plain text and they choose the secret key and they get their ciphertext they send the ciphertext to the recipient the recipient must have the same set of tables to decrypt but in fact the key can tell us the mapping to use k17 we could write as those eight bits which I did these eight bits k17 we can say is one one zero one zero zero one zero how that works is that we read this so it's meaning like a zero the plain text zero zero maps to this value plain text zero one maps to the second value plain text one zero perhaps to the third and plane takes one one match to the fourth value so we order the plaintiffs so if this is the key what we do now is that the the source chooses the key that is this specific mapping they encrypt and they get 0 1 as the output they send zero one to the recipient if the recipient also knows this key then what do they get as the output well they receive ciphertech 0 1 which is in the second position of the key and therefore the plain text is 0 1 of output because it's write it in blue we have our site and text red the plain text the key is the blue value and this is just the values in order so we always write these in order so if recipient receives zero one from the key they know that 0 1 goes to 0 1. if the recipient received one zero as the site and tax they'd know the plain text is one one if they receive one one they know the plaintext is zero zero so the the key in this case defines the mapping this is an ideal block Cipher and that we can Implement any block Cipher just as this mapping from plain text values to a cyber text the problem with using this is that it's impractical to to implement return to our slides for a moment an ideal block Cipher we take an end bit input and bit plain text and that can map to 2 to the power of n possible States so we had our two bit plain text we got four possible plain text inputs to the power of two and we do some substitution we take the input and replace it with one of the other possible values or one other one possible value so there are two to the power of n possible outputs which map back to a twobit input a twobit output infused this allows for all possible combinations of plain text to cycle text mappings and another example the one that was we saw another example is shown on this slide but maybe better to show just as these tables just one other example where here's a mapping from on the lefthand table the encryption table these 16 plain text values can map to these 16 cycle text values that's one possible mapping in this Cipher how many mappings are there in total how many possible we saw in our previous example we had 24 possible magnets 24 possible Keys here I've shown just one mapping for a different Cipher how many possible in total foreign mappings if you want to find the answer maybe start writing them all out it'll take you a long time though that just focus on the left table the other one's the decryption foreign let's go back to our sorry wrong direction our first example we had a twobit block two bits of plain text gives us four possible plain tax values zero zero zero one one zero one one and how many Arrangements of those four values can we have how many different ways can we arrange them all of these 24 values earlier the possible Arrangements there are 24 or 4 factorial Arrangements combinations so with this was a twobit block Cipher what about with our other Cipher how many possible mappings 16 factorial why is a 4bit block Cipher plain text four bits how many possible plain text values are there 16 now listed here into the power of four sixteen possible plain texts I challenge you to go and write those 16 values or if you want to do it in decimal rather than binary write the value 0 to 15 and then try an arrangement arrange them in different orders see how many different Arrangements you can make and it'll be 16 factorial which is what they're not calculator how many Arrangements we have a four bit block Cipher so 2 to the power of four possible plain text 16 factorial possible Arrangements again 16 factorial two 20 trillion different arrangements okay so you go and write them all all down and that's how many possible Arrangements we have in that case maybe that should be the penalty for those uh who cannot answer the quiz in the next lecture anyone who gets less than 50 has to write more down sounds okay doesn't sound that hard to write 20 trillion different Arrangements okay all right so so the point is that this is just one of those 20 trillion different Arrangements we have many others which Arrangement do we use to encrypt this is one well the one that we use is defined by the key how long is our key in this case thank you what is the key and go back to our easier example where we have just 24 Arrangements we have a 2bit block Cipher 24 possible Arrangements the key that determines the arrangement we're using for example key 17 was tells us the order in which our plain text values map to our ciphertext so we could write the key key 17 as in fact one one zero one zero zero one zero eight bits and the way that we interpret the key is is that since we know it's a twobit block Cipher we know that okay the first two bits in the key map to zero zero the second two bits mapped to zero one the Third two one zero and the last two to one one so in that case we could represent the key as eight bits how big is our key with our other side in this case well the key would be all of these values what we would send or what we could store as the key is one one zero so every four bits identify the site text for the inorder plain text so 4 by 16 or 64 bits would be the length of the key in this case because if we know the key if we know these 64 bits and store them in order when I receive ciphertext1010 from the key I can determine well that's in the what is it in the night position and therefore it maps to decimal 9 or binary one zero zero one so we could use a key in that way so the key in this case in general is how big this is with four bits we have four by sixteen with a four bit block Cipher four by sixteen or an end bit block Cipher and by 2 to the power of n four by sixteen four by two to the power four is the key length in this case in in bits in this case so what yeah the key tells us the mapping let's go back to our simple simpler one of the wrong way 24 mappings okay and we let's keep it simple but which mapping in which order do we do these mappings we need to Define that yeah the key length uh yes correct what did I say oh sorry n n times 2 to the power of n correct so in our case 64 4 by 2 to the power of four so in this case we have a block size of Two Bits n equals to two the key is 2 times 2 to the power of two or eight bits that is these eight bits is key 17. if I want to encrypt using a different mapping for example key 13 then I could set the key to be zero one one zero zero zero one one and when the receiver receives the ciphertext 0 0 if they know this key from the key they determine that the plain text is one zero but that leads to our problem with this ideal block Cipher let's say we have a large block size n for example is 64. 64 bits so we've seen an example of a block of two bits a block of four bits let's say we have a block of 64 bits which we'll see is typical then the key length is 64 times 2 to the power of 64 bits which is too large because it's too large to be able to distribute to someone it's too hard to to write down and to to record and it becomes very hard to implement when you have such large values so using a large block size is it is not possible if we use such a cycle using a small block size therefore makes the key more manageable but it turns out the smaller the block if we have a typically large plain text we have more blocks and it becomes much easier to perform an attack by using the static statistical characteristics of the plain text so we have a problem we can't use a small block size because it makes a tax easier based on statistical analysis but we can't use a large block size because it makes the key too large so we need some alternative approach so an ideal block Cipher allows all possible mappings real block ciphers today do not use this approach they only allow a select number of mappings but they make the tradeoff of being able to use a large block by keeping the key small and there are different ways of doing it and there was one there's one common approach it was devised by a guy called feistall the approach in general is to use Simple ciphers smaller blocks but apply them multiple times and in some structured manner to make the output cryptographically strong so to use two or more simple ciphers but repeat one after another and and that's the concept we started to introduce with our classical cybers by repeating the same simple Cipher we can get more strength in the output of psychotics and what did we have we had in our ideal side and let's write it down with our ideal Cipher we said with an Ambit lock and that block size how many Transformations or mappings do we have foreign we had 2 to the power of n factorial Transformations or mappings which is good we want as many as possible but the key length becomes n times 2 to the power of n which is bad because if n is large that key length becomes too large if n is n is 10 for example and this is a Thousand Times Ten this ten thousand bits is the key length La it's bad because of the management problem for the key Distributing the key whether firestore block Cipher it makes a tradeoff we have an nbit block size and the mappings is not determined by the block size but by the key length we also Define a k bit key so we set the key length and the number of mappings depends upon the key length so key length is K bits the number of mappings is 2 to the power of K which is this tradeoff of we drew we reduce the number of mappings yes let's say n and K are the same length with an ideal block cycle we have 2 to the power of n factorial mappings which is much much more than just 2 to the power of n if n and K are the same so we reduce the number of mappings but we have a manageable key length K bits so if we Define K as 64 say 64 bits we have 2 to the power of 64 possible mappings uh but we have a manageable key length if we have a 64bit block with the ideal Cipher the key length is 2 to the power of 64 a two to the yeah 2 to the power of 64 times 64 which is just too large he is just 64 bits so fossil structure allows us a much more manageable size in the key length but by repeating the simple encryption operations provides almost equal security is what an ideal blocks are and sufficient security the picture on the next slide shows the structure actually the next one we will not go into much detail because we'll see it in deaths it repeats the general design of a cycle it's not a specific Cipher it's a general design and it breaks the cipher into a set of rounds a round is the same each time the same algorithm we just repeat this algorithm multiple times of multiple rounds and it involves splitting the plain text into left and right halves so if we have a 64bit plain text we break it into two 32bit portions swapping the halves we'll see some different operations like swapping the halves using an exclusive ore and applying some function and he generalized that some function we'll see some specific instances and a key is an input and then repeating and repeat and repeat as as per how many rounds we have so we'll come back to that when we see deaths because it's an example of a faster structure or the concepts there's an alternate alternation between substitutions and transpositions so coming back to our classical ciphers we're using these basic operations replacing and rearranging substitution is replacing transposition is rearranging or permutations and we'll see shortly that we talk about s operations and P P for permutation is commonly used he operations and applies the concepts of diffusion and confusion anyone understand confusion I think everyone's experts there's many people who are confused we will look and come back to these concepts of what do we mean by diffusion and confusion with respect to cyphers but let's move on from some of the abstract Concepts and and look at some specific examples we'll come back to the next lecture let's go to Des and then we'll see a few examples before going through the details the data encryption standard it was probably it would maybe still is the it was the most widely used Cipher in the world symmetric block cycle it was developed about 40 years ago very designed by people at uh IBM and NSA apparently had input and it was standardized by what was then called NBS but is now called the National Institute of Standards and Technology East so U.S standards organization created the standard for deaths and the idea was that when this organization creates the standard all the US government departments must use that for encryption and because the US government is using it for encryption many companies use it for encryption and not just in the US outside and it's spread across the world in the deaths become effectively a worldwide standard for encryption a symmetric block Cipher it operates on a 64bit input block so to encrypt we take 64 bits of plain text and we produce 64bits output so we produce 64bit cytotext what if my plain text is larger than 64 bits well we break our plain text into blocks of 64 bits in length encrypt them one at a time and then we've got different ways of combining those output cycle texts together and the next topic will talk about how to combine modes of operation so yes just looks at 64 bits at a time it has a 64bit key but we'll see when we look at the details that only 56 bits of that of those 64 were actually used in the encryption the other eight bits were used as a parity check so parity check to check if there's any errors so from a security perspective it's effectively a 56bit key how long is our Brute Force take against 64 bits a 56 bits Brute Force worst case we need to approve force of 2 to the power of 56 operations if you go back to the last set of lecture notes what days hours seconds if we have Ultra fast machines from a key length perspective it's insecure it's too short nowadays but in the 70s 80s and 90s it was okay but now it's it's not a the principles used in desks have been applied in other Cycles so to overcome the short key length there were improvements like triple deaths and they are still in use today so the principles used are used will see in other Cycles what we're going to do and we'll not go through the details today but in the next lecture we're going to go through the details of how deaths works but because it's quite complex what I'll use is take a cut down version it works on 64 bits I cannot write 64 bits on the board and do an operation or it takes too long so some people have developed one for teaching called simplified debt which will cut things down to smaller smaller sizes eight bits 10 bits and we'll go through one example to show the operations it's not a real site it's just for teaching but we'll go through that next week so we'll go through simplified deaths as an example and then we'll look at well real deaths and look at the details and some of the design issues and and possible attacks on real deaths finished today I want to move on and look at some software that we can use for encryption I know we've talked about a lot of Concepts today so let's look at some practice first let's remind you what your uh homework tasks are you have a quiz to do before the lecture next week okay you must do the quiz and there's a new exercise that I've added but the exercise is not marked or anything and you should only do the exercise if you understand from the quiz okay I've just added it today uh don't it's you don't have to do it it may just help you with understanding some of the the more advanced concepts but before I talk about the exercise um I've mentioned before and I also appointed on the website there are some that's the wrong one I've written up some examples using classical ciphers and attacking classic classical sites so in this web page and you've got to print out described how to do a brute force and more importantly how to do frequency analysis attacks on very simple classical sites I recommend you read that and understand that because if you can understand how the attacks can be performed when you understand the limitations and and approaches for your attacks on real science and there's another one about the onetime Pat so I recommend reading that and looking at the example to see well why is the onetime pad Unbreakable why is it provide perfect security if you don't understand then then have a read through this and it talks about with an example why even a Brute Force attack on the onetime pad will be unsuccessful so read them coming back exercise one only do this if you are okay with all the other Concepts so far because it can be time consuming quite simple here's some ciphertext find the plain text or key okay I give you I think there's four different ciphertext values for example this I give you a hint all right Caesar cycle was used find the key find the plaintiff plain text entry some are easy the first one should be easy second one here's some ciphertext rail fence was used find the key then you'll find them Playtex and I think that one's easy most people could do that three some cyber techs Rose columns was used this takes a little bit of thinking and a bit of trial and error to break that one okay maybe you could write some software to automate it but you can do it on paper as well that one those who can do it you can do it with software fine but what I don't suggest is find some Website that solves it for you no point but I I if you want to write software or use a spreadsheet or some some scripting language to automate the tasks for sure recommended and especially for the last one psychotex 4 monoalphabetic Cipher was used using English only so the key length is 26 characters effectively randomly erased here's the ciphert X find the plaintiffs I think most people can do one and two quite easily three and four take a bit more time and thinking but if you can do them then you're probably fully understand both how the ciphers work and how the attacks work let's move to real ciphers for the last five five minutes or so another print out provided you and on the website here is well let's use some software to encrypt once we go through a desk let's encrypt something with deaths so you can get different software implementations of many of the ciphers that we we talk about one common open source library and application for encryption is open SSL and we'll use it for demos and examples throughout the course openssl it provides a command line interface it's usually aren't available for most Linux and Mac operating systems already installed I'll just quickly show some examples so this web page describes how to use it let's look at a few examples of how to use them foreign some data first let's encrypt some plain text and I'll take a plain text file with them okay so I've created a plain text file which is just some text message hello this is our super secret message keep it secret uh let's encrypt it using openssl and yet that's uh we'll choose a cipher go different ways of doing it first let's find some details about our plain text sorry how long is a plain text I have a piece of software word count it tells me it's 72 characters long okay let's start with that it's 72 characters in fact it's 72 bytes one character is one bite if we look at how plain text.txt file it's 72 bytes so we're going to encrypt a 72 byte plain text I I have to have a look at the details in maybe hexadecimal everything I'm doing is on the website on those instructions so I would not explain too much just do the steps so that's our message so this is the ASCII this is the hexadecimal remember our ASCII Maps back to binary or we can represent that binary as hexadecimal then so hello dot space t is in fact represented as these hexadecimal digits or even nicer binary yeah hard to see do it again okay of course I don't expect you to read this but this is h e l l o uh when we get o dot space t so just a binary representation so when we're applying our real cycle we're actually operating on the binary form when we apply Des AES and others we take the binary values and apply our Cipher on those binary vectors but of course hard hard to uh show binary values sometimes so let's encrypt and I'll encrypt using deaths but we need a key okay I need to encrypt with some key and with this we have a 64bit key although we only use 56 we need to specify a 64bit key and turns out with the software we can use we can use hexadecimal I don't have to I can write in binary 64 bits or 16 hexadecimal digits anyone suggest a key for me 64bit value or 16 hexadecimal digits well it's best to choose a random key remember a key should be such that it should be secret so I shouldn't tell you but it should be such that no one can guess it if I choose a key of all zeros well an attacker could just try all zeros and it's not very sensible to choose that way so ideally your key should be generated randomly you should not choose it you should let a computer generate it for you so it generates some random number different ways to Generate random numbers program we're going to use to encrypt is called openssl and it includes many different encryption operations including random number generation it has an operation to generate a random number eight hexadecimal eight bytes in hexadecimal that's what we're saying here here it is so what I did is generated an eight byte random number and output in hexadecimal and that's the value sorry we lose a little bit that's sure you can see them again we haven't explained it yet but it turns out to encrypt we need a key and some initial value and I'm going to use some at random initial value but let's encrypt and we use openssl we say we want to encrypt with a symmetric Cipher what Cipher deaths and in the next topic we'll see that ECB means something electronic code book but not so important yet but Des ECB encrypt minus E input plain text file output ciphertext Dot ENC whatever extension I like is not so important import key my random value so use my key to encrypt and we need some initial value let's not explain that yet but we'll need that and I'll choose this other random number for an initial value and sometimes our Cipher when our text is not of a particular length or pad had the plain text I don't want to do any padding here it's not necessary so I'm going to specify an option to not pad no pad and done we encrypted okay so you don't have to remember all these operations so you're just giving you an example and we have our ciphertext which is 72 bytes long that's our cyber text let's look at the ciphertext now there it is okay there's our psychotics from encrypting our message hello this is a super secret message here's our psycho text and as you see it's just a random set of these are hexadecimal digits there's no meaning in ASCII so it doesn't make sense to look at this from a text file perspective because we get any of those uh ASCII characters the dots mean unprintable and we could look it in binary as well but I will not show you in binary so we've encrypted using openssl you can do that on any file it doesn't have to be a text file it can be an image it can be a Word document any file you like because opensl SSL just treats it in its binary form and zeros and ones and to finish of course let's decrypt and decrypt is almost the same as encrypt so almost repeat the command instead of minus E what do we have minus D to decrypt and the input is of course the ciphertext and the output is some file let's say it's my uh received message same key we need to decrypt with the same key as we encrypted with in the same initial value and let's look at our received message and it should be the same as our plaintext message yes okay so we decrypted successfully that's all our received message which was output from the decryption is identical to the original plain text which was the input to the encryption so just a taster become experts in openssl because you use that you may use that in your homeworks and you'll use it in practice in the future to encrypt data so have a look on some of the websites to see how openssl works and start to use it especially as we go through the real science enough for today to next week we'll look at the details of deaths by going through a simplified depths symmetric block Cipher that takes 64 bits of plain text input and produces 64 bits of ciphertext as output so encrypt 64 bits at a time it uses a 64 bit keyer's input but in fact only 56 of those 64 bits of key are actually used in the encryption the other eight bits are a parity check to demonstrate deaths I'm going to use this academic version of desk called simplified desks he uses the similar operations but it just cuts down instead of using 64bit blocks it cuts down to eight bits just so we can go through an actual full example or at least some parts of the example on the screen or on the board so simplified desk is not for real world use but we'll see and compare it to real deaths after we go through the example simplified deaths we deal with 8bit blocks so it's just cut down to to operate similar to Deaths 8bit we look at eight bits of plain text and we'll produce eight bits of ciphertext the key will be 10 bits and we in real desk we have 16 rounds that is we apply some function and then repeat it 16 times and simplify desk just two to to speed things up uh the steps that we'll see in the diagram of what what is the the steps we apply this captures the overall diagram for simplified desk and it looks similar to real deaths except it has only two rounds in this diagram real desk has 16. how we read this is that we have to encrypt plain text to get ciphertext if we have ciphertext and want to decrypt to get plain text we go in this direction and we'll explain the blocks but in fact in both cases we take our original key in this case a 10bit key and we generate what's called round keys or sub keys K1 and K2 and this will be round one round two we'll use sub key or round key K1 in round one and K2 and round two in real deaths we do a similar thing where we generate 16 round keys and use one in each of the rounds so there's this key generation step followed by the encryption what are all these blocks will go through them but in in summary the ones with a p initial permutation permutation 10 permutation eight we'll see another one I think permutation four they are permutations which means transpositions or simply rearrangements they take some input and rearrange the bits we're operating on bits now not not English letters but remember rows column we took all right going backwards we took some characters and rearranged them we did a transposition or a permutation on those input characters we'll do the same in all of these IP is an initial permutation P10 and p8 are different permutations in fact switch or swap SW here is also a permutation it takes eight bits and swaps the halves so it puts the first four bits last and the last four bits first we'll see that in the example a shift is a left shift again a permutation take eight bits shift it all to the left wrap the first bit around to the end similar to a Caesar Cipher which shifts to the right okay so just a permutation that will not help us so there's permutations and then we'll see in detail that this F this function it's called a round function is where the details are and that will include some permutations as well as a substitution and the substitution is what adds the security we need the substitution in there without it that it'll be very easy to break simplified desk as well as real deaths the actual permutations how we rearrange the bits is defined it's standard and it's known by everyone so well these are the definition of them we'll return them and return to them when we need them not quite yet so we'll return to them through our example let's start with an example and generate a key and we'll see the steps in detail the example I think you have a printout in your handouts of an example I'll try and go through on the screen and we'll calculate it as we go but you you have it already printed out I'll show you you have this document which goes gives all the details of what we're going to go through at the moment so try and follow along and see what's happening foreign let's try and start with a key and generate the round keys and I've just chosen a random key for this example so our key that we'll start with TK 10 bits that's the key that we've chosen for example the user chooses a random key and shares it with the the recipient so both sides the encrypter and decrypter must have this shared secret key we'll have some plain text I'll introduce in a moment the first thing that we must do is generate sub keys and the steps are defined here we take 10 bits as input the 10bit key is input and the way we read this diagram so this arrow with the slash store and 10 means 10 bits are flowing through here in order P10 is a permutation it takes 10 bits in and rearranges them in some way in some defined way and produces 10 bits out of course it's just a permutation in this case and will in fact we'll treat it as two different halves the left and the right half five bits at a time then we'll do a left shift on each half LS means left shift shift the bits to the left by one position so with five bits moving to the left where the leftmost bit will become the rightmost bit it'll wrap around we do it on each half and then we'll feed them in and do another permutation p8 in fact this permutation will take 10 bits in and will juice produce eight bits out so it permutates and deletes two bits to get the output K1 the first round key and the outputs of those left shifts will be fed down to do another left shift left shift by two positions p8 will be applied again we'll get the second round key K2 out so let's let's go through that with our 10 bits our 10 bit key so the first thing is we apply P10 so with our key after applying P10 that rearranges those 10 bits but how and that's defined on one of the slides P10 if we go back is defined as if these are the 10 bits coming in bit one through to bit 10 then the order in which they come out are defined by the second row the first bit moves to the seventh position the tenth bit moves to the sixth position the third bit moves to the first position and so on so that's a fixed permutation it just rearranges the bits we'll see when we look at real deaths it has the same there's a a large definite a large list of bits that says of these 64 bits we are rearrange them in this manner why is that coming up connect let's get rid of this error okay so let's do that permutation P10 where the well the third bit will become the first bit and so on you do it and just check that it makes sense and I'll write it down just so it's clear in this instance not for all the others what do we have these what do we have three five seven three five two seven four ten that's a two we'll go through slowly in the first case and then we'll speed up as we go through the uh the next steps so the result after we apply permutation P10 is that the third bit one becomes the first bit the fifth Bit Zero becomes the second bit the second Bit Zero becomes the third bit and so on seven or 10 bit one bit nine bit eight bit six so that's all very simple rearrange the bits and we'll see the other permutations are very similar different arrangements and we'll talk about why a particular arrangements are chosen later but let's just go through and and perform the operations that is the first step so the 10 bits that come out we're at this position we treat them as two halves and do a left shift on each half left shift by one position so you split them into two halves now and after doing a left shift focusing on the first five bits everything moves to the left where the leftmost bit ends up as the rightmost bit and similar for the right half and next so that's the output of the left shifts they feed into p8 another permutation but note that p8 takes 10 bits in produces 8 Bits out and it's defined as this select and permutate so two bits are going to be removed as the output bits one and two so we get six three seven four eight five ten nine as the rearrangement bits one and two are going to disappear and after p8 we'll get eight bits and they'll be following T8 the first two bits disappear so now we have 10 bits they're going to disappear and these remaining eight bits are going to be rearranged according to p8 the definition of p8 I want to write down the rearrangement you need to check back on the the slide as to what that definition is but just mix them up that is in fact key key one round key for round one we'll use that later that's this output here K1 the previous input to p8 is taken again and perform we perform another left shift on each of the halves by two positions so we'll continue and we'll do another left shift by two positions this time not one and that is taking this one and this value so take those five bits and do a left shift by two positions of course wrapping around where necessary so just focusing for example here this bit if we shift to the left by two positions comes to here and then here this second bit one two positions so the two ones end up here on the output and the three zeros of course will be there so we skipped over p8 that was just used to get k 1 and the last last step p8 is applied again on those 10 bits apply p8 and you'll get K2 and p8 is the same as it was defined before remove the first two bits and rearrange the remaining eight and we get I have the answers from before you can check that will be K2 so the operations are very simple in fact in real deaths they they're that simple we're shifting bids we're rearranging bits transpositions in this case yep yes it in this case this is the algorithm it's defined like this whenever you have a key the the steps we're doing now is generating the round Keys the output of this step we started with our 10bit key we get K1 and K2 as output we always apply those steps that we've gone through always using that fixed definition of p8 left shift and P10 it doesn't change so very simple and the same in desks we'll just see that the the permutations have more bits than than what we're dealing with here so we get two round keys this is the key generation stage we'll use them in a moment just go back put everything into context what we just did was this middle part whenever we have our input key the user chosen key we generate two round Keys K1 and K2 by P10 left shift p8 left shift p8 and then we'll use those two keys when we encrypt our plain text and we'll go through that step of encrypting the plain text but it turns out with simplified deaths and even real deaths decryption also uses those same round keys so when someone receives ciphertext they want to decrypt they take the same 10bit key follow those exact same steps and they'll get the same values of K1 and K2 and we'll return to it but we'll notice that decryption follows the exact same steps as encryption encryption we'll see is IP F of k s w f of k i p the inverse IP decryption exactly the same steps the only difference is that we'll use the round keys in the opposite order in encryption K1 is used first and then K2 in decryption K2 and then K1 the benefits of encryption and decryption being the same operations is that you only need to implement it once you implement encryption and you now have an implementation of decryption that's a significant practical advantage so let's now encrypt some plain text any questions easy so far and it will only get easier as we go we will not go through all the steps don't worry we're just some initial steps let's try again we'll need K1 and K2 and we need some plain text to encrypt I've chosen some plain text we'll return to K1 when we need it some random plain text so that's we want to encrypt this 8bit block if I had a thousand bits of plain text and I'd have to break it into 8bit blocks and encrypt one block at a time so what do we do to encrypt the details are here a little bit more detail than the overall diagram this is the encryption phase and it's hard to see uh at this size but we start with eight bits plain text IP is what we call the initial permutation it's a permutation we do just at the start we only do it once in the encryption we'll see at the end we do an inverse initial permutation okay nothing complex that and then these two dark gray boxes other rounds and they involve some permutations in fact EP is expand and permutate meaning we're going to take four bits in and produce eight bits out so we take four bits expand to get eight bits rearrange we're going to take our key K1 which we just generated an exclusive or with the output here we're going to split it into two halves and feed four bits at a time into the two s boxes s0 S1 are called s boxes substitution boxes so the operations we've seen so far are just transpositions permutations the other main operation in cryptography is a substitution we're going to replace bits with other or sets of bits with other sets of bits so we'll see the details of them we'll take the output they'll produce two bits out who have another permutation we're going to X or with the left half of our original output here we'll get four bits and four bits and then we'll swap the halves and we'll do it all again one round the second round let's go through just the first few steps and then we'll give you the answer so you can check if you need first the initial permutation and like the other permutations it's defined bits one to eight become rearranged in in this order okay so that's fixed it's always fixed it's always those values rearrange and you get what do you get tell me the values try it bit two become the second bit on the input becomes the first bit on the output the sixth becomes the second and so on what have I done wrong I've got the wrong answer in front of me sorry I'm going to go back and start again I've got the wrong plain text luckily I noticed before we got halfway through let's try a different plain text because I only have the answer to that one I misread my notes this is the plain text I want to try because I have the answers and we can check and confirm at the end let's forget about the first plain text but we do the same initial permutation the second bit becomes the first and the sixth bit becomes the second and so on and in fact where I misread is that that becomes one six and what do you get this is where I misread the plain text that would be the output after we rearrange those eight bits according to IP foreign that is the output of Ip and in fact now we we operate on two halves the right half we're going to feed into this block here denoted as F uppercase F the left half will return to later we'll need it later so the right half the right four bits we expand and permutate and then xor with the key K1 and expand and permutate is defined as this four bits in we're going to repeat those four bits and rearrange them as defined at the first bit becomes the second bit and the eight bit the second bit on input becomes the third and the fifth bit on output and so on so we expand and permutate only on the right most half so that was just on those four bits then we xor with K1 and K1 is what we generated before from before K1 was we have if you do an xor between those eight bits One X or one I remember their the basics of xor when they're the same we get zero when they're different we get one and then we're going to input split that into two halves and input that into our s boxes and that's really the next step that we need to go through that's different from before then we the rest is easy so just to show where we're at we had eight bits out of our expand and permutate we xor with the K1 and take four bits into s0 and four bits into S1 where the S boxes we perform a substitution and the way that we use it we're going to the S boxes are also defined the substitutions like our uh monoalphabetic Cipher defines how we what we replace our plain text characters with what do we get on output this defines given an input what is going to come out and it's defined we'll Define it as two matrices s box zero s box S1 so focusing on s0 we have four bits in the way that we interpret this so this is the s box we have a four bit input bits one through to bit four bit one and bit four specify the row bit two and bit three specify the column and we just do a simple Matrix lookup and with the element that we find becomes the output where we label our columns and rows in in binary so 0 1 2 3 in decimal so row 0 or in binary zero zero zero one one zero one one and column zero one two three and bit one and four specify the row two and three specify the column so what's the output find out the output when we feed these values into our two s boxes foreign and two bits going to come out with S1 the row is going to be 0 0 and the column 1 1. if it's one and go back beats one and four specify the row two and three specify the column so row 0 0 column one one or in decimal row zero column three look up your s box row zero the first row column three the last row output one zero okay so it's just a look up on that defined substitution box so the output for S1 will be one zero and then do the same for the the right four bits to get S1 what does S1 give us first and fourth bit column second and third bit and just do a lookup in the s box if we can get past the S boxes you'll see that the rest is all permutations and easy any questions on the S boxes or or the other aspects of simplified desks so far find out the output of S1 is it one one row now think of the rows and columns in binary the easiest way row 0 1 column one one so when we look at our Matrix we if you want to convert a decimal then zero through to three zero one one in s box S1 the second row zero one the last column one one produce output one one okay just to look up on that Matrix our substitution we are the output of s0 and S1 we have four bits we permutate with P4 we'll get four bits out then we xor those four bits with the left half that came out of the initial permutation let's quickly do that and then we'll get to our answer so we're going to apply P4 now four bits into P4 we'll produce those four bits out where does that come from four bits in one zero one one P4 is defined here a rearrangement bit two becomes the first bit and then the remaining three bits at the end and X all that with the left half we have it up somewhere this left half of the initial permutation if we can bring it down is then reused down here one zero one zero this one zero one zero is the left half from our initial permutation output you can follow it up on here or on the slide it comes from the initial permutation exclusive or foreign what do we just do we just took the four bits out of P4 exclusive all with the four bits from the initial permutation we get four bits out combine it with the original right half of the initial permutation I'll bring that down the right half here is now reused one zero zero one and the last in fact that's the end of our round that's the end of the round we swap the halves and then repeat all of it again repeat the round again what we've just done is we started with plain text we did the initial permutation then we did everything inside this dark gray block now we're going to swap the halves and then we repeat everything inside the dark gray block but using K2 as an input a distance and then we'll get some eight bits out do an inverse initial permutation we'll get our ciphertext so let's swap the halves and then I'll give you the answer you can do the rest in your own time swap the halves so this is the swap then you apply our round function denoted on the diagram is f of K using K2 as an input you'll get as an output I've done it before I hope has the output you'll get eight bits of then you'll do the inverse initial permutation and you get your output ciphertext foreign we will not go through many ciphers in this much detail we'll just use this one to demonstrate that in fact complex ciphers is made up of simple operations so as the output of our swap swapping the halves we get these eight bits you apply the the dark gray block again but use a K2 as an input and we calculated K2 before you get some eight bits you apply the inverse initial permutation and then you get eight bits of ciphertext and we're done you as homework will try and work out what the inverse initial permutation is well the inverse of Ip so try and work out what it means to do the inverse of this operation this permutation try it's the inverse yes let's see what happens it's it's like thinking about the the rose columns a little bit just be careful with it so we're done we've encrypted using simplified deaths if we want to decrypt in fact we do the exact same steps we except we take our ciphertext eight bits exact time steps but we use K2 first in the first round and then K1 okay so just rearrange the ordering of the keys so you know simplified desk now to finish the last two minutes that was the example we went through comparison of simplified death and real deaths some some aspects so a simplified this is just for educational purposes real deaths some of the differences all right we now we have 64bit blocks not eight and we have 16 round Keys it turns out the round keys in real deaths are 48 bits so K1 K2 K3 up to k16 will each be 48 bits they'll be derived from the original input key right the initial permutation is 64 bits the function f if you look in the diagram operates on 32 bits simplified Des had two s boxes real desk has 8s boxes for the same Concepts 16 rounds not two rounds this is this concept of keep applying transpositions and substitutions and you get better and better cycle text from a security perspective so you could go away and do simplified deaths if you had the definition of all those operations and for your reference I included them here just taken from the textbook real death goes through 16 rounds here's the initial permutation IP and the inverse 64 bits in we rearrange those 64 bits so the first bit ends up here the 58th bit becomes the first bit and so on that's all the expand and permutate permutation functions a single round we take our right half expand and permutate xor s box permutate EXO and keep going all right the S boxes with simplified desk we just had our two four by four major matrices here we have eight S boxes but same concept we just do a lookup in the s box to get the output in this case we get output 4 bits I think we have a decimal 4bit value there and it's slightly different in the key generation but uh it's not much more complex so we now know simplified deaths you could now expand that knowledge to real deaths and real deaths is one of the most used ciphers in the world it's no longer recommended but if you consider the its use over the last 30 or 40 years is one of the most used ciphers in the world and many other ciphers use similar Concepts rounds substitutions transpositions xor generate keys and so on so this is one example of a real and relevant Cipher on Thursday we'll talk about some of the some of the reasons it uses these operations and some of the limitations of them and then move on to the next topic let's stop there this is from the previous set of lecture notes on the classical ciphers but generally talked about attacks and we skipped over one side and I forgot to come back to it so Now's the Time because we mentioned some of the concepts as we move forward coming back to an attacker what they want to do is discover the plaintext or the key getting the keys better because then you can uh if the other users don't know then you can easily decrypt subsequent ciphertext that you come across the attacker we assume knows ciphertax so we can obtain the ciphertext and we know the algorithm being used so that's an assumption uh hiding the algorithm is usually not possible uh adds very little extra security we'll see and we'll see today in some attack where the attacker often makes use of known pairs of plain Tech ciphertexts and that's what we'll see in some actor attacks and different attacks we've mentioned Brute Force again before so you know about Brute Force try all keys so you need to know how many keys and how how many keys we can try per second to work out how long a Brute Force attack takes Crypt analysis we've seen some attacks for example in the quiz the mono alphabetic Cipher we can use frequency analysis that is take advantage of the fact that the plain text and the ciphertext exhibit similar characteristics in the frequency of letters diagrams and so on and there are other types of attacks that can be performed on real ciphers often so now moving away from Brute Force often the other types of attacks there are some common techniques which are applied across against different Cycles so there may be a tax specific to one Cypher like death but but it won't work on AES but then there may be some general techniques that may work across a set of Cycles and we're not going to go into any details of those techniques we may see today we'll see one example we may see a few later but just to mention some of the methods the general methods linear cryptanalysis is really trying to find some think of some linear equation that relates the ciphertext back to the key and back to the plain text and solve effectively that equation but it's it can be very complex and differential Crypt analysis is looking at differences in across different plan cytotext values to try and work out how that Maps back to a key we'll see meet in the middle attack today that'll become clearer side Channel attacks and there are others side channel is using uh some outside information to try and use determine the key or the the plaintext an example and it's it's used in a number of systems is when I encrypt something on my computer say I'm implementing I've implemented deaths and I'm in quick encrypting some data there are many different operations of desks we saw simplified desks yesterday the rounds the xor the permutations and so on it turns out in some cases if you can measure how long it takes your Hardware to do each operation you can get some extra information and try and then use that to try and determine the key or plain text so one example of a side Channel attack is actually measuring how long the the hardware takes for each operation in the encryption and because depending on different keys and different plain texts the operations may take different amounts of time so by analyzing that you can start to work backwards from the cycle text to a key or plain text so using extra information some other information from some other channel often attacks are compared against the worst case Brute Force so look if we can do Brute Force then fine we can defeat the cipher but often the the success of other attacks is compared against well how long is it does it take compared to Brute Force we'd like to be faster than brute ports okay so brute force is the the worst case approach if we can come up with an attack which is better faster than Brute Force then that's a good thing from an attacker's perspective defeating the security so with Brute Force we normally measure the number of operations so how many decrypts do we need to do to defeat the cipher to find the key for example which depends entirely on the number of keys and the type and the time depends upon how long each operation takes so a cipher with a 64bit key takes worst case with Brute Force 2 to the power of 64 operations to find the key so we use a similar metric to measure other attacks how many operations does it take to find the key should be better than Brute Force if that attack is ever any use so if a Brute Force attack takes two to the 64 operations and we've got some other attack that takes 2 to the power of 60 operations and we'd say that's better than Brute Force and is the weakness in the cycle but the other thing we'll see that other attacks use is not just that they take many operations but to work often they require some memory to store information while they're performing the attack the less memory required the better it is from the attacker's perspective and often they require knowledge the attacker requires knowledge of past pairs of plain text cytotecs so the attacker has some ciphertext uh trying to find the key often attacks assume that the attacker also knows some other ciphertext values which were produced with the same key from same some paint text and the attacker knows both the pair of plain text and ciphertext but they don't know the key so how many pairs of plain text ciphertexts or and particular um can we choose particular values has an impact on how we measure how successful an attack is some classification of that information known by the attacker not this slide is here what is known from the attacker's perspective okay let's imagine where the attacker trying to defeat a cipher the worst case for us well first in general the more information I know the more the better it is for me to be able to attack a cycle so the worst case for the attacker is knowing very little the worst case is knowing just the ciphertext and the algorithm we're assume in all these cases we know the algorithm and if we just know the ciphertext then we need to take that ciphertext and the algorithm and determine the key or the plain text for that psychotics normally we look for the key but it can be a little bit easier for the attacker if they know some pears in addition to the algorithm and ciphertext they know some pairs of past plain text cycle text somehow they've discovered some past ciphertext values and the corresponding plain text but not the key so that's what we mean by plantex ciphertext pairs plain text was encrypted with a key to get a psychotex the attacker knows the plain text and ciphertext but they don't know the key are trying to find that that information can help the attacker to try and find the key how do we get a past pair of plain text ciphertext maybe the plaintext became not important and is no longer considered secure and is made available so the attacker can learn the plain text without knowing the key the simple example I think I may have mentioned it before is that okay um some text is some information about some event happening in the future the event will happen at this time at this location after the event happens the attacker knows the psycho text they also can determine the plaintext because they know that the event happened at this time and at this position so they can determine what the original paintex was without knowing the key so there are a number of cases when the attacker we assume those pairs of plaintiff psychedules oh if the attacker can choose what pairs it can learn it can make the attacker even of the attack even easier so a known plain text is the case where the attacker is able to find some plaintext cyphert experts chosen plain text is where they've chosen particular plain text values and found the corresponding psychotex values an example I choose a plain text value as the attacker and somehow I get the user to encrypt that plain text with their key and I intercept their ciphertext so now I know the plain text and ciphertext choosing the plain text allows the attacker to choose values that may help breaking the cipher by finding weaknesses that depend upon that plaintext so being able to choose the specific value can help in some attacks chosen ciphertext is similar except the attacker gets to choose the ciphertext and can find the corresponding plain text chosen text is when we can have both the attacker can choose both plain text and ciphertext and get the other value in the pair generally as we go down the more information the attacker knows the greater the chance they can perform a successful attack with ciphertext only then it's harder for the attacker with chosen text is generally easier for the attacker we'd like to design ciphers such that we can defend against any attack preferably even if the attacker knows chosen plain text chosen ciphertext or even chosen text sometimes we can defend against all sometimes just selection so the more info that the more information the attacker knows generally the easier it is for them to attack we'll see this come up when we perform an attack in a moment well soon hopefully at the end of this lecture and the last thing that we missed over how do we measure security well the absolute measure we can say a cipher is unconditionally secure means it's perfect in terms of security that is the ciphertext has no information such that an attacker can find out the correct plain text or key so a cipher which is unconditionally secure has that property the only known the only known Cipher that is unconditionally secure is the onetime pack we've seen the example of the onetime pad even if we try a Brute Force attack given some cyber text we cannot determine the correct plain text or key so it's perfect in terms of security it's unconditionally secure under no conditions is it insecure no other ciphers are known to be unconditionally secure there are conditions in which they are insecure so therefore to be practical to compare ciphers we talk more about computational security and in general as Cipher is considered to be computationally secure if the cost of breaking it exceeds the cost of the information encrypted or the time required to break exceeds the useful lifetime of that encrypted information example I have a hundred thousand baht in my bank account and my password to get access to my bank account is encrypted and someone finds the encrypted password some malicious user a student and they want to get my 100 000 Baht so they go and they buy many computers and do a Brute Force attack against my password and they spend a million bucks to find the password they get the password they get into my bank account they steal my 100 000 baht this information would say is computationally secure because the value of the information was 100 000 bar for the attacker but the cost of breaking it was 1 million so it costs them all to break it than it is than they get in return so a simple example that we need to evaluate how much is the information worth that one was easy but uh I encrypt I encrypt a confident confidential information about trade secrets for my company I don't want other companies to get that what's that information worth it's very hard to put a value on lots of information so it's hard to put numbers on how much is the information actually worth and how much would it take to cost to break that how much cost would it take it's hard to estimate the value of a lot of information the other one is the exam I have the exam on my laptop for the midterm the midterm is in what four weeks time and I encrypt the exam you can have the ciphertext you again you have all these computers the lab computers and you start your attack and it takes you seven weeks to find the exam answers put the exams over okay you had you sat the exam you needed the exam answers in four weeks took you seven weeks to get them so again in that case we'd say it's computationally secure because the time required to break the cipher exceeded the the value or the useful lifetime of the the encrypted exam in that case again it's hard to put or it's hard to estimate what the lifetime of some information is so although the concept is easy in practice knowing how valuable information is how long do we need to keep it secure is not easy to predict and how how long does it take to break is again not easy to predict so one time pad is the OWN only unconditionally secure Cipher all others are conditionally secure that so therefore we look at the computational security how much effort how much cost or time does it require to break it and we'll come to some of that when we look at deaths so let's go back to our desk slides our block Cipher and there's two concepts we skipped there on death as well death and the fiscal structure and many block Cycles in general use the concepts of diffusion and confusion and one of your favorite scientists come up with these Concepts so Claude Shannon some of you took its 323 we saw Shannon capacity equation about how much information we can send across a channel Shannon came up with that Shannon also did a lot of work on security or the concepts of security security and data Communications are closely aligned it's about representing information and getting a information in an efficient way from A to B so there's similar Concepts so Shannon come up or Define the concepts of with ciphers we'd like to have a cipher that has diffusion and confusion what do they mean in simple terms and just go back the feistful structure and including gas use or apply these Concepts so they do have this diffusion is spreading out the plain text when we get the cyber texts our plain text always has some structure think of an English phrase or document there's some structure in the frequency of letters when we apply our Cipher we'd like that structure to be diffused to be spread out across the entire cyphotex so the structure is no longer present in the cycle text that's the idea then so that the structure in the plain text or the statistical nature of the plain text is reduced in the ciphertext so preferably that it looks random in the end how to achieve that apply permutations or transpositions repeatedly and then on the input plain text and apply some function to like a substitution function in the same way that deaths as some basic permutations P we saw those P boxes we saw in simplified desk P10 p8 P4 permutations but also some s boxes for substitutions and repeat each round so that increases the amount of diffusion of the plain text the other part is confusion make the relationship between the cipher text and the key complex with the intention that even if there is some structure in the ciphertext so the attacker can find some structure in the ciphertext that is some letters occur more frequent than others it still should be hard to take that ciphertext and find the key so if if that's achieved we've got confusion so making it hard given the ciphertext to find the key so make the relationship between them very complex we saw in some of our classical ciphers once we find the ciphertext the the key is easy to find once we found the psychotex on our mono alphabetic cycle we've automatically got the key whereas with this and other ciphers will see even if you find the ciphertext for a given plain text it's still hard to find the key and that's the concept of confusion and it uses some substitution some complex substitution algorithm nonlinear mean it's hard to go in the inverse and in death the S boxes implement this uh increased confusion in the cycle let's hope it decreases confusion of your knowledge of death let's go through and look at the design characteristics and summarize what we know about deaths we went through an example of simplified deaths and then a comparison with real deaths and it's really scaling up simplified depth we make it simple so we can do an example real deaths just as more as boxes more rounds larger blocks and so on but the same Concepts and operations you can look through the details of deaths again of course no need to remember these and no need to remember simplified desk operations okay so I don't ask you in the exam uh to remember these s boxes or this this picture or these permutations you don't need to remember them the reason we went through this example was for you to see that we're using very simple operations permutation substitutions but combining them together to get uh a good Cipher so let's go and look at some design characteristics of deaths is it good and one of the the measures of seeing how good a cipher is and it's not just for desks but for others as well is the Avalanche effect an avalanche what happens at the top of the mountain the small thing starts falling small rock falls and it knocks more rocks and a more rocks and more rocks and at the end there's the whole mountain is falling down the concept is that with ciphers we'd like to have the Avalanche effect with good ciphers and the effect is that small changes in the input produce large changes in the output a small change at the start means a large change at the at the end and we can look at it from two perspectives from the input being the plain text or the input being the key to show that we'll look at the two examples here first in summary death has the Avalanche effect that is that's good for security it's considered designed to be a good design because it exhibits the Avalanche effect and the next two slides give examples of that the idea is that we have two different plain text values they differ by just one bit if you look these are in hexadecimal but in fact it's just the first hexadecimal digit differs zero to one in binary just one bit differs in these two input values so a small change in inputs what we'd like is to produce a large change in the output cycle text and this shows shows those changes so we see after a set of rounds so we start with plain text this zero two four six eight so on that's plain text one and the one below it one two four six eight is plain text two and of course they differ by just one bit single bit difference and the Delta column shows the number of bits that differ so at the start just one bit differs and then we encrypt through the different stages of deaths real deaths not simplified deaths and what this table shows is the output after each round this has 16 rounds so we take the input plain text we apply round one and the output if we encrypt plaintext one is this three c f and the output if we encrypt plain text 2 after round one is this three c f 0 3 and so on there's only one bit that differs between those two outputs so a small change in the input so far has only produced a small change in output that's not the Avalanche effective but with this we go through multiple rounds if we do the second round we get this output these two outputs they differ by five bits after three rounds differ of difference of 18 bits four rounds 34 and we keep going after our 16 rounds and our inverse initial permutation in this specific example 32 bits differ and that's what we aim for what we'd like is the two input plain text values which differ by just one bit when we encrypt both of them using the same key with like the ciphertext values to be completely different now remember with desk we use 64bit blocks so the output ciphertext one and ciphertix 2 64 bits in length what we're like is that the difference is a random or appear random and on average if you have a 64bit block we'd like at least half of the bits to be different 32 would be optimal it turns out to be 32 in this case but on all patterns because as an example let's say an 8bit block let's say a cycle text is what's a ciphertext value which is different from C2 a C1 significantly different we have a 8bit ciphertext value to keep it small what's a value that is significantly different from C1 in this case so an example cycle text C1 give me an example ciphertext right let's keep it simple what's the difference how many bits just one bit differs in this case so I would say that these are similar they're not much different so eight bits differ right that's significantly different but now if we have a random or another Cypher text value then we'd like on average if we consider all possible cyber text values on average we'd expect half of the bits to change because what if we have all the bits change and it's just the inverse all the time another random value may be eight bits how many bits differ one two three four just two random values four bits differ on average if we take two random ciphertexts we'd like half of the bits to differ so with this which has 64 bits in the block an avalanche effect ideally would produce half of the bits different after encryption and this specific instance we do 32 bits in other instances it may vary it's not always the same so that demonstrates that the Avalanche effect is in effect in this example and it is in general with deaths and it in fact turns out after about round four we have this difference of around 32 it goes up and down a bit so maybe we can just encrypt uh after four or five rounds and stop with this so the number of rounds generally the more rounds you add the more secure the output is but the more time it takes to implement so it takes time to do this processing so 16 was chosen as a tradeoff of okay we see that four may be okay in this case but maybe in other cases we need five or six rounds or 16 is uh gives us some more freedom some in case uh for some cases which don't have the Avalanche effect until six seven eight rounds but it's not too many such that it's too slow to implement so choosing the number of rounds was an important design decision I've asked in exams or in assignments to measure the Avalanche effect of different ciphers and they see some examples later to understand what it means the second one is the same concept but take two plain text values which are the same these two values encrypt one with key one encrypt the same plain text with a different key differing just by one bit so going back the second example is plain texts are the same but the two keys that we use to encrypt differ by one bit in the first example the plain text values differed by one bit the key was the same and we see in this case where we change the key again after six seven eight rounds we're getting close to this about half bits are differing in output after the entire encryption 30 in this specific case on average if we try different values we'd like 32 it would be the average difference so Des has the Avalanche effect which is good and in fact it is achieved after just several rounds which means it's likely that the number of rounds of 16 is sufficient it was a good design choice what else about deaths the key size is not good the 64bit initial key in death is actually split into two parts eight bits used for a parity check but not used in the encryption so only 56 bits are used in the encryption so an attacker really only using it only needs to guess those 56 bits which means there are 2 to the power 56 possible keys or about 7 by 10 to the 16. in 1977 someone designed a machine they didn't build it they designed or estimated a machine that would break deaths in about 10 hours if it cost 20 million US dollars so that's what 40 years ago in 1998 the electronic Frontiers Foundation built a machine that cost a quarter of a million US Dollars and they broke it in three days so a Brute Force dedicated Hardware to try desk keys they did it in about three days today it's considered too short to withstand Brute Force attacks 56 Pips is not long enough in general with this the algorithm is considered secure that limitation is the key size so the design people have done a lot of analysis than they find in most cases it's secure they can't find weaknesses in the algorithm but it has the weakness of the key length is too short so one approach then because many people had software and Hardware that implemented deaths being used a lot they trust the algorithm how do we make it more secure use it multiple times with a different key each time take a your plain text encrypt with Des with a 56bit key you get some ciphertext then encrypt that ciphertext using Das again with a different 56bit key and you get your ciphertext and now effectively you have 2 by 56bit keys or 112 bits and a Brute Force against 112 bits is uh considered reasonably secure nowadays so the concept was reused deaths by applying it multiple times and a popular Cipher today and although no longer recommended but still widely used is triple deaths and that ignore this 128bit Keys we'll look in details and see there are different options for the key length of triple deaths yes it uses 128 bits but there are other values we'll see that here what else about death there are some theoretical attacks on deaths timing attacks observe how long it takes your Hardware to encrypt and decrypt and use that information to try and work out what the original plain text or key was in theory possible in practice very easy to to defend against by changing the implementation of this to have some small variations in how long each operation takes and that makes these attacks these timing attacks almost impossible there are other attacks by observing how plain text values change over time looking at the differences there are some attacks so I remember brute force in death 2 to the power 56 operations that's the worst case this differential cryptanalysis attack and they could get it down to 2 to the power of 47 operations much better but it required the attacker to have 2 to the power 47 plain text values known in advance so they need to know a lot of plain text in advance for this attack to work so in practice not very useful and another one uh linear cryptanalysis got it about the same number of operations and they need 2 to the power of 43 known plain text values so if the attacker knows a lot of past plain text cyphertex pairs a lot in this case two to the power of 43 pairs then which is what 100 billion different pairs of cycle text plain text then they can do a tax on deaths which take about 2 to the 47 operations about a thousand times faster than a Brute Force attack still slow well today nowadays brute force is easy against deaths so because it can be broken in Brute Force these attacks people do not explore them much more because you just use brute force to break another issue with this was that originally was designed in private the people who designed it were for companies or governments and they didn't tell people how they chose all the values these are the S boxes from real deaths they tell us that we take some bits in we get some bits out why is it chosen this way or the designers chose it to be this way and there was no original motivation of well why did they choose these values why not some other arrangements it turns out that people have done analysis and found that even though they don't know the original motivations if you make small changes in the design it turns out the death is much less secure so small changes in those S boxes for example means that the Avalanche effect is not not as good and that there's more weaknesses in deaths which suggests that they chose the design to be strong they knew about other attacks so generally Des is considered a good algorithm but poor key length and definitely not not suitable today what about other Cycles triple deaths AES and other block Cycles so the next move since deaths was considered good to apply it multiple times we'll come back to this we'll look at double desk and triple deaths come back to these and look at an attack in some detail but it turned out that even triple deaths was considered secure it was three times as slow as death because in fact you apply the same algorithm three times so to encrypt something was three times slower than desk which wasn't fast uh in the start so the advanced encryption standard was developed designed in the the late 90s the idea was to make a secure of course but also to work well on different types of hardware and in software the advanced encryption standard is used and highly recommended for use today so still considered secure and it's recommended by the US government for example and many people use it in many different implementations in wireless LAN in internet communications in file 11 encryption so if you encrypt your hard disk with Windows or your operating system it usually uses a yes so it's very common it uses 128 bit blocks okay this was 64 bits AES 128 bits it allowed different size keys 128 192 256. so the longer the key the the more secure against Brute Force it used rounds and depending upon the key length it used different rounds 10 to 14 different rounds and used xor and some other s boxes and some other arithmetic that was a little bit more complicated than deaths but still considered secure we're not going to cover the details of AES we just used desk to show an example of one Cipher the other ciphers we will not go into that detail we just mention characteristics but a yes is considered a good Cipher to use that today generally considered secure and others a list of some not all block ciphers some of the designers when they were designed at some characteristics of the block size the key size the design approach the fastest structure is similar to what deaths used those rounds with substitutions permutations they all use similar approaches not the same some are more secure than others generally AES is considered a highly recommended let's go back to death double deaths and triple deaths so given death is considered secure but the key length is too short the idea to improve it was to apply it multiple times then you can reuse the software and Hardware that already implements this so and all the the experience of using it can be reused so encrypt multiple times each time you encrypt use a different key then for a Brute Force attack the attacker needs to guess all keys you use and effectively increases the key length turns out double desk is not so good and therefore triple death was designed so let's look at why double desk is no good that is and also the general concept of double encryption it's not just double deaths this is the idea we have some plain text normally we encrypt using some key and we get output ciphertext so Brute Force requires guessing that key with double encryption we take our plain text equipped with one key hit some intermediate value X then encrypt that intermediate value with the same Cipher but using a different key and then our cycle text is the output so our key is actually made up of two parts K1 and K2 and they are they're different say two random keys so now what an attacker needs to do effectively our key length has doubled for Approved Force attack they need to guess both values they need to try all values and therefore if K1 is 56 bits like in death and K2 is a different 56 bits then the attacker for a Brute Force attack needs to try 112 bits that is 2 to the power of 112 operations so that was the idea of double encryption but it turns out it has a severe weakness and we'll use an example to go through that Witness so how that weakness arrives and the example you have one in your handouts but I created a bigger one which is a little bit more interesting so take one of these and pass along it's a cipher but a a block Cipher will use as an example you don't need to do other courses you can do other courses at other times try and solve this a few more enough okay just give this to your old shot on the screen and explain what it is we'll use it as an example three more with me first what what is this this is our let's say our our Cipher that we've designed it's a five bit block Cipher that is the block of plain text is five bits we take five bits of plain text we'll apply our Cipher we'll get five bits of ciphertext as the output so a five bit Block in this case to keep it small and we've got a three bit key so the way we read this table is that with a five bit input block there are 32 possible plain text inputs two to the power five and I've listed them here on the left column and then what I've done is said that okay if we're using this particular key in the next columns the keys up the top zero zero zero for example if we take the ciphertext five zeros using key zero zero zero the output ciphertext will be zero zero zero one if I used a different key for example one one one here in the last column encrypt the same plain text the output ciphertext would be one one zero one that's the right way to read this this table plain text input different Keys along the top and the corresponding ciphertext that will get out of our Cipher when we use that key I've just randomly created this okay this arrangement and each of these columns are just randomly mixed them up if you you check you'll see that this this column with a key zero zero zero the 32 values here is just a random arrangement of the 32 possible plain text values so we have a reversible mapping we don't map one plain text to more than one ciphertext value there's 32 unique values here and I've just a different random arrangement in the second and the subsequent so that's our simple Cipher that we can encrypt any plain text five bits long and we'll get a ciphertext as output given one of the three bit keys consider this is our Cipher uh and we want to increase the key length so we have our Cipher like a desk but we want to apply it two times to increase the key length our double Cipher double encryption so what we do is we encrypt twice but using different Keys each time so the concept is let's call our Cipher ABC in the normal approach what we do is we take some plain text in our Cipher ABC takes a key as in and produces ciphertext's output and the the ciphertext it produces is given by that table let's say we want to do it differently and use double encryption we take our five and the plaintext is five fifths cypertext is five fifths and the key was three bits let's say we take our plain text in apply ABC Once with key one and then we'll get an intermediate output equal x and then apply the same Cipher again on the x value with a different key 2 and we'll get our cyber text so that's our double encryption let's see how that works and see how we can attack that just to make sure people are awake with double encryption no we'll see how you're awakened when we go through our example um so we're going to do an attack on this Cipher first Brute Force attack on the single instance of the cipher what would approve how many operations does a Brute Force attack take in the worst case Brute Force on the single instance well we need to try all possible keys we have a three bit key so there are eight possible keys so a group Force takes two to the power of three or eight operations what about a brute force on our double Cipher how many operations calculate the number of operations to the power of 9. not how many keys do you get to choose from how many possible keys are think of the key in the double Cipher as just being a combination of those two a concatenation of those two that is to encrypt what I do is I choose K1 one of eight and then I choose K2 one of eight so how many possible values do we have that is I can choose a three bit value here three bit value here we could say our resulting key is it's a K1 combined with K2 so how many keys do we have how many possible keys 64 where does that come from okay there's there are eight values for the first key there are eight possible values for the second key so let's say we choose the first value for the first key then we can choose one of eight values for the second if we choose the second for here we can choose one of eight we get eight times eight or two to the power of six we have effectively six bits okay three bits here three bits here the resulting key is the combinate or the uh concatenation of those two so effectively we have six bits we've doubled the key length with six bits our brute force would take two to the power of six or 64. operations of course easy to break but we'll see uh much stronger in theory than our single Cipher doubling the key length any problems so far on this concept so we double our key length by applying the cipher twice with respect to a Brute Force attack so if I give you a plain text oh sorry if I give you a ciphertext you if I give you a ciphertext output it's five bits you can try all 64 keys and one of them will give you the correct plain text which one is going to be hard to tell but in general when we have a large plain text and structure in the plaintext we'll be able to find now it turns out although a Brute Force attack takes 64 operations 2 to the power of six there's a what's called a meat in the middle attack which will take much less effort in fact the meat in the middle attack will show we can break this Cipher in about the same number as operations as a single version so let's try it so we're going to apply the double Cipher the meat in the middle attack assumes the attacker knows some plain text ciphertex pairs so that's the first Assumption of this attack and I'll give you some and we'll make use of them so the attacker now in the meat in the middle let's try and attack and the attacker for this attack to be successful needs to know some pairs of plain Tech ciphertax and I'll give you some I'll give you two to get started so how to interpret this is this is some plain tax value this is a ciphertax value let's call it P1 c one and this is another plain text value P2 and C2 let's assume the attacker knows these values somehow they've discovered these values and they don't know the key the map the plain text to the ciphertext so they know these pairs their aim is to find the key so the aim for the attacker find the key given our Cipher and given these pairs a Brute Force attack we could take our ciphertext and try all 64 Keys one of them would give us this plain text and we'd know that key gives us the correct uh plain text and that's the key to use but we can be faster than a trying all 64. let's see how so the first step for the meeting the middle attack is that we take one of the known plain text cyphertex Pairs and starting with the plain text encrypted using all possible key values so we'll start with P1 and encrypt P1 so Brute Force against P1 but for a single version of the cipher so using different key values how many possible key values are there for a single version of the cipher that is let's go to our picture what we're going to do is the attacker is we've got a value of P we're going to encrypt that using our table with a all possible values of K1 how many values well there are three bits so there are eight possible values of K1 and that's the the eight columns here okay one of zero zero zero through to K1 of 1 1 1. encrypt that plain text and we'll get eight values of this intermediate value X do that see what you get so you take that plain text and encrypt it with our Cipher our single version of the cipher and get eight values of this intermediate output I'll call it X uh PSI X 1 with K1 X11 so when we take P1 0 1 1 0 1 and use key zero zero zero what do we get as an output well you look up the table our plain text zero one one zero one is here what you do is you take the plain text value encrypt it with the first key all zeros and this will be the value of the x that comes out our intermediate value and then do it again for the second key and you'll get this value and the third key through the eight key so we get these eight intermediate values that's the first stage of this attack what we're gonna what we're trying to do is to find the key in less than two to the 2 to the power of six operations in less than 64 operations the first case is encrypt a encrypt the plain text with eight keys so eight operations and you get these eight values as output I X values so I'll list them you can check I've got the answers in front of me but just from that table that row gives us the eight possible values if we encrypt using the second key the third key gives us one oh fourth key those eight values are just the row in that that table you check so the row where the plain text is zero one one zero one for the eight different keys so we just encrypt using our single Cipher that with all keys how many operations so far or eight operations one for each key next step is to take so we knew P1 and we know the corresponding ciphertext C1 what we just did is take P1 encrypt it with all possible Keys the next step is to take the corresponding ciphertext and decrypt it with all possible Eight Keys and we should get matching X values why look at our diagram our Cipher is if we encrypt p with all values of K1 we'll get these eight X values we know the corresponding ciphertext with e so if we decrypt C going backwards C going backwards with all possible values of the key then we'll get eight possible X values at least one of them those X values should match because if we use the correct key if we're using the correct key we take P1 encrypt with the correct key one we get an X if we have the ciphertext and decrypt with the correct key we must get the same X so from the attacker's point of view try C1 decrypted with all eight keys k2s to get a set of eight X ones encrypt the plain text with all keys decrypt the ciphertext with all keys with the aim of meeting in the middle so we know C1 C1 is our all ones if we use the correct key if we encrypt P1 with the correct K1 and decrypt C1 with the correct K2 which will get the same x value so let's try so given C1 what is the plain text if we decrypt using key zero zero zero or we can see from the table if the ciphertext is all ones where are we the Cyber text is all ones here if we decrypt using key zero zero zero the plain text will be one zero zero zero one so we're going backwards now decrypting this table shows taking the plain text with the keys we'll get this ciphertext so to decrypt we find the ciphertext corresponding K column gives us the plaintext so decrypting this with key zero zero zero gives us one zero zero one so that's our first x value and then we do it for the next key so same ciphertext will give us this plain text 0 0 1 1 0. and then for subsequent years if I can find all ones we have it somewhere down here and so on okay so we take the ciphertext decrypt with all the Eight Keys and the values that we'll get I have them are those eight values so if you look up the ciphertext with each of those Eight Keys the corresponding plain text values will be these eight and what we said is that if we'd use the correct key the X values if we come from both directions should match which X values match none of them yes some of them do don't necessarily look in this way that is if I encrypt P P1 with this key I get this value if I decrypt the ciphertext with any of these Eight Keys these are the eight X values I get does this x match one of these eight and we check which ones match and how many try and find them you'll see that the first x value is not in the list one one one zero one is not in this list the second one zero zero one one do we have a currency yes we do there's a match here and then we do it for the rest and this one matches in two instances I thought it was in two instances yep you see now that the three sets of values that match that is here uh what have I yeah zero zero one one zero zero one one one zero one zero zero zero zero one zero zero zero what does that tell us it tells us the possible keys are either okay what so K1 tells us this value K2 this value so K1 being 0 0 1 and K2 being 1 0 0. or K1 is zero one one produce this x value and K2 being 1 1 1 or K1 K2 so it tells us that we've got three potential keys in this case let's list them okay one the first match is that's this value here and the corresponding K2 that gives us the correct ciphertext V100 remember our our final key is just the combination of K1 and K2 that's a potential correct key but there are two others as well and K1 one zero zero a two or one so the attacker has now broken down to being three possible correct values how do we know which one's the real one we use our second pair of plaintiff cytotecs that we know so we assumed at the start that the attacker already knew two pairs of plantex cytotecs sometimes they need just one it turns out sometimes in many cases there'll be just one correct value and that's it you found the key if not you need a second pair and what we do now is check if we take P2 encrypt with K1 of 0 0 1 we'll get some intermediate value then take the intermediate value and encrypt with K2 do we get C2 if so this is the key if not try this one or this one which one is it so what you do now is take your P2 and encrypt with K1 find the intermediate value then encrypt again with K2 and the ciphertext you get if this is the correct key pair or set of keys is C2 let's look in the table P2 is 1 1 0 0 1. P2 is one one zero zero one and the first possible key was zero one zero is that right zero zero one so we try zero zero one encrypt P2 with zero zero one the intermediate value is five zeros and then take the intermediate value and encrypt it with K2 so all zeros encrypt it with K2 and what was K2 one zero zero we get this value as an output one one zero one one is it correct yes it is so what we just do we talk if I can fit it in here we took our plain text 11001 encrypted with this key and the output was our intermediate value of all zeros and then we took that value encrypt with a second key and the output was one one zero one one and in fact that matches our expected ciphertext C2 we've found our key already we're lucky in this case we didn't have to try the second two but you can try the second two and you'll see that they don't produce the correct ciphertext just to confirm you'll see that if you take P2 with these two keys you will not get C2 and the same with the second one so we have the answer the attacker knows the key it's zero zero one one zero zero how many operations did we take to do that how many encrypts or decrypts we treat encrypts and decrypts the same in terms of the amount of effort so how many well we can count them we took our plain text and tried all Eight Keys two to the power of three or eight operations there so in the first instance we took here 2 to the power 3 operations and then we did the same with our ciphertext try all keys so another 2 to the power of three operations and then we did One two operations here just to check so two in this case so the total number of operations 2 to the power of three plus two to the power three plus another two compare that to Brute Force our brute force is 2 to the power of six in this attack we had plus another two 18 operations or 2 to the power of three plus one plus those extra two to the power of three plus two to the power of three is two times two to the power 3 which is 2 to the power of three plus one plus another two small ones at the end sometimes we don't need to row those two at the end uh it will vary Brute Force 2 to the power of six operations meet in the middle attack two to the power of four plus a couple of others extend that from not a threebit cipher to a 56bit cipher of deaths our example we use a three bit key same concept applies in deaths if you use a 56 bit key brute force in death would take and running out of space but in death brute force would take 2 to the power of 112. with a 56bit key but the meat in the middle attack we see with a three bit key is 2 to the power of three plus one plus a few others turns out that this is usually quite small compared to this so it turns out with and 2 to the power of two times three for brute force with this Brute Force 2 to the power of 12 with a meat in the middle on S is 2 to the power of 56 plus one plus some others and usually that's quite small it's a compared to two to the power of 56. so approximately two times normal deaths and meet in the middle attack on double deaths takes about twice as much of effort as a brute force on single deaths double desk is about two times stronger than single deaths which is nothing so if single desk takes two days to break double desk takes four days which is nothing in terms of security it's not secure or if it cost a thousand dollars to break deaths it costs two thousand dollars to break double discs so using double desk doesn't provide much advantage over single deaths because of the meat in the middle attack hence double death is not used and in general double encryption okay this is a problem with double encryption turns out by using three stages not two we can overcome this meat of the middle attack and that's where we get to Triple deaths and that's what's used in practice today so we're out of time so try and get your heads around how to do a meet in the middle attack on double encryption but in summary we need some known plain text cycertex pairs that's an assumption the attacker knows these values at the start just two normally even with real deaths you don't need to know many you take a plain text encrypt with all possible keys 2 to the power of K if our single single cipase K bit key length and then take that corresponding ciphertext and decrypt with all possible Keys another 2 to the power of K and then if you find the matching ones and if you have more than one then try the second pair and usually there's not many that are that are matching so it doesn't take many further operations to do those second second pair and then you find the key so double encryption doesn't help triple encryption avoids this problem let's stop there next week we'll move on to the next topic of using modes of operation how do we encrypt a large document these are operating on 64 bits 128 bits what happens if we have one megabyte and then move on to I think public key encryption maybe next week we'll get on to that if you want to collect your hard copies of your quiz you may do so they're in alphabetical order so you may find your name so this topic we're going to get to very cover very briefly stream ciphers and relate it to that and a very important part of many security algorithms is random numbers okay so we'll talk first about random numbers and then some quick examples of stream ciphers and then return and look at brute force and other attacks on cyphers in general with our block Cipher with AES for example it operates on a block of 128 bits at a time and one mode of AES I use 128 bit key and to use a a block Cipher a symmetric Cipher the encrypter and decrypter must know the same key okay so we encrypt with one key we decrypt with the same key that's the idea of a symmetric cycle how do we choose a key choose 128bit value 128bit key anyone how are you going to choose one uh what about and I will not write all 128 bits but what about this as a key if I choose a key I want it to be secret but I'll tell you okay all zeros 128 bits and maybe a one at the end decimal one I chose that as my key and I tell you the person I want to send a message to and what I do is I take my data my file I encrypt using AES using this 128 bit key you know the key so you can decrypt is that okay secure why why is it what's wrong all right everyone knows but let's say I trust you and we don't want uh someone from uh it section to know so what can an attacker do to try and decrypt the ciphertext that we get so I take some plain text encrypt using this key and I get some ciphertext the attacker has the side for text assuming we have a strong Cipher there are no known attacks against the cipher what's the what can the attacker do to try and break the ciphertext to get the plain text what can they do they don't know the key what can the attacker do come on you you need to be think like a malicious person I know Brute Force generally brute force or trying guess Keys okay Brute Force means gas a key that is take the ciphertext let's as an attacker guess choose some random key decrypt and see if the plain text we get from decryption makes sense if it does we've found the key okay if it doesn't we try a different key we guess a different key and we keep guessing keys until we get one that decrypts successfully now maybe as an attacker instead of getting random Keys maybe you'd start with some uh structured keys what if maybe I'll try all zeros as a key as the attacker guess that one first and maybe try this key second yes it can be a random value but the attacker if they have some knowledge about how you may choose the keys they can use that to try and try those keys first which gives a much more chance of finding the plain text brute force is going to take too long but if they can try the keys all zeros or ones 127 zeros and one one then immediately they found the plain text the point is if you want to prevent a Brute Force attack when you choose a key you should choose random keys if you choose a key okay let's just use all ones because it's easy to write down then it's not random and the attacker can take that knowledge okay Steve's lazy he just chooses Keys which are easy to write down and he'll try them first and find the the plain text so when you choose a key it should be a random value similar when you choose a password for your login for Moodle which should be a random password a random set of characters everyone chooses random passwords for your bank account your Hotmail your or your no one chooses random passwords okay we'll come to that in another topic uh because random passwords for humans are hard to remember but for computers because usually the user doesn't have to remember the key we'll see that it's usually software choosing the key so they can random choose a random value and store it in memory or on disk and encrypt using the random key so we need to use random numbers to generate keys for encryption many other aspects of security network and and security protocols make use of random numbers and that's why we're talking about random numbers now because they in fact used in many parts of security one of them is choosing keys but there are other parts where we use random numbers how do you choose a random number come on you've all had almost two weeks holiday or maybe holiday uh so you're all your brains are refreshed yeah to choose a random number use the current time okay is the time random sorry use the time to generate a fake random number the time's predictable it's not random the time now and the time in one second time I can predict what that is the time is not random what can we do with it throw a dice okay so every time I wanted I want to choose 128 bit key so what do I do get a a die 128 side die and roll it uh or two side and roll it 128 times flip a coin okay not very convenient how you get a computer to Generate random numbers you use a function what function on your computer scientists give me an example Rand use the Rand function okay great now your task is to implement a new Rand function how you're going to implement it what does a Rand function do it's not magic it follows some steps you can't just rely on that all the time so is how would the Rand function in your programming language be implemented how do you think a computer can Generate random numbers anyone use the the ID of the CPU or uh of the process the software process uh uh usually not random usually limited between zero and sixty five thousand or so uh there's not many values to choose from I suspect it's not very random I want to choose a a value of 128 bits length and I think there'll be some structure in the processes the first process will always be process ID one say on our Unix system where do you generate how do you Generate random numbers okay let's try easily how do you Generate random numbers I ask you choose a random number between one and one million or too slow for my software okay anyone else how do you Generate random numbers well it's hard to describe isn't it how do you remember a computer just does what we program it to do okay we program a computer from the very Basics the Assembly Language to program you know the operations so to implement that Rand function in C or in whatever language you use we must program some function so in most cases we actually don't you create real random numbers or true random numbers we use some function that approximates random numbers and we'll go through some functions some are very simple some are more complex but it's really just a function that takes some input and produces hopefully some numbers which look random so it's not easy to create random numbers in many cases with our computers we generate what we'll call pseudorandom numbers not quite not not really random but approximately okay so we often call them pseudorandom numbers not true random numbers so let's let's explore that a bit further and see how computers May Generate random numbers why do we need random numbers in security select Keys we need to random numbers and we need to do it fast and so we can't just roll it roll a dice manually we need software to implement to choose a random number and be able to do it quite quickly and repeatedly and there's a number of other so generating keys uh we'll use them in stream ciphers authentication we'll see these Concepts or Technologies later they all make use of random numbers so we need random numbers what do we mean by Randomness a uniform distribution is one measure there are others it's not the only one but think of a sequence of numbers then we'd expect if it's a binary value we'd expect on average for a long sequence we'd have the same number of zeros and ones so a long sequence say if we consider many many random numbers binary say millions of bits we'd expect not all of those best to be zero if all of those one million bits were zero I would guess that that's not a random number so we'll have to expect uh the same frequency of ones or zeros that we consider a a binary value but not necessarily 500 000 ones followed by five hundred thousand zeros same number of ones and zeros but we'd look at subsequences instead of looking at all one million look at five hundred thousand we'd expect approximately half of them to be zeros and ones as well solves different subsequences we'd expect a uniform distribution of our zeros and ones that's one measure or one way that we we try and interpret randomness another one is the independence take a sequence of numbers the next number in the sequence should not depend upon the previous numbers or at least it should be very hard to see the relationship we'll see with pseudorandom numbers let me generate a random sequence of numbers I'm going to write some numbers let's say I have a random number generator and I call it many times okay my code calls the Rand function many times and it returns these values the first value it returns is 10 that's working decimal the second value it returns is 20. the third value is 30. and then 40. what do you think the and then 50 what do you think this value is going to be we'd say that this value is not in independent of the previous values it's actually dependent on the previous value we see there's a pattern here is this a random sequence no there's some structuring this the next value in our sequence was dependent on the previous values and here it's quite obvious it was dependent what about this what's the next value a sequence of numbers generated by the Rand function the first time I call it 17 then 26 then 93 1 52 what's the next value what's the next value what do you think and I'll give you a hint it's been between zero and one hundred I don't know that is there's no pattern in this case I tried to choose them randomly in my head in this case so we'd say that we have a sequence and we cannot see any dependence between the numbers whereas in the first sequence we could see the dependence that they're increasing by 10. in this case we cannot see the dependence between the numbers and that hopefully this next one is into independent of the previous ones it doesn't depend upon the previous values if so then we generate a random sequence of numbers so we'd like Independence of our numbers so that given one value we cannot infer what the next value would be so you couldn't guess what this would be well you couldn't correctly guess uh because you there's no dependence between those numbers so that's what we'd like in a random number generator and that another way to interpret that is it's hard to predict the next value okay and that's an important property for security we'll see why soon so we distinguish between true random number generators and pseudo random number generators sometimes shorteners prng pseudorandom functions let's let's ignore that we're not talk about that keep it simple a true random number generator uses some physical source some nondeterministic source to Generate random numbers nondeterministic means it's not predetermined we do not have some algorithm for generating them some examples of such sources something that measures radiation events in in the physical environment uh radiation measurements of radiation from some source is in is considered to be random or as close as random as as we know in physics similarly if we have capacitors on some electronic uh set of on a motherboard for example or on on a circuit board the measurements from those capacitors usually exhibits randomness some noise from different electronic components it's considered that the noise is not predictable it's random uh or some noise from some audio system okay some the noise that's come comes out of the the speakers through the the audio system is often considered random truly random so yes we can use in computers some of these sources okay well we'll talk about that uh okay and then maybe a little bit less so but still often considered true random is different physical activities if we think about a computer uh measuring the difference between the times of i o input output operations on a hard disk okay the the rights and the reads on the hard disk uh over different periods of time uh in some cases exhibits true randomness or interrupts in fact usually combining these together not just one but looking at the time in which software or interrupts occur on from a piece of hardware disk read write operations activity on a keyboard even on a mouse can start to exhibit true randomness all of these true random number generators usually require some physical device to measure them okay how do I get random numbers out of some radiation or leaky capacitors I need some special device to measure the input and then convert it into binary for our random numbers and usually they generate just a small number of values over a period of time so because they need physical devices to implement random number generators using true sources on on computers is usually costly or inconvenient so it's not so calm who has a radiation measuring device on their laptop no one okay so how do you get random numbers on your laptop how does the Rand function work well we use what's called pseudorandom number generators we use some algorithm or function to calculate numbers and output a sequence of numbers such that hopefully if it's a good algorithm those that sequence of numbers appears to be random it's not truly random but for most practical purposes it's random enough relatively random sequence but note it's a deterministic algorithm the algorithm is implemented follows some steps so in theory you can determine the next value you can determine what the values are going to be in the sequence in practice it just needs to be hard to predict the next value so in practice most computers use pseudorandom number generators some special cases may use true random number generators for example you buy CPUs now like an Intel or an AMD CPU and they have inbuilt their own operations to Generate random numbers and it's thought that they take some measurements of what the CPU is doing to get some input of randomness and that can be used as a true random number generator so to use in a computer system where we need a generate a random number or a sequence of bits if we have a source of true Randomness we can measure that and then convert it into binary and we get our random stream of bits but that requires some physical measurements usually and it's inconvenient so in a pseudorandom number generator what we do is we just have some algorithm that takes some initial input some initial value and with random numbers it's called the seed value and that algorithm takes that c produces an output and usually has some feedback the next value is fed back and produces the the next value so we generate a stream of bits if we look in binary and that's a pseudorandom number generator let's go straight to an example we'll come back to some of the things we skip the linear congruential generator lcg an example of a simple pseudorandom number generator simple to explain and go through a few examples uh here it is the idea of random number generators is they generate a sequence of numbers where that sequence should appear random so this function or algorithm is defined here where it takes several parameters the idea is that we have three constants a C and M a is a multiplier C is just some value that we add and we take the current value of our random our current random value and multiply by a add C and mod by m the modulus and that produces our next random value in the sequence and to generate the next value then we use the the previous one again and use the same function and generate hopefully a random sequence so just let's see how that works in practice and then we'll come and discuss some of the design issues so what we need to do is choose values of these constants a C and M so the constants for this algorithm and we have an initial value X 0. we need to start with some value that's called our seed value so we'll choose a seed value so I'll give you some parameters and you'll calculate some of the values in the sequence let's say to get started we choose uh we're using lcg and the parameters you can try let's keep it simple a is one C is one m is 100 and we start with an initial value a seed value x0 of let's say 23. no significance of the sea generate the next few numbers in the sequence using the lcg function see what happens so use those three constants in that algorithm in that equation and the initial value x0 and see what X1 is and X2 and that will be our sequence generated by this pseudorandom number generator so find X1 when you have X1 you can find X2 and X3 anyone have the values of the the first 10 X1 through to X10 so simply look at that equation x n plus 1 equals a x n plus C Mod m you have the constants AC and M you have x0 so from that you can calculate X1 n equals zero so you'll get X1 as the output then do it for the first few values what do you get keep going values come on come on give me some random numbers no need to use your computer to calculate I think you can calculate addition and multiplication by yourself but fine use your computer see if this random number generator is as good as the one that the Mac OS uses excuse me X1 24. keep going X2 X3 X4 let's see so simply a times x n the current value plus C Mod m m is 100 C is one a is one so in fact we forget about a because it's multiplied by by one so it's the current value plus one mod 100. so the current value plus one mod 100. 24. X2 be 24 plus 1 mod 100. so we say x our sequence we're starting with x0 our C was 23 and if we write the sequence of numbers I think you'll see 24 25 we just PL add one all the time up to where 99 what's after 99. zero mod 100 and eventually we'll get back to 23. that's a comma okay all right not a very good random sequence so this is our random number generator but with the set of parameters we've used it's not very good okay so we'll change the parameters in a moment uh so we just increment by one so uh not a good random sequence but we the aim is to generate a sequence of numbers which is appears random this one doesn't appear random it's obvious in this case now uh but some characteristics note that when we get back to 23 if we keep going we'd be back to 24 25 and we just repeat all the time we'd get back to 23 and repeat re repeat so the set of unique values is called the period or the length of those unique values is the period of this sequence what's the period of this sequence or how many values so the period in this case goes from here up to 22 in fact so 23 all the way through to 22 and how many values there 100 the period of this sequence we have 100 different values generated here we'll return to what we why that's significant after we see a few other sequences let's try again but with some different parameters and see if we can get a better random sequence one that it looks more random let's try our lcg same algorithm but let's try a is seven C is zero and M is 32. and a seed of one generate the the set of sequence numbers with this configuration of the lcg easy tasks same algorithm different parameters a is 7 C is zero m is 32. okay X1 what value do you get remember we have a times x zero seven times one plus c all mod m foreign and X2 foreign to keep your brains working I know some simple mathematics X2 17 someone's got 17 that sounds familiar X2 17. again no problem seven a times our previous value all right a times our previous value which was seven plus zero mod 32. 49 Mod 32 17. X3 and you'll do the same 7 times 17 which is 119 Mod 32 23. good you can check X4 7 times 23 which is 161 mod 732 is 1. okay X5 it's seven again we're back we're repeating again okay because if we have one we've already got to one so from one the input will be seven again we repeat so we can say this sequence in this case X we start at one seven twenty three a period of four there are just four values generated with this sequence and then we repeat in the previous sequence we had a period of 100. we'll see the longer the period the better but not necessarily the better random sequence okay we saw would we have 23 24 25 definitely not random looks a little bit more random it's not one two three four five but can we do better well if you change the parameters around you can start to get more random looking sequences so it's all about with this algorithm choosing the correct parameter values uh we'll not go through it I'll give you a one that you can check later another configuration uh a is five C is zero again m is still 32. with the same seed of one we get and I've calculated it before one five 25 29 17 21 9 13. and then we go back to one a period of eight so we have a very simple algorithm with several parameters and it turns out with this algorithm if we choose the parameters well so some parameters are not good the first set were terrible because we just got incrementing numbers if we choose them well though we can generate quite good random sequences this sequence 1 5 25 29 17 21 9 13. can you see any structure there nothing obvious okay there is structure because it comes from an equation okay but the sequence at least very simple example it looks to have some randomness especially compared to the first sequence which was just incrementing numbers the third one compared to the previous one all right there's only four numbers there in general the longer the period the better we desire a long period that is a large number of numbers before we repeat with lcg how do we make the period longer what's all right in theory what's the maximum period uh it's m okay this equation take some value mod m so the answers are always going to be between 0 and M minus 1. we can never have an answer which is larger than or M or larger because we mod by m so the period is limited by m in this case so if you want a large period make M large and some recommended values for using lcg in practice is to make M as large as possible and it turns out it's good if it's a prime number modding by a prime number will give us more distinct values in in the result so choose the the a prime number as large as possible well that depends upon your your computer say if you've got 32bit numbers uh a large prime number is 2 to the power of 31 minus one people have found that before which means the maximum possible period if you use this value of M is about 2 to the power of 31. okay about 2 billion so you can have up to about two billion different values in your random sequence then you'll have to repeat guaranteed you'll have to repeat and you need to choose values of A and C which are good the first values we chose were not good some people have done analysis and found out if C is zero some there are several good values of a one is turns out sixteen thousand eight hundred and seven try set C to 0 a to sixteen thousand eight hundred and seven M to 2 to the 31 minus one choose a seed choose x0 and start calculating the sequence of values and you'll see you'll get a very long sequence of different values before they repeat and they will look random so there's the first example of a very simple algorithm to Generate random numbers so your random function in your programming language we'll use a pseudorandom number generator not necessarily this one maybe maybe a different one we'll use a pseudorandom number generator to generate a sequence of numbers and they will always have a period a finite period which means if you keep calling that random number generator eventually you'll get back to the first value and repeat the sequence unless you change the parameters and that's where the seed is important by changing the seed you'll get a different sequence to start with so if you're using the random function in your programming language then often there's a way to change the seed for that random number generator and that will produce the different sequence of random numbers let's go back and see some of the general concept we've missed so what would we like with a pseudorandom number generator we want to be able to generate a stream of numbers a sequence of numbers usually we think about binary all right our examples we use decimal but usually we want binary values for security or for security applications we're generally like such that we can generate some stream of random numbers but if you don't know the seed that initial value it should be hard to determine the sequence okay so if you don't know what the seed is an attacker even if they know that algorithm shouldn't be able to determine what the sequence is should be unpredictable forward and backward unpredictability means that given some value cannot predict the next value okay you cannot predict forward or given some values you cannot predict previous values so given subsequent values you cannot predict what happened in the past there are different tests so we've just said we said this sequence looks random okay there is a mathematical test to start to consider a sequence and give some measurements of how random it is okay so there are different tests to to be more scientific than just saying it looks random like looking at the frequency of numbers and bits that occur in there how often they occur the subsequences things like compressing if it compresses well it's not random if it doesn't compress well then it generally exhibits randomness so what we're like is when we use random numbers for security purposes is a generator such that if the attacker doesn't know the seed they cannot predict other values in the sequence and for that to work we normally need to keep the seed Secret and often to choose a seed we don't just choose x 0 equals one we choose a seed which is random and a common way is then to use a pseudo a true random number generator use a true random number generator to generate a seed and then use that seed in a pseudorandom number generator to generate a larger sequence it's more convenient because true random number generators generally just work or only produce a small sequence of values in a fixed period of time so a common use of random numbers for security purposes you have it says an entropy Source but think of some physical Source some measurement of the CPU operations the the disk operations the noise from circuits you have different sources you have some device that can measure those sources and generates some random number we'll use that as a seed into our pseudorandom number generator which generates a large sequence of random numbers true random numbers are typically generated only a small sequence of values in some period of time pseudorandom number generators can generate many random numbers in the same period of time so this is a common way to use it often your operating system May try and implement this in that your operating system provides a facility for generating random numbers in that your computer measures different characteristics and you can use a combination of physical sources CPU operations hard disk operations keyboard input Mouse movements different physical operations on your computer are measured and used to generate a true random number generator which is then used as a seed in a sum function our pseudorandom generator which is then made available to Applications by your operating system what's another random number generator there are many others okay we've just gone through a simple one that we can demonstrate lcg turns out it's not very secure lcg so it's not commonly recommended for when you want strong security there are other algorithms which are better developed by three people a different algorithm it's considered secure when we use it for for cryptographic or security applications you can see the example on the next slide but we take some large prime numbers um and this may not make sense to you yet but we'll in the next few topics such that those large numbers when we mod by four give three calculate some large n by multiplying those prime numbers and we take our initial value as some random s squared mod n and then go through a loop and generate x i based upon the previous value squared mod n and extract the last bit in that number to get the the sequence of random numbers but not so important to go through that have a look if you want so an example of some initial parameters we go through and generate these values using the equation and we take the last bit from that and our random bit stream is one one zero zero one one zero zero zero zero one and keep going okay so that's the output in this case not these numbers but those bits are the output and we just keep running that Loop okay it's a for Loop it can run forever just keep running that and it keeps generating a stream of bits this is our random bit stream if we want to generate our 128 bit key we run it 128 times iterations uh I think somewhere else maybe I don't but there are many other algorithms and I think that will stop for us on random numbers there are different algorithms we can all use soyuz block ciphers like des and AES to Generate random numbers because encryption the idea of encryption takes some structured plain text produce some random looking ciphertext so encrypting something produces a random number so we can use encryption to Generate random numbers so it works quite well the problem is often it's quite slow to encrypt something compared to using the algorithms we've seen so we can use encryption if needed let's have a look at an example several examples let me just check uh say on a Unix operating system the operating system has its own random number generator so it measures and there are different implementations but it commonly measures different inputs from the hardware and think of that as the true random number generator and generates a sequence using some pseudorandom number generator in Unix or Linux operating systems it's called a special device called random or you random and it just keeps generating random numbers but it generates a sequence a binary sequence so if I look at the contents of view random which is generated by my operating system I'll see random bits but if I display it on the screen it will come out as garbage so I will just display a selection of it using this program xxd xxd takes the binary value and converts to hexadecimal Okay so this displays the output of the operating system random number generator a sequence of bits head minus one just takes the first line of output okay because it keeps going and xxd takes that first line of output which is a sequence of bits and converts it to hexadecimal so I can show on the screen 7 5 8B this is the the random hexadecimal digits okay so uh that's produced from the operating system just an example and other operating systems would have their own implementations of random number generators some are more secure than others in terms of the ability to predict the next value in the sequence if I want in binary doesn't show as well but we can convert instead of hexadecimal into binary and we get our binary sequence do it again uh let's zoom out a bit if I keep doing it you should see it's not easy to see but if you compare all those values you'll see that that different there's no structure in there okay if you do tests on the randomness on those sequences of zeros and ones you should see that they exhibit those characteristics of uh unpredictability and distribution of zeros and ones the next part is related is stream ciphers but let's let's finish with something else let's not cover stream cybers today and go back and look at uh in the last 10 minutes something that we skipped is a tax on block science and the last slide one of the last slides returning the block site as Des AES triple Dash and others how secure are they well there are two types of attacks brute force and crypt analysis Brute Force try all keys so the security depends upon the length of the key so with this the key space with a 56bit key is 2 to the power of 56 so an attack on deaths the time it takes if we measure in number of operations we need 2 to the power of 56 operations to find the key Brute Force try all keys in worst case so we talk about the time for a DEC attack the best known method is in fact Brute Force takes 2 to the power of 56 operations which is feasible today with the right Hardware that's possible triple Jess if you use three different Keys three different desk keys or 56 bits gives us a key length of 168 bits so the key space is 2 to the power of 168. a Brute Force attack on Triple deaths would require 2 to the power of 168 operations okay so if you do the calculations that's going to take forever but we can still use the man in the middle attack on Triple death but we need to do it two times because we have two values in the middle triple deaths double deaths had encrypt you get an x value encrypt again with triple Dash encrypt we get X1 encrypt get x2 and get our ciphertext after the third encryption we can do a man in the middle but it takes much more effort because we need to do it two times effectively turns out the amount of effort required using a man in the middle attack on Triple deaths requires 2 to the power of 111 operations Brute Force 2 to the power of 168 but with a man in the middle we cut it down to just 2 to the power of 111. there are other known attacks one of them by Lux who's wrote a paper about it takes a little bit longer 2 to the power of 113. so we measure attacks based upon how many operations they they would take We compare them to Brute Force if it's slower than Brute Force then it's not a good attack if it's faster than Brute Force then then that's better how much faster we care about so brute force on Triple deaths 2 to the one six eight but there are better known attacks which bring it down to much less but still 2 to the power of 111 still would take a long time and we've got some slides earlier I think we've seen how long that would take but with these attacks the other thing to measure how good they are remember with double desks we assume the attacker knew some plain text cyphertex pairs in advance to perform the attack the attacker needed to know something in the advance so we often measure how much data is known in advance the more you need to know the harder it is for the attacker okay so with a man in the middle attack you only need to know four different values that's nothing that's easy but with this other attack you need to know about four billion different values which is much harder in practice to know those values so we can compare them based upon how much data they need to know and how much memory they consume when we do the attack how much data we need to store so with a man in the middle attack we require to use memory of up to 2 to the 56. which is a lot of memory okay so if you do the calculation in bits or bytes whatever it doesn't matter so in theory we can do these attacks but in practice uh well we can't because of the time but if we could because of time in practice the memory becomes a limitation we don't have enough memory to perform these attacks AES is recommended today and there are three modes with AES they have different key lengths two are listed here 128 bit key key space two to the one two eight the best known attack at least in the last few years with this one called bike leak attack and the amount of time it takes is two to the one two six point one so I Brute Force 2 to the power of 128 this Krypton analysis this other attack about 2 to the power of one two six about four times faster than Brute Force so not very effective because if Brute Force took a billion centuries then this attack would just take uh 250 million centuries still doesn't help us it doesn't require much memory but it requires a lot of known data three ah I I can't remember but billions of terabytes okay so again not practical from memory from data perspective or from time with a 256bit key the same attack brings it from 256 down to 254. so there are different attacks this just lists some of the the known attacks on the real ciphers the attacks we measure compared to Brute Force usually in terms of number of operations amount of memory needed amount of space to store the data and the amount of data you need in advance to perform the attack and they differ in each of those so today AES the advanced encryption standard even with 128bit key is considered secure okay there are no known attacks that we're aware of that uh are practical and even in the future it's still considered secure with 128 bits but if you want to be safe use 192bit keys or 256bit keys Okay so uh maybe in a in the future come someone will come up with better attacks but it's unlikely that there'll be a significant advance that reduces this to be manageable maybe down to 2 to the power of 100 or 2 to the power of 80 may be possible in some cases the problem with longer Keys is that it's slower to encrypt and you're we're going to introduce over the next few lectures some software to do the encryption called openssl and I'll just give a quick demo now it's does encryption using different ciphers and it actually I will not do an encryption I'll just show a speed test it gives us some how fast my computer is to encrypt using different ciphers if I use AES with a 256bit key with a different mode of operation it does a speed test of takes many random inputs and encrypts them using AES with a 256bit key and at the end you'll give me some some performance benchmarks doesn't take long it tries different input sizes don't worry about all of this this is saying that it takes just focus on this number 60 million bytes per second it can encrypt okay 60 megabytes per second is the speed so if I have 60 megabytes of data and I encrypt with AES in this configuration my computer can encrypt 60 megabytes per second about different computers will be at different speeds and different algorithms different speeds I think we have triple deaths different name this ed3 so you can try different ciphers and see which ones are faster than others I made a mistake in the previous case Des ede3 really means triple deaths encrypt decrypt encrypt 20 million bytes per second AES was 60 million bytes per second Triple S 20 million bytes per second it's triple death is three times slower than AES so there's the advantage of AES it performs much much better one last one by default they use software to encrypt the CPU just normal software I've set an option to tell my tell the program to use my special instructions on the CPU that does AES encryption before AES was 60 million bytes per second by using Hardware encryption so the CPU has Special Operations to encrypt AES it's up to 176 million bytes per second so Hardware encryption can be much faster than softwarebased encryption we'll see some more examples of openssl over the coming lectures let's stop there so again our symmetric block ciphers operate on a small block of bits at a time 64 bits 128 bits a comma the modes of the modes of operation are ways to use that same Cipher on a larger input larger than the block size ECB is the the basic approach and what you would expect in a very trivial approach you take your plain text say a megabyte you break it into blocks that match your Cipher so my plaintext P is broken into blocks of P1 P2 up to PN then I use my Cipher AES desk whatever I use my Cipher to encrypt each block of plain text using my key my chosen key and get ciphertext C1 as output then I use the same Cipher the same key to encrypt and I get C2 as output and I do that for each of the input P's P1 to VN I get C1 to CN out the output resulting ciphertext is just a concatenation of those C values okay so that's the basic approach split your plain text into blocks encrypt each block one at a time same key same Cipher ciphertext is a combination of the output ciphertext blocks the problem with ECB is that you can get repetitions in the output ciphertext and you may have seen that in some of your quiz questions actually I don't think you used ECB if you you may or may not have seen the repetition but if you have two blocks which are the same on input because we're using the same key and the same Cipher we'll get the exactly exact the same ciphertext blocks output if two blocks are the same on input then the two blocks in the ciphertext will be the same so let's say you have a large file and you want to encrypt it you break it into blocks if it turns out that there's some repetition in the file then there'll be repetition in potentially in some of the blocks and repetition in the output ciphertext which is bad from a security perspective any repetition in the ciphertext is some structure in that cyber text and it it makes a potential opportunity for an attacker to exploit that structure to work out okay there's some structure in the ciphertext work backwards to find out the corresponding plain text so ECB two blocks are the same on input will get the same output ciphertext so that's not good from that perspective so other modes of operation are used and these all work for different ciphers doesn't matter if it's AES desk or something else and the two you saw in the quiz was CBC Cipher block chaining and counter mode CTR let's just have a quick look at them Cipher block chaining we chain the output of one step to become the input of The Next Step so we take our long plain text break into blocks P1 through to PN and we start with another value our initialization Vector IV we choose some other value so we have a key chosen plus an IV we use that to start this encryption and with CBC the approach is take your plain text block xor with the IV value then encrypt the answer of that the output ciphertext is C1 but that C1 is fed into the next stage so we don't use the IV again that's used just once to initialize the ciphertext is fed into the next phase P2 is xored with C1 then encrypt so we're not encrypting directly upon the ciphertext we're encrypting the site sorry we're not encrypting the plain text we're encrypting the plain text xord with the previous values and then we keep going in a chain like that so this is a way such that if we have two plain text values which are the same P1 and P2 are identical it's most likely that C1 and C2 will be different because P1 xhord with IV is going to be different from P2 xor with C1 even though P1 and P2 are this the same that we xor them with different values here we X all with the initialization Vector here we xor with C1 which with high probability will be different from the initialization vector so two input plain text blocks will produce different output ciphertext blocks and that's our goal here to to mix things up on the upward that's a common mode of operation use I think in many encryption algorithms or products if you don't specify usually they'll use CBC so there are others but this is a common one what about xor exclusive or we'll see it again when we look at stream ciphers in a moment take your plain text xor with a random value is a form of encryption and it's equivalent if you have a good random value equivalent to a onetime pad so xor is a good operation note the ciphertext should be random or random looking random appearance because the idea of encryption takes some structured plain text encrypt and get some random looking ciphertext xoring this random looking ciphertext with our structured plain text P2 should produce some random looking output which is good for dispersing the structure from the plaintext encrypting that should give us more Randomness in the output so xor is a common operation used in encryption we see it in these modes of operation and in other in the details of science note for decryption you need to go sort of in the reverse steps so that you get the original plain text back and I think in the quiz you had to attempt some of these with in your case you use that small five bit block Cipher so the table that I gave you the table I gave you you use in this block here so you talk actually I gave you decryption I think you took your ciphertext you took your key if you're using CBC and you look up in the table for that ciphertext using that key what was the original plain text and you've got the output here then you xored that with your initialization Vector which was given in the question and then you've got P1 and then C1 was fed into the xor in the next stage there are other modes of operation and the other one you saw in the quiz was the counter mode let's go back sorry CBC Cipher block chaining one stage depends upon the output of the previous stage okay you look at the second stage here to encrypt let's say we know all the plaintext values to encrypt P2 we must have C1 in terms of an implementation that means this must be done in serial we cannot implement it in parallel because to encrypt P2 we need C1 and to encrypt and to get C1 we must first encrypt P1 so we cannot encrypt P1 and P2 at the same time with ECB we could with ECB if we have P1 and P2 let's say I have two cores on my computer I have a quad core processor I could send P1 to be encrypted on one core and P2 to be encrypted on a different core and they could happen in parallel at the same time because they P2 encryption doesn't depend upon the output of the encryption of P1 so we can implement this in parallel depending upon how many processes we have with CBC we cannot because to do the encryption here we need the result of the previous phase so we cannot put it in parallel so that's a disadvantage in terms of performance if we want to encrypt things quickly we cannot Implement CBC in a parallel mode counter modes another approach it's very simple and it has the advantage that you can encrypt in parallel quite easily you choose a counter an initial value so another IV let's say zero in binary you encrypt that value with your key and then xor with the plain text the plain text block and you get your cycle text for the second plain text block the counter two is just counter one incremented by one so if counter is zero a counter one was value zero counter two would be value one that's a counter we just keep incrementing where the initial value of counter one is your IV remember even though the counter is predictable encrypting the counter value with your key produces a random output some psychotects we cannot predict the value and xoring that random value with the plain text produces random looking output our ciphertext box C1 so very simple in that we just encrypt a counter and xor that output of the counter with a plain text and an advantage compared to CBC is that we can implement this in parallel there's no dependence upon the second block compared to the first block so what I can do is I take my plain text blocks I generate my counter values because I know them in advance counter one is going to be zero counter two is going to be one and so on and all I do is on one core or one CPU encrypt the first block and at the same time on the other CPU encrypt the second block so they can be encrypted at the same time in parallel and we'll get our paint our ciphertext out and we can do that for as many cores as many CPUs as we have or as many entities that we can execute in parallel so this has an advantage in terms of performance compared to CBC CBC and counter mode are considered practically just as strong as each other they're both considered secure and CBC is more commonly used because it's been around longer but counter mode is starting to be used or is being increasingly used and there are other modes of operation some are generic for all ciphers some are specific to selected ciphers some are specific to AES trying to take advantage of AES structure effectively with counter mode what we do take some fixed predictable input encrypted and the process of encrypting produces a random output that's the idea of encryption take some structured input encrypt and get some random ciphertext as output random looking or pseudorandom and then we do that for each phase to encrypt our plain text we take that random output here and xor with P1 take this random value xor with P2 and so on so really all we're doing is taking our plain text block and xoring with a random value and it turns out that's what stream ciphers do so this is a block Cipher but stream ciphers use the same concept last week we spoke about random numbers and that random numbers are important to computer security generating them is not easy we need some algorithm to Generate random numbers and a block Cipher is an algorithm to Generate random numbers our encrypt block here takes some counter as input and a key and the output is a random sequence of bits or a pseudorandom sequence of bits and same here so xoring that pseudorandom sequence of bits with a plain text is a form of encryption and it can be implemented very fast we'll show some examples of different Block ciphers in use uh later uh just notice counter mode encryption decryption what's the difference almost nothing so the same algorithm it's just encryption P1 here you get C1 out to decrypt C1 here P1 out you can use the same code the same software the same Hardware to implement encryption and decryption with counter mode it's just the reordering of those that input foreign ciphers quite briefly so we are actually we're skipping this one we can use block ciphers like AES des and so on to as pseudo random number generators if I need a random number for security I can encrypt some value with a block Cipher and there are different ways to do it one is using counter mode we take some counter uh and here we're using it in the opposite approach we have some some value we xor and encrypt to give us our bits here so we have a key so we can do it in other ways output feedback mode is one that we skipped over in the slides but another mode of operation and there are other ways to use and this was an example of using triple deaths for generating a random sequence of bits stream ciphers to effectively do what we just saw with catamo we take our plain text think of it as a stream continuous sequence of bits okay so imagine you uh using Skype or a voice over IP application on your computer you're talking the microphone takes your voice and converts the software converts it to bits bits that represent your voice and as you send them across the network you want them to be encrypted so you wanted an encrypted voice call so think of the bits coming in here as the bits representing your voice the stream of input bits continuously coming in you have a key you have some pseudorandom number generator it's called a byte generator here because it's generating a byte at a time but it generates random numbers this is the seed to the pseudorandom number generator it produces a random number as output represented in binary we xor that random number with the first in this case byte of your plain text the result of the xor is your ciphertext so if this is your voice coming in that is you're talking on the computer the microphone sends it to a codec which generates some bits representing your voice then the encryption software xores those first eight bits of your voice with some pseudo random number the output 8 Bits are the ciphertext which are sent across the network and that continues to happen as you keep generating input bits you just keep xoring with this the next random number in the sequence and keep going keep sending a stream of ciphertext and decryption is easy note xor if you xor the plain text with this value K and get C to decrypt we use xor again take C xor with the same K gives us the original plain text back so at the decrypter we have the same input key uppercase K here generate the same sequence of pseudorandom numbers and xor the first eight bits of ciphertext with the same lowercase k as was used for encryption here this lowercase k is called a keystream it's just it's the case streams used to xor with the input plain text string the structure of stream ciphers and the difference between different stream ciphers is how they Generate random bytes there are different ways to do it so algorithms have effectively different pseudorandom number generators one of them we'll come back to that rc4 is a common commonly used example of a stream Cipher it has an algorithm shown on the following sides but we will not go through it to this in this lecture there's an algorithm that effectively implements this pseudorandom bite generator and it's relatively simple and a key advantage of stream ciphers compared to block ciphers is that usually they're faster to implement so it doesn't take long to generate this random value and it doesn't take long to do an xor in Hardware or in software xor is very easy very fast whereas if you want to encrypt something with this or AES it can be quite slow so stream ciphers are generally much faster to encrypt than block cybers therefore they're mainly or commonly used when where we need small delay we can't wait a long time to encrypt our data like realtime voice Communications or realtime Communications of some media so some common applications of stream ciphers is encrypting realtime medium for the stream Cipher to be secure the pseudorandom number generator must be good it must produce a good sequence of pseudo random numbers a long period we spoke about our random number generators the sequence of numbers we generate there must be a large variety there we shouldn't repeat those numbers so a large period required there so as random as possible the output should be the less random the output is that what it should approximate a true random number generated so some algorithms don't generate uh as good random numbers as others that is it's easier to determine what the next value will be or what the previous value came from thing and as with any Cipher that we have a secret key there's a secret key in this case this key K must be kept secret it must be long enough to withstand Brute Force attacks often simpler to implement and faster than block service the problem with stream ciphers is that you cannot reuse the keys you need to use a different key when you have a next set of plain text with block ciphers you can reuse keys with a stream Cipher if you let's say you encrypt some voice call using one key and then you reuse that key the next day and the next day and the next day you keep reusing the same key with the stream Cipher it becomes very easy for the the attacker to get the ciphertext and promotable ciphertext work back and get the key okay so with stream ciphers it's important to change the key on a regular basis so often those keys would be generated and updated automatically and that's about all we want to say about stream ciphers there's an example of rc4 here I'm not going to go through it this semester uh note it's developed by Ron rivest remember the name because he comes up later uh it has different key sizes it's very simple to implement so simple that you could implement it yourself in a a couple of hours it's a for Loop another for Loop and a loop with a few basic operations so it's very simple to implement it has a few weaknesses that people are starting to identify but for the purposes it was used for was quite good as a stream Cipher it was used for example in Wireless lens there's only a few few known attacks which are practical but there are other stream Cycles which are now considered stronger than rc4 we're going to move on give some other examples and I'll move on to a new topic but with we're starting to finish this topic about our traditional ciphers up until now after going through things like Caesar and visionaire and the classical cyphers those and then death AES are block Cyprus and they're symmetric Block ciphers in that both sides must have the same key and the stream ciphers are also symmetric both sides must have the same key so all of the ciphers we've considered so far have that same characteristic symmetric symmetric key ciphers the Symmetry between the keys on both sides the encrypta and decrypton the next topic is going to lead us into an alternative approach where we have two different keys at the encrypta and decrypton and that requires some new new Concepts to talk about before I I close this and move on any questions block ciphers modes of operations stream ciphers random numbers any questions for the upcoming quiz so the size that I skip over we will not covering the exam or the quiz so rc4 for example and because we missed a lecture I need to move on a little bit as an or alternatively we have we can have a makeup lecture do you want to make up lecture hands up if you don't want to make up lecture okay I need more than half so I you can't put two hands up that doesn't count as two okay well at this stage we don't need a makeup lecture because we missed just one but we'll see how we go with progress let's encrypt so far we've just looked at algorithms of course if I give you a one megabyte file and you want to encrypt it with desk you cannot do it by hand we need some software implementation to do so and implementing the ciphers and making sure they implemented correctly is important for security because if you implement a cipher and you make a mistake in the implementation some bug then it opens up an Avenue for an attack so when you write your software and you develop a website that needs encryption you probably won't Implement your own Cipher you'll you will not design your own Cipher nor will you implement an existing Cipher you'll probably take a library that someone else has developed that implements the cipher so many people don't Implement their ciphers themselves they use something that others have used and tested a lot and one Library that's common and open is called openssl I'll show you a few examples and I'll point to some on the website that you can see more details of those examples but we'll ask you in some homework to use this software to do some encryption and to solve some problems the software is called openssl open SSL it it's a standalone application that we can run on the command line it's also a library in that you can write your own code and link to the operations provided by openssl we'll use it in command line mode there are many different things that we can do with openssl we can encrypt with different ciphers we can generate Keys random numbers uh and some Key Management that we'll see in later topics there are some different versions that's just to show the version I'm just going to show a few quick examples of encrypting with uh symmetrically ciphers let's start with some message and so I want to encrypt some plain text so let's create some plain text let's download and I'm just creating it long enough so we can use it in the example here so that's just my my plain text and I'm going to write that to a file let's call it plain text so there's our message it's our plain text for our example uh how long is it um the size of this file is 72 bytes okay so that's the size of the file 72 bytes there are 72 characters there one character one byte in the storage when we use our ciphers we're encrypting on the binary input so not like Caesar where we're going to change H to another letter we just treat this text as a set of zeros and ones so 72 bytes in this case let's look at those bytes just so we know what we're dealing with and to look at the binary view of a file I can see the ASCII contents to look at the binary contents we need some special program I have one called xxd it will show me the the contents of the file in binary minus B for binary show me across eight columns the plain text and I'm going to have to zoom out of it all it does is program xxd and I'll Zoom back in in a moment is shows this file in its binary form okay just a sequence of bits so the first eight bits and the last eight bits here let's encrypt and we'll encrypt using a symmetric block Cipher we'll start with Des okay just normal deaths and we'll use ecd mode of operation and to encrypt with this we need a key how do we choose a key I'll need a key for desk how do I choose a key someone choose a key for me how long should the key be for death 64 bits deaths actually has a 64bit key although only 56 bits are used desk takes a 64bit key someone choose a 64bit key well we want a random key preferably I don't want to choose a key that someone can guess so we've actually to generate the key we'll create generate a random number so let's generate a random number first and then we'll use that as the key and luckily openssl has a way to Generate random numbers it has a Rand operation generate a random number eight bytes long eight bytes is 64 bits and instead of outputting binary we'll make it a little bit easier and output in hexadecimal no need to remember these operations uh there's links to a detailed description of them in a way in the website I'll show you later uh just demonstrating what you can do generate a random 64bit or 8 byte value output in hexadecimal there it is 16 hexadecimal digits now let's encrypt using that as the key openssl ENC to encrypt and we need to choose our Cipher and the cipher we're going to use is eat is death and we should choose the mode of operation as well so ECB CBC counter and others we can choose from to start I'll just choose ECB the very basic mode and to encrypt we'll specify minus E tell it to encrypt the input we want to encrypt the plain text file I want to produce an output let's call it ciphertext dot bin sorry it's wrapping around but encrypt using desk and ECB mode of operation the plain text file output into a file called ciphertext.bin doesn't matter about the extensions and now let's specify our key and I'll copy the key from the random number and use that so open SSD will allow us to give a key in hexadecimal instead of just binary encrypt using des and ECB this plain text using this key producing this cycle text normally with modes of operation we'll also include an initialization vector it's not needed for ECB but I'll just so we can repeat this later I'll include it here and it needs to be 64 bits or 16 hexadecimal digits that's in hexadecimal that's a bad initialization vector all zeros you shouldn't choose that you should choose another random value so it should choose a random value here for my initialization vector bye just for this example done encrypted the output ciphertext 80 bytes input plaintext 72 bytes output ciphertext 80 bytes what happened is that correct what went wrong what we'd expect is that if I have an input of 72 bytes plain text I get 72 bytes output ciphertext all of our ciphers take the same length input same length output okay 64 bits in for one block 64 bits out combine the blocks same length in same length out here it's different 72 bytes in 80 bytes out it turns out that with many ciphers they add some padding in there and even some error detection to be able to detect if something goes wrong and that's what these extra eight bytes have been added in this case open SSL is has added some padding in there it wasn't really needed so let's add an option encrypt again but say Notepad let's not Pat just to make things a little bit simpler in the output and now our output is 72 bytes okay that's what we should have or we expected at the start 72 bytes in 72 bytes out but in practice we'll often allow padding in case the input is not uh integer multiple of the number of bits of our block we need to do some padding now let's look at our ciphertext and it's binary if you take those ASCII characters and try and view them they'll produce some strange characters let's look at them with xxd and I'll look at them in binary so zoom out a little bit let's look at the cycle text there it is okay so the binary ciphertext and it's hard to see of course but if you look closely you should shouldn't see any structure in here or should you and this is the corresponding ASCII representation of this where you see a dot it means it's a nonprintable character Okay so this is the actual binary after encrypting anyone see any structure in the ciphertext what I'd like is my structured input plain text this message when I encrypt it I get some random looking output if you can see structure in the ciphertext and that's bad for security anyone seen a structure anyone all right here's a hint there is some structure there's a problem anyone notice it maybe look at the ASCII representation of the ciphertext I'll zoom in a little bit more sorry uh uh sorry I can't zoom in very easily without getting the right hand side I'll point it to you because it's hard to see I've seen it before and it's not obvious if you look at these two lines of binary and this line of binary values in the ciphertext you see the ASCII is the same in fact if you look closely the binary values are the same this line this 64 bits and this 64 bits are identical so we have some structure in the plain text that's not good that is bad for security what's the problem so was it the fourth line and the seventh line well you can see some of the bits here identical here same eight bits same eight bits same eight bits and so on why bonus one mark for the next Quiz for a quick answer quick correct answer why in the ciphertext do we get some structure in this case the structure is a sequence of 64 bits were identical translate all right uses the same process uh be more specific yep both plain texts are the same be more specific the both blocks of plain texts are the same therefore the output ciphertext is the same because of in same key but there's one more step yeah ECB I think half a mark each bonus yeah ECB mode of operation the same that's the the problem in this case let's go back and zoom out uh look at the input plain text and remember our blocks are 64 bits so effectively each line is one block input so with our mode of operation P1 is hollow dot space t P2 is his space is space o and so on look at the fourth block space secret space and the seventh block space secret space the same two blocks so P four and P seven in the mode of operation are the same let's go back and just make that clear we're using ECB as the mode of operation although we don't list them here but p 4 and p7 are the same we encrypt with the same key using guess therefore we'll get the same ciphertext as output and indeed we do these two blocks the ciphertexts are the same and that's bad and that's the problem with ECB when you have same input blocks you'll get the same output ciphertext box and the attacker can try and take advantage of that so ECB usually should not be used especially when we have large plain text input I will leave it for you as your homework and I'll set a homework soon that it requires you to use openssl and encrypt some plain text decrypt some ciphertext just to get some feel with the software and to see what it can do and maybe do a little bit of analysis of the outputs in some cases you can do many more ciphers we can change to AES different modes of operation and in fact uh even symmetric public Keys cryptography since everyone's so excited about openssl we'll stop there and try a new topic any questions before we move on about that concept of the the poor security of ECB foreign block ciphers and symmetric key encryption let's try an alternative approach and close this wrong one this is from one of our earliest lectures we've seen this before this is the the general model for encrypting for confidentiality where what we do is we take our plain text input and in a cipher take a key the output is a ciphertext we send the ciphertext the decrypter the receiver applies the decryption algorithm a key and gets the plain text up until now key one and key 2 have been the same with symmetric key encryption uh shared secret key k K1 and key two are the same there's some problems with that it can be very inconvenient for some purposes so people have developed an alternative where there's two different keys and that's the what the next form of cryptography we're going to cover but to understand some of that we need some refresher in some cases some new material on some of the mathematics that supports the new form so that's the next topic that we'll start on today and it's some very simple mathematics that will just uh cover with a few examples that will set us up for the next form of cryptography so I call it number Theory it covers a few different things some of it should be easy that is just refreshing your memory some of it may be new but still easy just remind you something about prime numbers and division so this you should follow and if you don't understand then then have a read ask me a question otherwise we'll go through quite quickly uh just some remind you of some terms okay division we all know about how division works but we can talk about some a divisor and B divides a we can say B divides a if a equals some integer times B and sometimes we write this so just the terminology we sometimes we write this as b and a vertical bar a so this is the topic on number Theory B is a divisor of a we can say yeah and we know about greatest common divisors of two numbers the greatest common divisor of those two numbers can be found anyone unclear so far gcd greatest common divisor so the greatest common divisor of seven and 15 is 7 and 15. is one okay the greatest common divisor of eight and uh 20. four okay all right so look at the divisors of eight one two four eight look at the devices of 20. one two four five ten twenty and look at the the greatest common values simple there's there are efficient algorithms for finding greatest common devices especially large numbers for small numbers in example is easy we can do it in our head but if you have very large numbers there are some algorithms for finding the greatest common divisor we say two integers are relatively prime if the greatest common divisor of those two integers is one so our example 7 and 15 the greatest common divisor of 7 and 15 is one so we say those two integers are relatively prime not Prime relatively prime so that may be new to some of you is height and R8 and 20 relatively prime 8 and 20 are not relatively prime so if they have a greatest common divisor which is greater than one then we say they are not relatively prime that will come important later and we'll see it in use a little bit later prime numbers everyone remember prime numbers what are the first 10 prime numbers give me a prime number seven okay give me a smaller prime number three another one one's confusing let's not cover one one's not really considered a prime number two is two is a prime number uh two three five seven no more even numbers of course a prime and then the numbers how do you define the prime number their divisors are one in itself okay the devices of that number are one and itself so prime numbers I think you're aware of fine uh some integer P larger than one we Define prime numbers larger than one if and only if it's divisors are plus or minus or really one and P one in itself and any integer any integer not necessarily a prime can be factored in into its Primes where some integer a can be written as some the second Pro or prime two powered to some exponent and multiply by different primes so any integer can be written as multiplying a set of primes out and that will become important later uh very simple examples just to all right keep going what is 15 written as multiplication of primes or let's start easier what what are the divisors or factors of 15. the divisors of 15 are 1 3 five and if we count 15 is a divisor therefore the prime divisors are three and fifth three and five less than fifteen so three times fifteen all right what are the divisors of 24 one oh we're not all right one two six I twelve 24. 24 is written as primes prime factors how we write 24 as in as a multiplication of primes which means take the prime numbers and multiply them together to get 24. well 2 is a prime 24 divided by 2 is 12. divides by 2 here's a 6 divided by two or 2 to the power 3 Times by 3 to the power of one so we can write any integer as if we multiply the prime numbers and select an exponent here an integer exponent so in this case it's 2 to the power 3 times 3 to the power of 1 times 5 to the power of zero we don't write that because 5 to the power of 0 is 1 times all the other primes to the power of zero that is sometimes useful or simply the prime factors of 24 or 2 and 3. so we'll see we'll be interested later in finding the prime factors in this case we found them as two and three okay and that's what this equation States General we can write any integer as multiplying the primes together where those exponents are integers zero or higher and a list of some prime numbers the first or the under two thousand okay okay let's move on modular arithmetic we in some of the algorithms we'll use for public key cryptography the next uh form of encryption we'll use modular arithmetic and normal arithmetic it's normal arithmetic but we mod the answer effectively and it has some useful properties uh when we use it in encryption so very Basics you know about mod a mod n is the remainder when a is divided by n okay we write a mod n n is called the modulus n is the modulus in this case we can say two numbers are equivalent or congruent modulo and equivalent in mod n if when we take those two numbers and mod by n we get the same answer so we often write that as a is equivalent to B in mod n easy one what's the answer three in mod 10 13 and 3 are the equivalent of congruent modular modulo 10. because 13 mod 10 is three three mod 10 is three that's all when we mod by the same number and get the same answer we say they're equivalent in the modulus do we need more examples not really negative numbers will ignore for the moment what's next so the mod n operator maps all of our integers so the infinite set of integers into some finite set of zero to n minus 1. okay so when we mod by n the answer is always between 0 and N minus one that's all we're saying so it Maps it to a particular set denoted as z n so Z8 is zero up to seven take any integer mod by eight and the answer will always be in that set of zero to seven modular arithmetic performs arithmetic addition subtraction multiplication and division within the confines of some set ZN so we talk about a set Z8 means the answers of our arithmetic will always be between be between 0 and 7. so when we do 10 plus 15. in mod 8 and the answer is always going to be between 0 and 7. so always the answers of the arithmetic operations are always in this set let's go through some simple examples make sure we don't get some useful ones foreign yell out the answers anyone Arthur four plus three don't all yell at the same time okay this is a hard one four plus three again seven okay not bad four part four plus seven louder one note we're using Z10 here in other words to be precise everything is mod 10. so what our modulus is always 10 so I'm not writing the mod operator here we're using modular arithmetic in this specific examples the problem Additionally the if you just add them with your normal original modify uh what about the track well that need to use the new content first with with addition with modularity we can just add the numbers using our normal approach the pathway and one by ten with we can talk about the input what the inverse operation of a difference first operation of multiplication so we talk about the people so now using that I'll just write here normal arithmetic not using modulus four plus three is one instead of minus 3. which is right up as inhibition 7 plus negative three so this is our operation subtraction is the same as adding the inverse inverse of plus three is negative three so if we want to perform subtraction instead of minus B it's the same as 7 plus the inverse is driven the inverse of 3 or precisely the additive inverse 3 is minus so that's the normal concept of arithmetically making things think about the inverse of the numbers inverse when we add is subtract we'll negative who use the same concept with modularism so we can talk about the additive input and I think a is the additive inverse of B in a plus b is equivalent to zero odd n the same in our normal arithmically the additive inverse of 3 if the number starts that when we add it to three we did zero three plus minus 3 gives us zero so we say the additive inverse of three is minus three but in modular arithmetic we don't have negative numbers so what the additive inverse of Z10 the additive inverse of tree okay the value of 10 numbers again when we add the two numbers together we can hear over here so the additive inverse of three what number when we add the three to the hip in Europe and then the fact that you just use an adjectives the performance attraction we add the energy together in our normal arithmetic free minus three seven subtract 3 17 or 110 or 4 minus seven not ten or 10. every they have to must be between zero and now three seven seven why subtraction is the same as additional of the added even though so there's something that confuses some people we're not dealing with negative numbers we can still do subtraction and we still use the same concept of our normal repetitive but everything is in modern okay in normal arithmetic we implement we can Implement retraction simply adding the invert inverse of three to one of three because three plus minus three is zero the same concept is modulator we can implement the fraction by adding the additive additive input of 7. seven examples foreign okay additive inward in all numbers will have an additive income so in our set zero the attitude University zero and one is nine but two is eight so the whole numbers have compatible let's so we can do addition subtraction operation multiplication all right okay okay hey not four 12.8 foreign foreign normally we multiply the two numbers together a number again with each other foreign great foreign foreign foreign about that be more announcements thank you so we're at the stage of just the last operation for our modular arithmetic logarithms exponentiation is easy well easy in terms of concept that is it's repeated multiplication and in terms of how we think about exponentiation you take uh your number raise it to the power mod by and you get your answer so conceptually easy in practice time consuming sometimes to calculate we'll see some examples when we have big numbers last one logarithms and the concept we have is a discrete logarithm in normal arithmetic if we have b equals a to the power of I I is the index or the exponent then the log in base a of B is I that index or exponent but now we have everything mod n all right and this this uh equation mod P so if we have B equivalent to a raised to the power of I all in mod T then we say in the same concept the logarithm in base a with mod P of b equals I the index so we're trying to find the index of this exponentiation the opposite of the exponentiation operation and we call it for modular arithmetic a discrete logarithm if we go back to multiplication in modular arithmetic we can do multiplication for all numbers but we cannot do division for all numbers and similar follows we cannot do logarithms for all numbers there's only special cases where we can determine the unique exponent so we need to introduce a primitive route to explain that so A Primitive route is of some so we Define A Primitive route of some prime p a prime number P if a number is a primitive root of that Prime P then a raised to the power of one two three up until P minus one gives us distinct values and that's best shown with some examples so we'll go straight to some examples to introduce the concept of a primitive route and then see the discrete logarithm relies on A Primitive route being found I have some better examples let's say our modulus is everything is mod seven for this set of examples mod set seven so in our equation mod P or p is seven let's look at the numbers when we take some number a and we raise it to some power I where I ranges from from Mod 7 1 up until six foreign so we're trying to give an example of a primitive root A Primitive root of some prime or some number P is that if we can take that primitive root raise it to the powers of one two three up until P minus one if the answers are distinct different values let's try some values so what we're going to do is take our value a raise it to the power of I and then mod by our modulus P which in this case is seven for this example so a to the power of I mod 7 so 1 to the power of one mod seven we get what one one to the power of anything we're going to get one so this is going to be a simple case we'll write the answers here just to demonstrate a equals a one I equal to one one to the one mod seven answer is one one to the power of two mod seven also one one to the power of three mod seven you can see what we're going to get as artists we'll come back to that one and let's try for a different value of a and then explain what they mean what if a equals two so what we do when we mod 7 consider 2 to the power of one two to the power of two two to the power 3 and so on mod 7. what are the answers 2 to the power of one mod seven is two two to the power of 1 is 2 mod 7 we get two is the answer 2 to the power of two mod 7 . how about we uh I'm very lonely up the front come down closer everyone small small group of students large room move down the front it's okay to eat everyone moved down the front front two rows it's okay we've got time off you go yeah everyone moved I can't move the screen closer to you come on the front three rows it's okay it's all right Just For Today front three rows yes everyone not not just uh two or three people just try something different it's okay bring your laptop it's not too hard just just move down the front the front a little bit closer there's so many seats to choose from yeah okay now I can ask a question and hear your answers two to the power of two mod seven what's the answer four two to the power of three mod seven two to the power of three is eight mod seven we get one 2 to the power of four mod seven try it 2 to the power of 2 mod 7 we get four two to the power 3 mod 7 we get one two to the power of four mod seven two to the power of four is 16 mod 7 the answer is two to the power of five mod seven two to the power of 5 is 32 mod 7. four four two to the power of 5 is 32 4 times 7 is 28 remainder is four two to the power of six mod seven one check two to the power of 6 is 64. 9 times 7 is 63 so the remainder is one okay easy maybe it's so easy when you're sitting down the front too so let's do this one what if a is three three to the power of one mod seven easy three three to the power of two is nine mod seven three to the power of three mod seven three to the power 3 is 27. mod 7 6 3 to the power of four I'll give you a calculator you can use your head fine what do we have 3 to the power of four mod seven sorry that's four what's the next one three to the power of five mod seven five okay so this is doing it for us so that this one was three to the power of four mod seven we got four three to the power five mod seven five three to the power of 6 mod 7 let's use our calculator one okay nothing hard there now why do we do that our modulus is Prime Seven p is seven A Primitive route of seven is a number when we raise it to a power of all the integers up until that number seven but less than we get distinct answers so we say three is a primitive root of mod 7. with two we get nonunique values in this set of answers two occurs twice four and one occurs twice with a equal to three when we mod raised to the power of I and mod by seven we get this distinct set of six values yeah so we say a is a primitive root all right two and one are not in this case and then we can try for other numbers so that's the definition of primitive root we use it to do to work out when a discrete logarithm is possible the idea is that a discrete logarithm coming back remember logarithm find the find the exponent or index that's a logarithm given the base and the answer find the index that when we raise the base to that index we get the answer B same with discrete logarithm but everything is mod P with some base I if we mod P and get the answer B what is the index I sorry some base a base is a mod is p the answer is B then the index is I well we can only solve such value and get a unique exponent I that is get an answer that's unique if a the base is a primitive root of prime p so that's the conditions when our discrete logarithm will work it's give an example have we got what is this discrete log in base three mod seven of six the way we read that is that three raised to some power so some index mod by seven give us an answer gives us an answer six so what is that index 3 raised to some number then we mod by 7 gives us six what is that number where do you get the number from we just calculated it didn't we three raised to the power of some number mod 7 this table we calculated these values calculated with Mod 7 gives us an answer six so what's the index that gives us an answer six three so the answer of this is three and we can check you can check that that is 3 the base to the power of the answer 3 mod 7 3 to the power of 3 is 27 mod 7 gives us 6. okay that one's fine discrete log of Base 2. mod 7 still of four the discrete logarithm of four in base 2 mod 7 means two to the power of some number 2 to the power of some number mod 7 gives us the answer of four what is that number what is the index what do we have as possible answers yeah we just calculated again we just calculated it for the values when we mod by seven we calculated it the base is two raised to the indexes of one through to six mod by seven we get the answers two four one two four one in this question we have or do we have 2 to the power of discrete log of 4. so what index gives us an answer of four there are two possible values two to the power of 2 mod 7 gives us four two to the power of 5 Mod 7 also gives us four we don't have a unique value and therefore we cannot determine what the index was originally there's no way to know which index was it if we want to do a discrete logarithm there's no unique answer here why because the base is not a primitive route of seven so when the base this value is a primitive root of the modulus then we can get a unique answer because we have a distinct set of values here but when the base like two is not a primitive root of seven then we will not get a unique exponent because we have multiple instances of the answer so what's the answer well we say there is no answer or no unique answer not of interest to us there are two possible answers but generally we'd like to get a unique value especially when we apply to encryption so when we want to use the discrete logarithm we normally need to have the base To Be A Primitive root of the modulus in this case it's not and we'll see algorithms cryptographic algorithms that use this concept so again all we did was for our example when we're using mod 7 we said well given the values one up until six the set of E exponents if a to the power of I these are the possible values of I when we mod by seven if we take all values of a which values when we raise the power of I give us a unique set here three does two dozen one dozen and you can check the others whether they do or not if they do it's called A Primitive root and if we have a primitive root in this case we can solve the discrete logarithm with a unique answer thank you not all okay and some useful values the only integers with primitive roots are listed here two four and some prime raised to some integer any Prime raised to the integer P to the power of one p to the power of two and two times that value so there's only some numbers have primitive roots and that restricts us when we want to find a discrete logarithm so when we want to use the discrete logarithm in a cryptographic algorithm we must choose our numbers carefully so for now just be aware what is a primitive root A Primitive root of some prime p is a number such that when we raise it to the powers up until P minus one we get distinct answers when we mod by P what is a primitive root and that for a discrete logarithm we can only find a unique exponent if the base a is a primitive root of the Prime p so that's what we need to know for now now we say we can find the answer another thing we'll see later maybe not today solving the discrete logarithm can be complex complex enough if you use large enough numbers practically impossible that is if you spend your 10 million years trying to solve it you will not get an answer it'll take too long so that will be a property that we take advantage of later but we'll return to that when we use it this is using Mod 19 as a different example we had an example of mod 7 if we have Mod 19 what are the Primitive routes of 19. and this is a table similar to what we calculated this is the values of a and then a to the squared cubed up to a to the power of 18. up to P minus 1. how many primitive roots of 19 are there are six and this these gray boxes highlight look at the the answers when we raised the power in Mod 19 the gray boxes highlight the unique set of values A Primitive route is one that gives us a unique set of values which is distinct amongst all 18 in this case one two three four five six possible primitive routes they are two three ten thirteen fourteen and fifteen okay and in Mod 19 some discrete logarithms so the answers have been calculated for us so in base 2 base 3 10 13 14 15 base of the Primitive root Mod 19 so for example log in base 13 Mod 19 of 8 is 15. that's how we read this table the log or the discrete log of the top row the answer is the the second row and the base is 13 here mod 19. the base here 14 mod 19. so the base are the six different primitive routes generally I do not ask you to solve a discrete logarithm in a quiz or an exam unless I give you some extra supporting information so especially with large numbers they're not solvable with large enough numbers there are no known algorithms that can solve the discrete logarithm in reasonable time with small numbers you can do it with trial and error okay you can find a way to do it but if it's large enough it will take too long and this actually this is the last point on this slide with certain problems when the numbers are large enough it takes too long to be able to solve those problems and we'll take advantage of that fact when we use some of this mathematics in in public key cryptography three problems that we will see that arise which are what we see computationally hard meaning if the numbers are large enough it'll take forever to get the answer factorization that is given some integer n which was calculated by multiplying two primes together if n equals P times Q p and Q are prime numbers large prime numbers if I give you n it'll take you forever to find p and Q if you don't know them that's the problem there there's no known algorithm that will take n and Factor it into its two Primes in reasonable time uh one example of a large number uh one maybe five or so years ago now a number n which was the number n was 768 bits long or 232 decimal digits so write a number 232 digits given that number Factor it into its two primes p and Q several years ago it took some on something like 2 000 uh Computing or man years to to do that factorization so if you make it longer it will effectively take forever sorry be and this problem is yes yes uh NP uh yes yes I don't know if all of them I think interfacturization I'm not sure uh in practice um too large whether it's NP uh what's the difference MP complete and be hard uh I don't remember for all of those algorithms so there's some slight subtle differences in the nonpolynomial algorithms and effectively they are but there's some variations so some are easier than others okay but yes effectively all of these algorithms we cannot solve them in reasonable time if we have a large enough input the input for Euler's token is or the problem is given n just n a nonprime n a composite n find the totian remember the token was the the count of numbers less than n which are relatively prime with n we could do it we could okay if n was 20 the 1 2 3 up to 19 check which numbers are relatively prime with n but now make n a thousand bits long hundreds of digits and then find the answer it's considered harder than it integer factorization with the same size n it will take you longer to do this and this so this one may take a million years this may take two million years but effectively unsolvable similar discrete logarithms with large enough values finding the index is considered unsolvable so if you know the base the modulus and B finding the discrete logarithm is impossible we'll come back to them and see how they used in cryptography and that's our next topic so let's get to it any questions before we move away from the theory onto the application in in security all right next topic public key cryptography what have you done crashed so all of the security schemes we've seen up until today have been symmetric key cryptography encrypt with one key decrypt with the same shared secret key now we're using to moving to a different approach public heat cryptography let's look at the principles and then an example so it's reported that around the 1960s the NSA and the US discovered the concepts or developed the concepts for public key cryptography similar organization in the UK around the same time or the 1970s that's the first known report but it was only made public and 1976 two guys Diffie and Hellman come up with this idea of public key cryptography so that was the first that the public knew of this concept and it was only until later that NSA and and the government headquarters in in the UK started to advertise that they already knew about it so it's only been around for 40 50 years Caesar Cipher's been around for what two thousand years so it's relatively new the idea is to use two different keys for our encryption and decryption not using a shared secret key the motivation of Diffie and Hellman to come up with this idea was to when you use secret key encryption you often rely on someone generating the key for you and giving you the key you often need to trust someone else with a key to make it easy to distribute they wanted to develop a way to avoid relying on other organizations to to trust with your key and so you can do it just direct between two users and to do things like digital signatures which is someone can take some documents say electronic file and attach their signature to it such that at a later time anyone can prove that it came from that person that's your idea of a signature you sign a document the concept is that later someone can see that document and prove that it came from you that you have approved that document because it's got your signature on it they wanted to to provide this functionality and they come up with public key cryptography so the principles symmetric algorithms use the same secret key for both encryption and decryption asymmetric algorithms which is another way for public key cryptography algorithms asymmetric use one key for encryption and a different but somehow related key for decryption so two different keys they're not random keys but they're related in some way usually they require that asymmetric algorithms that it's hard computationally and feasible practically impossible if you know the algorithm and you know one of the keys to find the other key sometimes it's useful to have to be able to use the keys in office orders but we'll ignore that last point we'll come to it when we need it so we have now have two keys encrypt with one decrypt with the other and the requirement is that if I know an algorithm I know one key it should be hard for me to be able to determine or calculate the other key so in fact we have two keys we talk about a key pair and one's a public key and one's a private key so we talk about our public private keypad and in most systems the way that works each user in that system has their own care own key pair so we denote that for user a they have two keys the public key of user a and the private key of user a so the private key of Steve and the public here Steve I have my own key pair you have your own key pair everyone has their own keypad often created by yourself and we'll see the ways we're creating them later they're not random numbers okay they're the key values are not random numbers they are related somehow a public key as you guessed by the name it can be made public that means if I have my public key and private key the two values I can tell all of you my public key doesn't matter it's available to everyone anyone who wants it my private key again should be secret it should be private to me so I have my key pair I tell everyone you I tell everyone my public key but I keep my private key secret I don't tell anyone that's the assumptions that uh our keys rely on and then all right let's see these four secrecy and authentication with some pictures uh to explain how we use those keys so the concept let's say I want to get a message from A to B confidentially we have a message M the plain text this is user a on the left user B on the right we want to get a message from from A to B such that no one else in between can read the message we want confidentiality both users have their key pair so we can say user a has a key pair user B has a key pair to achieve confidentiality what we do user a on the left takes the message uses a public key encryption algorithm e and uses the public key of the destination so if user a is tending to B and they want this message only to be read by B and user a encrypts the message using the public key of B in this encryption process and the result we can write as we encrypt using the public key of B message M and we get some ciphertext as output we send the site text across the network the destination B receives the ciphertext and to decrypt they use their corresponding private key if a message was encrypted with B's public key our algorithm should be such that it will only successfully decrypt with these private Key Well the other key in the key pair so what b does they take the cytotec C their private key prb and decrypt using our algorithm and if our algorithm is designed correctly they'll get the original message as an output so we'll get the plain text back so if we want to have confidentiality with public key encryption and this is an important point to remember the concept is always encrypt with the destinations public key we'll look at the algorithms for e and d uh in this topic but the concept in general is you encrypt with the destinations public key and the destination decrypts with their private key and because why does it work well the keys should be related in such the way that it will only successfully decrypt if we use the other key in the key pair we have a key pair p u b p u r p r b public key of B private key of B if we encrypt with the public be a public key of B we can only decrypt with a private key of B that's the the requirements of our algorithm now why does this provide confidentiality let's say a malicious user intercepts the ciphertext they have sea they want to find m so they have C they need to decrypt C using some key but the nature of the algorithm should be such that we can only decrypt the ciphertext using the other key in the key pair from which it was encrypted this ciphertext was obtained by encrypting with a public key of B therefore it will only decrypt with the private key of B and by definition the private key of B is known only to B it's private to be so a malicious user cannot decrypt because they don't have the private key of B so no one can intercept and find the original message M unless we know that private key only the pro person with the private keys and can successfully decrypt for this to work we need to design an algorithm such that it was successfully decrypt and a way for generating the keys such that it will work in this manner so this is just the concept how does it actually work depends upon the algorithm but people have designed algorithms that meet these requirements so it does work we'll come back to authentication we can use the keys in the opposite order but we'll come back to that after we go through an example of an algorithm to see that in use what have we got let's go direct to an algorithm we'll come back to the applications after we see a detailed example let's get to one and the most common and maybe the first algorithm or one of the first few algorithms that was developed and still used widely today RSA we're going to go through it in detail see how it works and we may see another algorithm in a little bit less detail a little bit later maybe after the midterm so RSA is one algorithm for public key cryptography there are others this is my one of the most widely used algorithms where does the name come from it was developed by Ron rivest ADI Shamir and Len Adelman r s and a okay so the name comes from the three people who develop this algorithm so in 1978 these three researchers developed this algorithm and then they started a company to sell products that implemented the algorithm called RSA security eventually sold to some other companies so it's still part of another company now RSA EMC I think is the company it's the most widely used public key algorithm and the way that we think of the plain text and ciphertext is integers numbers it's a block Cipher we take a block of text an integer and we encrypt it using RSA and commonly it's just used on small inputs but we'll come to that after we go through how RSA works so going back to our general approach for public key cryptography we need an encryption algorithm we need a decryption algorithm and we need some way to get the keys unlike symmetric key cryptography the keys must be generated and they're related in some way in symmetric key cryptography we normally just create a random key a random sequence of bits but here we have an algorithm for generating the public and private key because for the decryption to work those keys must be related so with RSA there's a key generation algorithm we'll go through the steps then there's an encryption algorithm and a decryption algorithm and we can describe the whole algorithm of RSA on this single slide remember back to death simplified deaths even if you remember back to that lecture Des there are many different algorithms of the uh the generating the sub Keys the S boxes the uh the different rounds and we repeat the rounds with deaths the 16 rounds the many large s boxes and so on that was quite complex encryption with RSA is simply take our message as an integer rise to some power mod by n so conceptually it's very very easy it's just doing exponentiation in modular arithmetic modular exponentiation and decryption is just as easy it's the same algorithm just we vary the numbers that we use to decrypt some ciphertext we take the ciphertext raise it to some power D mod by n and we get the original message back very simple algorithms conceptually to implement and to a little bit more complex but compared to our block ciphers our symmetric block ciphers uh much simpler for this to work we need to generate the keys correctly and that's what we'll go through first the way of generating the keys and then we'll look at an example that shows how it works so what happens is that each user in the system generates their own key pair so imagine every user goes through the key generation steps and at the result of the key generation each user has a key pair once each user has a key pair we can encrypt and decrypt using the correct key so let's go through key generation first step to generate your own key pair what do you do is choose two primes p and Q two prime numbers and then you calculate n as the multiplication of those two Primes let's do it in an example let's go through an example where we generate our keys for the example we're going to use very small values just so I can calculate them we can always do it in our head but we'll talk later about in practice so first RSA key generation and you think each user does this they do it independently so the first step is to choose two prime numbers p and Q two prime numbers okay I'll choose two that I can calculate easily p17 Q is 11. okay we'll talk later about what are the recommender values especially regarding length but the concept is the same and then we calculate n which is p times Q where we hit 187. so that's the first step in generating our keys The Next Step we're going to need the totient of n we're going to use the totian of n to find some other value either so let's first work out the totient of n Euler's totium what's the value the torsion of N and in our case is 187 quickly find the answer of 187. the totian remember that the number of numbers less than 187 which are relatively prime with 187. so we in the very basic form we say all right number one is it relatively prime with 187 well what does relatively prime mean it means are the two numbers have a greatest common divisor of one and 187 greatest common divisor one okay relatively prime two and weight at one eight seven what's the greatest common divisor if it's one and relatively prime three and one eight seven four and one eight seven and so on what's the answer how many numbers less than 187 are relatively prime 160 okay he calculated quickly we don't do it the manual way okay we've got a formula that will help us solve this quicker if we go back to our number Theory one characteristic of the totian of n is that the totian of I'll just write it here the total of a prime number is p minus 1. because the number of numbers less than that Prime which are relatively prime with that Prime is all of them so the numbers less than P there are P minus one values so the total of a prime is p minus one and it can follow from that the totian of two primes multiplied together remember p n is just P times Q is the totian of the primes multiplied together so let's write that 187 we know because we just calculated it is 17 times 11. so do it on the four way 17 is a is a prime 11 is a prime because we just chose them that way so it's equivalent to the partition of 17 times the total of 11. that's true if they are prime numbers and the totian of 17 is 17 minus 1. and the total of 11 is 11 minus one so the fact that we chose the primes means we can quickly solve the total of the multiplication of those two Primes that's going to be needed in step two step two is Select some value e some integer e such that it is relatively prime with a totian of n and it's stated on the slide here is that e and the totion of n the greatest common divisor is one or in other words the two values are relatively prime so find an e which is relatively prime with 160. and it should be less than the totian of n there may be multiple values find one yes it's not small find an a number that is relatively prime with 160. small as possible uh sorry e should be greater than one and less than the totian of n okay so not one there are multiple answers okay so it needs to be a number which has a greatest common divisor with 160 of one seven yeah so greatest common divisor with 160 it's not going to be an even number two has a greatest common divisor with 160 of two so that's not an answer 3 and 160 4 5 6. try some numbers just try a few so we have the total of 187 find an e we want the greatest common divisor of e and 160 to be 1. so an e should be greater than one and less than 160. as the condition so you can test them okay in a very simple form two and 160 no they don't have a greatest common divisor of one three in 160 yes that one's okay 4 and 160 in fact all of the even numbers have a greatest common divisor or have a divisor of at least two so the the we can rule out the even numbers 5 and 160. greatest common divisor is it one or higher it's higher 160 has a divisor of five so we cannot use five seven check it's okay 160 will not divide by seven seven is a prime number and we can keep going nine I think you'll find nine is okay eleven is also okay there are multiple answers here many or multiple numbers between 1 and 160 which are relatively prime with 160 choose one of them that's the step two and that's the value e in our algorithm and I would choose because I've got the answer seven next so that was step two step one choose your primes calculate n step two calculate the totion of N and find e select an e such that it is relatively prime with the totian of n step three find some d or calculate d such that D is the multiplicative inverse of E in them thank you in mod the torsion of n so D times e mod the totian of n should be one that's our requirement find D E I chose a seven find D in other words e and D are multiplicative inverses multiply them together we get one as the answer when we mod by the total of n which is 160. so e you're correct e times d mod our totion of n 160 should equal one a is let's get rid of a e is 7 in our case seven times D mod 160 equals one what value of d and you can manually try some different values okay so the the very basic way seven times d mod 160 equals one means seven times D should be either 161 or 321 or 481 or some other value why because when we mod by 160 we'll get one so that's the basic way that is if 7 times d if it equals 161 then 161 mod 160 gives us one is there any and remember we're dealing with integers here is there a d such that multiplied by 7 we get 161. or other words 161 divided by 7 do we get in an integer yes D equals 23. so we've got our new parameter d they're in fact algorithms for the computer to do this to solve it quite quickly to find such a d it's not so hard to find with a with an algorithm there are algorithms that will do it for us if you want to do it manually then basically you look at what number when you multiply with e gives us 161 plus one or two times 160 plus one or three times 160 plus one because all of those numbers mod 160 will give you one we're done we've generated our key pair the values which are generally considered our key pair the public key is e and n the private key is DNN but in practice some other values are often stored as well especially p and Q they are also private it depends upon the implementation but pink p and Q must be kept secret one way to keep them secret is to delete them you generate them using a computer two large Primes go through these steps get your value of e d and n then delete p and Q so then no one can find it but it turns out to help with the implementations it's usually useful to keep those values we use them later but in in theory you don't need them in practice we often do so let's write down our key pair and I will denote as the public key of our user what are we at e was seven n is 187 and the corresponding private key in this pair d is 23 n is 187 the same n a little bit conflicting in the words or the terminology here we said the public key is made public okay we can tell everyone my value of e is seven my value of n is 187 I can tell everyone once I've generated these the private key should be kept private I should keep it to myself not tell you but often because we use n we also write it in the private key n is not private n is public because it's in the public key but we often write it as part of the private key as well because we use it when we do the encryption and decryption so be careful there are really three values here e and D must be secret don't tell anyone your value of d e and n can be public or and are made public but often we write the private key is also including n so I generate those values I tell you my public key yep if you know Ian n can you calculate d uh no if the numbers are big enough and and I think we'll run out of time today but in the next lecture we'll go through and see well what can an attacker do when we have large enough numbers for today we'll just get to let's use the algorithm the next lecture will analyze and see well why does it work for now I think we won't get time to see why it works we'll just see how it works of how to use it but you're on the right track that we need to start asking well what does an attacker do we will come back to that so for now we've generated a key pair everyone does that generates their own key pair you tell everyone else e m you don't tell anyone D or P or Q they must be kept secret now you want to encrypt some message where are we here sorry let's say this is the key pair that we've generated for user B user B did this and a wants to send a message to b and we want this message to be secret to be confidential what do we do we have some message we want to send it to be what we do is we take that message and we encrypt it using the RSA algorithm and to keep the message secret we encrypt it with B's public key okay so to send to someone else use their public key what's the message my message is a complex one it's 88. the plain text in RSA are just integers so let's say you have a sequence of bits like an ASCII message a hello you must somehow represent that as integer just as one number because the encryption operation operates on that integer and that's easy to do if you have ASCII you can create the uh the binary form of each letter h e l l and O get it in 8bit values and then you can combine those uh five eight bit values you get 40 bits and that can be your integer so you can convert any message into a single number the constraint is that the the integer M your plain text so that you want to send must be less than the number n our n is 187 so we have must have a plain text Which is less than 187 so I've chosen 88. what does 88 mean nothing in this context but uh with a larger example it could have some meaning and then we use this equation to encrypt take your message raised to the power of E mod by n and you get sieve so a does that foreign to encrypt they use B's public key the value of e is 7. and N is 187. what's the answer you can go and do it on pen and paper remember last week we showed you how to do the modular multiplication or exponentiation you can break it into 88 squared three times and then Times by 88. you don't need to do it I've got the answer for you I don't know if my calculator will do it 88 to the power of 7. mod187 11. okay so we can calculate that we send that across the network the value 11. again I know it's hard to to visualize but the value of 88 is our plain text it has no meaning in this example but if we had a much larger numbers we could have the integer to represent any information just by converting that information to binary we send the ciphertext across the network B the receiver decrypts and the decryption algorithm is that you take C raised to the power of d mod by n and you should get the message back let's try so B receives to get the message back let's say m Prime the received value they take C 11 raise it to the power of d d it was encrypted with B's public key therefore we decrypt with B's private key in this case D is 23. n is 187 again and I need my calculator 11 to the power of 23 mod 187. any guesses 88 Magic it works that is with these numbers at least when we took 88 raised the power of E mod by 187 and then took that value and raised it to the power of D this other number mod by the same end we get the original message back and that's what we need for encryption we need to be able to encrypt get ciphertext and decrypt and get the original plain text otherwise it's useless it worked in this case it will work in all cases because of the way that we chose those keys e and D thank you why all right before we go through why will it work any questions on the steps so far not on how we attack it but just on how we generate the key and how we encrypt and decrypt any questions so when we have a quiz on Thursday if we have a quiz then you can encrypt with RSA decrypt with RSA generate RSA keys at least for small values all right you need a calculator for this step well you don't really I could ask you I wouldn't in a quiz but I could ask you to solve it manually by expanding it out you could but are not that mean uh not in a quiz in an exam I'm meaner than that so you may have to solve these manually but the steps you should be able to generate your own key pair using small numbers like I've just chosen any questions first what the last thing today yeah why does it work if we change M to a different value will it always produce when we get the ciphertext and decrypt with d will we always get M back here well yes it will why let's have a quick look let's look in general the equations sorry C we start with the first equation we have is C equals m to the power of E mod n and the other equation we have is M the decryption is C to the power of d mod n so let's start with the right one start here M so the other two equations we have we want to see if we start with M encrypt and then decrypt will we get the original M back start with the right equation and do some substitutions so that's just the right equation the right hand side now let's replace this C with this C okay we know C equals m to the power of E mod n let's call this m m Prime meaning the the decrypted m we take our ciphertext decrypt and we get M Prime now let's replace C with the top left equation C is in fact created by taking m to the power of E mod n all to the power of d mod n so I've just done a substitution in that case we can expand this that is m to the power of E mod n all to the power of D we have the same properties in Normal exponentiation m to the power of E o to the power of d is what m to the power of D all to the power of E in normal arithmetic equals with normal arithmetic m to the power of E times d the same applies in modular arithmetic and you can check and go back to our properties to see that m to the power of e to the power of d is the same as m to the power of E times d mod n mod n and we don't really need that all I did was effectively bring this D inside here m to the power of e to the power of D is m to the power of E times D mod n and we have the second mod n but note if you mod end multiple times it's the same as modding and one time 12 mod 10 is 2. mod 10 is 2. mod 10 is two if you keep modding 10 you'll still get two so it doesn't matter how many mod ends we have here it's equivalent to just to one mod n so it simplifies to m to the power of E times D mod n so if we take our original message M raise it to the power of E times D mod n we get M Prime our encryption and decryption will work if m equals m Prime that's our requirements for successful decryption to get the original M back so it leads to the question is in what conditions does m equal m Prime if you take some number raise it to the power of E times d and mod by n you get that same number as an answer if we have those conditions then our decryption works foreign yeah one of our theorems from the previous topic is going to help us let's write it differently but just change the variables instead of M Prime we require M Prime and M to be equal let's say we require something like this a equals a to the power of something e times D mod n when do we have such a condition and this will be our last thing we look at I have to go back to last topic which will give you the answer here when does a to the power of something equal a in mod n when that something is the total of n plus one so we will use this theorem to find the conditions when RSA algorithm works but we've run out of time so the next step what we'll do is we'll take this algorithm and we'll use it to find the last two conditions but if we think of that as the totian out the theorem was like this version of n almost the same when are when are these two equations the same when are these the same when e times D equals a total of n plus one if we have e times D equals the total of n plus one let's finish today I mean let's spend another minute to finish those two will be the same if this is true when is this true well when e times d mod the totian of n equals one that is um mod this by the totian of n and you get the left side mod this side by the torsion of n divide by the totion of n the remainder is one the total of n plus one mod the totian of n is one left over so that's our condition for when RSA will decrypt and if you go back to the key generation we have this condition we chose a d such that when we Times by e and mod by the totian of n we got one so the way that we generated the keys made sure that this condition was true which makes sure RSA decrypts successfully so that's the way to show that RSA always works if you generate the keys in that that approach with the algorithm we we use that's a bit involved try and understand make sure you know the key generation encryption and decryption and then try and understand the concepts behind why RSA works what we'll do next lecture is attack RSA if we're the malicious user how can we find the plain text given the ciphertext or even better how can we find the key the private key given just the public key or the ciphertext we'll look at that next lecture foreign 's awake good if you're interested in RSA you may have seen or in Security in general sorry I've got it somewhere you may have seen in the news last week and this week on the technical news that people have come up with ways to break RSA researchers cracked the world's toughest encryption they're referring to RSA by listening to Tiny sounds maybe your computer or your CPU the setup is a laptop here decrypting with RSA a microphone it listens into the CPU actually listens to the noise it makes and comes out of the fan of the the laptop and then from that they determine the secret key just by listening to the CPU from a distance of one to four meters it works and if you're interested this week I'm going to give a presentation maybe at a lunchtime break where there's no one no one has any free time about how it works so I'll send out an announcement tomorrow maybe it's not required to attend only if you're interested in knowing out knowing how it works it will most likely be Friday lunchtime then we'll I'll give some plots and some results from their paper that show how that works okay that will be breaking RSA it's not needed for the lecture only if you're interested so again this is our RSA encryption decryption and the other part which is a bit hard to remember but you should it would have helped you solve that part C of the first exam question is that the key generation now with RSA the security comes from using large numbers not from using small numbers like in the exam of course we can break that it's using large numbers and therefore we need software to do the uh encryption and decryption for us and also importantly to generate the keys with symmetric key ciphers there's a shared secret key how do you generate a key for a symmetric key Cipher random okay you and I we want to use AES to encrypt in our data between us we both need the same key so what may happen is I choose a random number uh 256 bit key a 256bit random number I generate it using some software openssl I give you that random number and that's the key that we will use it's a shared secret key between the two users but with public key crypto the keys are generated According to some algorithm not a random number so with RSA here's the algorithm so we can use openssl to generate these keys and again the idea is that every user has a pair of keys public and private key so you generate your own pair I'll show you how to do that with openssl and there are some notes on this I'll point to on the website so I'll just go direct to the command uh you can zoom in we can use different software to generate the keys and this is just one way to use openssl to generate a public or in this case a public private key pair the operation gen P key we're using sorry we're using the algorithm RSA there are other algorithms that we can use for this one just RSA and then we've we don't have to but in this case I'll specify two key options this Dash it continues across the next line Dash P key opt an option for the key we can specify some optional parameters the first optional parameter is the key length with RSA the key length is really the length of n the modulus n so I specify I want n to be 2048 bits and all right we may have seen in the slides there are three typical values for n in common use 1024 bits 2048 and 4096. the larger value the more secure but the slower it is to encrypt and decrypt the second option is that public exponent I specify in this case the public exponent e to be three so I can choose the value of E if I don't give these options openssl will choose default values and from memory I think the default public exponent is 65 537 it's a common value and it's probably best to use that compared to three but I just use it as a different example here three and I can't remember the default size maybe it's 1024. everyone watch and see how long it takes so I'm going to generate my key pair all right almost instantaneously it took a bit of time you see some dots and so on it takes some time because what just happened then was my computer chose two primes p and Q such that when those two multiplied together we got a 2048bit number n then it selected some value e well that was already selected three I better calculated D which is uh the multiplicative inverse of e in the mod the total of n so these steps were performed by open SSL and that's case and we get a public and private key let's look at the values it was saved in a file called I call privkey.pm PM's just a format commonly used so my key pair is saved in this file it's 1704 bytes long let's look at the contents should we have a quiz next week on the contents of this file I think you should be able to do this you can try it at home zoom out try again there's my key pair now we need to explain the the format of this I generated the key pair we'll see the detailed values in a moment but what openssl does by default in this this format of the output is it it encodes the the values into some form that can be printed on the screen and for example included on a web page so this is not encrypted this is what we say is encoded in the same way that we have ASCII encoding to encode uh our different characters into some decimal or some binary value we can have different encodings and this is one encoding it's called base base64 encoding that takes some binary values and encodes them using I think it's one of 64 different characters and that's the accommodation here so it makes no sense here but that's all the information needed because a decoder will find the original values so often you'll see not private keys but when we look at public Keys you'll see some encoding like this say attached to the bottom of an email or on a web page let's look at the actual values let's decode this and the way to do it openssl has an option we can output it in some nice to view text format take our input private key and produce an output in a text former and so I can scroll through I'll pipe it into less gives us the original form and we scroll down then it gives us n and now it gives us the human friendly form a little bit more human friendly than their first one it gives us the private key the modulus n okay there's the value of n it's 2048 bits but it's represented in hexadecimal here so if you convert you'll get this as a 2048bit number the public exponent e so e is 3 in in decimal the private exponent D is the next value don't look at this because this is private for me again a lot another large number so this value is the secret value that it should be specific to you and not shared with anyone else right it's just a demo in this case so really we have three values e d and n d must be kept private e and N we make public but for performance reasons for the implementation we also store some other intermediate values so we just really need e DNN but open SSL and other software store some other values to to help the the speed up the encryption and decryption so we see prime one and Prime 2. recall what happens in the key generation is that we have a prime p a prime Q we multiply together to get n this is p and Q I don't know which order it doesn't matter the two prime numbers here so they are our large primes again must be kept private because if someone else knows these primes then they can easily break anything encrypted using your public key and then some other intermediate values are stored not so important for you to know about these there's two other exponents some other coefficient again just for implementation purposes those values which are stored in your key are listed here on one of the slides you can go back and check that but there's a modulus and the public exponent e the private exponent D the three values that we always think of where and we write it where we often write that the public key is e and n modulus and public exponent the private key is DNN private exponent and the modulus the remaining values are there for uh speeding up the encryption and encryption when we use these Keys the two primes and these other exponents and coefficient not so important to remember or worry about these they should be kept secret when you have them you shouldn't show anyone else what the values are otherwise they can defeat the RSA so really the public values that you can tell anyone else and an e the other values are kept private or Secret so I have a private key your next homework task is to generate your own Keys key pairs and we'll need to exchange some values and do some encryption and authentication using those key pairs so the private key from that we can extract the public values only so the values in the file so far are all of these we can extract just n and E and the way to do so with openssl we can extract just the public values we take our sorry we take our input private key which contains all values and output to some file I'll call Pub Key and specify to just output the public values so that we hide or don't display any of the private values so our private key contains all values proof key.pm public key contains just n and E and what you'll do in your homework is once you generate these the public key you can then tell over anyone else you can send anyone this file for example attach it at the bottom of an email put it on a web page because the cat contains your public values and we can look at them output into some text format so take my public key specify it's a public key coming in and display the output as text and just so we can scroll through our pipe into less and here's the encoded format of my public key so if you want to attach your public key to your email when you send someone an email you can attach just this encoded form because software will be able to decode it but here are the actual values the public key 2048bit modulus and hexadecimal and the exponent E equals three so the two public values of N and E that's all we'll attempt to cover today because no one's too concerned so next week we'll move on to the next topic there's another algorithm for public key crypto diffiehellman that we need to cover and then Authentication focused so far on confidentiality encrypting messages so no one can see the contents but another key part of security is making sure that we can confirm who did the message come from you receive a message did it come from Steve or someone pretending to be Steve like a masquerade attack so we need techniques to confirm that and we will use public key cryptography again to do that as well as some other techniques so that's the next topic so we got to this approach of using a public key Authority but before we we come back to this Authority approach and look at the another one let's just make sure everyone understands the problem I'm just going back to our man in the middle attack this was a scheme we used to distribute a secret and that's what we'll we're trying to do a wants to communicate with B to do so they want to encrypt their Communications and using a symmetric key algorithm so they want to encrypt everything using some secret key and in this scheme is denoted KS so KS is our secret but they don't know it yet so they haven't communicated in in the past so this scheme uses public key cryptography to exchange that secret where a sends its public key to B saying I am a I want to communicate with you let's create a shared Secret so that's step one we send our public key to a oh sorry we send our public key to B B generates a secret it creates KS let's say generator 256 bit random value and that will be the secret that they use for AES to encrypt the data so B creates KS and is going to send KS back to a but of course we cannot send the secret in the clear it must be encrypted because if we send it in the clear across our Network then someone can intercept and find our secret so what V does is encrypts the secret KS using the public key of A so that if someone intercepts this message message number two they need the private key of A to try and decrypt and get KS without the private key of A they will not be able to learn KS and who has the private key of A A does that's how uh understanding of public key cryptography only a has a private q a so the idea is that b sends this encrypted message back a receives it decrypts using the private key of A and learns KS and from then on they use KS to encrypt their data KS and some symmetric key cycle so this is a common technique that we use a public key and public key encryption to encrypt a shared secret key and once that secret key is shared we use that secret T secret key to encrypt using a symmetric key algorithm because symmetric key algorithms are much faster than public key algorithms but we saw that there's a problem with this we went through and I don't have the picture here but we went through and you went through and tried to work out well what could an attacker do and come up with this man in the middle attack a sends the message to b but someone in the middle modifies that message in particular uses a different public key just to remind us of what what it is the man in the middle attack involved a sending a message as per the original scheme public key of A and the ID of a but the man in the middle that is C intercepting and modifying such that they send so this is C receives that you've drawn this before they change the public key to theirs they don't change the identity B receives that so C is somewhere in the middle of the the path of a network they received the message before it gets to be and modify the public key B thinks it got a message from a B chooses KS and sends that KS back to a encrypted with the receive public key B thinks the public key of a is this value but it's in fact the public key of C so B encrypts KS using the public key of C not knowing that thinking it's the public key of a as a result when C intercepts the reply it can decrypt and learns KS C can decrypt because C has the private key of C and then C sends back that same KS to a but encrypted with A's public key which is of course known and when a receives this reply they decrypt with their private key and they learn KS so we've gone through this attack of this man in the middle attack just to remind you that someone in the middle intercepts the messages and changes the public key so this is not good so the what we're dealing with now is ways to make sure that the public key we have when B receives a public key B needs to know this is A's public key they need to be sure who's public here it is otherwise such attacks are possible so what we're dealing with is ways to prevent these attacks and so to prevent a man in the middle attack on the public key we need some secure way to to distribute public keys and we went through this scheme first the way to securely distribute public Keys is to get someone else to confirm they are indeed someone's public key so in this case we introduced this new entity called the public key Authority who everyone trusts so assumes that this Authority is trusted and that includes that everyone knows the public key of the authority if you know the public key of the authority when the authority sends you a value and signs that so a message to this public key of B was signed by the authority a can verify that because when something's signed with a private key we verify that with a with the corresponding public key so this scheme is really a way so that A and B can exchange public keys and they're sure they are the correct public Keys it's not a man in the middle attack like in the previous uh approach and the way they do that is that the public key of B is signed by the authority and the public key of A in message five is signed by the authority as well and since they are signed by the authority both A and B can verify them by decrypting with the public key of the authority and that comes back to our assumption that a trusts the authority which really means a has the public key of the authority and knows for sure it is the public key of the authority it's not someone pretending to be the authority so we we have that assumption maybe what happened is that a physically went to the authority confirmed their their identity and got the public key then so this is just one scheme for Distributing public keys so that if someone tries to send a public key pretending to be someone else we can detect that it involves if a wants to talk to B a sending a request to the authority and getting the public key of B identify contacting B saying I want to communicate with you B does the same to learn the public key of A and the last two steps are just to confirm that these messages are a recent and not been replayed by someone else and the end result is a noise B is public key and B knows A's publicly easy one of the problems with this approach is that every time a wants to communicate with a new entity we go through these steps of contact The Authority get the key and the the receiver contacts The Authority gets the key imagine there are thousands of entities in the network they all need to communicate with each other there's many contacts to the authority and it becomes overloaded it becomes a bottleneck many packets are sent to the authority which must respond quickly if the authority cannot respond then A and B cannot communicate so the next scheme is one way to improve that mainly from a performance perspective not from security and it's called public key certificates thank you so we'll go through the general approach again the same objective A and B want to learn each other's public key and they need to be sure that they're they're public key not someone else's similar approach we have some third party to confirm whose key it is and in the previous scheme it was called a public key Authority here the more common name is a certificate Authority what happens is that a and b are issued certificates denoted in this diagram is CA and CB a certificate will contain the public key of that entity signed by the authority and this is a bit confusing when we compare this diagram to the previous one these four messages sent between a and the authority and B and the authority no there's no numbers on them they actually happened before the communications need to take place so they happen manually whereas in the previous scheme we didn't draw the ones that happen manually all seven messages happen automatically across the network in this case contact The Authority get a response whereas with if we want to draw the equivalent to what we have here A and B want to communicate using certificates let's draw it the scheme is quite simple a sends its certificate to B in the first message and then B response with its certificate so if we want to compare those schemes of using the authority the public key Authority versus using the certificate Authority compare this diagram with this one when we use the public key Authority every time a wants to communicate with someone we go through these seven steps contact The Authority get a response contact thee who contacts The Authority gets a response the problem was that there was many Communications to the authority when we use certificates it's this approach a wants to communicate with B quite simply a sends its certificate to B and B responds with its own certificate and we get the same security as in the previous scheme so we need to go through what is a certificate and what does it mean and why this is secure now this diagram compared to this one it's actually these Two Steps step one and step two that's all it's just that this picture it's a bit confusing it includes the prior steps that must happen manually in advance whereas the publicly Authority didn't include them so note when we use certificates every time a wants to communicate with someone it's very easy a sends its certificate to the destination and that destination let's say C sends back its certificate and then they're done what's a certificate in the same way that the author the public key Authority signed A's public key a certificate is A's public key signed by an authority when we say signed by someone we mean encrypted using that sign as private key confirming it came from that particular entity so the certificate of a includes the public key of A signed by someone else signed by the authority in our scheme and in our diagram back to the lecture notes it's captured in these steps here these two so what happens at the start is user a goes to the authority and say I want a certificate here's my public key and the authority confirms that this is user a and this is user A's public key so in a simple example let's say I'm the authority and all of the users are the students in this class so one student comes to me and say Here's my public key and I look at your public key I look at your ID card to confirm this is you it's not someone pretending to be you and I confirm yes this is you and this is your public key therefore what I do is I issue a certificate that's what the authority does they create a certificate which contains the public key of that user Pua in this case the identity of that user some timestamp so T1 here is a timestamp saying that this certificate is valid from right now maybe until six months in the future and I signed that information so the authority encrypts that information using their private key so that anyone else who has the public key of the authority can verify so think of a certificate as the public key of a user signed by some Authority and we'll see that a different format this is the general concept we'll see a more specific format in a moment similar B does the same B goes to the authority saying here's my public key and the authority creates a certificate for them CB in this case now note that these steps happen in advance that is whenever a wants to communicate with someone all it does is sends its certificate so once a has CA its own certificate if it wants to communicate with B it sends C A to B it doesn't have to contact the authority if it wants to send communicate with C some other entity it just sends its certificate to C so it doesn't matter the destination we don't have to contact the authority except in the very first instance and that really cuts down on the communications because it's only that first step of being issued a certificate that we have to contact the authority what is the certificate what information is is included inside here's one representation which is on the slide or on the diagram before where we said it includes the public key of A the identity of a some time stamp because instead of having certificates which are valid forever we have some time limitation on them and importantly encrypted using the private key of the authority and that allows someone to verify it if they have the public key of the authority so again this comes back to trust to be able to verify a certificate you must have the public key of the authority and you must know it is indeed the public keys that the public key of the authority it can't be someone else so we must trust the authority the certificates this is the general concept but we'll go through a more detailed View and look at some specific examples of how to store that information that's what we do to them when we sign something what do we do when you sign if you're using public key cryptography when you sign something how do you sign a message how do you sign a message encrypt with something okay you get an F in the exam if you say that anyone else encrypt with encrypt with a private key still not enough f for U maybe a d plus is a bit closer encrypt with right more specific if you want to sign something what do you do all right hash is is is good you'll get an A if you say hash but even if you just want to be you encrypt with the private key of who you that is if you want to sign something you encrypt with your private key so make sure you're clear because remember everyone has their own private key think of all users have their pair of keys so to sign something you encrypt with your private key now more specifically we encrypt a hash of the message using your private key the hash is there for performance reasons not for security so let's write that down here we haven't shown the hash function but in practice we usually use a hash function even for certificates so one way we can write CA we have the identity of a that is some something that identifies this user in the system we have the public key of A so the actual public key of the user we usually include some time stamp so noted here T1 meeting some information about when this certificate was created and how long it's valid for and all of that information is combined with the signature and we create the signature by encrypting using the private key of the authority I'm going to run out of space the hash the hash of what I'm running out of space you'll find more space the hash of all of this okay so this is our message this is the information we want to sign think of this as our message m we take the message and combine it with a signature this part is if we m is here this part is the signature the message is the information we want to communicate to someone our identity our public key some timing information a timestamp we take that message and it's signed we actually take the hash of the message and encrypt the hash value using the private key of the signer The Authority in this case so someone else signs this message on AIDS behalf so message signature where the signature is the hash of the message encrypted with a private key that's the same as we've seen all through the content on public key cryptography so really a certificate is the public key and identity and some other information signed by an authority signed by someone else usually when B receives this certificate so in the first message these values are sent from A to B when B receives it what does B do B receives the certificate what does it do decrypt decrypt what your signature okay we the the general process we say we verify okay so we to verify we decrypt the signature s we decrypt it using which key the public key of the authority okay so if it was encrypted with the private key of the authority we decrypt with the public key of the authority we get a hash value and we compare the hash value with the hash of a message so this verification step so we say the verification verify what do we do we decrypt using the public key of the authority the signature component s here and we take a hash of the message component and then we compare them so that's the verification step decrypt the signature we should get a hash value take a hash of the message and compare those values if they're the same everything's okay if not don't trust it okay so this is the same as we've seen with all of our signatures to do so we need the public key of the authority so for B to do this verification it must know the public key of the authority and that's when we say we must trust the authority including we must know the public key of the authority and it we must be sure it's it's the authorities it's not someone else's because remember that's our problem our problem is if you get a public keys from someone how do you be sure it's theirs so we're saying that we have some initial trust that we are sure that the public here of the authority is indeed theirs if we can do that we verify the signature meaning we now know the public key of A and because we trusted the authority we know that it is indeed the public key of A because if it wasn't the verification would fail B of course does the same thing it sends back its certificate and a verifies that so same steps any questions yep how do you become how does an entity become a trusted Authority so in in a generic system say then an entity must be trusted by the users how does it become trusted by the users well depends on what system let's say the system is we want to allow all students to communicate then one way to get a trusted Authority is to choose someone that you all trust maybe me and I become the trusted Authority of course that assumes that you all trust me if you don't then that system won't work so in practice in the internet how does someone become a trusted Authority um how do you trust me why do you trust me yeah do you why would why do you trust anyone well based on past experiences okay if your past experiences with them have been positive then you build up Trust so in practice certificate authorities in in the internet usually are based upon organizations that people have dealt with in the past and have done things that have build up their trust um but there's no absolute way to become a trusted Authority you must trust someone otherwise there's no way to bootstrap to start this off any other questions so far this is important because when you open up your computer and you open it a website in particular a website using https to secure create a secure connection to that website that web server is sending you its certificate and we'll see some examples of that so secure web Communications uses digital certificates and therefore it's important to understand what they are what the limitations of them are and how they provide security let's try our man in the middle attack important see what conditions a man in the middle attack would be successful yes our assumption is that when we say we trust the authority it means we know the public key of the authority and our man in the middle let's call him m uh let's call them because we may use M for the message let's call them something else uh d oh I've got to choose a letter that we won't use C we use for a certificate Authority sometimes f just so we don't get confused with some of the other letters we use remember our man in the middle a sends data to B but F intercepts the malicious user intercepts and makes some changes so a sends its certificate to B but fintercepts what can f do well can f learn A's public key yes the public key is included in the certificate so F knows the public key of A F wants to forward on a message to b I think making B think it came from a what can f do let's try some different things that F can try let's say F tries to create a new certificate containing its own public key I'll call it c a prime it's not CA it's going to be modified and how is it modified let's say ca Prime contains the public key of f the identity of a a timestamp just a note t and the signature component and again I will not try and draw the rest but the signature component is the entire message hashed and signed too much so we've got some missing parts here we'll come to them in a moment so the certificate remember public key identity timestamp and then take all of those values inside here hash them and encrypt with a private key who's private key whose private key do we encrypt with whose can we not encrypt with normally we'd encrypt well the signature is using the private key of the authority oh the malicious user F doesn't know the private key of the authority so CA maybe we can draw CA so people are clear the original certificate CA public key of a identity of a timestamp and then encrypted using the private key of the authority the hash of all of those three values that's the original certificate public key ID time stamp hash it all encrypt with the Authority's private key but when F tries to send a fake certificate to B they've modified the public key of A to be the public key of f hoping that b will receive this and use this instead of the public key of A they don't change the ID the timestamp they copy from the previous one they take a hash of all those values and encrypt with the private key well the important point is that they cannot use the private key of the authority because they don't know it it should be private just in the certificate Authority so let's denote they use some private key X a private key of x hoping to fall be into thinking this is the public key of A B receives the certificate and verifies so try the verification steps remember to verify we take the hash of the received message decrypt the signature try to verify do we have a volunteer to come and do it on the board yep what is X good question f received the certificate CA they want to change the public Key C between CA and CA Prime the thing that's changed is instead of Pua puf this is trying to do a man in the middle attack so they change that but they want to also change the signature remember the message must come with a signature so what I've attempted to do they take the hash of these values and they encrypt using someone's private key they should use the private key of the authority but they don't know it so I'm saying that they use some private key of X it may be F's private key but it's a private key which is not that of the authority so it's a private key B receives this be verifies and the verification steps are the same as always we decrypt the signature component and compare to the hash of the message component remember message component signature component try the verification this is the message component and this part here is the signature component so the verification by B decrypt the signature component which was the hash value encrypted with the private key of x and we're going to compare that to the hash of the message component when B verifies which key did I use to decrypt no the public key of the authority B receives a message a certificate this certificate should have been signed by the authority therefore to verify it you use the public key of the authority to verify so you decrypt the signature component with the public key of the authority and again our basic assumption is that every entity knows the public key of the authority and it is indeed the public key of the authority what happens in the first step when we decrypt and then compare to the hash of this value why what happens are they the same so once we decrypt here and compare to the hash we need to check are they the same no they will not be the same why not that a different key was used between the encrypt and decrypt here we use the private key of x to encrypt some hash value the hash value was in fact the same as this but we decrypt that ciphertext using the wrong public key using the different public key and the pair that was used to encrypt therefore the resulting output will not be the same as the original input it would not be the hash value so that will not be the same and when we compare them and find they're not the same then there's an error that is the certificate fails the verification we don't trust it so when B receives this CA Prime as a result of the verification steps it finds I don't trust this certificate maybe report the error or at least don't use the public key in in future communications so again this is using same Concepts that we've looked at when we look generally at signatures any other ways to attack what can f do what can f do to try and full B into thinking this is the public key of A but it indeed is the public key of f what we did was we changed the public key and then we try to regenerate a signature but we didn't have the right private key to generate the correct signature so that was a failure here another way would be to change the public key but we just reuse the signature from the previous approach the previous the real certificate but again you'd find out that the hash of this would not match the hash of the original value and therefore to be detected so changing just the message but not the signature would also be detected yeah so it turns out by using this signature then B can verify changes of the of the message and therefore because we have the public key of the authority at B when we receive a certificate we can be certain that we have the correct users public key if it verifies and B can do the same in the opposite direction how did B get the public key of the authority I know many people are thinking of that any suggestions how does B get the public key of the authority could they use certificates yeah if so how does B get the public key of the authority because that's an important part here that is to verify we use the public key of the authority because we assumed the signature was created using the private key of the authority so what if we if the malicious user f created this signatures using the private key of x and then F got B to think that the public key of the authority was actually the public key of x so that would be a successful attack in that case so we need to be sure then we when we have the public key of the authority it is indeed theirs if we use certificates we could do that but it means that we need another authority to confirm that this is the public key of the authority okay remember all the certificate is doing is confirming this is the public key of a particular user and it's doing so by having a another user The Authority confirming that by giving it signature so to be sure that it's a public key of the authority we could include the public key of the authority in a certificate and have it signed by someone else by another Authority but for that to work we must know the public key of that other authority and we have this infinite Loop so we must trust one public key of one Authority at least but we can have a hierarchy it can be such that the public key of the authority is in fact signed by a higher up Authority and that makes things more convenient in large Networks it turns out in practice usually public keys of authorities are stored in certificates as well so we could say the certificate of the authority is the public key of the authority their identity a time stamp t some some indicator of how long this certificate is valid for and then a signature again we take a hash of those first three values in the signature I just never have space to draw them okay so this could be the certificate of the authority including its public key its identity a timestamp the hash of all of those values and encrypted using the private key of who of another Authority or itself all right let's do another Authority First and we'll see the the hierarchy let's say it was encrypted using a private key of someone else I'll say Authority two you can see that someone else some other authority meaning this public key is signed by a higher up Authority but then we have this same issue that the public key of this higher up Authority what is that well it could be a certificate the certificate of this second Authority we don't have to be limited by a single one is its public key its identity a timestamp we haven't said too much about that we'll come back to it later encrypted using someone's private key of the hash of all those values same structure public key identity timestamp signature where the signature is those values hashed and encrypted with a private key who's private key who's private key another authority authority three okay and you see where we give this this continuation that someone needs to sign the public public key so we could have the private key of the authority three and then we'd need a certificate of authority three signed by Authority four and we'd go forever well at some point in this hierarchy we need a route and the root Authority has a special case certificate where it signs its own certificate let's say Authority two is the root Authority it's signed by itself check the the public key in the private key same entity and we get what's called a selfsigned certificate so this is how the the root Authority distributes its public key it creates its public key identity timestamp and signs it itself saying I confirm that this public key is my public key and that's what we need to trust that is the other users need to trust this one so that they can confirm the lower level certificates so if we trust this certificate then we can confirm the certificate of the first Authority which in turn can be used to confirm the certificate of user a and other users but it's signed so we can have this hierarchy of certificates and at the top of the hierarchy is a root CA and that has a certificate which we call is selfsigned the private key used there is the corresponding key of the public key inside the certificate selfscience certificate it's like saying foreign this this piece of paper contains my public key and I sign it to confirm it's my public key and I give it to you how do you confirm that it is my public key well you cannot with a selfsigned certificate it's me confirming that it's mine but anyone can do that anyone can say here's my public key and I confirm it's my public Key by signing it themselves so there's no security uh measure in that it's not secure a selfsize certificate because anyone can create a selfsigned certificate but in in the digital certificate system we need to be able to trust at least one selfsigned certificate so how would we trust it then let's say it's an organization or an entity that everyone else trusts in that system and they they implicitly trust that it is their correct public key we'll look at the x509 certificates uh just some notation just to summarize this hierarchy in this picture we use some notations saying that a certificate of X is issued by some Authority y by denoting it as shown here so let's use that in our example some shorthand notation that says we had the certificate of a was signed or issued by our Authority and the certificate of the authority not good names but our first Authority was signed by Authority two and the certificate of authority to was selfsigned because a shortened way to to write down who signs particular certificates to verify one certificate we must trust the certificate of at least one other entity so to verify a certificate we must trust or we must have the public key of the authority and to verify that we must have the public key of authority too and we must in this case ex trust the selfscience certificate of authority too so we can build up a chain of trust amongst these certificates so long as we have the route in the hierarchy we can verify the others foreign up your web browser people always sit in my classes with their laptops open your browser do something useful and access the Moodle website log in if you're already logged in log out and log in again and I'll do it here for those that don't have their computers so my browser I access the Moodle website and I need to log in well uh it's here somewhere the login button log in now note the URL not in the top of the address bar there the URL ict.sit Dot tuacth slash Moodle what protocol was used to access that website HTTP so accessing a web server HTTP now I log in and maybe you can see I cannot zoom when you hover over a link usually your browser shows you the the destination URL down the bottom note that the destination is https what's going to happen when I click on the link those with the computers click on the link this connection is untrusted if you didn't get that then you've been hacked okay then your login to Moodle is insecure so this is a warning message presented by my browser and let's see what it says you have asked that so this connection is untrusted you've asked your browser to securely connect to ICT s i t t u a c t h but we cannot confirm that the connection is secure normally when you try to connect securely sites will present trusted identification to prove that you're going to the right place this site's identity however cannot be verified so this is a message from my browser saying I cannot confirm I can cannot verify that this is in fact ICT server and https which is what we're using here uses digital certificates for servers to verify their identif identity to browsers when you access a website you would like to know it is that website that you're setting up a secure connection with it's not a man in the middle attack and this message is saying well we cannot be sure maybe someone between my browser and the ICT server is performing a man in the middle attack because what's happened and we'll see in details later that the server has sent its certificate to my browser and my browser has tried to verify the certificate but reports this error saying it cannot be verified so this is an example of receiving a certificate that is not trustworthy so let's not trust that and let's not go to that website let's try a different one I open up a different website again using https so my internet works slowly it's coming using https and https uses digital certificates and it's connected to this website no warning which implies that the server this fsf.org has sent their certificate to my browser and my browser automatically goes through the verification process it tries to compare the signature with the public key and identity information and if they're verified it allows me to access the website if it doesn't verify then it presents that warning and since it didn't present the warning it was successful here I can see this little lock up the top the padlock and if I click on that I can see more information and it gives me a summary uh the lock here he says you are connected to fsf.org the domain verify verified by Gandhi SAS so this is a given me summary about The Authority that has verified the identity of this website and more information and your browser will show you if you look into the details the certificate of the web server so here I'll view the certificate and it gives me a summary of the certificate sent by the server to my browser remember a certificate is a public key in identity of some entity in the network issued by someone else signed by an authority so it summarizes it's issued to fsf.org and is issued by some other organization the common name is just the the field which indicates the domain for this certificate also includes optionally organization organizational unit and some serial number for this certificate so in practice we don't just include the public key and one field with the ID we can include other values issued by is the identity of the authority some organization called Gandhi standard sslca CA short for certificate Authority and some organization name and the timestamp here it's stored as represented by two values the date when this certificate was issued and when it expires so certificates have a fixed lifetime or a finite lifetime let's look at the details and again my browser represents and shows that this certificate is actually part of a hierarchy so the certificate for fsf.org was signed by an organization Gandhi standard SSL and that certificate was signed by some other authority called utn user first Hardware this is the shortened name for those authorities so in fact here we have a hierarchy one certificate signed by another which in then signed by a third similar to our example where we had a certificate signed by the authority which was signed by authority too so there are in fact three certificates here the web servers certificate the first authorities and then the topmost authorities or the root authorities the details of those certificates are included here and the format is referred to as x509 there's a standard that says what what's the contents of a certificate and the name of that standard is x.509 so it's commonly used in in certificates there have been some different versions and we'll look through some of the fields in there it's on the slide here it shows the different fields but we'll use the example to see them we have something identify the version of the the certificate but it's a standard used x509 I think version three will see a serial number that identifies the this certificate so each certificate gets a a different serial number we sign the sign the certificate so we drew generally we encrypt the hash value well what algorithms do we use for the hash value and for the encryption so it gives some values here the issuer is the authority who signed this certificate validity is like our timestamp not be not valid before this date not valid after someday and the subject is whose certificate it is and we'll have the subject public key information version three that's just the version of the the the format of this certificate some unique serial number so another certificate would have a different value the algorithms used in this certificate The Authority who issued the certificate so some values to identify that organization it's usually an organization can be a person not valid before some time and date not valid after some time and date so after that date whoever receives this certificate should treat it as untrustworthy so they should be updated over time the subject and the important part is the common name which identifies in web browser in web service certificates the domain so here anything.fsf.org so this certificate is that is for that domain when you visit a website with that domain this certificate applies the others are just I think the common name the organizational unit are just optional values people then the public key information the algorithm used RSA and the actual public key remember RSA we have a public key which is e and n and the private key DN so in the public key n is the modulus so there's the value 2048 bits in hexadecimal and E is the exponent 65 537 so this is the actual public key the RSA public key for that subject for the web server there's some extensions some extra optional information that can be used to support by the uh the certificate Authority would not look at them that algorithm used for signing sha1 with RSA that refers to we find it the hash algorithm H is sha1 and the encryption algorithm is RSA so the signature algorithm refers to the two algorithms used here we may use different algorithms sorry and finally the actual signature so this is the 2048bit signature used which is that s part when we draw on the screen that's the certificate of the of the web server fsf.org it was issued by an organization called Gandhi standard sslca to verify this certificate we need the issuer's public key which is stored in the next certificate up in the hierarchy the subject is Gandhi standard sslca the issuer in this case is utn user first Hardware so another Authority to verify this certificate we need this utn user first Hardware certificate and we see that up in the topmost of the hierarchy subject and the issuer anyone want to guess who's the issuer of this certificate all right itself at the top of the hierarchy we'll have a a root certificate and it's a selfsigned certificate so the subject is utn user first Hardware the issuer is the same utn user first Hardware so this is a selfsigned certificate it's the same as this example where we had think of this as the servers certificate issued by one Authority that Authority certificate was issued by a second Authority but that second Authority certificate is selfsigned by itself it doesn't have to be two levels all the time it can be a single level or it can be multiple let's go back to our first example just to finish when I connected to ICT what happened it gave me a warning saying my browser could not verify the received certificate try again untrusted connection technical details saying the certificate is not trusted because it is selfsign so the browser says I've received a certificate from a server but it's signed by the person whose public key is included and if we want to access this website we must manually trust the certificate so I understand the risks and we can add an extent exception we can actually view the certificate in fact since I run the ICT server I've created a selfsigned certificate because I haven't gone to the effort of creating a real certificate and you can see it's out of date as well okay 2012. so this is the issuer and the subject are the same in this case so be careful when you access such sites if we confirm the exception and we manually trust it then we get access to this site okay I'm sure you've seen others like that next week we'll discuss some of the issues well why do we have that why is there a selfscience certificate and other issues of where did the why did the browser trust these other authorities so whose certificates do we initially trust some of the Practical issues to finish off on certificates and that'll be next week any questions on certificates so far you'll see a few more examples next week you'll see some in your homework which is yet to be released will be today or tomorrow any questions you follow the certificates on your laptop so the informal homework whenever accessed some websites and check the certificates from your browser just so you can get some examples and see the the general structure to start to understand what's happening a formal homework will be assigned soon