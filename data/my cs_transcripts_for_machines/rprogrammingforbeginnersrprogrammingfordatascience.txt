this video covers key strategies and knowledge that will make working an hour much easier in the near and long term let's start by opening our if we want you can type directly into the console however this makes it a bit difficult to recreate our work so it's helpful to open a new our document also called an R script we can open a script by holding down command and hitting n whenever you write our commands you should write them in our script then you can send the commands in your script to an our console to be run for example if your cursor is online in the our script you can run that line of code in the console by holding down command and hitting return to run a larger block of code highlight the code hold down command and hit return it is useful to type your commands into an R script because you can organize their commands and you can run and rerun these commands quickly and easily you can also save an R script so you can use it later and this makes it easy to pick up where you left off in your next work session here I'll save my script to the desktop with the name temp dot R saving and loading files an hour can be very helpful Hara is always looking in a particular folder on your computer and it is sometimes important to know where it is looking so you can access and save files there are two tools that will make this easier get WD and set WD which stands for get working directory and set working directory to get WD function will tell you which directory R is currently working from if you'd like to change the directory you're working in use the set WD function and specify a file path inside the parenthesis where the path is contained in quotation marks for those work in OS X there's one more tool command D typing command e will open a window where you can navigate to folder of your choosing when you are done in an hour session save your script and then type Q open parentheses close parentheses into the console as long as you carefully document your work in an R script there's little reason to save your work space in the next video we'll begin creating objects in our to get acquainted with our let's do some basic calculations we can add numbers multiply numbers and we can invoke builtin functions to do more complex calculations so R is good at calculations but we don't want to type in all of our data instead we'll often store our data into our objects in a later video will load in larger data objects but for now let's create some simple R objects let's save the value for to an object called X usually we use a less than symbol followed by a dash to communicate that we want to save something like a number into an R object now we can use X to do some basic calculations for example X times X or we can calculate the square root of x note that sometimes people might call X a variable so think of the terms object and variable as meaning the same thing in our the names of our objects can include letters numbers underscores and periods however the name should always start with the letter usually one that is a lowercase if you'll be sharing your code with others check with your group to see if there's a style guide that you should follow for your R code one last tip if you want to review an earlier command you made click the command line on the our console and then hit the up arrow on your keyboard when you do this you will be able to see earlier commands you have run and if you desire you can rerun them in the next video we'll create and work with vectors in our one of the fundamental objects in R is a vector which is just a term to mean a single set of values in a particular order we can create a simple vector in R using the concatenate function which is a function represented by a lowercase C inside the parentheses we put values or other vectors separated by commas and these will be stuck together to create a new vector when we print the vector R simply prints the values one after another you might wonder what happens if there are so many values in the vector that it hits the end of the line well the values wrapped to the next line just like the text would if you were writing a paragraph notice that there's also little extra information in the first and second lines in the first line we have a number one in brackets and on the second line we have a number 10 in brackets in each case these correspond to how far our is into the vector at the start of each line for example the 10 indicates the first element on the second line is the tenth element of the vector the one in the brackets at the start of the output indicates that this line was the start of the printed vector this brings up a subtle point looking back on our earlier output we can see the bracket one in each output while each earlier output looked like a scalar that is a standalone number each of these is really a vector with a single value in our a vector of length one is equivalent to a scalar for those vectors with length greater than one it is common for us to want to access a specific element let's call our longer vector V if you wanted to look at just the first element of V we use brackets with a 1 or if we wanted the third value we could use a 3 in the brackets we can also request several values at once to do so we create a vector that indicates the positions of the values we want returned then we put this vector into the brackets so let's suppose we want to look at the first three values we start by creating a vector of one two three here I've done that using the special notation 1 colon 3 which produces a vector with the values 1 2 3 I'll save this vector into a variable called look at and then I'll use look at inside the brackets to get at the first three values of V there are three more functions worth remembering when it comes to vectors length head and tail the length function indicates the number of elements in a vector the head function returns the first six observations in the vector and the tail function returns the last six observations in the vector here's V printed out for comparison also if we want we can specify a second argument in the head or tail functions this second argument says how many observations we want to see for example here I'll specify that I want to see just the last three values of V using the tail function with 3 as the second argument in the next video we'll work with character and boolean vectors our can handle a lot more than numbers for example you can handle character objects which are also known as strings we can make a simple character object just by putting some text in quotation marks you might notice something we saw before which is that the output is again preceded by a 1 in brackets this character object is a vector and we can create a longer vector using the concatenate function as with numeric vectors we can apply functions to a character vector to learn more about it or get summary information in addition to the numeric and character type of vector we can create a boolean vector in the simplest case we can write true in all caps or we can write false in all caps we could also create a vector of true and false values using the concatenate function one of the really handy features of boolean vectors is that they can be used to extract specific elements of a vector that meet a certain criteria for example here we'll use the end char function to find out the number of characters in each character string in the vector then we're going to create a new vector called under 10 this vector will indicate which elements of V have less than 10 characters finally I can subset V using under 10 in the next video we'll start doing arithmetic with vectors the simplest type of vector arithmetic anar is just adding a number to a vector let's create a vector V of values 10 20 30 40 50 and 60 then we'll add one to this vector when we add a single number to a vector it adds that number to each element of the vector we can also do simple multiplication which works in the same way things get a little trickier when you multiply two vectors where each are longer than length 1 let's create a second vector called W that takes values 2 3 4 5 6 & 7 I've constructed this vector using a special notation of 2 7 which generates a sequence of integers 2 through 7 this is a handy way to create a sequence of all integers between two values let's multiply V and W is that what you expected our performs elementwise vector multiplication that is it'll take the first value in each vector and multiply them then it'll take the second value from each vector and multiply those and so on when working with vectors are works in the same way when do an addition subtraction division and other basic operations things get a little more confusing when we multiply vectors of different lengths let's overwrite W with a vector of length 2 that takes values 5 and 10 when we multiply V and W now the result might be surprising we get another vector with 6 elements let's take a closer look at what happened the first two values make sense they are again the element wise multiplication however when we get to the third value it appears to be the product of the third value of V and the first value of W the fourth value is the product of the last value of V second value W what we've just observed is that our recycled the vector W so that it could complete the multiplication across the full length of V it also did so without any warning or error r is built to recycle vectors and it doesn't always tell you when it does so let's do one more vector multiplication well overwrite W one more time and make it a vector of length four with values 5 10 15 and 20 here this vector has been created using the sequence function the first argument says where the sequence starts the second where the sequence should end and a third how big of jumps to take to get from the first to the last value here again we multiply out V and W are again will recycle W but this time it gives us a warning in this case when our recycled W it still had elements left over when it ran out of elements with V so it wanted to make sure that we are aware of this there are several ways we can perform arithmetic and are using vectors we can raise every element in a vector to a power or a different power for each element here I've again use the integer colon integer notation to create a vector of values two three four five six seven many functions also work nicely across vectors such as the square root function in the next video we'll learn about matrices matrices are just slightly more complicated than vectors to create a matrix we usually start by creating a vector here I'll create a vector that has elements 1 through 12 using the integer colon integer notation next I'll use the matrix function to create the matrix whenever creating a matrix it is helpful to provide the number of rows and the number of columns to ensure that you're creating the precise matrix you expect you can do this using the n row and n call arguments if you happen to forget to use the argument names our will try to guess what you meant it usually does this based on the order of the arguments for the matrix function if we specify the number of rows before the number of columns we get the same type of result you can also experiment with leaving off one of the arguments notice that if I only include the number of columns I need to specify the N call argument name if I want to get the same matrix that I got before the matrix function is very handy in that well you might specify the complete set of data for the matrix right up front you don't always have to do this if parts of the matrix will repeat here's the matrix with all zeros we only need to specify a single zero for the entire matrix we can also specify a partial vector that can be used to fill in the entire matrix let's create a 3 by 4 matrix with values 11 12 and 13 filled in in the entire matrix in this example the vector which had length 3 was recycled until the 3 by 4 matrix was filled up notice that the vector runs down the columns rather than across the rows if we had wanted to make it run across the rows we can add a fourth argument to the matrix function by row equals true we also sometimes want to learn more about a matrix we might start using the DIMM function to learn the dimensions of the matrix here the output of dim is a vector of length 2 the first values the number of rows in the matrix and the second is the number of columns we can also apply the length head and tail functions to a matrix the length will return the number of elements in the entire matrix and the head and tail functions will provide up to six rows from the top and bottom of the matrix if we want we can specify a second argument in the head or tail function take it a different number of rows back one last matrix topic to consider is how does like a one or more elements of the matrix let's return to the matrix that we had at the beginning of the video here it's just values 1 through 12 in the matrix that has three rows and four columns like with vectors we can subset a matrix to select one or more parts of the matrix but since a matrix is twodimensional we need to specify two dimensions in the brackets for example if we use 2 comma 4 we will get the element in the second row in the fourth column if we leave the column entry blank we'll get all of the columns and if we leave the rows blank we get all of the rows just like with vectors you can use vectors of length greater than 1 inside the sub setting to return more than one value using vectors with lengths greater than 1 to get both rows and columns may produce a slightly surprising result another matrix let's consider the matrix where we specify the rows 1 and 2 and the columns 3 and 4 doing so gives us back a sub matrix specified by these dimensions finally before moving on one final word on matrix sub setting if you forget the comma R will still return a value each matrix is stored in R as a vector with extra dimensions so if we request the third element of the matrix it counts down the first column and returns the third element if we specify the fifth element our runs out in the first column and so goes the second column as it keeps counting I wanted to highlight this not because subset in this way is a good idea but just to make clear that it can be accidentally done and so it's something you need to watch out for using the row column subsidy notation is the preferred in the next video we'll take a look back at the first six videos and also how to access help files for functions inside of our functions are special our objects have taken other objects as arguments and produce something in many cases the person who wrote the function provides default values for some or even all of the arguments we've now seen a couple important functions and techniques first we saw the concatenate function that was easy to create vectors and we saw we could create vectors that are sequences of integers using the integer colon integer notation we use the length head and tail functions to learn more about vectors we also saw character vectors the letters object is a builtin vector of letters inside of our and we wanted we could examine a subset of the letters we also saw how to construct matrices using the matrix function as well as how to specify the number of rows and columns for a matrix Susan the second and third arguments the dim function provided a way to check the dimensions of a matrix and we could again use brackets to examine a subset of the matrix except that we specified both rows and columns or just one videos are great but they're no stand in for documentation thankfully most functions an hour are very well documented to access the help file for a function just type a question work the function name and then hit return here's the help file for the sequence function at the top of the file is a description of the sequence function and other related functions described in this help file the next section shows the sequence function and its variants and arguments section provides details for what type of inputs are reasonable and how to specify additional options the next sections of particular interest are the see also and examples sections it's a good idea to take a look at the example section early on when you're exploring a new function on OS X it's also easy to run examples from the help file by highlighting the example text holding down command and then hitting return congratulations you've completed the first section of our videos take some time to try out what you've learned and when R gives you an air check for typing mistakes which are common after you finished experimenting fuel up and start section 2 welcome to section 2 R is a powerful tool for data analysis and the first step to working with data in R is to get the data into R suppose I have a CSV file on my computer and I want to load into R since I'm running R on OS X I could use the command V trick to change my working directory to the folder with the file but it's also helpful to know how to navigate using the get WD and set WD functions will also make use of the list files function which lists the files and folders in the current working directory I want to get into my Google Drive folder so I'm going to specify that in a set WD function next I'm going to print out the folders in this Google Drive folder and navigate to projects next I'm going to navigate to the top secret folder and since I know there's a data folder there I'm just going to add this folder into my set delete command alright I've arrived and I can now see the dataset of interest in my current working directory the state dot CSV data set since I'll be saving this code I might as well save my current working directory in a set WD command at the top of my script this way I won't need to set the directory in the future unless I changed the working directory of my project files now that I'm ready to go I'll load in the state CSV file using the read CSV function specifying the name with the file in quotation marks when you're reading a CSV file in DAR it's stored as a data matrix it is more formally called a data frame in are just like with the regular matrix I can use the DIMM function to see how many rows and columns are in the data set there are 51 rows representing all US states in Washington DC and 12 different columns representing the 12 different variables recorded for each state I'll use the head function to print out the first two rows of the state data set just like I could do with a regular matrix however if I apply the length function R we'll just return the number of variables in the data set which are represented by the columns data frames are one of the most common objects for holding data inside of our meagan subset on them in ways similar to how I might subset a matrix this is fine but they're actually better ways with data frames a new function for data frames worth remembering is the names function which is used to access the variable names once you know the names of the variables it's easy to extract out the entire variable using the dataset name followed by dollar sign then followed by the variable name let's take a look at the smoke variable the smoke variable is a numerical variable representing the percentage of people who smoke in each state if I wanted I could apply some standard functions like the mean or standard deviation function to get some summary information about this variable in addition to substudy with brackets I can make use of the subset function here I'm gonna examine only states with smoking rates higher than 25% if I wanted I could also specify that I only want to select a small number of columns next I'll take a look at the party that won each state in the 2012 presidential election this is in the press 12 variable note that the press 12 variable isn't numerical yet it was stored the smoke variable which was a numerical object in the state data frame data frames can hold a different type of variable in each column while a matrix can only hold a single data type for the entire matrix notice also that the output doesn't look like a regular string output which generally has quotation marks when it is printed out additionally there's a listing at the bottom that indicates there are two levels output like this indicates that this is a factor variable or a factor object a factor object is a special kind of object that's sort of a blend between character and numerical variables if you ever have substantial trouble working with factors in our you can just convert the factor to string with the Eze character function R will generally convert a character variable back into a factor variable when it is appropriate to do so however we know R does do this conversion it may notify you with Orion just read your warnings carefully and make sure that that's all that's happening in the next video we'll talk about ways to take a quick look at a data object inside of our and we'll also take a look at data objects there are two other functions I'll consider that provide a brief overview of a data frame but first I'll load in data set this time stock market data I've already navigated to the proper folder and I can see the file in my current working directory if I use the list files function this particular data set is saved as a tab delimited text file so to import it into R I'm going to use the read the limb function in the last video we saw how to load in CSV files and in this video we've seen now how to load and tab delimited files if you aren't sure how to load in your particular data set Google your question there are many online resources about loading data in tar likely to be very useful all right back to the data set I'll take a look at the first in the last three rows I can also get a better overview of the data set by using the STR function that provides a breakdown of the objects structure here I can see that stocks is an object with over 70,000 rows and eight variables I can also see each of the names of each of the variables and the first several observations get a sense of what each contains note that observations for factor variables may look like numerical variables another helpful function to get an alternative look at an object is the summary function in the case of a data frame the summary object returns a summary of each column notice that there's n/a values represented in some of the columns in our na means that there's a missing observation and here it lists the number of missing observations for each of these columns note that the STR and summary functions are not specific to data frames they can be applied to any other object to get a quick peek about the object and its characteristics you might have noticed that one of the variables in the stock data set is a date I'm going to take a closer look at the date and printout the first 20 values if I look carefully I can see there's also levels attribute associated with these dates that means that R has interpreted this field as being a factor it'd be much more useful to keep this as an actual date object in this case the dates are formatted as day month and year and in such cases I want to examines variables a date object using the as date function I also need to specify the format of the date there are many different ways to format dates so you may need to look up how to specify the date format so you run into for this purpose you'll probably want to look an STR P time function help file you can do this by typing question mark STR PE time and hitting Enter I'm gonna save the formatted dates and then the object called s date while having this date object is helpful I really would like to replace the original date object with this one in fact it actually would've been much easier had I just skipped the step of creating a state and is saved the modified version over the date object right from the start now if I look at the stock objects again with the head function I can see that the date variable is now formatted a standard way starting with all four digits of the year than the next two digits for the month and then the last two digits being the days you might wonder why go to all this trouble to format the date why not just leave it as a factor or decided as a character first you might like to examine the differences of dates to learn the proximity of two observations to each other second if you generate a time series plot that makes use of the date object R will do its part to help make the plot look nice for example here I'll plot the time series of the stock price for Google I'm specifying the data's variable for the horizontal axis and since this is formatted as a date hour we'll use this information and plot the years all along the axes had I not converted the date over to a date object the plot wouldn't have looked nearly as nice there are several other reasons to properly process and format dates in R but the general reason is that doing so communicates the data structure accurately and this will make it easier for you and others to use and reuse your code in the next video we'll talk about if statements and also the which function in this video I'll cover two important structures in any language the if statement and logical operators I'll also introduce the ifelse and which functions I'm going to occasionally rely on the stock data used in the last video but to keep things simple I'm also going to omit any rows that have an na value as these represent missing observations in the data an if statement is used to execute some section of code on the condition that a particular statement is true in this setup the code inside the braces will run if the condition is true for example suppose I want to check whether the first entry in the stock data was up or down if it was up I want to create a variable called status that takes the value up it would also be informative to label the statuses down if the stock is down so I'll add an else statement the code in the second set of braces will execute if the condition is false however this still isn't quite right what if the stock opens and closes at the same price I can add a condition for the second set of code using a second if statement after the else command then I'll add another else command at the end that labels status with a value of flat if the stock is flat for the day I also want to briefly mention the ifelse function which could be used in this context to create an up down flat vector for all the elements in the stocks data in just a few lines of code the ifelse function takes three arguments a vector of length 1 or more that contains true and false values a value to take for each true instance and a value to take for each false instance though this still isn't quite right because I need to return a value of down if the close is lower than the open I can do this by creating the second condition and I need one more if else command here I've done something subtle I've provided the status argument for those cases where the close is not lower than the open I've exploited a special feature of the ifelse function which is that when a vector of length greater than 1 is provided in the second or arguments ifelse will be performed element wise for that argument I'll leave it to you to verify that this code works and why it works you should think about each possible case a stock can be updown or flat and I strongly recommend you create some test data and work your way through each step of the code next I want to talk about logical operators I'm going to create a vector with ten random integers between negative 1 and 13 and a second vector in the same way I'd like to know whether all the elements in X are greater than 0 I might intuitively start by using the command X greater than 0 however as our does in many other scenarios it also performs this check element wise here you can see I have a vector of true and false values but I can use the all function around X greater than 0 to answer the question as to whether all of the values of X are greater than 0 we can also check other things such as do any elements of X line up with those in Y this again returns a vector of true and false but this time I can use the any function to check whether any of the values are equal we can also do other checks that relate x and y for example consider the separate commands X greater than 0 and y greater than 0 if I wanted to check in which elements this was true in both vectors I could use a single ampersand between the commands here the single ampersand means to check whether both the first and the second condition are true on the element wise basis there's a similar or command using a pipe or a vertical line character that creates an elementwise basis on whether one statement or the other statement is true are like other languages also has a double ampersand and double pipe notation though I'm going to move on if you're interested in this you should check out the help file for X or the last topic I wanted to cover in this video is the which function you use to identify which elements or observations satisfy a particular condition for example I'd like to know which observations had a big intraday fluctuation to begin I'll create an object called fluctuation that gives the raw intraday fluctuation I can scale the fluctuation by dividing the difference by the opening share price of the day next I'll create a condition for whether the fluctuation was greater than say 25 percent this is a boolean vector of true and false values that report whether each row in the data frame satisfied or did not satisfy this big fluctuation condition if I wanted a vector reporting just those rows that satisfy the condition I can use the which function these rows are present observations where the stock price fluctuated by more than 25 percent in a day if I wanted I could examine each of these rows in the original data set in the next video I'll talk about for loops a second key programming tool is the for loop a for loop is a structure used to execute a set of code repeatedly the for loop statements specifiers an index over which the loop is computed for example here I'll execute a for loop using an index called I the object I will start the loop by taking the first value in the 1 through 10 vector that is to start I will equal 1 next the for loop will execute then I will take the next value in this vector which is 2 and loop will execute again this will continue until I is taken the last value in the vector 10 and the code executes one last time in this set of code the value I squared will be appended to vector X using the append function here I got an error I'll take a closer look I can see that X never actually existed so there is no way to pend anything onto the first iteration to fix this I'll just initialize X as an empty vector using the concatenate function but leaving the arguments empty okay this runs well look at X in each iteration value of I squared was appended to the end of X so the first element was created when I was 1 the second when I was 2 and so on okay I've done something pretty cool here I've done ten calculations using a for loop and it wouldn't be hard to do many more with the same set of code for example I could easily go from 1 to 100 rather than just 1 to 10 while there are other better ways to do this particular calculation there are instances where for loop is very useful all right one more look at the stock data to calculate the smallest and largest values for each stock in the stock data set I'm going to start by creating an object called the tickers that is just a list of the unique stock tickers in the data since for loops can iterate over any vector I will write a for loop to iterate over the object that I've called the tickers it's sometimes helpful to also give a meaningful name to the index so I'm going to change the index I to ticker now I need to create code for the general case for a given ticker calculate with the low and the high value I'll start by identifying which rows are of interest in the stocks data set the vector called look at is a boolean vector indicating which observations represent the ticker for the given iteration next I can create two statements calculus to low and highest high of these observations finally I need to store these values somehow I can start by initializing two objects lows and highs next I can use an append command to append a value on to the end of the vector alright I can run the code and print the results but something's wrong well I'd want to spot check some of my data anyways something bad has happened a value of na in R means that a value is missing and more generally oftentimes functions will return na if any of the observations are missing if I took a look through our data set I'd find that there are several observations with missing na values here I've checked how many entries in the column lo of the stocks data set are missing in many functions such as min and Max there's an optional extra argument that is useful for ignoring missing data the narn argument which I'll set to true in the min and Max functions now when I rerun the code I get sensible results I'd want to look at the data more carefully to see why some observations are missing but I'll leave this as a topic for another set of videos one final word even in this example there are other better functions that could have been used to get the same results much more quickly this would be important for code that should be implemented efficiently and I'll get to these functions in the future however for the beginning our programmer it's sometimes easier and clearer to simply implement a for loop lists are a special type of object that hold other objects I can initialize a list by simply using the list function I can create items in the list by providing arguments to the list function what is important to understand is that a list can hold objects of all different types in this example the first object is a numerical vector of length 5 second objects is a character vector of length 1 and a third object is a boolean vector of length 1 if I wanted to access an item I use the subset in a double bracket I can also add on new items even providing the character name for the item when a list has named objects those objects can be accessed using a special dollar sign notation but is reminiscent of the same notation for data frame Liss also aren't restrained to holding just vectors they can also hold matrices data frames and even other lists lists are so powerful since you create helpful ways to organize diverse sets of data or results oftentimes I have many groups of data and would be helpful to calculate statistics reach I might organize these statistics using a list I'm going to load it in the stock data just as we have in the last couple of videos my goal will be to create a summary of the prices for each stock I'm going to do this using a for loop the first line in the for loop will identify the rows of interest the second line will calculate the summary and start an object called stock summary I also shouldn't forget to initialize a stock summary object here as a list finally I can take a look at the results not surprisingly there's a lot to look at if I wanted I could look at a specific summary for a particular stock say Google's stock what I've done here in just six lines of code is very powerful I've calculated summaries for every stock in data set and this code works regardless of if I have five stocks or five thousand stocks in other instances I might choose to do something even more complex like fit a linear model to the data for each stock separately even in that complex case a list can be used to store the result I noted in the last video that is a become more familiar with our you'll find out that there are more helpful functions to do operations commonly done in for loops this is also true with this example which could have been written much more compactly using some additional functions some of these functions we'll encounter in the next section like the function is buy and apply great work on making it through the second section of videos take a short coffee break practice what you've seen and then get started on the third section writing your code into our scripts is valuable for managing or organizing our objects but sometimes you may wish to clear some objects from your workspace to get a look at what objects exist in your current workspace use the LS function if you want to remove an object use the remove function with the argument name as the object to be removed if you want to remove all the objects in a workspace you can use the list argument in the remove function and specify all the objects in the workspace using the LS function it's also helpful to be able to easily convert between objects of different types will consider three functions for converting objects to numerical character and factor object types for instance we can apply each of these functions to the object X applying the as character and the as factor functions back to the outcome had I wanted to actually change X to say a factor I could have assigned the new result tax one special note here if you have a factor variable that also looks numeric always convert it to a character before converting it to numerical value there are other comparable functions that you may occasionally find useful such as as matrix as data frame and as list one last functional considering this video is the unlist function in the usual process of data analysis I might create a list to hold summary results of an experiment here I'll construct a list manually for four groups in this example you can think of the first number for grouped represent its corresponding sample size the second number might represent the average response for that group and the third value might represent the standard deviation for the group just a side note worth mentioning I typically perform these types of calculations in an automated way which would make it easier for the code to be scaled to an arbitrary number of groups if you need to refresh her on this topic look back to the fifth video in section two all right so the results are stored in a list where each list item represents the results for a single group if I unlist this object I get a vector of the unlisted results it would actually more useful to hold this object as a matrix or as a data frame so I'll form these unlisted results into matrix if I'd prefer a data frame I could use the as data frame function applied to this matrix if I wanted I could also adjust the column names of the data frame using the names or the column names function in the next video we'll explore the family of apply functions which are helpful for applying a function across the rows or columns of matrix or across the elements of a list the apply function and its variants are useful for applying a function across an hour object we'll consider two variants of these special class of functions apply and T apply and we'll also look at the by function I'm going to start by loading in a new dataset website revenue for the month of March for ten businesses I've used the argument header equals false because there are no call names stored in this comma separated values file the data in this data matrix have been stored in a slightly unorthodox way each business is represented as a column and each row represents a day in order of March 1st through March 31st so for example on March 3rd the 10th business made $23.98 it might be helpful for me to take a quick look at how the businesses are doing by taking a look at their total revenue I could take the sum for each column using a for loop and store that result in a vector but this would actually be inefficient instead I should use the apply function which will be more compact and also run faster with larger data sets the apply function is useful for applying a function across the rows or columns of a data matrix that is I might want to apply a function across each row separately or across each column separately the first argument is the data matrix itself the second argument is the dimension number over which to apply the function rows are represented by number one and columns by number two think of the second argument as specifying the dimension that you actually want to retain the last argument is the function to be applied in a similar way we can also compute the total revenue for all the companies on each day of the month by applying the sum function over each of the rows notice that there are some missing observations if we would look into the data more carefully we would find that there are two missing values each in the third column if we know that it's okay to omit these data we can tell the sum function to ignore the missing observations using n/a remove equals true the apply function passes this argument on to the sum function generally any extra arguments to apply will be passed to the function you specify in the third argument in this particular use case we probably should want to investigate the missing observations rather than simply ignore them also just a technical note for this application of apply I could have used either their call sums or row sums functions all right onwards the second function T apply to help explain this new function I'm going to load in a second data set that summarises eBay auctions for the Mario Kart video game for the Wii this is a tab delimited text file of the data so I'm going to read it in using read elimb to keep things simple let's focus on three variables wheels conditions and total price the t apply function is similar to the apply function in that it helps aggregate data efficiently for instance we could examine the sum of all the total prices of auctions that were new and used separately by providing the vector for the total price as the first argument the vector for the conditions is a second and then the sum function as the third just like an apply the third argument for the t apply function is another function to be applied across the data however in this case the function is applied to each group where the groups are specified by the second argument which in this case is the condition of the game I'm going to modify this command a little bit since it makes more sense to look at the average price of the game as you might have anticipated the games that are new tend to sell for more than the games that are used here the difference is about ten dollars there's a second important variable in this application that relates the price the number of steering wheels that come with the game in the auction these steering wheels are game accessory that make playing Mario Kart a bit more fun let's look at the average price of the auctions with different numbers of wheels included as you might expect we again see a steady increase in price associated with having more wheels included in the auction about six to ten dollars per wheel now there's something interesting to think about here if I consider the influence of both price and the number of wheels simultaneously what will this do to the estimated cost of a new game versus a used game and also the cost of an extra wheel a table to look at the average price across each of the combinations of condition and wheels can be made using the T apply function to do this I'm going to provide the data frame with just the condition in the wheels columns as the second argument some of these numbers will look a little bit surprising for instance going from no wheels to one wheel doesn't seem to influence the price and then the game is new if we dig in a little more here using length function in place of the mean function I can see that one of the groups had very few observations and so this average is probably less reliable and this might explain the difference if I was going to continue this analysis I'd probably look into this some more one last function before we wrap up the buy function is a variant of the T apply function but by default it returns a vector of the results note that when it is printed it won't really look like a vector that you could access the elements just as if it was a vector in the next video we'll take a look at three functions with within and aggregate in this video I'll take a look at three functions with within and aggragate to explore these functions I'm going to load in the Mario Kart data set the width function can be used to access variables in a data frame with ease this is especially important when the name of the data frame is long and multiple variables are being accessed for a calculation I can read this command as with Mario Kart compute the total price minus the shipping price the width in function is similar to with except that it's easy to create new columns and merge them with the original data set for instance here I'll add an auction closing price to the data frame and store the result in a new data frame called m'kay notice that the commands to generate the new variables goes inside braces as the second argument if I had wanted I could have added multiple variables by creating more variables inside of the braces as you can probably guess the width function is useful for oneoff calculations well within is useful for expanding a dataset to include new variables when I want to aggregate or summarize results I often use the aggregate function here I'll aggregate cross the number of wheels and the condition variables the first argument is a formula the dot on the left side of the tilde means keep all the variables for the output and the variables on the right side separated by a plus sign indicate which variables to aggregate across the second argument is a data frame and the third argument is how to a great the variables had I only wanted to aggregate across one variable say the total price I could have replaced the dot with the total price variable notice the similarities between what the aggregate and t apply functions produce which you should use depends on what you will use the output for congratulations you finish section three the next section will introduce how to write your own functions building functions in hours a key skill that we'll cover in this section of videos in this first video the basic structural function will be introduced in the context of reporting both the mean and the standard error of a data set I'm going to start by creating a test dataset called D here D is a sample of 25 observations from a Poisson distribution with 8 degrees of freedom next I'd like to ensure that my test dataset is stable so if I rerun my code I'll get the same kind of results I'm going to do this using a set seed function now if I regenerate my data and multiple times I get the same test data set now on to the general structure of a function I'll start by carefully choosing a function name here I've thought about this ahead of time I'm going to call it get mean and standard error next I'll assign a function object to this name using the function declaration I've provided a generic argument X to represent the data and I'll use braces to contain the code to be executed using the arguments I'll compute the mean the length of the data set and the standard error of the mean inside of these braces presently the function identifies the mean and it's standard error however the variables m and se only exist in the scope of the function so when I run the function I don't actually get any results what I need to do is add a return statement now whenever you run the function the mean and the standard error will be returned this new function can be helpful however its present output isn't actually ideal it would be nice to make explicitly clear what each of the outputs is from the function in the next video I'll expand the function and take a look at this challenge the function in the last video is used to report the mean and the standard error suppose I wanted to also report a 95% confidence interval for the mean here L can start a confidence interval the Qt function is used to identify the ninetyseven point fifth quantile of the T distribution with n minus 1 degrees of freedom there might be some temptation to concatenate the confidence interval with the current results being reported from the function in some instances this might be fine but it isn't a very clear way to organize the results for example what if another user mistakenly thought the first two values with the confidence interval and last two were the mean and the standard error that could be disastrous when multiple objects are being returned from a function it's usually helpful to return them in a list but even now things might still be a little bit unclear for this reason it's useful to add names to each element of the list and before I forget I should update the name of the function I'm going to name it get CI for get confidence interval there's one more change I want to make before moving on making the function slightly more general by allowing for a different confidence level I'm going to do this using a second argument called level sense the 95% confidence level is so commonly used I'll so spy 0.95 confidence level as the default next I need to make some slight adjustments the body of the function to make use of this new argument I can compute the upper percentile for the confidence interval then provide this as a substitute for 0.975 now I can run the function without specifying the level to get a standard 95% confidence level or if I want a different confidence level say 99% I can easily make that request suppose the user input a value for a level of 99 rather than 0.99 for the level argument in this application it would be nice if the function failed elegantly and communicated why there was an error rather than simply reporting a warning this will be the topic of the next video providing clear feedback to users is one part of building great functions I'm going to take a look at the function from the last video that was used to compute a confidence interval for the mean using the sample of data what if a user provided a percentage instead of a proportion for the confidence level currently the user simply gets a warning and the reason behind the warning isn't going to be obvious to new our users instead it'd be helpful to stop the execution of the function and clearly communicate what is wrong I'll do this by stopping the function if the level of the argument takes value less than zero or greater than one to stop the execution of a function and return an error use the stop function the argument if the stop function is a character string to communicate why the air was generated here I'll communicate that the level variable should have been represented by a proportion between 0 and 1 now when a user inputs a level value that is invalid it stops and returns an error I'm also a little concerned that a user might provide a level that takes value like 0.05 or 0.1 they might think they are supposed to provide a significance level rather than a confidence level if the confidence level is smaller than 0.5 I'd like to warn the user that they should rethink their input I can do this using the warning function in the next video I'll introduce how to pass an arbitrary number of arguments to a function in this video I'll cover how to pass arguments to existing functions inside of functions you are creating to do so I'll use the website Revenue data highlighted in the last section I'd like to create a function that summarizes the revenue and other objects like it I'll call the function Rev summary it'll take just one argument that should be a data frame or a matrix where the rows represent days columns represent different websites and the entries represent revenue for the websites on each day I'll build in a simple check to make sure that the data object comes in in a form of a matrix or a data frame if it doesn't then I'll provide a suitable air next I'll calculate to summaries the average revenue per company and the average revenue per day for the companies in a previous video I use the apply function for this but here I'll use two functions and are specifically built for taking the mean across rows and columns row means and call means I'll return those results in a list with two items that we returned at the close of the function mean revenue per company and mean revenue per day finally I'll apply my new function to the revenue data when I execute the function I get a list back as expected however there are some n/a values that indicate that some data are missing here al dente' Phi which observations in the revenue data are missing using is n/a function together with a which function and an additional argument array index equals true the first is for the 12th day and the third company the second is for the 13th day and the third company it's possible that some end users of this function including myself may occasionally want to have such observations omitted from the calculations in the functions using an n/a argument similar to how we've seen this argument used with other functions however this n/a remove argument would need to be passed to both row means and call means this is fine but it's actually a little bit more generalizable to accept an arbitrary number of arguments we pass to these functions I can do this using an ellipsis in rev summaries declaration this allows the Rev summary function to accept extra arguments not specified in the function declaration next I indicate which functions should receive these X arguments since my intention here is to allow users to pass the n/a a remove argument to row means and call means I will add an ellipsis to the end of each of these functions now if I pass any remove equals true into the rev summary function this argument we passed the row means and call means functions which will then remove the any values from the calculations note that if you want you may access the arguments from the ellipsis in your function using the list function with an ellipsis as its argument in this way you may also write functions that allow for an arbitrary number of arguments and then access all of those arguments and list what's been covered in this video is how to easily pass additional arguments inside your functions and how to access those extra arguments using the list function in the next video I'll show how to hide function output that might flood a user's screen and we'll also cover a useful tool for building recursive functions which are functions that call themselves in this video I'll show how to make output invisible which is helpful when I'll function is a large output and I'll also cover how to use a function recursively if your function returns a lot of results it might be a bit obnoxious when a person forgets to assign the output to an R object if you think your output is likely to be annoying when it's printed out you can use the invisible function in place of the return function then when user fails to save the result to an R object their console will not be flooded with output and if they do assign the output to an object the object will store the result that said invisible output can confuse users so use this trick with caution it's also worth noting that using classes and methods inside of R is another way to address this challenge however classes and methods aren't topic I'll cover in this video and one more tip before we move on to recursive functions if you happen to flood your console screen or if you simply want to clear the console if you're on a Mac use command Alltel or if you on windows control l which will clear your console screen all right on to recursive functions a recursive function is a function that may call itself for example I can create a function called log me that takes the log of a value if the value is larger than 1 and keeps doing this until it gets a value that's less than 1 if the value is less than 1 then the function simply returns the result the way the code is written works but what if I happen to change the functions name I would still want the function to call itself to make sure it does I should use the function called recall which automatically calls the function it's in in general using recalls the preferred way to build recursive functions in our in the next video we'll look at how to use a custom function with the apply function in the last section I talked a bit about the apply family of functions these are very powerful functions for applying the same function across many sets of data they're even more powerful when combined with custom functions to begin I'm going to create a sample object X that's a matrix with 1000 rows and 10 columns containing 10,000 random draws from a Poisson distribution with 8 degrees of freedom if you recall I could easily to apply a function across each row or column here I've calculated the mean for each column if I wanted I could also create a custom function on the fly that calculates the standard error of the mean using each column separately note that here I've omitted the prices for the function declaration I did this since the function can fit on one line but I could include braces if I liked this inline use of functions is very useful since it allows you to apply simple custom functions on the fly it's also common to make complex functions and use them in a third argument of apply here I'm going to first load in the get CI function then I'm going to call it inside of apply you might recall that the get CI function actually returned the list the apply function adapts its output to accommodate complex outputs by the function being applied sometimes they'll return a vector other times the matrix and other times the list here since get CI outputs a list the best way to represent many outputs of that function is to contain them in a sort of super list this completes the fourth section of videos take some time to try out what you've learned in these first four sections of video browse online for some data or acts some of these datasets that are already present in your accession