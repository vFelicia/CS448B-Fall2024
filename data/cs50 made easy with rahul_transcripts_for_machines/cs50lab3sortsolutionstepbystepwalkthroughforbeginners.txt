hey guys in today's video we're going to be going over cs50 lab 3 sort but before we jump into that make sure you subscribe to the channel with notifications on because i'm going to be posting videos every single week so you don't want to miss that now let's jump straight into sort okay so in this problem set they give us three different programs called sort one sort two and sort three and they correspond to one of the sorting algorithms it can either be merge sort bubble sort or selection sort right so our objective here is to find out which sorting algorithms belongs to which sort okay so and they give us some data files to help with that as well and we'll see how it's relevant a little later on but first let's go over each of the sorts so these were explained very clearly in the lecture so i'm not going to go over them too much i'm just going to um briefly explain them so bubble sort if you remember from the lecture compares pairs of adjacent value one at a time and swaps them if they're in incorrect order and this continues until the list is sorted right so basically bubble sort has an order or a big o of n squared right which means in the worst case scenario when there is an unsorted array it takes n square steps for bubble sort to completely sort them okay and bubble sort has an omega of n which means that when there is already a sorted array or in the best case scenario bubble sort only takes n steps to sort them okay now for selection sort okay so selection sort has an order of n squared which means that in the worst case scenario in an unsorted array it's going to take n square steps for selection sort to sort the array now selection sort also has omega of n squared which means that in whether it's whether the list is sorted or unsorted selection sort still takes n square steps right best and worst case scenario it still takes the same amount of steps which is n squared now when a sort has the same order and omega it has a theta of n squared right it's the same thing the best case and worst case scenario is going to take n square steps to sort it so selection sort has a theta of n squared and now merge sort if you remember was proposed in the lecture as the most efficient sort right so the most efficient sorting algorithm so we can see here that merge sort has an order of n log n which means in the worst case scenario when there is an unsorted array it's going to take n log n steps for merge sort to sort it and it also has an omega which means in the best case scenario it's also going to take n log n steps first merge sort to sort it so merge sort has a theta of n log n right because that is the same big o notation which is order and has the same omega which means in the best case and worst case scenario it's still going to take roughly n log n steps from resort to sort the data okay so what can we kind of conclude from this okay so we can see that let's let's let's just take the worst case scenarios first so the worst case scenario bubble sort takes n squared steps selection sort and the worst case scenario takes n squared steps as well okay now merge sort in the worst case scenario only takes n log n steps right an n log n is less than n squared so it takes less steps right so we can conclude that for an unsorted array right in the worst case scenario merge sort will perform the quickest right because it's on the order of n log n and bubble sort and selection sort will perform relatively similar because they both have an order of n squared right so we know that bubble sort and selection sort are going to be slower than merge sort when sorting an unsorted array right because of their orders what about the best case scenario the best case scenario here is obviously a sorted array so bubble sort has an omega of n which means that it's only going to take n steps to sort an already sorted array okay where selection sort again has an omega of n squared which means it's going to take longer than verbal sort for sure and merge sort takes n log n steps in the best case scenario as well so um over here n squared is obviously the biggest so selection sort is going to take the longest and we can see that merge sort is analog n steps so that's pretty slow as well that's larger than m so we can say that in the best case scenario with a sorted array bubble sort should be the quickest because it has an omega of n and in second place it should be merge sort and finally the longest is selection sort so what conclusions can we draw from this well we can say that bubble sort is going to be the quickest right when it's when a when it's in a sorted array and selection sort is going to be the longest in an unsorted array right for an uncertain array because it has an omega of n squared which is larger than both n log n and n okay so the conclusions we can draw from this is that for a sorted array bubble sort will perform the quickest because that is an omega of m and selection sort will perform the slowest because that has an omega of n squared right okay so how do we now take this these conclusions and find out which sorting algorithm corresponds to which sort in this code that they give us so let's go ahead and try that so again for an uncertain array merge sort will form the quickest okay let's keep that in mind for an unsorted array merge sort will perform the quickest okay okay so now let's try to run an unsorted array right random random 50 000 let's say so how we do this is we want to time it right the one that takes the least amount of time is going to be merge sort obviously so let's just see the time taken here okay so let's try to run this now and the way we run it as time dot slash sort 1 let's say we want to test out sort 1 first random 50 000 dot text and over here basically cs50 gave us three types of files uh a file where things are randomly ordered right an unsorted array reversed where it's just uh sorted backwards and a fully sorted array so we don't really need reversed for our scenarios here so we're going to be focusing on random and sorted arrays only okay so first of all uh let's just sort um let's see what's let's see how long sort 1 takes to sort this file of unsorted areas okay and this is how we do it time dot slash sort one run sort one on this file random fifty thousand dot text and let's see what it gives us taking quite a while here okay so uh let's see let's take a look at the real time okay because that's what matters to us so it took us sort one for an unsorted array of fifty thousand took us seven point eight seven one seconds okay sorry seven buckets let's see how sword two does so let's time dot slash sword two and let's run the same file again random fifty thousand dot text let's see how long story two takes us and we can already see that it was a lot quicker so that took us 0.663 seconds what about sort three let's do time dot slash sort three random fifty thousand dot text and we can see this one is not very quick as well okay that took us 3.519 seconds okay so from this what's very clear is that there's one very clear winner right sword two was obviously the quickest so based on that logic based on our conclusions earlier for an unsorted array merge sort will perform the quickest okay so from this we can kind of reduce that sword two is going to be merge sort okay because it performed the quickest for an unsorted array that's an omega of n log n sorry it has a it's on the order of n log n which means for unsorted array it only takes n log n steps where selection and bubble sort take n squared steps okay so now it's clear that sort two is merge sort but we don't really know whether sort one like sort one merge or bubble or sorry three merger or bubble we don't know that yet right so let's take a look at a sorted list let's run the source for sorted list now and let's just run sorted 50 000 again so let's take the time so time dot slash sort one sorted fifty thousand dot text oh that's pretty quick so sword one zero point four four zero seconds right i'm just copying the time from here this is so i remember the time it took now let's run the time again for sword two this time and for the same file sorted 50000 dot text okay let's run it it's pretty quick as well so it took 0.407 seconds and next up let's do time dot slash sort three sorted fifty thousand dot text okay that took us three point one five six seconds okay let's just these are a bit close so let's try to run these again um time dot slash sort one let's run two sorted fifty thousand dot text okay so it took 0.577 seconds 0.577 seconds okay so over here for the sorted list we know that bubble sort is going to perform the quickest because it has an omega of n which means in the best case scenario for solid array it only takes n steps so according to our conclusions here bubble sort will perform the quickest so from here we can deduce that sort 1 should be bubble sort right because it took the quickest for a sorted array and we know from our previous experiment that merged sort of sort two so sword three has to be selection sort right and this also kind of makes sense because we can see that uh sword three right which we switch we propose selection sort takes roughly the same amount of time for an unsorted and a sorted list right n squared has a theta of n squared and we can also see that sword two takes roughly the same amount of time for an unsorted and assorted list because it has a theta of n log n so it's going to be faster than selection sort with both and it's going to take roughly the same amount of time in both an unsorted and sorted list right okay so we figured this out now that sort 1 is bubble sort and we've confirmed it again sword two is merge sword right and sword three is selection sort so why did we need to do for both an unsorted and assorted list because we could we we figured out only the merge sort of sort two but we didn't know whether sort one a selection or bubble that's why we had to run it again through a sorted list and now we have the answers right so let's go ahead and go to answers dot text which is again this is all in the distribution code so sort one uses we know the answer now is bubble sort sort two uses uh the answer is merge sort right from our two experiments we did and sort three uses selection sort selection sort okay so how do you know that sword one uses bubble sort well because it uh it ran the fastest on a sorted array right on a sorted list so to use merge sort how do you know because it ran the fastest when using an unsorted list right remember has a theta of n log n so that's faster than both bubble sort and selection sort because they both have omegas of n squared right it ran the fastest on a random or unsorted list right and finally it's our three selection sort we said that because where do we say that well a sort uh one is bubble sort and sword two is merged sort so three has to be selection all right so basically it was the only option left but also we know that it took roughly the same amount of time for both uh unsorted and sorted which means it should be correct right it has a theta of n squared and we can see that merge sort also took roughly the same amount of time because it has a theta of n log n right so for both unsorted and sword it took roughly the same amount of time and bubble sort was the very clear winner in a sorted list so that's why it was sort one so this actually conforms with our theories with our conclusions that we made over here based on the big o notations which is the order of and the omegas of each of these sort starting algorithms right so i hope that all made sense today guys if it didn't make sense it's probably because you didn't understand the fundamentals of what uh selection sword bubbles or nword swords are so i urge you to go back and watch the lecture if you don't understand that but this is one of the simplest problems that we'll ever get in cs50 right it was very straightforward i hope everything was clear today make sure to leave a like on this video if you enjoyed if it helped at all and make sure to subscribe to the channel because i'm gonna be posting videos every single week that's all for today guys bye david