hey guys in today's video we're going to be going over cs50 problem set to caesar so make sure to subscribe to the channel if you haven't already because i'm going to be posting cs50 solutions every single week let's jump straight into caesar now okay so the point of caesar is actually to encrypt some text based on the user's key what does that mean so let's say a user runs the program right the program is called cesar with dot slash caesar that means the user has chosen the key to be one so what does that mean so if the user types the letter a our program would need to print out the letter b so depending on the key so the key is one so a prints out b because we need to convert a to b we need to skip one step based on the key okay so similarly b is converted to c and c is converted d right it just moves one step based on the key so let's say the user types dot slash caesar two so now the key is two so if the user types in the letter a we need to print out the letter c right in other words is the plain text what the user types in and c is the cipher text or what our program prints out okay and so on and so forth he can be any number right this is just examples so our program needs to prompt the user for plain text right would they type whatever they want and then we convert it to ciphertext based on the key right okay so let's just give an example here let's use user types in dodge slash c01 and for the play text they type in abc so our cipher text we need to print out bcd okay and notice here how it's case sensitive so capital a turns into capital b lowercase b turns into lowercase c and uppercase c turns into uppercase d okay so the case still remains and also if you notice here for the first time we've not had this in preview in previous problem sets is that the key is not a normal input so we don't use get string okay rather it's actually on the command line itself so in previous problems that's what we used to do is just run like dot slash scrabble dot slash readability but over here we run dot slash caesar one or dot slices or whatever the key is right so that's why we now have a command line argument so rather than using int main void like we used to do in the previous problem sets we now run this int main in rxc string arc v because we now have taken input on the command line rather than just leaving it void okay so i hope that makes sense so far and now there are two conditions for the command line argument right what are they so first what is what does argc mean rec is an int and it's actually how many arguments there are okay so argc so the first argument here is the dodge caesar and the second argument in this example is one okay so argc is equal to two okay so the first condition is that arg c always has to equal to two dot slash caesar is the first arg c and the second one is the number right the key so for example we can't have a dot slash caesar one space one because that doesn't make sense right that we don't know what the key is so that's why rxc always has to be equal to two and y so in this case rc is three right that's less than one one so that doesn't make sense and it can't be one rxc can't be one either because then it'll just be dot slash caesar that's the first argument so it always has to be rxc is equal to two dot slash caesar and the key two arguments and the second condition is that argv one must only contain digits okay so why is that uh let's take an example over here arc v0 is dot slash caesar right so that's fine arc v1 must only contain digits because let's say the user types in dot slice user x but we don't know what the key is right it doesn't make sense or let's say they type in dot sizes are 1x right that doesn't make sense either so our v1 must contain only digits okay so those are the two conditions and if it doesn't fulfill these conditions both these conditions have to be fulfilled otherwise we need to print usage dot slash user key which basically is just telling the user how to use the program successfully okay how to use the program correctly so let's try to put this whatever we learned into code and it should be simple enough right so if we knew the first one is rc needs to be 2. so if rc is not equal to we need to print the error message and return one right quit the program so if rxc is not equal to 2 and how do we say that we actually said by using exclamation mark and equal to so this just means if rtc is not equal to 2 what should we do we want to print the error message which tells the user how to use the program print usage dot slash user key and we also want to exit right we want to return one okay the second condition is argue one must only contain digits and over here we actually need to use a loop why do we need to use a loop because we actually need to go through every single character of argue one and determine whether or not it's a digit okay so again so let's say it was just uh dot slices or one x if we didn't use a loop it would just check for the first character whereas we need to actually go through entire rv one and check one by one is this character digit is this character digit or not okay so that's why we need to use a loop so we can use a for loop right and by this point we know how to use for loops from all the previous problem sets so let's say end i equal to zero let's set an index and set to zero and i needs to keep on going as long as i is less than the length of arc v1 right so i is less than sterling arc v1 right i plus plus which basically means go through the entire arc v1 one at a time starting from zero and what do we need to check for if it's a digit then we need to print the same error message but how do we actually check whether or not something is a digit well it turns out there is a formula called is there's a function called is digit right and again we wouldn't know this this is not common knowledge it's not common sense you would know this uh because first of all it's in the cs50 explanation right and also by just playing around with the cs50 manual learning different functions things like that okay so we need to check if it's a digit right and this is under the header file called ctype.h so let's include that and also if you remember from the previous problem sets sterlin is actually under the header file called string.h right so for to use sterling we use string.h as well okay so we've used those header files so if is digit right so we need to check whether or not it's a digit uh according to this arc v1 so if it's not a digit then we want to return an error and quit so again if exclamation mark is digit arc v1 i right what do we need to do we want to print again the exact same thing as we printed before users we need to print the error message as well as return one okay so i hope that makes sense so far right we fulfilled the two conditions because as we said rc needs to be equal to two so if it's not two then quit the program and print this error message and arg v1 needs to only have digits right so we loop through the entire rv1 one character at a time and if it's not a digit then print this error message and quit the program right so we've reached here so far but now we we know logically that the formula to convert plain text to ciphertext is actually plain text plus key plain text plus key will give you cipher text right this makes sense so let's say a plain text was a well like what the user types unless the user types in a and a key of one we have to print out the cipher text which in this case would be b right so that makes sense so far um but again so we we know that key needs to be an int right the key needs to be an integer so that we can use we can make a formula out of it to later convert plain text into ciphertext but if you notice here our v which is where the key is rv1 is actually a string right so it's a digit but it's considered a string so let's say the key is one well it's still a digit number one but rather than counting it as an integer where we can do mathematical functions with it it's counted as a string okay so we need to convert the key into an integer so that we can do math with it right okay so okay so in this example here dot classes are one one is a string okay even though it's a digit it's still a string it doesn't count the computer doesn't count it as an end because arc v is a string so we need to convert it to an integer right so let's see if there's a function to convert a string into an integer and it turns out there is and again this is not common knowledge whatsoever right uh you need to know this by either reading cs50s explanation or by just going through the manual and figuring it out yourself so it runs out of this function called a to i which converts strings to an int right that's the definition here and that's under the header file standard lib.h okay i'm just gonna include that okay so we know we need to have a key right we have a key but now we need to convert the key into an integer so let's just make an end let's call it in k for key right just to make it easier to remember a to i which is just convert string to integer arg v1 right so we defined a variable called k which is an integer and now we assign the value of the key as an integer into k okay so k for key just to make it simple and now what do we need to do well now we need to actually prompt the user for some plain text and how do we go ahead how do we go about doing that very simple it's been there since problem set one which is just using the get string function right so string plain text to get some string from the user get string right this is to get a string from the user uh let's say plain text okay okay and now we want to print out the cipher text okay so get string plain text and we want to print with cipher text and then we actually now we need to use the formula and everything to get the actual cipher text so what we've done is prompted the user for plain text and then print out ciphertext and they print out the actual ciphertext so print out the word ciphertext colon and then the actual ciphertext okay so now first things first as we know from scrabble and even readability we know that uh different keys according to ascii the lower case and uppercase are they have different values right so if you remember actually uppercase a has an ascii value of 65 whereas lower case it has a has an ascii value of 97 right so we know that over here according to our program it needs to be case sensitive right so we can already determine somehow that we need to treat uppercase letters and lowercase letters are differently because they have different ascii positions or ascii values so okay so we know that so now what we need to do is we actually need to make a loop to go through the entire a plain text one character at a time and convert it to ciphertext right so let's first of all let's go ahead and make the loop and again let's use a for loop again we should be very familiar with for loops at this point we should be comfortable manipulating them so let's make another integer let's call it j because we've already used i over here so if j equal to zero keep on going as long as j is less than the stirling of what this time strata of the plain text and j plus plus okay so what this for loop means just set and make a variable called j index it to zero keep on going as long as j is less than the plaintext as long as the less than the length of the string of the plaintext right and j plus plus which just means go one at a time okay so so far this makes sense and our first instinct here right and my first instinct here so there's no shame in that is printf and what do we want to do we just want to print the character and what character we want to print we just want to print plain text right plain text j plus k and this is what makes logical sense for everyone right so you the cipher text you want to print the ciphertext right so it placeholder c so we're going to print the ciphertext which so far what we think logically is just plain text whatever that is plus k which is the key right so let's say it was a let's say the plaintext was a and the key of one well then we would want to print out b right we want to print the singular letter b character so this makes sense but there's actually a flaw with this because let's take a look here what if someone typed the letter z okay which is very common right so let's say someone type the letter z capital z and that has an ascii value of 90 right and let's see someone just put a key of one symbol so that it would convert it to whatever is ascii position of 91 right z which is 90 plus 1 according to our formula here so 90 plus 1 would give us 91. but what is actually in the ascii position of 91 what is the ascii value of 91. well we don't know right i mean it's probably a comma or an exclamation mark or some other random character whereas what we don't we don't want to print that random character if someone prints out the letter z and has if someone inputs the letter z and has a key of one we actually wanted to loop back over to a right so if if it's a z with a key of two we wanted to loop back over to b right we want to loop back over the alphabet essentially rather than just um printing out some random character in ascii going over the bounds right going overbound so what do we need to do here well so we know that this doesn't work because we can go overbound with this right so what we need to do is actually and again if you've done scrabble this might come a little naturally to you and i hope you've done scrabble if you haven't go go back and watch that video first do readability and then only come to caesar okay so how do we get this plain text plus key to loop back over once it goes past z so there are a few simple steps so the first step is reset the values so that the alphabet starts from zero rather than 65 right and this is very similar to what we did in scrabble so we need to set a we need to send a back to position zero okay and then we need to do mod 26 okay so for those of you that haven't come across this mod function it's basically saying whatever the remainder is take that as an int and that's the value of the mod okay so so that mod over here the the function of it is actually to loop back to make it a loop okay so mod 26 so when it reaches over 26 characters we wanted to loop back to the beginning okay we want to loop back to zero so actually 26 mod 26 gives us 0 because there's no remainder when you divide 26 by 26 right just a simple quick explanation of one mod is 26 mod 26 is zero because 26 divided by 26 gives zero remainder whereas 28 mod 26 gives you two because when you divide 28 by 26 the remainder is two because that's a real quick explanation of what mod is um so basically so first we reset the values to zero and then we do mod 26 so that it loops over it doesn't go over bounce right and after that we need to bring it back to its original ascii value okay so this okay so this might be a little bit confusing at first let's go straight into an example here so this is the function we came up with right minus 65 to bring it back to zero mod 26 to loop over and then we said we want to also plus 65 to bring it back to its original ascii value okay so why is this right what how does this make sense so let's say someone input the letter capital z okay and capital z as we know has an ascii value of 90 right so let's just take that as an example someone puts in the letter z so z minus 65 would give us a 90 minus 65 which is 25 and let's just say the key was one right so the key was one so 90 plus a minus 65 which is 25 plus the key which is in this example as it's one that'll give us 26 right 90 minus 65 25 plus 1 26. now 26 mod 26 would give us 0 right and then we'd add back the 65 so that it prints out the letter a so when uppercase z is a plain text our ciphertext would now print out whatever is the ascii position of 65 which is the capital a right okay so might be thinking why do we need to add back the 65 because otherwise it would be a 90 right capital z minus 65 which is uh 25 plus 1 which is 26. now 26 mod 26 would give us zero so to print whatever is the ascii position of 0 which we don't want that we want to print whatever is the ascii position of 65 which is a so that's why we need to add it back and back to 65. so plain text minus 65 to set the alphabet back to zero plus k obviously converted to ciphertext mod 26 so that it loops back over whenever it goes over the 26 and then plus 65 to bring it back to the original ascii value right so i hope that explanation makes sense uh rewind the video and watch it again if it doesn't right but hopefully it does make sense right so for j okay and this is only for capital letters right because a is capital 65. so if it's a capital letter and again here uh we don't really want uh we don't really want to deal with ascii and all that again so we know from the previous exercises that we can just write is upper for uppercase characters so if is upper plain text j then we want to print this right so hopefully everything makes sense so far so we go to the loop and if it's upper then if it's an uppercase letter then we use this formula what happens if it's a lowercase letter well we know we already know how to do it f is lower right this from the previous um uh previous problem sets rather than saying ask rather than putting the ascii values and everything we can simply do is lower so if plain text is a lo if it's a lowercase letter what do we need to do well something very similar to this but because uh lowercase it doesn't start at 65 it starts at 97 right we want to minus it by 97 to bring it back to its original position and then add back 97 so it goes back to its original ascii position so it's exactly the same formula as for the upper case so we can just copy and paste that right print xj minus 97 plus k and bring it back to 97 right so hopefully everything makes sense so far if you don't understand the logic here please rewind the video watch it again i'm sure you'll get it eventually it's it's tough to wrap your head around because our initial instinct is just cipher text is plain text plus key right but we need the mod to loop over and we need to bring it back and everything so keep that in mind okay so if it's if it's an upper case then do this if it's a lowercase letter then do this and so they tell us over here that we want to keep all um anything that's not letter like let's say it's a number or a or a full stop exclamation mark whatever is punctuation we're going to leave it as it is okay so let's say plaintext is ab50 we want the ciphertext to be with the key of one let's say we want the cipher text to be bc50 so a plus one b b plus one is c but the 50 should remain as it is right and full stops exclamation marks everything should remain as it is so we only want to manipulate the letters okay so over here we've done if it's an uppercase letter then do this if it's a lowercase letter then do this now else if it's anything else if it's not a letter basically if it's not an uppercase letter or a lowercase letter then what do we want to print we want to just print it as it is right we don't want to do anything fancy so we just want to print the character as it is again we use a placeholder c and we just want to print it out as it is so we don't make any changes over there okay okay so everything here makes sense so far all right uh if it's an uppercase through this lowercase with this and if it's anything else other than an uppercase or a lowercase letter which means if it's a number or punctuation or blah blah print it as it is okay and then after that we just want to print a new line right so ciphertext it will print out the ciphertext as it is and then we just want to print out a quick new line print f and we just want to print a new line simply there and okay okay so let's see if our code is correct oh okay we forgot to close our for loop here that would give us an error later on the program okay so first of all let's compile our program makes easier and a few errors here percent see okay so it's an error on line 33. okay i closed the bracket too early here i needed to actually open a bracket here okay so the error was that i didn't put the brackets right it's also hold down so let's make caesar okay it compiles let's run dot slash c01 key of one okay ask me for the plain text that's good sign plain text let's say is a okay ciphertext b that's okay sounds good so far let's say dot slash caesar okay gives me an error oh but uh prompts me again on the same line that that doesn't look very nice so let's just put over here start a new line when you give the error message that's backslash n okay that's mixed either once again dot slash caesar okay uses user key okay gives me the error message c02 let's say a becomes c okay that's a good sign so let's go ahead and check our code now check 50 okay copy and paste it hopefully everything's correct right we've gone through this whole thing and everything seems to be correct uh hopefully it is and by the time we're waiting for this guys please make sure to subscribe because we'll be posting videos every single week make sure to leave a like on this video if it helped and yeah uh let's go ahead let's do the cs50 course together guys we can get through it i know we can let's just go ahead and wait for our results we've done everything correctly hopefully everything i've said today makes sense by the way guys um this one is a little bit complicated kind of wrap your head around the logic of the mod um if you want me to make a separate video just explaining mod so that this whole problem becomes clear let me know and i'll go ahead and make a video just about that and over here everything is correct guys okay so thank you so much for watching if you have any questions leave in the comments down below and answer every single question and that's all for today thanks guys bye david